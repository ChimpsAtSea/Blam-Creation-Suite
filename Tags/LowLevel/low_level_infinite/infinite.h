#pragma once


namespace blofeld
{
	namespace infinite
	{
#pragma pack(push, 1)

		struct s_s_anytagguts
		{
			long global_tag_id;
			char local_tag_handle[4]; // padding
		};
		static_assert(sizeof(s_s_anytagguts) == 8, "struct s_s_anytagguts is invalid size");

		struct s_anytag_struct_definition
		{
			long long vtable_space;
			s_s_anytagguts internal_struct;
		};
		static_assert(sizeof(s_anytag_struct_definition) == 16, "struct s_anytag_struct_definition is invalid size");

		struct s_s_object_meta_label
		{
			string_id meta_label;
		};
		static_assert(sizeof(s_s_object_meta_label) == 4, "struct s_s_object_meta_label is invalid size");

		struct s_ambientactioninfo
		{
			c_enum<e_i343interactiveobjectsinteractivedesire, char> desire_type;
			char generated_pad5f2a[3]; // padding
			c_enum<e_i343actionsystemactiontype, long> action;
			string_id animation_token_override;
			real time_playing_animation;
			real cooldown_time;
			string_id composition_name;
			c_typed_tag_reference<COMPOSITION_TAG> composition_definition;
			real max_distance_agents_will_consider_this_opp_from;
			c_typed_tag_block<s_s_object_meta_label> ambient_meta_labels_block;
			c_typed_tag_block<s_s_object_meta_label> exclusion_meta_labels_block;
			real min_danger_to_activate;
			real max_danger_to_activate;
			real abort_danger_level;
			real chance_per_second;
			real min_enemy_target_distance;
			real max_enemy_target_distance;
			real max_height_difference;
		};
		static_assert(sizeof(s_ambientactioninfo) == 96, "struct s_ambientactioninfo is invalid size");

		struct s_ambientactionpointdefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_ambientactioninfo> ambient_info_block;
			char generated_padc9b5[4]; // padding
		};
		static_assert(sizeof(s_ambientactionpointdefinition) == 32, "struct s_ambientactionpointdefinition is invalid size");

		struct s_abcarchivepointer
		{
			long long archive_read_pointer;
			c_static_string<256> name;
		};
		static_assert(sizeof(s_abcarchivepointer) == 264, "struct s_abcarchivepointer is invalid size");

		struct s_abcstat
		{
			string_id name;
			string_id value;
		};
		static_assert(sizeof(s_abcstat) == 8, "struct s_abcstat is invalid size");

		struct s_abcsourcefiletag
		{
			s_anytag_struct_definition anytag;
			s_abcarchivepointer ptr;
			c_static_string<256> dccsourcepath;
			c_typed_tag_reference<ASSET_TAG> asset;
			c_static_string<256> dcc_instance_name;
			real dcc_start_frame;
			long frame_count;
			real frames_per_second;
			c_typed_tag_block<s_abcstat> statistics_block;
			char generated_pad18e1[4]; // padding
		};
		static_assert(sizeof(s_abcsourcefiletag) == 836, "struct s_abcsourcefiletag is invalid size");

		struct s_assetentry
		{
			c_typed_tag_reference<ASSET_TAG> asset;
		};
		static_assert(sizeof(s_assetentry) == 16, "struct s_assetentry is invalid size");

		struct s_keywordqueryentry
		{
			string_id query;
		};
		static_assert(sizeof(s_keywordqueryentry) == 4, "struct s_keywordqueryentry is invalid size");

		struct s_assetcollectiontag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_assetentry> assets_block;
			c_enum<e_assetcollectionquerymode, char> querymode;
			char generated_padd9ee[3]; // padding
			c_typed_tag_block<s_keywordqueryentry> keyword_queries_block;
			char generated_pad26a3[4]; // padding
		};
		static_assert(sizeof(s_assetcollectiontag) == 48, "struct s_assetcollectiontag is invalid size");

		struct s_i343aisquadconstructionactorcellentry
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<CHARACTER_TAG> character;
			c_typed_tag_reference<WEAPON_TAG> primary_weapon;
			c_typed_tag_reference<WEAPON_TAG> secondary_weapon;
			char generated_padbb57[4]; // padding
		};
		static_assert(sizeof(s_i343aisquadconstructionactorcellentry) == 68, "struct s_i343aisquadconstructionactorcellentry is invalid size");

		struct s_i343contenttagsteammatechatter
		{
			c_typed_tag_reference<DIALOGUE_TAG> chatter_dialogue;
		};
		static_assert(sizeof(s_i343contenttagsteammatechatter) == 16, "struct s_i343contenttagsteammatechatter is invalid size");

		struct s_assetdialoguetag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343contenttagsteammatechatter> teammate_male_chatter_block;
			c_typed_tag_block<s_i343contenttagsteammatechatter> teammate_female_chatter_block;
		};
		static_assert(sizeof(s_assetdialoguetag) == 40, "struct s_assetdialoguetag is invalid size");

		struct s_defaultstimulussuppressorparam
		{
			string_id stimulus;
		};
		static_assert(sizeof(s_defaultstimulussuppressorparam) == 4, "struct s_defaultstimulussuppressorparam is invalid size");

		struct s_dialoguesystemdatatagreference
		{
			c_typed_tag_reference<DIALOGUE_SYSTEM_DATA_TAG> dialogue_system_data_tag;
		};
		static_assert(sizeof(s_dialoguesystemdatatagreference) == 16, "struct s_dialoguesystemdatatagreference is invalid size");

		struct s_ai_dialogue_definitions
		{
			s_anytag_struct_definition anytag;

			/* Global timing */

			real_bounds strike_delay_bounds;
			real remind_delay;
			real post_combat_results_wait_time;
			real grapple_hook_pull_delay_time;
			real player_shoot_min_interval;
			real actor_shoot_min_interval;
			real cover_curse_chance;

			/* Player look settings */

			real player_look_max_distance;
			real player_look;
			real player_look_long_time;

			/* Spartan nearby search distance */

			real spartan_nearby_search_distance$2;

			/* Face friendly player distance */

			real face_friendly_player_distance$2;

			/* Space dialogue effect */

			string_id space_dialogue_effect$2;

			/* Speaker distance restrictions */

			real max_respond_distance;
			real max_respond_distance_in_space;

			/* Pattern selection ranges */

			real speaker_max_delta;
			real pattern_max_delta;

			/* Danger Level thresholds */

			real player_shield_damage_threshold;
			real player_body_damage_threshold;

			/* Subtitles */

			real max_player_distance;

			/* Default stimulus suppressors */

			c_typed_tag_block<s_defaultstimulussuppressorparam> default_stimulus_suppressors_block;

			/* Dialogue System Data Tags */

			c_typed_tag_block<s_dialoguesystemdatatagreference> dsd_tags_block;
			char generated_pade870[4]; // padding
			long long runtime_dialogue_system_data;
		};
		static_assert(sizeof(s_ai_dialogue_definitions) == 136, "struct s_ai_dialogue_definitions is invalid size");

		struct s_i343aiairdropairdropsystemglobalsdefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<KIT_TAG> default_flight_path_kit;
			char generated_padfc5f[4]; // padding
		};
		static_assert(sizeof(s_i343aiairdropairdropsystemglobalsdefinition) == 36, "struct s_i343aiairdropairdropsystemglobalsdefinition is invalid size");

		struct s_namedhlodsettings
		{
			c_typed_tag_reference<HLODPRESETS_TAG> hlod_settings_preset_list;
			string_id hlod_settings_name;
		};
		static_assert(sizeof(s_namedhlodsettings) == 20, "struct s_namedhlodsettings is invalid size");

		struct s_autohlodlevelsettings
		{
			s_namedhlodsettings hlod_settings;
			real switch_distance;
			c_enum<e_etargetlod, short> maximum_lod;
			char generated_padd86d[2]; // padding
		};
		static_assert(sizeof(s_autohlodlevelsettings) == 28, "struct s_autohlodlevelsettings is invalid size");

		struct s_autohlodsettings
		{
			s_anytag_struct_definition anytag;

			/* HLOD Auto-Generation Parameters */

			// custom bsp_cells
			long x_splits;
			long y_splits;
			long z_splits;
			// custom value
			// custom hlod_settings
			// custom bsp_hlod_settings
			s_autohlodlevelsettings bsp_hlod_settings;
			// custom value
			// custom bsp_cell_hlod_settings
			s_autohlodlevelsettings bsp_cell_hlod_settings;
			// custom value
			// custom value
			char generated_padd9ad[4]; // padding
		};
		static_assert(sizeof(s_autohlodsettings) == 88, "struct s_autohlodsettings is invalid size");

		struct s_i343damagedamagesourcedefinition
		{
			string_id damage_source_name;
		};
		static_assert(sizeof(s_i343damagedamagesourcedefinition) == 4, "struct s_i343damagedamagesourcedefinition is invalid size");

		struct s_s_ai_globals_gravemind_definition
		{
			real min_retreat_time;
			real ideal_retreat_time;
			real max_retreat_time;
		};
		static_assert(sizeof(s_s_ai_globals_gravemind_definition) == 12, "struct s_s_ai_globals_gravemind_definition is invalid size");

		struct s_s_ai_globals_formation_definition
		{
			c_typed_tag_reference<FORMATION_TAG> formation;
		};
		static_assert(sizeof(s_s_ai_globals_formation_definition) == 16, "struct s_s_ai_globals_formation_definition is invalid size");

		struct s_s_ai_globals_squad_template_definition
		{
			c_typed_tag_reference<SQUAD_TEMPLATE_TAG> squad_template;
		};
		static_assert(sizeof(s_s_ai_globals_squad_template_definition) == 16, "struct s_s_ai_globals_squad_template_definition is invalid size");

		struct s_s_ai_globals_squad_template_sub_folder_definition
		{
			string_id sub_folder_name;
			c_typed_tag_block<s_s_ai_globals_squad_template_definition> templates_block;
		};
		static_assert(sizeof(s_s_ai_globals_squad_template_sub_folder_definition) == 16, "struct s_s_ai_globals_squad_template_sub_folder_definition is invalid size");

		struct s_s_ai_globals_squad_template_folder_definition
		{
			string_id folder_name;
			c_typed_tag_block<s_s_ai_globals_squad_template_sub_folder_definition> sub_folders_block;
			c_typed_tag_block<s_s_ai_globals_squad_template_definition> templates_block;
		};
		static_assert(sizeof(s_s_ai_globals_squad_template_folder_definition) == 28, "struct s_s_ai_globals_squad_template_folder_definition is invalid size");

		struct s_s_ai_globals_custom_stimulus_definition
		{
			string_id name;
		};
		static_assert(sizeof(s_s_ai_globals_custom_stimulus_definition) == 4, "struct s_s_ai_globals_custom_stimulus_definition is invalid size");

		struct s_s_ai_globals_trait_vision_definition
		{

			/* Vision Traits */

			real vision_distance_scale;
			real vision_angle_scale;
		};
		static_assert(sizeof(s_s_ai_globals_trait_vision_definition) == 8, "struct s_s_ai_globals_trait_vision_definition is invalid size");

		struct s_s_ai_globals_trait_sound_definition
		{

			/* Sound Traits */

			real hearing_distance_scale;
		};
		static_assert(sizeof(s_s_ai_globals_trait_sound_definition) == 4, "struct s_s_ai_globals_trait_sound_definition is invalid size");

		struct s_s_ai_globals_trait_luck_definition
		{

			/* Luck Traits */

			real evasion_chance_scale;
			real grenade_dive_chance_scale;
			real broken_kamikaze_chance_scale;
			real leader_dead_retreat_chance_scale;
			real dive_retreat_chance_scale;
			real shield_depleted_berserk_chance_scale;
			real leader_abandoned_berserk_chance_scale;
			real melee_attack_delay_timer_scale;
			real melee_chance_scale;
			real melee_leap_delay_timer_scale;
			real throw_grenade_delay_scale;
		};
		static_assert(sizeof(s_s_ai_globals_trait_luck_definition) == 44, "struct s_s_ai_globals_trait_luck_definition is invalid size");

		struct s_s_ai_globals_trait_grenade_definition
		{

			/* Grenade Traits */

			real velocity_scale;
			real throw_grenade_delay_scale;
			real dont_drop_grenades_chance_scale;
			real grenade_uncover_chance_scale;
			real retreat_throw_grenade_chance_scale;
			real anti_vehicle_grenade_chance_scale;
			real throw_grenade_chance_scale;
		};
		static_assert(sizeof(s_s_ai_globals_trait_grenade_definition) == 28, "struct s_s_ai_globals_trait_grenade_definition is invalid size");

		struct s_functiondefinition
		{
			// custom value
			s_tag_data data;
			// custom value
		};
		static_assert(sizeof(s_functiondefinition) == 20, "struct s_functiondefinition is invalid size");

		struct s_scalarfunctionname
		{
			// custom function
			s_functiondefinition function;
		};
		static_assert(sizeof(s_scalarfunctionname) == 20, "struct s_scalarfunctionname is invalid size");

		struct s_i343aiaimarkupfilter
		{
			c_enum<e_actortype, short> actor_type;
		};
		static_assert(sizeof(s_i343aiaimarkupfilter) == 2, "struct s_i343aiaimarkupfilter is invalid size");

		struct s_friendlysquadproperties
		{
			c_typed_tag_block<s_i343aiaimarkupfilter> follow_actor_types_block;
			real encounter_zone_exit_threshold;
			real dynamic_encounter_radius;
			real follow_radius;
			real area_refresh_distance;
			// custom left_behind_properties
			real maximum_follow_path_length;
			real waiting_distance_threshold;
			real minimum_waiting_time;
			// custom value
			real area_refresh_time;
			real new_vehicle_distance;
			real non_turret_passenger_exit_time;

			/* value */

			real turret_passenger_exit_time;
			real turret_passenger_exit_distance;
			real arrival_dialogue_event_min_delay_time;
			real arrival_dialogue_event_min_travel_distance;
		};
		static_assert(sizeof(s_friendlysquadproperties) == 68, "struct s_friendlysquadproperties is invalid size");

		struct s_pathingcostmodifiers
		{

			/* Pathing cost modifiers */

			real damage_area;
			real no_drive_zone;
			real avoid_area;
		};
		static_assert(sizeof(s_pathingcostmodifiers) == 12, "struct s_pathingcostmodifiers is invalid size");

		struct s_s_ai_globals_data
		{
			real ai_infantry_on_ai_weapon_damage_scale;
			real ai_vehicle_on_ai_weapon_damage_scale;
			real ai_player_vehicle_on_ai_weapon_damage_scale;
			real absolute_maximum_ai_hearing_distance_;
			real absolute_maximum_ai_speech_distance_;
			real maximum_individual_prop_perceived_danger;

			/* Sound Fraction */

			real quiet_perception_distance_fraction;
			real medium_perception_distance_fraction;
			real shout_perception_distance_fraction;

			/* AI Suicide Damage Source */

			s_i343damagedamagesourcedefinition aisuicidedamagesource;
			real danger_broadly_facing;
			real danger_shooting_near;
			real danger_shooting_at;
			real danger_extremely_close;
			real danger_shield_damage;
			real danger_exetended_shield_damage;
			real danger_body_damage;
			real danger_extended_body_damage;
			c_typed_tag_reference<AI_DIALOGUE_GLOBALS_TAG> global_dialogue_tag;
			string_id default_mission_dialogue_sound_effect;
			real jump_velocity___very_short;
			real jump_velocity___short;
			real jump_velocity___medium_short;
			real jump_velocity___medium_long;
			real jump_velocity___long;
			real jump_velocity___very_long;
			char jump_leap_placeholder[4]; // padding
			real max_jump_down_height___very_short;
			real max_jump_down_height___short;
			real max_jump_down_height___medium_short;
			real max_jump_down_height___medium_long;
			real max_jump_down_height___long;
			real max_jump_down_height___very_long;
			char another_leap_placeholder[4]; // padding
			real_bounds hoist_step;
			real_bounds hoist_crouch;
			real_bounds hoist_stand;
			real_bounds vault_step;
			real_bounds vault_crouch;

			/* PATHFINDING SEARCH RANGES */

			real search_range_infantry;
			real search_range_flying;
			real search_range_vehicle;
			real search_range_giant;
			real ai_seat_cooldown;
			real alert_stagger_delay_max;
			real berserk_animation_suppress_radius;
			c_typed_tag_block<s_s_ai_globals_gravemind_definition> gravemind_properties_block;
			real scary_target_threhold;
			real scary_weapon_threhold;
			real player_scariness;
			real_fraction player_desires_healing_health_threshold;
			real_fraction player_desires_healing_shield_threshold;
			real berserking_actor_scariness;
			real kamikazeing_actor_scariness;

			/* RESURRECTION */

			real min_death_time;
			real projectile_distance;
			real idle_clump_distance;
			real dangerous_clump_distance;

			/* TELEPORTATION */

			real cover_search_duration;
			real task_direction_search_duration;

			/* CURE ISOLATION */

			real time_unseen_before_teleport_allowed;
			real time_isolated_before_exiting_vehicle;
			real time_isolated_before_can_attempt_kill;
			real time_unseen_before_kill_allowed;
			real time_isolated_before_force_killed;
			c_typed_tag_block<s_s_ai_globals_formation_definition> spawn_formations_block;
			c_typed_tag_block<s_s_ai_globals_squad_template_folder_definition> squad_template_folders_block;
			c_typed_tag_block<s_s_ai_globals_custom_stimulus_definition> custom_stimuli_block;

			/* CLUMP THROTTLING */

			real stop_dist;
			real resume_dist;
			real min_dist;
			real max_dist;
			real min_scale;

			/* SQUAD PATROLLING */

			real passthrough_chance;
			real search_phase_skip_chance;
			real patrol_transition_timeout;
			real patrol_maneuver_timeout;
			real_bounds patrol_search_firing_point_time;
			real patrol_isolation_distance;
			real patrol_isolation_time;

			/* KUNGFU CONTROL */

			real kungfu_deactivation_delay;
			// custom presearch_child_counts_0_means_no_limit
			short suppressing_fire_count;
			short uncover_count;
			short leap_on_cover_count;
			short destroy_cover_count;
			short guard_count;
			short investigate_count;
			short search_by_fire_count;
			char search_padding[2]; // padding
			// custom value
			c_typed_tag_block<s_s_ai_globals_trait_vision_definition> vision_traits_block;
			c_typed_tag_block<s_s_ai_globals_trait_sound_definition> sound_traits_block;
			c_typed_tag_block<s_s_ai_globals_trait_luck_definition> luck_traits_block;
			c_typed_tag_block<s_s_ai_globals_trait_grenade_definition> grenade_traits_block;
			// custom search_pattern_specification
			real max_decay_time;
			real decay_time_ping;
			real search_pattern_radius;
			short search_pattern_shell_count;
			short_bounds search_pattern_cells_per_shell_range;
			char generated_pad10c4[2]; // padding
			// custom value
			// custom playfighting_modifiers
			real playfight_burst_duration_mod;
			real playfight_burst_error_mod;
			real playfight_burst_error_bonus;
			real playfight_burst_radius_mod;
			real playfight_grenade_miss_distance;
			real playfight_damage_mod;
			// custom procedural_playfighting

			/* value */

			real_bounds playfight_distance_thresholds;
			s_scalarfunctionname distance_function;
			// custom value
			// custom value
			// custom ai_networking_parameters

			/* IMPORTANT */

			real position_discrepancy_below_which_throttle_fixups_are_used_exclusively;
			real positional_discrepancy_below_which_throttle_fixups_are_not_used_if_authority_is_stopped;
			real predict_ahead_time;

			/* Interpolation Settings */

			c_typed_tag_reference<SIMULATION_INTERPOLATION_TAG> simulation_interpolation_parameters;
			c_typed_tag_reference<SIMULATION_INTERPOLATION_TAG> action_simulation_interpolation_parameters;
			real jump_takeoff_warp_threshold;
			// custom value
			real default_max_active_camouflage;
			real max_player_lof_crouch_distance;
			real player_lof_crouch_time;
			real player_lof_stand_time;
			// custom vehicle_properties
			real vehicle_exit_after_player_delay_time;
			// custom value
			// custom slip_space_spawning
			c_typed_tag_reference<EFFECT_TAG> slip_space_spawning_effect;
			// custom value
			// custom weapon_interactive_object_properties
			c_typed_tag_block<s_ambientactioninfo> ambient_info_block;
			// custom value
			c_typed_tag_block<s_friendlysquadproperties> friendly_squad_properties_block;
			c_typed_tag_block<s_pathingcostmodifiers> pathing_cost_modifiers_block;
		};
		static_assert(sizeof(s_s_ai_globals_data) == 648, "struct s_s_ai_globals_data is invalid size");

		struct s_s_ai_globals_definition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_s_ai_globals_data> data_block;
			char generated_pad5c43[4]; // padding
		};
		static_assert(sizeof(s_s_ai_globals_definition) == 32, "struct s_s_ai_globals_definition is invalid size");

		struct s_attachedlightcone
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<LIGHT_CONE_TAG> light_cone_definition;
			argb_color color;
			real intensity;
			real length;
			real width;
			real camera_fade_near;
			real camera_fade_far;
			real lengthwise_offset_percentage;
			char generated_pad4c79[4]; // padding
		};
		static_assert(sizeof(s_attachedlightcone) == 76, "struct s_attachedlightcone is invalid size");

		struct s_animatedmesh
		{
			s_anytag_struct_definition anytag;
			dword flags;
			byte version;
			byte authored_fps;
			word resource_frame_count;
			s_tag_resource perframe_rigid_body_resources;
		};
		static_assert(sizeof(s_animatedmesh) == 32, "struct s_animatedmesh is invalid size");

		struct s_physicsunsafeobjectfunctionentry
		{
			string_id object_function_name;
		};
		static_assert(sizeof(s_physicsunsafeobjectfunctionentry) == 4, "struct s_physicsunsafeobjectfunctionentry is invalid size");

		struct s_animglobals
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_physicsunsafeobjectfunctionentry> physics_unsafe_object_functions_block;
			char generated_pad2e3d[4]; // padding
		};
		static_assert(sizeof(s_animglobals) == 32, "struct s_animglobals is invalid size");

		struct s_subgraphreferenceexportedanimnodegraph
		{
			c_typed_tag_reference<XANIMNODEGRAPH_TAG> anim_subgraph;
		};
		static_assert(sizeof(s_subgraphreferenceexportedanimnodegraph) == 16, "struct s_subgraphreferenceexportedanimnodegraph is invalid size");

		struct s_subgraphreferenceanimstategraph
		{
			c_typed_tag_reference<XANIMSTATEGRAPH_TAG> state_subgraph;
		};
		static_assert(sizeof(s_subgraphreferenceanimstategraph) == 16, "struct s_subgraphreferenceanimstategraph is invalid size");

		struct s_i343animationcontrolparameter
		{
			string_id name;
		};
		static_assert(sizeof(s_i343animationcontrolparameter) == 4, "struct s_i343animationcontrolparameter is invalid size");

		struct s_i343animationlocalcontrolparametersdefinition
		{
			c_typed_tag_block<s_i343animationcontrolparameter> int_control_parameters_block;
			c_typed_tag_block<s_i343animationcontrolparameter> float_control_parameters_block;
			c_typed_tag_block<s_i343animationcontrolparameter> vector_control_parameters_block;
			c_typed_tag_block<s_i343animationcontrolparameter> bool_control_parameters_block;
			c_typed_tag_block<s_i343animationcontrolparameter> string_control_parameters_block;
		};
		static_assert(sizeof(s_i343animationlocalcontrolparametersdefinition) == 60, "struct s_i343animationlocalcontrolparametersdefinition is invalid size");

		struct s_blackboardentrydescriptor
		{
			c_enum<e_blackboarddatatype, long> data_type;
			string_id blackboard_id;
		};
		static_assert(sizeof(s_blackboardentrydescriptor) == 8, "struct s_blackboardentrydescriptor is invalid size");

		struct s_animgraphconnection
		{
			c_enum<e_animgraphnodetype, long> source_node_type;
			long source_node_index;
			long source_pin_index;
			c_enum<e_animgraphnodetype, long> destination_node_type;
			long destination_node_index;
			long destination_pin_index;
		};
		static_assert(sizeof(s_animgraphconnection) == 24, "struct s_animgraphconnection is invalid size");

		struct s_animationtokennode
		{
			string_id animation_name;
			string_id group_name;
			c_enum<e_animationmode, long> mode;
			real playback_rate;
			c_flags<e_animtokenflags, short, k_animtokenflags_count> animation_token_flags;
			char generated_pad4403[2]; // padding
		};
		static_assert(sizeof(s_animationtokennode) == 20, "struct s_animationtokennode is invalid size");

		struct s_animationexistsnode
		{
			string_id anim_set_name;
			string_id animation_name;
			long variation_index;
		};
		static_assert(sizeof(s_animationexistsnode) == 12, "struct s_animationexistsnode is invalid size");

		struct s_animsetexistsnode
		{
			string_id anim_set_name;
		};
		static_assert(sizeof(s_animsetexistsnode) == 4, "struct s_animsetexistsnode is invalid size");

		struct s_posenode
		{
			string_id animation_name;
			long frame;
		};
		static_assert(sizeof(s_posenode) == 8, "struct s_posenode is invalid size");

		struct s_selectionnodepose
		{
			s_animgraphconnection pose_connection;
		};
		static_assert(sizeof(s_selectionnodepose) == 24, "struct s_selectionnodepose is invalid size");

		struct s_selectionnode
		{
			long default_selection;
			c_flags<e_selectionnodeflags, short, k_selectionnodeflags_count> selection_node_flags;
			char generated_pad6efe[2]; // padding
			c_typed_tag_block<s_selectionnodepose> pose_connections_block;
		};
		static_assert(sizeof(s_selectionnode) == 20, "struct s_selectionnode is invalid size");

		struct s_layernodelayer
		{
			long index;
			c_enum<e_layernodemode, long> mode;
			real alpha;
			s_animgraphconnection pose_connection;
			s_animgraphconnection alpha_connection;
			c_flags<e_layernodelayerflags, short, k_layernodelayerflags_count> layer_token_flags;
			char generated_pad47a8[2]; // padding
			string_id correction_pose_bone;
			s_animgraphconnection replacement_anim_correction_pose_connection;
		};
		static_assert(sizeof(s_layernodelayer) == 92, "struct s_layernodelayer is invalid size");

		struct s_layernode
		{
			c_typed_tag_block<s_layernodelayer> layers_block;
		};
		static_assert(sizeof(s_layernode) == 12, "struct s_layernode is invalid size");

		struct s_autospeedtoken
		{
			string_id animation_token;
			real weight;
			s_subgraphreferenceexportedanimnodegraph subgraph_reference;
		};
		static_assert(sizeof(s_autospeedtoken) == 24, "struct s_autospeedtoken is invalid size");

		struct s_blendspacenode
		{
			c_enum<e_animblendnodetype, long> blend_type;
			c_typed_tag_reference<XANIMBLENDGRAPHNG_TAG> blend_graph;
			string_id anim_name;
			c_typed_tag_block<s_autospeedtoken> auto_speed_tokens_block;
			c_typed_tag_block<s_autospeedtoken> auto_turn_rate_tokens_block;
			real min_alpha;
			real max_alpha;
			real radius;
			long partition_count;
			string_id group_name;
			string_id label;
			c_flags<e_blendspaceflags, short, k_blendspaceflags_count> flags;
			char generated_pad29df[2]; // padding
			string_id channel_1;
			string_id channel_2;
			string_id channel_3;
			real input_smoothing_traversal_time;
		};
		static_assert(sizeof(s_blendspacenode) == 92, "struct s_blendspacenode is invalid size");

		struct s_statemachinenode
		{
			c_typed_tag_reference<XANIMSTATEGRAPH_TAG> animation_state_machine;
		};
		static_assert(sizeof(s_statemachinenode) == 16, "struct s_statemachinenode is invalid size");

		struct s_controlparameternode
		{
			string_id parameter_name;
			c_enum<e_controlparametertype, long> type;
		};
		static_assert(sizeof(s_controlparameternode) == 8, "struct s_controlparameternode is invalid size");

		struct s_subanimgraphnode
		{
			c_typed_tag_reference<XANIMNODEGRAPH_TAG> animation_graph;
		};
		static_assert(sizeof(s_subanimgraphnode) == 16, "struct s_subanimgraphnode is invalid size");

		struct s_transitiondatanode
		{
			c_enum<e_transitiondatatype, long> data_type;
		};
		static_assert(sizeof(s_transitiondatanode) == 4, "struct s_transitiondatanode is invalid size");

		struct s_objectfunctionnode
		{
			string_id function_name;
		};
		static_assert(sizeof(s_objectfunctionnode) == 4, "struct s_objectfunctionnode is invalid size");

		struct s_editablenumbernode
		{
			string_id property_name;
			c_enum<e_editablenumbertype, long> data_type;
			real float_value;
			real float_min_value;
			real float_max_value;
			long int_value;
			long bool_value;
			real_vector3d vector_value;
		};
		static_assert(sizeof(s_editablenumbernode) == 40, "struct s_editablenumbernode is invalid size");

		struct s_booleanlogicnode
		{
			c_enum<e_booleanlogictype, long> operation_type;
		};
		static_assert(sizeof(s_booleanlogicnode) == 4, "struct s_booleanlogicnode is invalid size");

		struct s_floatlogicnode
		{
			c_enum<e_floatlogictype, long> condition;
		};
		static_assert(sizeof(s_floatlogicnode) == 4, "struct s_floatlogicnode is invalid size");

		struct s_floatoperatornode
		{
			c_enum<e_floatoperatortype, long> operation_type;
		};
		static_assert(sizeof(s_floatoperatornode) == 4, "struct s_floatoperatornode is invalid size");

		struct s_intlogicnode
		{
			c_enum<e_intlogictype, long> condition;
		};
		static_assert(sizeof(s_intlogicnode) == 4, "struct s_intlogicnode is invalid size");

		struct s_intoperatornode
		{
			c_enum<e_intoperatortype, long> operation_type;
		};
		static_assert(sizeof(s_intoperatornode) == 4, "struct s_intoperatornode is invalid size");

		struct s_trignode
		{
			c_enum<e_trigtype, long> operation_type;
		};
		static_assert(sizeof(s_trignode) == 4, "struct s_trignode is invalid size");

		struct s_blackboardnode
		{
			c_enum<e_blackboardoperationtype, long> operation_type;
			s_blackboardentrydescriptor blackboard_entry_descriptor;
		};
		static_assert(sizeof(s_blackboardnode) == 12, "struct s_blackboardnode is invalid size");

		struct s_valueconversionnode
		{
			c_enum<e_valueconversiontype, long> conversion_type;
		};
		static_assert(sizeof(s_valueconversionnode) == 4, "struct s_valueconversionnode is invalid size");

		struct s_interpolationnode
		{
			c_enum<e_interpolationtype, long> interpolation_type;
		};
		static_assert(sizeof(s_interpolationnode) == 4, "struct s_interpolationnode is invalid size");

		struct s_constantfloatnode
		{
			real value;
		};
		static_assert(sizeof(s_constantfloatnode) == 4, "struct s_constantfloatnode is invalid size");

		struct s_constantintnode
		{
			long value;
		};
		static_assert(sizeof(s_constantintnode) == 4, "struct s_constantintnode is invalid size");

		struct s_constantint64node
		{
			long value;
			char generated_pad8671[4]; // padding
		};
		static_assert(sizeof(s_constantint64node) == 8, "struct s_constantint64node is invalid size");

		struct s_constantuint64node
		{
			long value;
			char generated_pad75b8[4]; // padding
		};
		static_assert(sizeof(s_constantuint64node) == 8, "struct s_constantuint64node is invalid size");

		struct s_constantstringnode
		{
			c_static_string<256> value;
		};
		static_assert(sizeof(s_constantstringnode) == 256, "struct s_constantstringnode is invalid size");

		struct s_constantboolnode
		{
			long value;
		};
		static_assert(sizeof(s_constantboolnode) == 4, "struct s_constantboolnode is invalid size");

		struct s_unitparameternode
		{
			c_enum<e_unitparametertype, long> parameter_type;
			real angle_lock_range;
		};
		static_assert(sizeof(s_unitparameternode) == 8, "struct s_unitparameternode is invalid size");

		struct s_endofanimationnode
		{
			c_enum<e_endofanimationeventtype, char> node_type;
			char generated_pade774[3]; // padding
			string_id group_name;
			real offset_time;
		};
		static_assert(sizeof(s_endofanimationnode) == 12, "struct s_endofanimationnode is invalid size");

		struct s_bonemasknode
		{
			string_id bone_mask_id;
		};
		static_assert(sizeof(s_bonemasknode) == 4, "struct s_bonemasknode is invalid size");

		struct s_iknodetag
		{
			real weight;
			string_id source_marker_name;
			string_id target_marker_name;
			string_id preferred_ik_chain_name;
			real blend_rate;
			c_enum<e_iktype, char> ik_type;
			char generated_pad0318[3]; // padding
			real priority;
			c_flags<e_iktaskflags, char, k_iktaskflags_count> flags;
			char generated_pad1cf9[3]; // padding
		};
		static_assert(sizeof(s_iknodetag) == 32, "struct s_iknodetag is invalid size");

		struct s_groundiknodetag
		{
			real weight;
			string_id source_marker_name;
			string_id preferred_ik_chain_name;
			real blend_rate;
			real priority;
		};
		static_assert(sizeof(s_groundiknodetag) == 20, "struct s_groundiknodetag is invalid size");

		struct s_lookiknodetag
		{
			real weight;
			real blend_rate;
			real priority;
			string_id relative_forward_marker;
			real yaw;
			real pitch;
			real yaw_min;
			real yaw_max;
			real pitch_min;
			real pitch_max;
			real yaw_pose_contribution;
			real pitch_pose_contribution;
			c_enum<e_lookikrelativeforwardmode, char> relative_forward_mode;
			char generated_pad9f7b[3]; // padding
		};
		static_assert(sizeof(s_lookiknodetag) == 52, "struct s_lookiknodetag is invalid size");

		struct s_concatenatestring
		{
			long index;
			c_static_string<256> _string;
		};
		static_assert(sizeof(s_concatenatestring) == 260, "struct s_concatenatestring is invalid size");

		struct s_concatenatenode
		{
			c_typed_tag_block<s_concatenatestring> strings_block;
		};
		static_assert(sizeof(s_concatenatenode) == 12, "struct s_concatenatenode is invalid size");

		struct s_animsetpushnode
		{
			c_enum<e_pushnodetype, char> type;
			c_static_string<256> _string;
			char generated_pada121[3]; // padding
			long push_order;
		};
		static_assert(sizeof(s_animsetpushnode) == 264, "struct s_animsetpushnode is invalid size");

		struct s_switchintinputvalue
		{
			long int_value;
		};
		static_assert(sizeof(s_switchintinputvalue) == 4, "struct s_switchintinputvalue is invalid size");

		struct s_switchstringinputvalue
		{
			string_id string_value;
		};
		static_assert(sizeof(s_switchstringinputvalue) == 4, "struct s_switchstringinputvalue is invalid size");

		struct s_switchnode
		{
			c_typed_tag_block<s_switchintinputvalue> int_input_values_block;
			c_typed_tag_block<s_switchstringinputvalue> string_input_values_block;
			long default_pin_index;
		};
		static_assert(sizeof(s_switchnode) == 28, "struct s_switchnode is invalid size");

		struct s_switchonassetinputvalue
		{
			c_typed_tag_reference<ANYTAG_TAG> asset_reference;
			c_enum<e_switchableassetinputtype, char> is_asset_category;
			char generated_pade0fe[3]; // padding
		};
		static_assert(sizeof(s_switchonassetinputvalue) == 20, "struct s_switchonassetinputvalue is invalid size");

		struct s_switchonassetnode
		{
			c_typed_tag_block<s_switchonassetinputvalue> inputs_block;
		};
		static_assert(sizeof(s_switchonassetnode) == 12, "struct s_switchonassetnode is invalid size");

		struct s_aimscreennode
		{
			real yaw;
			real pitch;
			s_animgraphconnection yaw_connection;
			s_animgraphconnection pitch_connection;
			string_id aim_animation_name;
			string_id label;
			c_flags<e_aimscreenflags, short, k_aimscreenflags_count> flags;
			char generated_pad6467[2]; // padding
			real input_smoothing_traversal_time;
		};
		static_assert(sizeof(s_aimscreennode) == 72, "struct s_aimscreennode is invalid size");

		struct s_accspacenode
		{
			string_id acceleration_animation_name;
		};
		static_assert(sizeof(s_accspacenode) == 4, "struct s_accspacenode is invalid size");

		struct s_animationextractnode
		{
			s_animgraphconnection pose_connection;
			string_id joint_name;
		};
		static_assert(sizeof(s_animationextractnode) == 28, "struct s_animationextractnode is invalid size");

		struct s_animationgetlocaloffsetnode
		{
			string_id joint_name_1;
			string_id joint_name_2;
			c_flags<e_animationgetlocaloffsetflags, short, k_animationgetlocaloffsetflags_count> animation_get_local_offset_flags;
			char generated_padb27a[2]; // padding
		};
		static_assert(sizeof(s_animationgetlocaloffsetnode) == 12, "struct s_animationgetlocaloffsetnode is invalid size");

		struct s_animationgetvaluesnode
		{
			s_animgraphconnection pose_connection;
			string_id joint_name;
			c_flags<e_animationgetvaluesflags, short, k_animationgetvaluesflags_count> animation_get_values_node_flags;
			char generated_pad70a2[2]; // padding
		};
		static_assert(sizeof(s_animationgetvaluesnode) == 32, "struct s_animationgetvaluesnode is invalid size");

		struct s_animationfkjointnames
		{
			string_id joint_name;
		};
		static_assert(sizeof(s_animationfkjointnames) == 4, "struct s_animationfkjointnames is invalid size");

		struct s_animationfknode
		{
			s_animgraphconnection pose_connection;
			c_typed_tag_block<s_animationfkjointnames> joint_names_block;
			s_animgraphconnection translation;
			s_animgraphconnection rotation;
			s_animgraphconnection scale;
			c_flags<e_animationfkflags, short, k_animationfkflags_count> animation_fk_node_flags;
			char generated_pad8b37[2]; // padding
			s_animgraphconnection pivot_pose_connection;
			string_id pivot_joint_name;
		};
		static_assert(sizeof(s_animationfknode) == 140, "struct s_animationfknode is invalid size");

		struct s_animationconstraintnode
		{
			string_id joint_name;
			string_id target_joint_name;
			string_id offset_joint_name;
			c_flags<e_animationconstraintflags, short, k_animationconstraintflags_count> animation_constraint_node_flags;
			char generated_pade4e3[2]; // padding
		};
		static_assert(sizeof(s_animationconstraintnode) == 16, "struct s_animationconstraintnode is invalid size");

		struct s_voiceoveranimationnode
		{
			c_enum<e_voiceoveranimationdatatypes, long> voiceover_animation_data_types;
		};
		static_assert(sizeof(s_voiceoveranimationnode) == 4, "struct s_voiceoveranimationnode is invalid size");

		struct s_nativeexpressionnode
		{
			c_enum<e_nativeexpressiontype, long> type;
			string_id native_graph_name;
			long use_native_graph;
		};
		static_assert(sizeof(s_nativeexpressionnode) == 12, "struct s_nativeexpressionnode is invalid size");

		struct s_exportedanimnodegraph
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<ANIMNODEGRAPH_TAG> source_graph;
			c_typed_tag_block<s_subgraphreferenceexportedanimnodegraph> anim_node_subgraphs_block;
			c_typed_tag_block<s_subgraphreferenceanimstategraph> anim_state_subgraphs_block;
			s_i343animationlocalcontrolparametersdefinition control_parameters_definitions;
			c_typed_tag_block<s_blackboardentrydescriptor> blackboard_entries_block;
			c_typed_tag_block<s_animgraphconnection> connections_block;
			c_typed_tag_block<s_animationtokennode> animation_tokens_block;
			c_typed_tag_block<s_animationexistsnode> animation_exists_nodes_block;
			c_typed_tag_block<s_animsetexistsnode> anim_set_exists_nodes_block;
			long blend_node_count;
			long overlay_node_count;
			long dummy_pose_node_count;
			long branch_node_count;
			c_typed_tag_block<s_posenode> pose_nodes_block;
			c_typed_tag_block<s_selectionnode> selection_nodes_block;
			c_typed_tag_block<s_layernode> layer_nodes_block;
			c_typed_tag_block<s_blendspacenode> blend_space_nodes_block;
			c_typed_tag_block<s_statemachinenode> state_machine_nodes_block;
			c_typed_tag_block<s_controlparameternode> control_parameters_block;
			c_typed_tag_block<s_subanimgraphnode> sub_anim_graphs_block;
			c_typed_tag_block<s_transitiondatanode> transition_data_nodes_block;
			c_typed_tag_block<s_objectfunctionnode> object_function_nodes_block;
			c_typed_tag_block<s_editablenumbernode> editable_number_nodes_block;
			c_typed_tag_block<s_booleanlogicnode> boolean_logic_nodes_block;
			c_typed_tag_block<s_floatlogicnode> float_logic_nodes_block;
			c_typed_tag_block<s_floatoperatornode> float_operator_nodes_block;
			c_typed_tag_block<s_intlogicnode> int_logic_nodes_block;
			c_typed_tag_block<s_intoperatornode> int_operator_nodes_block;
			c_typed_tag_block<s_trignode> trig_nodes_block;
			c_typed_tag_block<s_blackboardnode> blackboard_nodes_block;
			c_typed_tag_block<s_valueconversionnode> valueconversion_nodes_block;
			c_typed_tag_block<s_interpolationnode> interpolation_nodes_block;
			c_typed_tag_block<s_constantfloatnode> constant_float_nodes_block;
			c_typed_tag_block<s_constantintnode> constant_int_nodes_block;
			c_typed_tag_block<s_constantint64node> constant_int64_nodes_block;
			c_typed_tag_block<s_constantuint64node> constant_uint64_nodes_block;
			c_typed_tag_block<s_constantstringnode> constant_string_nodes_block;
			c_typed_tag_block<s_constantboolnode> constant_bool_nodes_block;
			c_typed_tag_block<s_unitparameternode> unit_parameter_nodes_block;
			c_typed_tag_block<s_endofanimationnode> end_of_animation_nodes_block;
			c_typed_tag_block<s_bonemasknode> bone_mask_nodes_block;
			c_typed_tag_block<s_iknodetag> ik_nodes_block;
			c_typed_tag_block<s_groundiknodetag> ground_ik_nodes_block;
			c_typed_tag_block<s_lookiknodetag> look_ik_nodes_block;
			c_typed_tag_block<s_concatenatenode> concatenate_nodes_block;
			c_typed_tag_block<s_animsetpushnode> anim_set_push_nodes_block;
			c_typed_tag_block<s_switchnode> switch_nodes_block;
			c_typed_tag_block<s_switchonassetnode> switchonasset_nodes_block;
			c_typed_tag_block<s_aimscreennode> aim_screen_nodes_block;
			c_typed_tag_block<s_accspacenode> acc_space_nodes_block;
			c_typed_tag_block<s_animationextractnode> animation_extract_nodes_block;
			c_typed_tag_block<s_animationgetlocaloffsetnode> animation_get_local_offset_nodes_block;
			c_typed_tag_block<s_animationgetvaluesnode> animation_get_values_nodes_block;
			c_typed_tag_block<s_animationfknode> animation_fk_nodes_block;
			c_typed_tag_block<s_animationconstraintnode> animation_constraint_nodes_block;
			c_typed_tag_block<s_voiceoveranimationnode> voiceover_animation_nodes_block;
			c_typed_tag_block<s_nativeexpressionnode> native_expression_nodes_block;
			c_enum<e_animgraphnodetype, long> final_pose_node_type;
			long final_pose_node_index;
			long final_pose_pin_index;
		};
		static_assert(sizeof(s_exportedanimnodegraph) == 732, "struct s_exportedanimnodegraph is invalid size");

		struct s_animentry
		{
			string_id token;
			long uniqueid;
			string_id legacyname;
			s_tag_reference animationsource;
			c_enum<e_animationtype, char> type;
			c_enum<e_animationcompressiontype, char> compression;
			char generated_pad78b5[2]; // padding
			c_typed_tag_reference<MODEL_ANIMATION_GRAPH_TAG> generatedmodelanimation;
			real weight;
			c_enum<e_autoweight, char> autoweight;
			c_flags<e_animentryflags, char, k_animentryflags_count> flags;
			// custom legacy_fields
			short loop_frame_index;
			c_flags<e_c_animation_user_flags, short, k_c_animation_user_flags_count> legacy_user_flags;
			// custom value
			char generated_pad5ed4[2]; // padding
		};
		static_assert(sizeof(s_animentry) == 60, "struct s_animentry is invalid size");

		struct s_legacyanimsetcompositeentry
		{
			string_id name;
			c_static_string<256> source_xml;
			c_enum<e_legacyanimsetcompositetype, char> type;
			char generated_padc60d[3]; // padding
		};
		static_assert(sizeof(s_legacyanimsetcompositeentry) == 264, "struct s_legacyanimsetcompositeentry is invalid size");

		struct s_animsettag
		{
			s_anytag_struct_definition anytag;
			string_id channel;
			c_typed_tag_reference<ANIMSET_TAG> parent;
			s_tag_reference asset;
			c_typed_tag_reference<ANIMFRAMEEVENTS_TAG> animation_frame_events;
			c_typed_tag_reference<ANIMFRAMEEVENTSAUDIO_TAG> audio_frame_events;
			c_typed_tag_reference<ANIMFRAMEEVENTSFX_TAG> effect_frame_events;
			c_typed_tag_block<s_animentry> animations_block;
			c_typed_tag_reference<MODEL_ANIMATION_GRAPH_TAG> reference_to_generated_anim_pool_tag;
			// custom legacy_animset_fields
			c_typed_tag_block<s_legacyanimsetcompositeentry> composites_block;
			// custom value
			char generated_pad5195[4]; // padding
		};
		static_assert(sizeof(s_animsettag) == 144, "struct s_animsettag is invalid size");

		struct s_subgraphreferencetransitionlogicgraph
		{
			c_typed_tag_reference<XTRANSITIONLOGICGRAPH_TAG> transition_logic_subgraph;
		};
		static_assert(sizeof(s_subgraphreferencetransitionlogicgraph) == 16, "struct s_subgraphreferencetransitionlogicgraph is invalid size");

		struct s_animstatenode
		{
			string_id name;
			c_typed_tag_reference<XANIMNODEGRAPH_TAG> animation_sub_graph;
			c_flags<e_animstateflags, short, k_animstateflags_count> state_flags;
			char generated_padde0e[2]; // padding
		};
		static_assert(sizeof(s_animstatenode) == 24, "struct s_animstatenode is invalid size");

		struct s_animstateconnection
		{
			short start_state;
			short end_state;
			c_typed_tag_reference<XTRANSITIONLOGICGRAPH_TAG> condition_graph;
			c_typed_tag_reference<XANIMNODEGRAPH_TAG> transition_blend;
			long priority;
			real duration;
			c_flags<e_animstateconnectionflags, short, k_animstateconnectionflags_count> inertialize;
			c_flags<e_animstateeventsflags, short, k_animstateeventsflags_count> process_events_from_both_states;
		};
		static_assert(sizeof(s_animstateconnection) == 48, "struct s_animstateconnection is invalid size");

		struct s_animdefaultstateconnection
		{
			short state;
			char generated_paddb5f[2]; // padding
			c_typed_tag_reference<XTRANSITIONLOGICGRAPH_TAG> condition_graph;
		};
		static_assert(sizeof(s_animdefaultstateconnection) == 20, "struct s_animdefaultstateconnection is invalid size");

		struct s_animstategraph
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<ANIMSTATENODEGRAPH_TAG> source_graph;
			c_typed_tag_block<s_subgraphreferenceexportedanimnodegraph> anim_node_subgraphs_block;
			c_typed_tag_block<s_subgraphreferencetransitionlogicgraph> transition_logic_subgraphs_block;
			c_typed_tag_block<s_animstatenode> states_block;
			c_typed_tag_block<s_animstateconnection> connections_block;
			c_typed_tag_block<s_animdefaultstateconnection> start_transitions_block;
			c_typed_tag_reference<XANIMNODEGRAPH_TAG> transition_blend;
			char generated_pad2a58[4]; // padding
		};
		static_assert(sizeof(s_animstategraph) == 112, "struct s_animstategraph is invalid size");

		struct s_antenna_vertex
		{
			real_euler_angles2d angles;
			real length;
			short sequence_index;
			char generated_padd920[2]; // padding
			argb_color color;
			argb_color lod_color;
			real hermite_t;
			real_vector3d vector_to_next;
		};
		static_assert(sizeof(s_antenna_vertex) == 64, "struct s_antenna_vertex is invalid size");

		struct s_antenna_definition
		{
			s_anytag_struct_definition anytag;
			string_id attachment_marker_name;
			c_typed_tag_reference<BITMAP_TAG> bitmaps;
			c_typed_tag_reference<POINT_PHYSICS_TAG> physics;
			real_fraction spring_strength_coefficient;
			real texel_to_world_width_scale;
			real falloff_pixels;
			real cutoff_pixels;
			real point_of_bend;
			real starting_bend;
			real ending_bend;
			real runtime_total_length;
			c_typed_tag_block<s_antenna_vertex> vertices_block;
		};
		static_assert(sizeof(s_antenna_definition) == 96, "struct s_antenna_definition is invalid size");

		struct s_i343actionsystemactionprioritydatadefinitionexistingentry
		{
			c_enum<e_i343actionsystemactiontype, long> this_action;
			c_enum<e_i343actionsystemactionpriorityresult, long> combined_result;
		};
		static_assert(sizeof(s_i343actionsystemactionprioritydatadefinitionexistingentry) == 8, "struct s_i343actionsystemactionprioritydatadefinitionexistingentry is invalid size");

		struct s_i343actionsystemactionprioritydatadefinitionincomingentry
		{
			c_enum<e_i343actionsystemactiontype, long> this_action;
			c_typed_tag_block<s_i343actionsystemactionprioritydatadefinitionexistingentry> existing_actions_block;
		};
		static_assert(sizeof(s_i343actionsystemactionprioritydatadefinitionincomingentry) == 16, "struct s_i343actionsystemactionprioritydatadefinitionincomingentry is invalid size");

		struct s_i343actionsystemactionprioritydatadefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343actionsystemactionprioritydatadefinitionincomingentry> incoming_actions_block;
			char generated_pade8f1[4]; // padding
		};
		static_assert(sizeof(s_i343actionsystemactionprioritydatadefinition) == 32, "struct s_i343actionsystemactionprioritydatadefinition is invalid size");

		struct s_visualregionnameblock
		{
			string_id name;
		};
		static_assert(sizeof(s_visualregionnameblock) == 4, "struct s_visualregionnameblock is invalid size");

		struct s_propertyregion
		{
			string_id name;
			c_flags<e_propertyregionflagsdefinition, long, k_propertyregionflagsdefinition_count> flags;
			c_enum<e_staticgeometrymergemode, long> static_geometry_merge_mode;
			c_enum<e_assetnumberofsides, long> number_of_sides;
			c_enum<e_prefablightmappingpolicy, char> lightmapping_policy;
			char generated_pad5489[3]; // padding
			real_vector3d probe_grid_capture_offset;
			string_id physics_material_name;
			string_id damage_section;
			// custom blendshapes
			c_enum<e_tensionsupportlod, long> tension_backing_data;
			real prune_threshold;
			c_enum<e_recomputednormalblendmode, long> recomputed_normal_blend_mode;
			// custom value
			// custom emblem_data
			long emblem_layer_depth;
			// custom value
		};
		static_assert(sizeof(s_propertyregion) == 56, "struct s_propertyregion is invalid size");

		struct s_relativesourcepath
		{
			c_static_string<256> path;
		};
		static_assert(sizeof(s_relativesourcepath) == 256, "struct s_relativesourcepath is invalid size");

		struct s_damagestateblock
		{
			c_enum<e_assetdamagestates, long> state;
			string_id geometry_name;
		};
		static_assert(sizeof(s_damagestateblock) == 8, "struct s_damagestateblock is invalid size");

		struct s_contenttagblock
		{
			string_id name;
			string_id groupname;
			c_typed_tag_reference<GEOMETRY_TAG> reference;
			c_typed_tag_block<s_relativesourcepath> relative_source_paths_block;
			c_typed_tag_block<s_damagestateblock> damage_states_block;
		};
		static_assert(sizeof(s_contenttagblock) == 48, "struct s_contenttagblock is invalid size");

		struct s_skeletonblock
		{
			c_typed_tag_reference<SKELETON_TAG> reference;
			c_static_string<256> alembic_source_path;
		};
		static_assert(sizeof(s_skeletonblock) == 272, "struct s_skeletonblock is invalid size");

		struct s_additionalcontentpath
		{
			string_id name;
			c_static_string<256> path;
		};
		static_assert(sizeof(s_additionalcontentpath) == 260, "struct s_additionalcontentpath is invalid size");

		struct s_markerblock
		{
			string_id name;
			string_id groupname;
			c_typed_tag_reference<MARKER_TAG> reference;
		};
		static_assert(sizeof(s_markerblock) == 24, "struct s_markerblock is invalid size");

		struct s_lodtransitiondistancesblock
		{
			real transition_distance;
		};
		static_assert(sizeof(s_lodtransitiondistancesblock) == 4, "struct s_lodtransitiondistancesblock is invalid size");

		struct s_visualregionoverrideentry
		{
			string_id region_name;
			string_id geometry_name;
		};
		static_assert(sizeof(s_visualregionoverrideentry) == 8, "struct s_visualregionoverrideentry is invalid size");

		struct s_materialoverrideentry
		{
			c_typed_tag_reference<MATERIAL_TAG> original_material_ref;
			c_typed_tag_reference<MATERIAL_TAG> override_material_ref;
		};
		static_assert(sizeof(s_materialoverrideentry) == 32, "struct s_materialoverrideentry is invalid size");

		struct s_assetchildobject
		{
			string_id parent_marker;
			string_id child_marker;
			string_id child_variant_name;
			c_typed_tag_reference<OBJECT_TAG> child_object;
			c_typed_tag_reference<OBJECT_CONFIGURATION_TAG> child_configuration;
			string_id damage_section;
			c_flags<e_i343modelmodelvariantobjectflags, char, k_i343modelmodelvariantobjectflags_count> flags;
			char generated_padb3ad[3]; // padding
		};
		static_assert(sizeof(s_assetchildobject) == 52, "struct s_assetchildobject is invalid size");

		struct s_mutedjointentry
		{
			string_id joint_name;
		};
		static_assert(sizeof(s_mutedjointentry) == 4, "struct s_mutedjointentry is invalid size");

		struct s_i343objectsobjectnodegraphdefinition
		{
			string_id name;
			c_typed_tag_reference<XOBJECTNODEGRAPH_TAG> exported_node_graph;
			c_flags<e_objectnodegraphflags, char, k_objectnodegraphflags_count> flags;
			c_enum<e_booleanoverride, char> enable_node_graph;
			char generated_pad8671[2]; // padding
		};
		static_assert(sizeof(s_i343objectsobjectnodegraphdefinition) == 24, "struct s_i343objectsobjectnodegraphdefinition is invalid size");

		struct s_assetvariant
		{
			string_id name;
			string_id style;
			long damage_style_index;
			string_id all_visual_region;
			c_typed_tag_block<s_visualregionoverrideentry> visual_region_overrides_block;
			c_typed_tag_block<s_materialoverrideentry> material_overrides_block;
			c_typed_tag_block<s_assetchildobject> child_objects_block;
			c_typed_tag_block<s_mutedjointentry> muted_joints_block;
			c_typed_tag_block<s_i343objectsobjectnodegraphdefinition> object_node_graphs_overrides_block;
			c_typed_tag_reference<RTMP_TAG> reference_to_material_palette_tag;
			c_typed_tag_reference<VECTORART_TAG> reference_to_generated_vector_art;
			c_typed_tag_reference<ABC_TAG> reference_round_trip_abc_tag_from_a_render_model;
			c_typed_tag_reference<ABC_TAG> reference_round_trip_abc_tag_from_a_runtimegeo;
		};
		static_assert(sizeof(s_assetvariant) == 140, "struct s_assetvariant is invalid size");

		struct s_uniqueassetgeometryvariant
		{
			qword uuid;
			c_typed_tag_block<s_visualregionoverrideentry> explicit_visual_region_list_block;
			c_typed_tag_reference<RUNTIME_GEO_TAG> reference_to_generated_prefab;
			c_typed_tag_reference<RAW_GEO_TAG> reference_to_raw_triangle_data;
			c_typed_tag_reference<STATIC_COLLISION_TAG> reference_to_generated_static_collision_geometry;
			c_typed_tag_reference<FIXEDDEPTHQUADTREE_TAG> reference_to_generated_lightweight_fixed_depth_quadtree;
			char generated_pada40c[4]; // padding
		};
		static_assert(sizeof(s_uniqueassetgeometryvariant) == 88, "struct s_uniqueassetgeometryvariant is invalid size");

		struct s_validationcomment
		{
			c_static_string<256> comment;
			c_flags<e_validationstatusflags, long, k_validationstatusflags_count> status;
		};
		static_assert(sizeof(s_validationcomment) == 260, "struct s_validationcomment is invalid size");

		struct s_validation
		{
			c_static_string<256> test_name;
			c_flags<e_validationstatusflags, long, k_validationstatusflags_count> test_status;
			c_typed_tag_block<s_validationcomment> comments_block;
		};
		static_assert(sizeof(s_validation) == 272, "struct s_validation is invalid size");

		struct s_contentvalidationgroup
		{
			c_static_string<256> group_name;
			long group_id;
			c_flags<e_validationstatusflags, long, k_validationstatusflags_count> validation_status;
			c_typed_tag_block<s_validation> validation_tests_block;
		};
		static_assert(sizeof(s_contentvalidationgroup) == 276, "struct s_contentvalidationgroup is invalid size");

		struct s_contentvalidationblockdata
		{

			/* Content validation tests */

			c_flags<e_validationstatusflags, long, k_validationstatusflags_count> validation_status;
			c_typed_tag_block<s_contentvalidationgroup> validation_test_batteries_block;
		};
		static_assert(sizeof(s_contentvalidationblockdata) == 16, "struct s_contentvalidationblockdata is invalid size");

		struct s_assettag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_visualregionnameblock> visual_region_names_block;
			c_typed_tag_block<s_propertyregion> property_regions_block;
			// custom component_tags_files
			c_typed_tag_block<s_contenttagblock> geometry_tags_block;
			c_typed_tag_block<s_skeletonblock> skeleton_block;
			c_typed_tag_block<s_additionalcontentpath> additional_content_paths_block;
			c_typed_tag_block<s_markerblock> marker_tags_block;
			c_typed_tag_reference<ASSET_PHYSICS_TAG> asset_physics_tag;
			c_typed_tag_reference<DAMAGE_TAG> damage_tag;
			c_typed_tag_reference<LEGACYANIMSET_TAG> legacy_animset_tag;
			c_typed_tag_reference<ASSET_SOUND_TAG> asset_sound_tag;
			c_typed_tag_reference<ASSET_DIALOGUE_TAG> asset_dialogue_tag;
			// custom value
			string_id asset_category;
			// custom lods
			// custom automatically_generated_lod_settings
			c_typed_tag_reference<LODSETTINGS_TAG> lod_settings_tag;
			string_id lod_settings_name;
			real lod_distance_bias;
			// custom value
			c_typed_tag_block<s_lodtransitiondistancesblock> lod_transition_distances_block;
			real lod_fade_out_after_distance;
			c_enum<e_hlodpolicy, char> hlod_policy;
			char generated_padebca[3]; // padding
			// custom value
			// custom variants
			string_id default_variant_name;
			c_typed_tag_block<s_assetvariant> asset_variants_block;
			c_typed_tag_block<s_uniqueassetgeometryvariant> unique_geometry_block;
			c_enum<e_rendermodeldefaultloadvariantpolicy, char> default_load_variant_policy;
			// custom value
			// custom static_collision_generation_settings
			c_enum<e_staticcollisionbuildpolicy, char> static_collision_build_policy;
			c_enum<e_staticcollisiondecalspolicy, char> static_collision_decals_policy;
			char generated_pad387f[1]; // padding
			// custom value
			// custom static_render_generation_settings
			c_enum<e_assetusecollisionasshadowpolicy, long> convert_collision_to_shadow_geometry;
			c_flags<e_meshlodflagsdefinition, short, k_meshlodflagsdefinition_count> converted_bullet_collision_lod_flags;
			c_flags<e_meshlodflagsdefinition, short, k_meshlodflagsdefinition_count> converted_play_collision_lod_flags;
			// custom value
			// custom generated_tags
			c_typed_tag_reference<MODEL_TAG> model_tag;
			c_typed_tag_reference<RENDER_MODEL_TAG> render_model_tag;
			c_typed_tag_reference<PHYSICS_MODEL_TAG> physics_model_tag;
			c_typed_tag_reference<COLLISION_MODEL_TAG> collision_model_tag;
			c_typed_tag_reference<MODEL_ANIMATION_GRAPH_TAG> legacy_model_animation_graph_tag;
			// custom impostor
			c_typed_tag_reference<IMPOSTOR_TAG> impostor_tag;
			// custom value
			// custom validation
			s_contentvalidationblockdata validation;
			// custom value
		};
		static_assert(sizeof(s_assettag) == 368, "struct s_assettag is invalid size");

		struct s_s_animation_graph_node
		{
			string_id name;
			short next_sibling_node_index;
			short first_child_node_index;
			short parent_node_index;
			c_flags<e_animationnodemodelflags, short, k_animationnodemodelflags_count> model_flags;
			real z_pos;
			long frame_id1;
			long frame_id2;
		};
		static_assert(sizeof(s_s_animation_graph_node) == 24, "struct s_s_animation_graph_node is invalid size");

		struct s_s_animation_node_usage_entry
		{
			c_enum<e_c_animation_node_usage, short> usage;
			short node_to_use;
		};
		static_assert(sizeof(s_s_animation_node_usage_entry) == 4, "struct s_s_animation_node_usage_entry is invalid size");

		struct s_s_animation_node_mask_entry
		{
			short node;
		};
		static_assert(sizeof(s_s_animation_node_mask_entry) == 2, "struct s_s_animation_node_mask_entry is invalid size");

		struct s_nodeflagstoragearray
		{
			long flag_data;
		};
		static_assert(sizeof(s_nodeflagstoragearray) == 4, "struct s_nodeflagstoragearray is invalid size");

		struct s_s_animation_node_mask
		{
			string_id name;
			c_flags<e_nodemaskflags, short, k_nodemaskflags_count> flags;
			short chain_start;
			c_typed_tag_block<s_s_animation_node_mask_entry> chain_ends_block;
			c_typed_tag_block<s_s_animation_node_mask_entry> nodes_block;
			short add_nodes;
			short remove_nodes;
			s_nodeflagstoragearray node_flags[32];
		};
		static_assert(sizeof(s_s_animation_node_mask) == 164, "struct s_s_animation_node_mask is invalid size");

		struct s_animationgraphuserparameter
		{
			string_id name;
			real default_value;
		};
		static_assert(sizeof(s_animationgraphuserparameter) == 8, "struct s_animationgraphuserparameter is invalid size");

		struct s_animationgraphskeleton
		{
			long skeleton_checksum;
			c_typed_tag_block<s_s_animation_graph_node> skeleton_bones_block;
			c_typed_tag_block<s_s_animation_node_usage_entry> bone_usage_block;
			c_typed_tag_block<s_s_animation_node_mask> bone_masks_block;
			c_typed_tag_block<s_animationgraphuserparameter> user_parameters_block;
		};
		static_assert(sizeof(s_animationgraphskeleton) == 52, "struct s_animationgraphskeleton is invalid size");

		struct s_animationikjunction
		{
			string_id name;
			short pivot_node;
			short parent_junction;
			short supporting_chain;
			short supporting_node;
			real_fraction pull_passthrough;
		};
		static_assert(sizeof(s_animationikjunction) == 16, "struct s_animationikjunction is invalid size");

		struct s_animationikjoint
		{
			short joint_index;
			c_flags<e_animationikjointflags, short, k_animationikjointflags_count> flags;
		};
		static_assert(sizeof(s_animationikjoint) == 4, "struct s_animationikjoint is invalid size");

		struct s_s_animation_ik_chain
		{
			string_id name;
			c_enum<e_c_animation_ik_chain_type, short> type;
			short start_node;
			short effector_node;
			short parent_junction;
			short rank;
			short antecedents;
			c_typed_tag_block<s_animationikjoint> special_joints_block;

			/* Pull settings */

			real_fraction native_pull_strength;
			real_fraction native_push_strength;
			real_fraction over_extent_pull_strength;
			real_fraction under_extent_push_strength;

			/* Effector Cone Limits */

			real_fraction effector_cone_limit_power;
			angle_bounds pitch_bounds;
			angle_bounds yaw_bounds;
			real_bounds offset_bounds;
			c_typed_tag_block<s_animationikjoint> full_joint_chain_block;
			real_fraction spline_reversal_strength;
		};
		static_assert(sizeof(s_s_animation_ik_chain) == 88, "struct s_s_animation_ik_chain is invalid size");

		struct s_s_animation_ik_leg_definition
		{
			long leg_ik_chain;
			real standing_compression_limit;
			real crouching_compression_limit;
			real_bounds foot_pitch_limits;
			real_bounds foot_yaw_limits;
		};
		static_assert(sizeof(s_s_animation_ik_leg_definition) == 28, "struct s_s_animation_ik_leg_definition is invalid size");

		struct s_s_animation_ik_arm_definition
		{
			long arm_ik_chain;
			real wrist_break_threshold;
			string_id fixup_axis_marker;
			real ik_wrist_break_acceptable_min_angle;
		};
		static_assert(sizeof(s_s_animation_ik_arm_definition) == 16, "struct s_s_animation_ik_arm_definition is invalid size");

		struct s_s_animation_ik_point
		{
			string_id name;
			string_id source_marker;
			c_enum<e_ikattachmenttargettype, long> attach_to;
			string_id destination_marker;
			real_point3d pole_marker;
			long chain_to_use;
			// custom value
			string_id weight_source_object_function;
			// custom value
			string_id priority_source_object_function;
		};
		static_assert(sizeof(s_s_animation_ik_point) == 40, "struct s_s_animation_ik_point is invalid size");

		struct s_s_animation_ik_set_item
		{
			short ik_point;
			c_flags<e_iksetitemflags, short, k_iksetitemflags_count> flags;
		};
		static_assert(sizeof(s_s_animation_ik_set_item) == 4, "struct s_s_animation_ik_set_item is invalid size");

		struct s_s_animation_ik_set
		{
			string_id name;
			c_flags<e_iksetflags, long, k_iksetflags_count> flags;
			c_typed_tag_block<s_s_animation_ik_set_item> ik_points_block;
		};
		static_assert(sizeof(s_s_animation_ik_set) == 20, "struct s_s_animation_ik_set is invalid size");

		struct s_i343animationikgroundfittingchain
		{

			/* Chain Drivers */

			long start_junction;
			long end_junction;
			real probe_distance;
			real angle_threshold;
			real maximum_rate;
		};
		static_assert(sizeof(s_i343animationikgroundfittingchain) == 20, "struct s_i343animationikgroundfittingchain is invalid size");

		struct s_animationgraphik
		{

			/* IK Junctions */

			c_typed_tag_block<s_animationikjunction> ik_junctions_block;

			/* IK Chains */

			c_typed_tag_block<s_s_animation_ik_chain> ik_chains_block;
			c_typed_tag_block<s_s_animation_ik_leg_definition> ik_leg_definitions_block;
			c_typed_tag_block<s_s_animation_ik_arm_definition> ik_arm_definitions_block;

			/* Points and Sets */

			c_typed_tag_block<s_s_animation_ik_point> ik_point_block;
			c_typed_tag_block<s_s_animation_ik_set> ik_sets_block;

			/* Ground-fit chains */

			c_typed_tag_block<s_i343animationikgroundfittingchain> groundfit_ik_chains_block;
		};
		static_assert(sizeof(s_animationgraphik) == 84, "struct s_animationgraphik is invalid size");

		struct s_animation_skeleton
		{
			s_anytag_struct_definition anytag;
			s_animationgraphskeleton skeleton;
			s_animationgraphik ik;
		};
		static_assert(sizeof(s_animation_skeleton) == 152, "struct s_animation_skeleton is invalid size");

		struct s_i343contenttagsvariantmodelhittype
		{
			string_id variant_name;
			c_enum<e_i343contenttagsmodelhittypeoverride, char> use_model_hit_override;
			char generated_padf148[3]; // padding
		};
		static_assert(sizeof(s_i343contenttagsvariantmodelhittype) == 8, "struct s_i343contenttagsvariantmodelhittype is invalid size");

		struct s_assetsoundtag
		{
			s_anytag_struct_definition anytag;
			c_enum<e_i343contenttagsmodelhittype, char> use_model_hit;
			char generated_padddab[3]; // padding
			c_typed_tag_block<s_i343contenttagsvariantmodelhittype> per_variant_model_hit_block;
		};
		static_assert(sizeof(s_assetsoundtag) == 32, "struct s_assetsoundtag is invalid size");

		struct s_assetcategorysettingpersku
		{
			real_bounds lod_distance_multiplier;
			// custom lod_splitscreen_multipliers
			real lod___2_player_splitscreen;
			real lod___3_player_splitscreen;
			real lod___4_player_splitscreen;
			// custom value
			dword number_of_lods_to_skip;
			real_bounds hide_after_distance_multiplier;
			// custom hide_after_distance_splitscreen_multipliers
			real had___2_player_splitscreen;
			real had___3_player_splitscreen;
			real had___4_player_splitscreen;
			// custom value
			real static_io_shadow_casting_maximum_distance;
			real dynamic_object_shadow_casting_maximum_distance;
			real dynamic_object_cast_shadow_outside_of_camera_frustum_distance;
		};
		static_assert(sizeof(s_assetcategorysettingpersku) == 56, "struct s_assetcategorysettingpersku is invalid size");

		struct s_assetcategorysetting
		{
			string_id name;
			string_id editor_group;
			// custom low_setting
			s_assetcategorysettingpersku low_setting;
			// custom value
			// custom medium_setting
			s_assetcategorysettingpersku medium_setting;
			// custom value
			// custom high_setting
			s_assetcategorysettingpersku high_setting;
			// custom value
			// custom ultra_setting
			s_assetcategorysettingpersku ultra_setting;
			// custom value
			c_enum<e_assetcategorysettingshadowcastingoption, char> shadow_casting;
			char generated_pad4ade[3]; // padding
			real shadow_distance;
			c_enum<e_assetcategorysettingexcludefromddgioption, char> exclude_from_ddgi;
			c_enum<e_assetcategorysettingexcludefromdxroption, char> exclude_from_dxr;
			char generated_pad9793[2]; // padding
		};
		static_assert(sizeof(s_assetcategorysetting) == 244, "struct s_assetcategorysetting is invalid size");

		struct s_assetcategoryglobalstag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_assetcategorysetting> asset_category_globals_block;
			char generated_pad66d4[4]; // padding
		};
		static_assert(sizeof(s_assetcategoryglobalstag) == 32, "struct s_assetcategoryglobalstag is invalid size");

		struct s_functiondefinitiondefaultone
		{
			// custom value
			s_tag_data data;
			// custom value
		};
		static_assert(sizeof(s_functiondefinitiondefaultone) == 20, "struct s_functiondefinitiondefaultone is invalid size");

		struct s_scalarfunctionnamedefaultone
		{
			// custom function
			s_functiondefinitiondefaultone function;
		};
		static_assert(sizeof(s_scalarfunctionnamedefaultone) == 20, "struct s_scalarfunctionnamedefaultone is invalid size");

		struct s_volumetexturefogglobals
		{

			/* Volume Texture Fog Non-blending Parameters */

			c_typed_tag_reference<BITMAP_TAG> fog_bitmap;
			real texture_repeat_rate;
			real distance_between_sheets;
			real depth_fade_factor;
			real transparent_sort_distance;
			c_enum<e_e_transparent_sort_layer, char> transparent_sort_layer;
			c_flags<e_volumetexturefogglobalsflags, char, k_volumetexturefogglobalsflags_count> flags;
			char generated_pad2c77[2]; // padding
			s_scalarfunctionnamedefaultone wind_strength_across_distance;
		};
		static_assert(sizeof(s_volumetexturefogglobals) == 56, "struct s_volumetexturefogglobals is invalid size");

		struct s_s_atmosphere_globals
		{
			s_anytag_struct_definition anytag;
			s_volumetexturefogglobals volume_texture_fog_globals;
		};
		static_assert(sizeof(s_s_atmosphere_globals) == 72, "struct s_s_atmosphere_globals is invalid size");

		struct s_animchannelentry
		{
			string_id channel;
		};
		static_assert(sizeof(s_animchannelentry) == 4, "struct s_animchannelentry is invalid size");

		struct s_animtokenglobalstag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_animchannelentry> channels_block;
			string_id internal_stringeditorproxy;
			string_id internal_intcontrolparameternamestringeditorproxy;
			string_id internal_floatcontrolparameternamestringeditorproxy;
			string_id internal_boolcontrolparameternamestringeditorproxy;
			string_id internal_stringcontrolparameternamestringeditorproxy;
			string_id internal_vectorcontrolparameternamestringeditorproxy;
			char generated_padee72[4]; // padding
		};
		static_assert(sizeof(s_animtokenglobalstag) == 56, "struct s_animtokenglobalstag is invalid size");

		struct s_audiogamebucketthreatsetup
		{
			real min_threat_value;
			short character_count;
			char generated_pad482f[2]; // padding
		};
		static_assert(sizeof(s_audiogamebucketthreatsetup) == 8, "struct s_audiogamebucketthreatsetup is invalid size");

		struct s_audiogamecontextualthreatsetup
		{
			real min;
			real max;
			real_fraction weight;
			real time;
			c_flags<e_audiogamethreatdefinitionflags, char, k_audiogamethreatdefinitionflags_count> flags;
			c_enum<e_audiogamethreatcontext, char> context;
			char generated_pad8e86[2]; // padding
		};
		static_assert(sizeof(s_audiogamecontextualthreatsetup) == 20, "struct s_audiogamecontextualthreatsetup is invalid size");

		struct s_audiogamethreatlogicinstance
		{
			string_id rtpc_name;
			string_id multiplayer_rtpc_name;
			string_id btb_rtpc_name;
			c_typed_tag_block<s_audiogamebucketthreatsetup> buckets_block;
			c_typed_tag_block<s_audiogamecontextualthreatsetup> damage_block;
			c_typed_tag_block<s_audiogamecontextualthreatsetup> distance_block;

			/* Aiming Min/Max settings */

			c_typed_tag_block<s_audiogamecontextualthreatsetup> aiming_block;

			/* Allegiance Min/Max settings */

			c_typed_tag_block<s_audiogamecontextualthreatsetup> allegiance_block;
			c_typed_tag_block<s_audiogamecontextualthreatsetup> targeting_block;
			c_typed_tag_block<s_audiogamecontextualthreatsetup> scariness_block;
			real min_threat_value;
			byte default_bucket;
			char generated_pad688d[3]; // padding
		};
		static_assert(sizeof(s_audiogamethreatlogicinstance) == 104, "struct s_audiogamethreatlogicinstance is invalid size");

		struct s_audiogameaudiothreatglobalsdefinition
		{
			s_anytag_struct_definition anytag;
			// custom audio_threat_globals

			/* Audio Threat System Global Settings */

			c_typed_tag_block<s_audiogamethreatlogicinstance> audio_threats_block;
			// custom value
			char generated_pad25d5[4]; // padding
		};
		static_assert(sizeof(s_audiogameaudiothreatglobalsdefinition) == 32, "struct s_audiogameaudiothreatglobalsdefinition is invalid size");

		struct s_deathdamageregion
		{
			c_enum<e_damagepart, char> damaged_region;
		};
		static_assert(sizeof(s_deathdamageregion) == 1, "struct s_deathdamageregion is invalid size");

		struct s_ragdolldeathblendfunction
		{
			string_id name;
			c_flags<e_poweredragdollblendflags, char, k_poweredragdollblendflags_count> flags;
			char generated_pad9986[3]; // padding
			s_scalarfunctionname blend_function;
			string_id ragdoll_subgroup;
		};
		static_assert(sizeof(s_ragdolldeathblendfunction) == 32, "struct s_ragdolldeathblendfunction is invalid size");

		struct s_s_death_program_selector_velocity_gate
		{
			real minimum_velocity;
			c_enum<e_deathprogramresult, long> death_program;
			real death_program_scale;
			real acceleration_direction_adjust_z;
			real fallback_death_program_scale;
			real fallback_acceleration_direction_adjust_z;
			real powered_ragdoll_impact_radius;
			string_id death_animation_stance;
			c_flags<e_velocitygateflags, char, k_velocitygateflags_count> flags;
			char generated_pad2cfd[3]; // padding
			// custom animate_then_ragdoll
			angle ragdoll_animation_bypass_angle;
			char cosine_angle[4]; // skip
			// custom value
			// custom powered_ragdoll
			real blend_duration;

			/* Blend functions */

			c_typed_tag_block<s_ragdolldeathblendfunction> blend_functions_block;
			// custom value
			// custom motor_driven_ragdoll
			real_fraction keyframe_threshold;
			// custom value
			// custom explosion_ragdoll
			real explosion_radius;
			s_scalarfunctionname explosion_impulse_curve;
			// custom value
		};
		static_assert(sizeof(s_s_death_program_selector_velocity_gate) == 88, "struct s_s_death_program_selector_velocity_gate is invalid size");

		struct s_s_death_program_selector_damage_type
		{

			/* Triggering Damage Source */

			s_i343damagedamagesourcedefinition damagesource;

			/* Damaged Regions */

			c_typed_tag_block<s_deathdamageregion> damage_regions_block;
			c_typed_tag_block<s_s_death_program_selector_velocity_gate> velocity_block;
		};
		static_assert(sizeof(s_s_death_program_selector_damage_type) == 28, "struct s_s_death_program_selector_damage_type is invalid size");

		struct s_s_death_program_selector_special
		{
			c_enum<e_objectdamageaftermathspecialdamagetype, long> special_type;
			c_typed_tag_block<s_s_death_program_selector_damage_type> damage_type_block;
		};
		static_assert(sizeof(s_s_death_program_selector_special) == 16, "struct s_s_death_program_selector_special is invalid size");

		struct s_s_death_program_selector
		{
			s_anytag_struct_definition anytag;
			// custom explanation

			/* Death Program Selection */

			// custom value
			c_typed_tag_reference<DEATH_PROGRAM_SELECTOR_TAG> parent;
			c_typed_tag_block<s_s_death_program_selector_special> special_type_block;
		};
		static_assert(sizeof(s_s_death_program_selector) == 44, "struct s_s_death_program_selector is invalid size");

		struct s_behaviornodesettings
		{
			c_enum<e_behaviorindex, short> behavior;
			c_flags<e_behaviornodeoverrideflags, short, k_behaviornodeoverrideflags_count> override;
			c_enum<e_behaviorchecktype, short> type;
			c_enum<e_behaviortimer, short> timer;
			c_enum<e_e_stimulus, short> stimulus;
			char generated_pad52cf[2]; // padding
			real seconds;
			// custom static_args
			c_flags<e_behaviornodevalidargsflags, short, k_behaviornodevalidargsflags_count> valid_args;
			char generated_pad061a[2]; // padding
			short short_0;
			short short_1;
			real real_0;
			// custom value
		};
		static_assert(sizeof(s_behaviornodesettings) == 28, "struct s_behaviornodesettings is invalid size");

		struct s_behaviornodechildindex
		{
			short child;
		};
		static_assert(sizeof(s_behaviornodechildindex) == 2, "struct s_behaviornodechildindex is invalid size");

		struct s_behaviornodedefinition
		{
			c_typed_tag_reference<BEHAVIORTREE_TAG> sub_tree;
			// custom settings
			s_behaviornodesettings settings;
			// custom value
			c_typed_tag_block<s_behaviornodechildindex> children_block;
		};
		static_assert(sizeof(s_behaviornodedefinition) == 56, "struct s_behaviornodedefinition is invalid size");

		struct s_behaviortreedefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_behaviornodedefinition> nodes_block;
			char generated_padd2e7[4]; // padding
		};
		static_assert(sizeof(s_behaviortreedefinition) == 32, "struct s_behaviortreedefinition is invalid size");

		struct s_s_bink_definition
		{
			s_anytag_struct_definition anytag;
			long frame_count;
			char generated_pad3c54[4]; // padding
		};
		static_assert(sizeof(s_s_bink_definition) == 24, "struct s_s_bink_definition is invalid size");

		struct s_bitmapdictionaryentrydefinition
		{
			string_id identifier;
			c_typed_tag_reference<BITMAP_TAG> bitmap;
			short bitmap_index;
			char generated_pade5bc[2]; // padding
		};
		static_assert(sizeof(s_bitmapdictionaryentrydefinition) == 24, "struct s_bitmapdictionaryentrydefinition is invalid size");

		struct s_bitmapdictionarymultiactionsetdefinition
		{

			/* Multi actions */

			string_id identifier;
			string_id action_1;
			string_id action_2;
			string_id action_3;
			string_id action_4;

			/* Invalid multi action flags */

			c_flags<e_invalidbitmapmultiactiontypeflags, short, k_invalidbitmapmultiactiontypeflags_count> invalidation_flags;
			char generated_pad2033[2]; // padding
		};
		static_assert(sizeof(s_bitmapdictionarymultiactionsetdefinition) == 24, "struct s_bitmapdictionarymultiactionsetdefinition is invalid size");

		struct s_bitmapdictionarycombinedbitmapdefiniton
		{

			/* Combined bitmaps */

			string_id bitmap_1;
			string_id bitmap_2;
			string_id bitmap_3;
			string_id bitmap_4;
			string_id combined;
		};
		static_assert(sizeof(s_bitmapdictionarycombinedbitmapdefiniton) == 20, "struct s_bitmapdictionarycombinedbitmapdefiniton is invalid size");

		struct s_bitmapdictionarydefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_bitmapdictionaryentrydefinition> entries_block;
			c_typed_tag_block<s_bitmapdictionarymultiactionsetdefinition> multi_actions_block;
			c_typed_tag_block<s_bitmapdictionarycombinedbitmapdefiniton> combined_bitmaps_block;
			char generated_pad39d8[4]; // padding
		};
		static_assert(sizeof(s_bitmapdictionarydefinition) == 56, "struct s_bitmapdictionarydefinition is invalid size");

		struct s_bitmapusage
		{
			string_id name;
			string_id editor_group;
			real source_gamma;
			c_enum<e_bitmapcurve, char> bitmap_curve;
			c_flags<e_bitmapusagebitmapusageflag, char, k_bitmapusagebitmapusageflag_count> flags;
			c_enum<e_bitmapusagebitmapslicer, char> slicer;
			c_flags<e_bitmapusagebitmapdicerflag, char, k_bitmapusagebitmapdicerflag_count> dicer_flags;
			c_enum<e_bitmapusagebitmappacker, char> packer;
			c_flags<e_bitmapusagebitmappackerflag, char, k_bitmapusagebitmappackerflag_count> packer_flags;
			c_enum<e_bitmaptype, char> type;
			char mipmap_limit;
			c_enum<e_bitmapusagebitmapsmallestmip, char> smallest_mip;
			c_enum<e_bitmapusagebitmapdownsamplefilter, char> downsample_filter;
			char filter_radius_bias;
			char generated_pad122e[1]; // padding
			c_flags<e_bitmapusagebitmapdownsampleflag, short, k_bitmapusagebitmapdownsampleflag_count> downsample_flags;
			char generated_pad5ee3[2]; // padding
			rgb_color sprite_background_color;
			c_enum<e_floatmapswizzle, char> swizzle_red;
			c_enum<e_floatmapswizzle, char> swizzle_green;
			c_enum<e_floatmapswizzle, char> swizzle_blue;
			c_enum<e_floatmapswizzle, char> swizzle_alpha;
			c_enum<e_bitmapusagebitmapforcedformat, short> bitmap_format;
			c_enum<e_bitmapcolorspace, char> source_color_space;
			c_enum<e_bitmapcolorspace, char> target_color_space;
		};
		static_assert(sizeof(s_bitmapusage) == 48, "struct s_bitmapusage is invalid size");

		struct s_bitmapgroupsprite
		{
			short bitmap_index;
			char generated_pad2095[2]; // padding
			real left;
			real right;
			real top;
			real bottom;
			real_point2d registration_point;
		};
		static_assert(sizeof(s_bitmapgroupsprite) == 28, "struct s_bitmapgroupsprite is invalid size");

		struct s_bitmapgroupsequence
		{
			c_static_string<32> name;
			short first_bitmap_index;
			short bitmap_count;
			c_typed_tag_block<s_bitmapgroupsprite> sprites_block;
		};
		static_assert(sizeof(s_bitmapgroupsequence) == 48, "struct s_bitmapgroupsequence is invalid size");

		struct s_bitmapsourcefile
		{
			c_static_string<256> path;
		};
		static_assert(sizeof(s_bitmapsourcefile) == 256, "struct s_bitmapsourcefile is invalid size");

		struct s_sourcepaths
		{
			c_static_string<256> source_path;
			c_typed_tag_block<s_bitmapsourcefile> intermediate_paths_block;
		};
		static_assert(sizeof(s_sourcepaths) == 268, "struct s_sourcepaths is invalid size");

		struct s_bitmapdata
		{
			short width;
			short height;
			word depth;
			c_enum<e_bitmaptype, char> type;
			char generated_paddca3[1]; // padding
			c_enum<e_bitmapformat, short> format;
			c_flags<e_bitmapflags, short, k_bitmapflags_count> flags;
			char mipmap_count;
			c_enum<e_bitmapcurve, char> curve;
			char generated_pad8fee[2]; // padding
			real streaming_scale;
			short sourcewidth;
			short sourceheight;
			s_tag_resource bitmap_resource_handle;
		};
		static_assert(sizeof(s_bitmapdata) == 32, "struct s_bitmapdata is invalid size");

		struct s_bitmapgroup
		{
			s_anytag_struct_definition anytag;
			// custom show_bitmap

			/* IMPORT SETTINGS */

			dword usage;
			string_id usageid;
			string_id package;
			string_id texture_group;
			c_flags<e_bitmapgroupbitmapgroupflags, long, k_bitmapgroupbitmapgroupflags_count> flags;
			short sprite_spacing;
			short mip_sample_count;
			real bump_map_height;
			real_fraction fade_factor;
			real blur;
			real mip_map_blur;
			c_enum<e_bitmapgroupcurveoverride, char> curve_mode;
			char max_mipmap_level;
			short max_resolution;
			c_enum<e_bitmapusagebitmapforcedformat, short> force_bitmap_format;
			// custom reset_usage_override
			c_enum<e_bitmapgroupsigneddistancefieldmethod, char> sdf_generation;
			char target_platform;
			short spread_factor;
			char generated_pad8ed2[2]; // padding
			c_typed_tag_block<s_bitmapusage> usage_override_block;
			c_typed_tag_block<s_bitmapgroupsequence> manual_sequences_block;

			/* IMPORT DATA */

			s_tag_data source_data;
			c_typed_tag_block<s_sourcepaths> source_paths_block;
			qword source_checksum;
			argb_color min_color;
			argb_color max_color;
			c_typed_tag_block<s_bitmapgroupsequence> sequences_block;
			c_typed_tag_block<s_bitmapdata> bitmaps_block;
		};
		static_assert(sizeof(s_bitmapgroup) == 188, "struct s_bitmapgroup is invalid size");

		struct s_bitmapusagetablebitmapsuffixes
		{
			string_id suffix;
			string_id usage;
		};
		static_assert(sizeof(s_bitmapusagetablebitmapsuffixes) == 8, "struct s_bitmapusagetablebitmapsuffixes is invalid size");

		struct s_bitmapusagetablebackcompatusage
		{
			c_enum<e_globalbitmapusage, long> usage_enum;
			string_id usage;
		};
		static_assert(sizeof(s_bitmapusagetablebackcompatusage) == 8, "struct s_bitmapusagetablebackcompatusage is invalid size");

		struct s_bitmapusagetable
		{
			s_anytag_struct_definition anytag;

			/* Bitmap usage definitions */

			c_typed_tag_block<s_bitmapusage> bitmap_usage_definitions_block;
			c_typed_tag_block<s_bitmapusagetablebitmapsuffixes> bitmap_suffixes_block;

			/* Usage Backcompat */

			c_typed_tag_block<s_bitmapusagetablebackcompatusage> usage_backcompat_block;
			char generated_pad2824[4]; // padding
		};
		static_assert(sizeof(s_bitmapusagetable) == 56, "struct s_bitmapusagetable is invalid size");

		struct s_s_real_sector_point_generic_volume
		{
			real_point3d position;
		};
		static_assert(sizeof(s_s_real_sector_point_generic_volume) == 12, "struct s_s_real_sector_point_generic_volume is invalid size");

		struct s_genericvolumenativepoint2d
		{
			real_point2d point;
		};
		static_assert(sizeof(s_genericvolumenativepoint2d) == 8, "struct s_genericvolumenativepoint2d is invalid size");

		struct s_genericvolume
		{
			c_typed_tag_block<s_s_real_sector_point_generic_volume> points_block;
			real height;
			real sink;
			real_point3d center_point;
			real trivial_cull_radius_squared;
			real_point3d aabbcenter;
			real_point3d aabbextents;
			c_typed_tag_block<s_genericvolumenativepoint2d> nativepoints2d_block;
		};
		static_assert(sizeof(s_genericvolume) == 72, "struct s_genericvolume is invalid size");

		struct s_editormetadata
		{
			c_static_string<256> folder_name;
			real_point3d local_space_pivot_point_position;
		};
		static_assert(sizeof(s_editormetadata) == 268, "struct s_editormetadata is invalid size");

		struct s_lightmappriorityvolume
		{
			string_id name;
			// custom volume_settings
			s_genericvolume volume;
			// custom value
			real volume_priority;
			real lightmap_priority;
			c_enum<e_lightmapexclusionboolean, short> exclude_shadow_geometry;
			c_enum<e_lightmapexclusionboolean, short> exclude_per_pixel_lighting;
			c_enum<e_lightmapexclusionboolean, short> exclude_analytic_sun_contribution;
			c_enum<e_lightmapexclusionboolean, short> exclude_analytic_light_contribution;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			c_typed_tag_reference<SCENARIO_STRUCTURE_BSP_TAG> owner_bsp;
			string_id owner_variant;
			short runtime_bsp_index;
			short runtime_variant_index;
		};
		static_assert(sizeof(s_lightmappriorityvolume) == 128, "struct s_lightmappriorityvolume is invalid size");

		struct s_airprobedensityvolume
		{
			string_id name;
			// custom volume_settings
			s_genericvolume volume;
			// custom value
			real air_probe_density;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			c_typed_tag_reference<SCENARIO_STRUCTURE_BSP_TAG> owner_bsp;
			string_id owner_variant;
			short runtime_bsp_index;
			short runtime_variant_index;
		};
		static_assert(sizeof(s_airprobedensityvolume) == 116, "struct s_airprobedensityvolume is invalid size");

		struct s_airproberegionvolume
		{
			string_id name;
			// custom volume_settings
			s_genericvolume volume;
			// custom value
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			c_typed_tag_reference<SCENARIO_STRUCTURE_BSP_TAG> owner_bsp;
			string_id owner_variant;
			short runtime_bsp_index;
			short runtime_variant_index;
			real probe_xy_spacing;
			real probe_z_spacing;
			long volume_priority;
			real blend_radius_xy;
			real blend_radius_z;
			c_flags<e_airproberegionvolumeflags, short, k_airproberegionvolumeflags_count> flags;
			char generated_pad0802[2]; // padding
			real probe_offset_above_ground;
			long number_of_z_layers;
		};
		static_assert(sizeof(s_airproberegionvolume) == 144, "struct s_airproberegionvolume is invalid size");

		struct s_s_dumpling_sector_point
		{
			real_point3d position;
		};
		static_assert(sizeof(s_s_dumpling_sector_point) == 12, "struct s_s_dumpling_sector_point is invalid size");

		struct s_s_scenario_dumpling
		{
			c_typed_tag_block<s_s_dumpling_sector_point> inner_points_block;
			c_typed_tag_block<s_s_dumpling_sector_point> outer_points_block;
			real height;
			real sink;
			real inner_value;
			real outer_value;
			real_point3d center_point;
			real trivial_cull_radius_squared;
			real bound_volume;
		};
		static_assert(sizeof(s_s_scenario_dumpling) == 60, "struct s_s_scenario_dumpling is invalid size");

		struct s_cubemapvolume
		{
			string_id name;
			c_flags<e_cubemapflagsclass, long, k_cubemapflagsclass_count> flags;
			s_s_scenario_dumpling dumpling;
			c_typed_tag_reference<BITMAP_TAG> cubemap_bitmap;
			c_enum<e_cubemapboolean, short> enable_parallax_correction;
			short cubemap_volume_priority;
			real_point3d cubemap_origin;
			real_vector3d depth_positive;
			real_vector3d depth_negative;
			c_enum<e_cubemapboolean, short> active_volume;
			c_enum<e_cubemapsizeclassification, short> maximum_cubemap_size;
			real_point3d intensity;
			real self_illum_scale_down;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			c_typed_tag_reference<SCENARIO_STRUCTURE_BSP_TAG> owner_bsp;
			string_id owner_variant;
			short runtime_bsp_index;
			short runtime_variant_index;
			real blend_distance;
			c_enum<e_cubemapvolumetype, long> cubemap_volume_type;
			real orientation;
			c_typed_tag_reference<BITMAP_TAG> cubemap_depth_bitmap;
			real depth_blend_range;
			real intensity_scale;
			c_enum<e_cubemapboolean, short> tintable;
			char generated_pad93d5[2]; // padding
		};
		static_assert(sizeof(s_cubemapvolume) == 220, "struct s_cubemapvolume is invalid size");

		struct s_bsplightingvolumes
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_lightmappriorityvolume> lightmap_priority_volumes_block;
			c_typed_tag_block<s_airprobedensityvolume> air_probe_density_volumes_block;
			c_typed_tag_block<s_airproberegionvolume> air_probe_region_volumes_block;
			c_typed_tag_block<s_cubemapvolume> cubemap_volumes_block;
		};
		static_assert(sizeof(s_bsplightingvolumes) == 64, "struct s_bsplightingvolumes is invalid size");

		struct s_i343benchmarkbenchmarkcompositioninfo
		{
			c_static_string<256> display_name;
			string_id composition_id;
			c_flags<e_i343benchmarkbenchmarkcompositionflags, char, k_i343benchmarkbenchmarkcompositionflags_count> flags;
			char generated_pad3ea5[3]; // padding
		};
		static_assert(sizeof(s_i343benchmarkbenchmarkcompositioninfo) == 264, "struct s_i343benchmarkbenchmarkcompositioninfo is invalid size");

		struct s_i343benchmarkbenchmarkmap
		{
			c_static_string<256> map;
			c_typed_tag_block<s_i343benchmarkbenchmarkcompositioninfo> benchmark_compositions_block;
		};
		static_assert(sizeof(s_i343benchmarkbenchmarkmap) == 268, "struct s_i343benchmarkbenchmarkmap is invalid size");

		struct s_i343benchmarkbenchmarkdefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343benchmarkbenchmarkmap> benchmarks_block;
			char generated_pad1294[4]; // padding
		};
		static_assert(sizeof(s_i343benchmarkbenchmarkdefinition) == 32, "struct s_i343benchmarkbenchmarkdefinition is invalid size");

		struct s_boost
		{
			c_typed_tag_reference<COLLISION_DAMAGE_TAG> boost_collision_damage;
			c_flags<e_boostboostflags, long, k_boostboostflags_count> flags;
			real boost_peak_power;
			real boost_rise_time;
			real boost_fall_time;
			real boost_power_per_second;
			real boost_low_warning_threshold;
			real recharge_rate;
			real recharge_delay;
			real post_boost_weapon_delay;
			// custom trigger_to_boost
			s_functiondefinition trigger_to_boost;
			c_enum<e_i343collectibletutorial, long> tutorial_id;
		};
		static_assert(sizeof(s_boost) == 76, "struct s_boost is invalid size");

		struct s_i343unitsboostdefinition
		{
			s_anytag_struct_definition anytag;
			s_boost boost;
			char generated_pada510[4]; // padding
		};
		static_assert(sizeof(s_i343unitsboostdefinition) == 96, "struct s_i343unitsboostdefinition is invalid size");

		struct s_botbackfilltuningdefinition
		{
			// custom bot_backfill
			real mmr_threshold_for_recruit;
			real mmr_threshold_for_marine;
			real mmr_threshold_for_odst;
			real mmr_threshold_for_spartan;
			// custom value
		};
		static_assert(sizeof(s_botbackfilltuningdefinition) == 16, "struct s_botbackfilltuningdefinition is invalid size");

		struct s_bothysteresistuningdefinition
		{
			// custom hysteresis
			real hysteresis_max_amount;
			real hysteresis_timeout_seconds;
			// custom value
		};
		static_assert(sizeof(s_bothysteresistuningdefinition) == 8, "struct s_bothysteresistuningdefinition is invalid size");

		struct s_bottraversalpropertiesdefinition
		{
			// custom traversal_properties
			real destination_evaluation_tolerance;
			real random_neighbor_selection_chance;
			real start_sprint_evaluation_tolerance;
			real stop_sprint_evaluation_tolerance;
			angle bot_angular_turn_velocity;
			angle bot_angular_turn_acceleration;
			real bot_stuck_time_timeout;
			real bot_end_of_path_tolerance_distance_sq;
			real wrong_path_direction_timeout;
			real ledge_fall_distance_sq;
			real waypoint_path_distance;
			angle jump_hint_facing_threshold_no_clamber;
			// custom value
		};
		static_assert(sizeof(s_bottraversalpropertiesdefinition) == 48, "struct s_bottraversalpropertiesdefinition is invalid size");

		struct s_botmeleetuningdefinition
		{
			// custom melee
			real melee_min_delay_time;
			real melee_max_delay_time;
			real melee_striking_distance_no_melee_weapon;
			real melee_striking_distance_with_melee_weapon;
			real minimum_melee_distance;
			real max_melee_distance_no_equipment;
			real max_melee_distance_with_objective;
			real min_melee_grapple_distance;
			real max_melee_distance_with_grapple_hook;
			real max_enemy_health_for_unarmed_grapple;
			real restrict_melee_knockback_weapon_desirability_min;
			real target_low_shield_vitality_threshold;
			real low_confidence_threshold;
			angle target_is_facing_away_angle_threshold;
			// custom value
		};
		static_assert(sizeof(s_botmeleetuningdefinition) == 56, "struct s_botmeleetuningdefinition is invalid size");

		struct s_botcombattuningdefinition
		{
			// custom combat
			s_botmeleetuningdefinition melee;
			// custom strafing
			real strafe_min_time;
			real strafe_max_time;
			real halt_strafe_chance;
			real halt_strafe_min_time;
			real halt_strafe_max_time;
			real halt_strafe_min_time_initial;
			real halt_strafe_max_time_initial;
			// custom value
			// custom vertical_movement
			real vertical_movement_min_delay_time;
			real vertical_movement_max_delay_time;
			real vertical_movement_crouch_chance;
			real crouch_hold_time;
			real vertical_movement_jump_check_height;
			angle target_is_aiming_check_threshold;
			real avoid_dangerous_object_jump_chance;
			// custom value
			// custom grenades
			real grenade_delay_min_time;
			real grenade_delay_noise_time;
			real grenade_min_target_distance;
			real grenade_max_target_distance;
			real grenade_distance_in_front_of_target_feet;
			real low_ground_height_threshold;
			// custom value
			real disengage_confidence_threshold;
			real evade_min_delay_time;
			real evade_max_delay_time;
			real combat_error_magnitude;
			real minimum_error_magnitude;
			real target_velocity_max_noise_threshhold_sq;
			real targeting_error_from_velocity_weight;
			real targeting_error_recalculation_time_min;
			real targeting_error_recalculation_time_max;
			angle desired_vs_actual_aiming_differential_allowance;
			real predictability_velocity_magnitude_change_threshold;
			angle predictability_velocity_direction_change_threshhold;
			real predictability_error_gain_rate;
			real predictability_error_decay_rate;
			real maximum_aiming_offset;
			real combat_weapon_switch_desirability_delta;
			real combat_weapon_switch_distance_delta;
			real initial_hide_point_search_radius;
			real location_sensor_activation_distance_sq;
			real disengage_max_jump_height;
			// custom value
		};
		static_assert(sizeof(s_botcombattuningdefinition) == 216, "struct s_botcombattuningdefinition is invalid size");

		struct s_bottargetpriorityinputdefinition
		{
			c_enum<e_i343botsbottargetpriorityinput, short> input;
			char generated_pad9bc9[2]; // padding
			real weight;
		};
		static_assert(sizeof(s_bottargetpriorityinputdefinition) == 8, "struct s_bottargetpriorityinputdefinition is invalid size");

		struct s_botawarenesstuningdefinition
		{
			// custom awareness
			real max_ground_awareness_distance;
			real max_air_awareness_distance;
			angle fov_degrees;
			real threat_sensor_awareness_distance;
			real active_camo_invisibility_threshold;
			real danger_decay_rate_per_second;
			real clairvoyance_max_time;
			real clairvoyance_max_distance;
			real dangerous_object_awareness_distance;
			real dangerous_object_max_time_to_damage;
			angle dangerous_object_approaching_bot_angle;
			real moving_dangerous_object_min_speed;
			real chance_to_notice_new_dangerous_objects_per_second;
			real dangerous_object_danger_radius_scalar;
			real target_hysteresis_max_amount;
			real target_hysteresis_timeout_seconds;
			c_typed_tag_block<s_bottargetpriorityinputdefinition> target_priority_calculation_inputs_block;
			// custom value
		};
		static_assert(sizeof(s_botawarenesstuningdefinition) == 76, "struct s_botawarenesstuningdefinition is invalid size");

		struct s_botguardbehaviortuningdefinition
		{
			// custom guard
			real min_guard_look_time;
			real max_guard_look_time;
			real min_guard_look_rotation_angle;
			real max_guard_look_rotation_angle;
			real guard_volume_boundary_width;
			real max_patrol_time;
			real min_patrol_pause_time;
			real max_patrol_pause_time;
			real min_guard_distance;
			// custom value
		};
		static_assert(sizeof(s_botguardbehaviortuningdefinition) == 36, "struct s_botguardbehaviortuningdefinition is invalid size");

		struct s_botpickuptuningdefinition
		{
			// custom pickup
			real pickup_distance_sq;
			real pathless_distance_sq;
			real item_pickup_delay;
			real weapon_pickup_cooldown;
			real item_observation_radius;
			// custom value
		};
		static_assert(sizeof(s_botpickuptuningdefinition) == 20, "struct s_botpickuptuningdefinition is invalid size");

		struct s_botweapondeftagblock
		{
			c_typed_tag_reference<WEAPON_TAG> approved_weapon_definition_tag;
			c_flags<e_botweaponusageflags, long, k_botweaponusageflags_count> weapon_usage_flags;
			real error_magnitude;
			real minimum_error_magnitude;
			real error_max_velocity_sq_threshold;
			real desirability;
			real min_distance_sq;
			real max_distance_sq;
		};
		static_assert(sizeof(s_botweapondeftagblock) == 44, "struct s_botweapondeftagblock is invalid size");

		struct s_botdifficultyleveltuningdefinition
		{
			c_enum<e_i343botsbotdifficultylevel, short> difficulty_level;
			char generated_pad637c[2]; // padding
			c_flags<e_botdifficultyflags, long, k_botdifficultyflags_count> difficulty_specific_flags;
			s_bothysteresistuningdefinition hysteresis;
			s_bottraversalpropertiesdefinition traversal_tuning;
			s_botcombattuningdefinition combat_tuning;
			s_botawarenesstuningdefinition awareness_tuning;
			s_botguardbehaviortuningdefinition guard_behavior_tuning;
			s_botpickuptuningdefinition pickup_tuning;
			c_typed_tag_block<s_botweapondeftagblock> weapon_tuning_block;
		};
		static_assert(sizeof(s_botdifficultyleveltuningdefinition) == 424, "struct s_botdifficultyleveltuningdefinition is invalid size");

		struct s_botequipmentdeftagblock
		{
			c_typed_tag_reference<EQUIPMENT_TAG> approved_equipment_definition_tag;
		};
		static_assert(sizeof(s_botequipmentdeftagblock) == 16, "struct s_botequipmentdeftagblock is invalid size");

		struct s_botadaptivetuningdefinition
		{
			// custom adaptive_difficulty
			real player_health_shooting_threshold;
			real max_movement;
			real max_aiming;
			real aiming_coefficient;
			real position_coefficient;
			real engagement_constant;
		};
		static_assert(sizeof(s_botadaptivetuningdefinition) == 24, "struct s_botadaptivetuningdefinition is invalid size");

		struct s_botglobals
		{
			s_anytag_struct_definition anytag;
			s_botbackfilltuningdefinition bot_backfill;
			c_typed_tag_block<s_botdifficultyleveltuningdefinition> difficulty_specific_tuning_block;
			c_typed_tag_block<s_botequipmentdeftagblock> approved_bot_equipment_block;
			c_typed_tag_block<s_botadaptivetuningdefinition> adaptive_difficulty_tuning_block;
			char generated_pad7603[4]; // padding
		};
		static_assert(sizeof(s_botglobals) == 72, "struct s_botglobals is invalid size");

		struct s_bitmappackagesettings
		{
			string_id name;
			string_id editor_group;
			c_flags<e_bitmappackagesettingsgroupflags, long, k_bitmappackagesettingsgroupflags_count> flags;
			c_enum<e_bitmappackagesettingsreductionrate, char> reduction_rate;
			char generated_padbb20[3]; // padding
			long minimum_texture_size;
		};
		static_assert(sizeof(s_bitmappackagesettings) == 20, "struct s_bitmappackagesettings is invalid size");

		struct s_bitmappackagetexturegroup
		{
			string_id name;
			string_id package;
		};
		static_assert(sizeof(s_bitmappackagetexturegroup) == 8, "struct s_bitmappackagetexturegroup is invalid size");

		struct s_bitmappackagesettingstable
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_bitmappackagesettings> settings_block;

			/* TEXTURE GROUPS */

			c_typed_tag_block<s_bitmappackagetexturegroup> texture_groups_block;
		};
		static_assert(sizeof(s_bitmappackagesettingstable) == 40, "struct s_bitmappackagesettingstable is invalid size");

		struct s_scenariobakedpvsvolume
		{
			string_id name;
			// custom volume_settings
			s_genericvolume volume;
			// custom value
			c_enum<e_scenariobakedpvsvolumeboolean, short> use_vertical_beam_count_override;
			c_enum<e_scenariobakedpvsvolumeboolean, short> use_beam_height_overrides;
			c_enum<e_scenariobakedpvsvolumeboolean, short> pin_the_beams_to_the_top_of_the_volume;
			c_enum<e_scenariobakedpvsvolumeboolean, short> add_beams_even_if_there_is_no_collision;
			long vertical_beam_count_override;
			real beam_1_height_override;
			real beam_2_height_override;
			real beam_3_height_override;
			real beam_4_and_above_height_override;
			long volume_importance_override_value;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			c_typed_tag_reference<SCENARIO_STRUCTURE_BSP_TAG> owner_bsp;
			short runtime_bsp_index;
			char generated_pad4130[2]; // padding
		};
		static_assert(sizeof(s_scenariobakedpvsvolume) == 140, "struct s_scenariobakedpvsvolume is invalid size");

		struct s_bspvolumes
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_scenariobakedpvsvolume> baked_pvs_volumes_block;
			char generated_pad512a[4]; // padding
		};
		static_assert(sizeof(s_bspvolumes) == 32, "struct s_bspvolumes is invalid size");

		struct s_i343cagesystemcagepoint
		{
			c_flags<e_i343cagesystemcagepointflags, char, k_i343cagesystemcagepointflags_count> flags;
			char generated_pad7a22[3]; // padding
			string_id name;
			c_enum<e_i343cagesystemcageoffsettype, char> offsettype;
			char generated_padc6d7[3]; // padding
			real_vector3d offsetposition;
			real_euler_angles3d offsetrotation;
			c_enum<e_i343cagesystemcagelocationtype, char> locationtype;
			char generated_pad138c[3]; // padding
			string_id locationname;
		};
		static_assert(sizeof(s_i343cagesystemcagepoint) == 44, "struct s_i343cagesystemcagepoint is invalid size");

		struct s_i343cagesystemcagedefinitiontag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343cagesystemcagepoint> points_block;
			char generated_pad90a9[4]; // padding
		};
		static_assert(sizeof(s_i343cagesystemcagedefinitiontag) == 32, "struct s_i343cagesystemcagedefinitiontag is invalid size");

		struct s_i343cagesystemcagepointdefault
		{
			string_id name;
			c_typed_tag_reference<CAGEDEFINITION_TAG> cage_definition;
			string_id point_name;
		};
		static_assert(sizeof(s_i343cagesystemcagepointdefault) == 24, "struct s_i343cagesystemcagepointdefault is invalid size");

		struct s_i343curvecurvereference
		{
			c_enum<e_i343curvecurvebuiltin, char> curve_type;
			char generated_pade4ec[3]; // padding
			c_typed_tag_reference<CURVEDEFINITION_TAG> curve_definition;
			string_id curve_name;
		};
		static_assert(sizeof(s_i343curvecurvereference) == 24, "struct s_i343curvecurvereference is invalid size");

		struct s_i343cagesystemcagetransitioncurve
		{
			c_typed_tag_reference<CURVEDEFINITION_TAG> animation_curve;
			string_id transform_curve_name;
			string_id focal_length_curve_name;
			string_id focus_distance_curve_name;
			string_id f_stop_curve_name;
			string_id perspective_curve_name;
			string_id variant_curve_name;
			string_id variant_name;
			real animation_time;
			real animation_playback_scalar;
		};
		static_assert(sizeof(s_i343cagesystemcagetransitioncurve) == 52, "struct s_i343cagesystemcagetransitioncurve is invalid size");

		struct s_i343cagesystemcageglobalsdefinitiontag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343cagesystemcagepointdefault> global_default_cage_points_block;
			c_typed_tag_reference<CAGEDEFINITION_TAG> default_cage_definition;
			string_id default_position_point;
			string_id default_collision_resolution_point;
			string_id default_orbit_center_point;
			string_id default_fps_point;
			real default_blend_in_time;
			real default_blend_out_time;
			real default_gaze_distance;
			angle default_gaze_outer_angle;
			angle default_gaze_inner_angle;
			angle default_gaze_velocity;
			// custom gaze_velocity_curve
			s_i343curvecurvereference default_gaze_velocity_curve;
			// custom value
			// custom transform_blend_curve
			s_i343curvecurvereference default_blend_curve_transform;
			// custom value
			// custom properties_blend_curve
			s_i343curvecurvereference default_blend_curve_properties;
			// custom value
			// custom from_gameplay_transition
			s_i343cagesystemcagetransitioncurve from_gameplay_transition;
			// custom value
			// custom to_gameplay_transition
			s_i343cagesystemcagetransitioncurve to_gameplay_transition;
			// custom value
			// custom camera_properties___old
			real default_focal_length;
			real default_focus_distance;
			real default_f_stop;
			// custom value
		};
		static_assert(sizeof(s_i343cagesystemcageglobalsdefinitiontag) == 272, "struct s_i343cagesystemcageglobalsdefinitiontag is invalid size");

		struct s_cameratrackcontrolpoint
		{
			real_vector3d position;
			real_quaternion orientation;
		};
		static_assert(sizeof(s_cameratrackcontrolpoint) == 28, "struct s_cameratrackcontrolpoint is invalid size");

		struct s_cameratracklens
		{
			c_flags<e_cameratracklensflags, char, k_cameratracklensflags_count> flags;
			char generated_pad783a[3]; // padding
			real focal_length;
			real focus_distance;
			real fstop;
			long bokeh_side_count;
		};
		static_assert(sizeof(s_cameratracklens) == 20, "struct s_cameratracklens is invalid size");

		struct s_cameratrack
		{
			c_flags<e_cameratrackflags, char, k_cameratrackflags_count> flags;
			char generated_padb652[3]; // padding
			c_typed_tag_block<s_cameratrackcontrolpoint> control_points_block;
			c_typed_tag_block<s_cameratracklens> lenses_block;
		};
		static_assert(sizeof(s_cameratrack) == 28, "struct s_cameratrack is invalid size");

		struct s_cameratrackanimation
		{
			string_id name;
			s_cameratrack track;
			long authored_fps;
		};
		static_assert(sizeof(s_cameratrackanimation) == 36, "struct s_cameratrackanimation is invalid size");

		struct s_cameraanimationgraph
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_cameratrackanimation> animations_block;
			char generated_pad38ed[4]; // padding
		};
		static_assert(sizeof(s_cameraanimationgraph) == 32, "struct s_cameraanimationgraph is invalid size");

		struct s_interfacecustomizationuicamerapresetsettings
		{
			c_enum<e_interfacecustomizationcorefocusmode, short> core_focus_mode;
			char generated_padbfbb[2]; // padding
			real camera_offset;
			real_vector3d camera_position_offset;
			real_euler_angles3d camera_facing;
			c_flags<e_interfacecustomizationuidofflags, char, k_interfacecustomizationuidofflags_count> dof_flags;
			char generated_pad7306[3]; // padding
			real dof_focal_length;
			real dof_focal_distance;
			real dof_fstop;
			string_id composer_scene_name;
		};
		static_assert(sizeof(s_interfacecustomizationuicamerapresetsettings) == 52, "struct s_interfacecustomizationuicamerapresetsettings is invalid size");

		struct s_interfacecustomizationuicamerapreset
		{
			string_id preset_name;
			c_enum<e_interfacecustomizationcoretype, short> core_type;
			c_enum<e_interfacecustomizationsocketitemtype, short> item_type;
			c_typed_tag_block<s_interfacecustomizationuicamerapresetsettings> camera_settings_block;
		};
		static_assert(sizeof(s_interfacecustomizationuicamerapreset) == 20, "struct s_interfacecustomizationuicamerapreset is invalid size");

		struct s_interfacecustomizationuicamerascenepreset
		{
			c_enum<e_interfacecustomizationspartancustomizationscenetypes, short> scene_type;
			char generated_pad0124[2]; // padding
			c_typed_tag_block<s_interfacecustomizationuicamerapreset> camera_presets_settings_block;
		};
		static_assert(sizeof(s_interfacecustomizationuicamerascenepreset) == 16, "struct s_interfacecustomizationuicamerascenepreset is invalid size");

		struct s_interfacecustomizationuicamerapresetstag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_interfacecustomizationuicamerapreset> camera_presets_settings_block;
			c_typed_tag_block<s_interfacecustomizationuicamerascenepreset> camera_scene_presets_settings_block;
		};
		static_assert(sizeof(s_interfacecustomizationuicamerapresetstag) == 40, "struct s_interfacecustomizationuicamerapresetstag is invalid size");

		struct s_collisiondamagefunction
		{
			// custom mapping_function
			s_functiondefinition mapping;
		};
		static_assert(sizeof(s_collisiondamagefunction) == 20, "struct s_collisiondamagefunction is invalid size");

		struct s_collisiondamagestruct
		{
			c_flags<e_collisiondamagestructflags, long, k_collisiondamagestructflags_count> flags;
			real minimum_velocity_for_lethal_collision;

			/* Game collision damage */

			s_collisiondamagefunction game_collision_damage$2;
			real_bounds game_acceleration;
			real minimum_velocity_for_game_damage;

			/* Game collision damage scaling */

			real apply_collision_damage_scale;
			real friendly_apply_collision_damage_scale;
			angle game_collision_damage_normal_threshold;

			/* Absolute collision damage */

			s_collisiondamagefunction absolute_collision_damage$2;
			real_bounds absolute_acceleration;
			real minimum_velocity_for_absolute_damage;

			/* Absolute collision damage scaling */

			real apply_absolute_collision_damage_scale;
			real friendly_apply_absolute_collision_damage_scale;
			angle absolute_collision_damage_normal_threshold;

			/* Alternative damage effect */

			c_typed_tag_reference<DAMAGE_EFFECT_TAG> alternative_damage_effect$2;
		};
		static_assert(sizeof(s_collisiondamagestruct) == 112, "struct s_collisiondamagestruct is invalid size");

		struct s_collisiondamagedefinition
		{
			s_anytag_struct_definition anytag;
			s_collisiondamagestruct damagestruct;
			char generated_padcb8c[4]; // padding
		};
		static_assert(sizeof(s_collisiondamagedefinition) == 132, "struct s_collisiondamagedefinition is invalid size");

		struct s_i343physicscollisiontypename
		{
			string_id name;
		};
		static_assert(sizeof(s_i343physicscollisiontypename) == 4, "struct s_i343physicscollisiontypename is invalid size");

		struct s_i343physicscollisionlayerdata
		{
			char collision;
		};
		static_assert(sizeof(s_i343physicscollisionlayerdata) == 1, "struct s_i343physicscollisionlayerdata is invalid size");

		struct s_i343physicscollisionfilterdefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343physicscollisiontypename> types_block;
			c_typed_tag_block<s_i343physicscollisionlayerdata> layers_block;
		};
		static_assert(sizeof(s_i343physicscollisionfilterdefinition) == 40, "struct s_i343physicscollisionfilterdefinition is invalid size");

		struct s_camera_fx_settingss_real_exposure_parameter
		{
			// custom value

			/* EXPOSURE */

			c_flags<e_camerafxparameterautoadjustflags, short, k_camerafxparameterautoadjustflags_count> flags;
			char generated_pad3d40[2]; // padding
			real exposure$2;
			real maximum_change;
			real blend_speed_0_1;
			real minimum;
			real maximum;
			// custom value
			real auto_exposure_screen_brightness;
			real exposure_offset;
			real sky_exposure_offset_stops;
			// custom value
			real prevent_fluctuation_time_range;
			// custom value
		};
		static_assert(sizeof(s_camera_fx_settingss_real_exposure_parameter) == 40, "struct s_camera_fx_settingss_real_exposure_parameter is invalid size");

		struct s_camera_fx_settingscamerafxexposuresensitivity
		{

			/* AUTO EXPOSURE SENSITIVITY */

			c_flags<e_camerafxparameternoautoadjustflags, short, k_camerafxparameternoautoadjustflags_count> flags;
			char generated_padf2eb[2]; // padding
			real sensitivity_0_1;
		};
		static_assert(sizeof(s_camera_fx_settingscamerafxexposuresensitivity) == 8, "struct s_camera_fx_settingscamerafxexposuresensitivity is invalid size");

		struct s_camera_fx_settingscamerafxexposurepitchinfluence
		{

			/* EXPOSURE PITCH INFLUENCE */

			c_flags<e_camerafxparameternoautoadjustflags, short, k_camerafxparameternoautoadjustflags_count> flags;
			char generated_pad3993[2]; // padding

			/* INFLUENCE FUNCTION (GROUND -> HORIZON -> SKY) */

			// custom function
			s_functiondefinition function;
		};
		static_assert(sizeof(s_camera_fx_settingscamerafxexposurepitchinfluence) == 24, "struct s_camera_fx_settingscamerafxexposurepitchinfluence is invalid size");

		struct s_camera_fx_settingscamerafxexposurecompensation
		{

			/* EXPOSURE COMPENSATION */

			c_flags<e_camerafxparameternoautoadjustflags, short, k_camerafxparameternoautoadjustflags_count> flags;
			char generated_pad19de[2]; // padding

			/* COMPENSATION FUNCTION (EXPOSURE MIN -> EXPOSURE MAX) */

			// custom function
			s_functiondefinition function;
		};
		static_assert(sizeof(s_camera_fx_settingscamerafxexposurecompensation) == 24, "struct s_camera_fx_settingscamerafxexposurecompensation is invalid size");

		struct s_camera_fx_settingscamerafxbloomhighlight
		{

			/* HIGHLIGHT BLOOM */

			c_flags<e_camerafxparameternoautoadjustflags, short, k_camerafxparameternoautoadjustflags_count> flags;
			char generated_paddc8c[2]; // padding
			real highlight_bloom$2;
			real maximum_change;
			real blend_speed_0_1;
		};
		static_assert(sizeof(s_camera_fx_settingscamerafxbloomhighlight) == 16, "struct s_camera_fx_settingscamerafxbloomhighlight is invalid size");

		struct s_camera_fx_settingscamerafxbloomhighlightthreshold
		{

			/* HIGHLIGHT BLOOM THRESHOLD */

			c_flags<e_camerafxparameternoautoadjustflags, short, k_camerafxparameternoautoadjustflags_count> flags;
			char generated_padedb3[2]; // padding
			real highlight_bloom_threshold$2;
			real maximum_change;
			real blend_speed_0_1;
		};
		static_assert(sizeof(s_camera_fx_settingscamerafxbloomhighlightthreshold) == 16, "struct s_camera_fx_settingscamerafxbloomhighlightthreshold is invalid size");

		struct s_camera_fx_settingscamerafxbloominherent
		{

			/* AMBIENT BLOOM */

			c_flags<e_camerafxparameternoautoadjustflags, short, k_camerafxparameternoautoadjustflags_count> flags;
			char generated_padfee3[2]; // padding
			real ambient_bloom$2;
			real maximum_change;
			real blend_speed_0_1;
		};
		static_assert(sizeof(s_camera_fx_settingscamerafxbloominherent) == 16, "struct s_camera_fx_settingscamerafxbloominherent is invalid size");

		struct s_camera_fx_settingscamerafxbloomintensity
		{

			/* BLOOM INTENSITY */

			c_flags<e_camerafxparameternoautoadjustflags, short, k_camerafxparameternoautoadjustflags_count> flags;
			char generated_pad4287[2]; // padding
			real bloom_intensity$2;
			real maximum_change;
			real blend_speed_0_1;
		};
		static_assert(sizeof(s_camera_fx_settingscamerafxbloomintensity) == 16, "struct s_camera_fx_settingscamerafxbloomintensity is invalid size");

		struct s_camera_fx_settingscamerafxbloomlayerintensity
		{
			c_flags<e_camerafxparameternoautoadjustflags, short, k_camerafxparameternoautoadjustflags_count> flags;
			char generated_pad8248[2]; // padding
			real large_layer_intensity;
			real medium_layer_intensity;
			real small_layer_intensity;
			real maximum_change;
			real blend_speed_0_1;
		};
		static_assert(sizeof(s_camera_fx_settingscamerafxbloomlayerintensity) == 24, "struct s_camera_fx_settingscamerafxbloomlayerintensity is invalid size");

		struct s_camera_fx_settingscamerafxbloomtintcolor
		{

			/* BLOOM TINT COLOR */

			c_flags<e_camerafxparameternoautoadjustflags, short, k_camerafxparameternoautoadjustflags_count> flags;
			char generated_pad8bf4[2]; // padding
			rgb_color tint_color;
		};
		static_assert(sizeof(s_camera_fx_settingscamerafxbloomtintcolor) == 16, "struct s_camera_fx_settingscamerafxbloomtintcolor is invalid size");

		struct s_camera_fx_settingscamerafxselfillumexposuresettings
		{

			/* SELF ILLUM EXPOSURE */

			c_flags<e_camerafxparameternoautoadjustflags, short, k_camerafxparameternoautoadjustflags_count> flags;
			char generated_pad01be[2]; // padding
			real preferred_exposure;
			real maximum_change;
			real blend_speed_0_1;
		};
		static_assert(sizeof(s_camera_fx_settingscamerafxselfillumexposuresettings) == 16, "struct s_camera_fx_settingscamerafxselfillumexposuresettings is invalid size");

		struct s_camera_fx_settingscamerafxselfillumscale
		{

			/* SELF ILLUM CHANGE */

			c_flags<e_camerafxparameternoautoadjustflags, short, k_camerafxparameternoautoadjustflags_count> flags;
			char generated_pad5a4a[2]; // padding
			real exposure_change;
			real maximum_change;
			real blend_speed_0_1;
		};
		static_assert(sizeof(s_camera_fx_settingscamerafxselfillumscale) == 16, "struct s_camera_fx_settingscamerafxselfillumscale is invalid size");

		struct s_camera_fx_settingscamerafxselfillumscaleperrace
		{
			c_flags<e_camerafxparameternoautoadjustflags, short, k_camerafxparameternoautoadjustflags_count> flags;
			char generated_pad7166[2]; // padding
			real parameter_value;
			real maximum_change;
			real blend_speed_0_1;
		};
		static_assert(sizeof(s_camera_fx_settingscamerafxselfillumscaleperrace) == 16, "struct s_camera_fx_settingscamerafxselfillumscaleperrace is invalid size");

		struct s_camera_fx_settingss_color_grading_parameter
		{

			/* Color Grading */

			c_flags<e_camerafxparameternoautoadjustflags, short, k_camerafxparameternoautoadjustflags_count> flags;
			char generated_pad78c0[2]; // padding
			c_typed_tag_reference<BITMAP_TAG> color_grading_texture;
			c_typed_tag_reference<BITMAP_TAG> hdr_color_grading_texture;
			real blend_time;
		};
		static_assert(sizeof(s_camera_fx_settingss_color_grading_parameter) == 40, "struct s_camera_fx_settingss_color_grading_parameter is invalid size");

		struct s_camera_fx_settingss_ssao_parameter
		{

			/* SSAO settings */

			c_flags<e_camerafxparameterenabledflags, short, k_camerafxparameterenabledflags_count> flags;
			char generated_pad4870[2]; // padding
			c_flags<e_camerafxssaoflags, short, k_camerafxssaoflags_count> ssao_flags;
			char generated_pad76e4[2]; // padding
			real radius;
			dword step_size;
			real angle_bias;
			real strength;
			real power_exponent;
			dword blur_radius;
			real blur_sharpness;
			real decorator_apply_darkening_scaler;
			real hemi_rejection_falloff;
			real gtao_intensity;
			real sun_ao;
			real spot_light_ao;
			real omni_light_ao;
		};
		static_assert(sizeof(s_camera_fx_settingss_ssao_parameter) == 60, "struct s_camera_fx_settingss_ssao_parameter is invalid size");

		struct s_speccontrolnodeint
		{
			c_enum<e_i343speccontrolgraphicsoptions, char> type;
			char generated_pad11b5[3]; // padding
			c_flags<e_speccontrolnodeoverrideflags, long, k_speccontrolnodeoverrideflags_count> flags;
			long input;
			real very_low;
			real low;
			real medium;
			real high;
			real ultra;
			c_enum<e_i343speccontrolsplitscreenlogictype, char> splitscreen_logic;
			char generated_padf7d4[3]; // padding
			real _2_player_splitscreen;
			real _3_player_splitscreen;
			real _4_player_splitscreen;
		};
		static_assert(sizeof(s_speccontrolnodeint) == 48, "struct s_speccontrolnodeint is invalid size");

		struct s_speccontrolnodefloat
		{
			c_enum<e_i343speccontrolgraphicsoptions, char> type;
			char generated_padf78c[3]; // padding
			c_flags<e_speccontrolnodeoverrideflags, long, k_speccontrolnodeoverrideflags_count> flags;
			real input;
			real very_low;
			real low;
			real medium;
			real high;
			real ultra;
			c_enum<e_i343speccontrolsplitscreenlogictype, char> splitscreen_logic;
			char generated_pad116d[3]; // padding
			real _2_player_splitscreen;
			real _3_player_splitscreen;
			real _4_player_splitscreen;
		};
		static_assert(sizeof(s_speccontrolnodefloat) == 48, "struct s_speccontrolnodefloat is invalid size");

		struct s_camera_fx_settingsdeferredreflectionsparameter
		{

			/* Deferred Reflections settings */

			c_flags<e_camerafxparameterenabledflags, short, k_camerafxparameterenabledflags_count> flags;
			char generated_padbf0e[2]; // padding
			c_flags<e_deferredreflectionflags, long, k_deferredreflectionflags_count> deferred_reflection_flags;
			real intensity;
			real intensity_first_person;
			real fade_to_cubemap;
			real border_fade_size;
			s_speccontrolnodeint ray_steps;
			real mip_blur_distance_scale;
			real depth_thickness;
			real ssr_near_fade_distance;
			real ssr_far_fade_distance;
			real ssr_roughness_threshold;
			real ssr_tonemap_strength;
			real ssr_tonemap_clamp;
			s_speccontrolnodefloat resolution;
		};
		static_assert(sizeof(s_camera_fx_settingsdeferredreflectionsparameter) == 148, "struct s_camera_fx_settingsdeferredreflectionsparameter is invalid size");

		struct s_camera_fx_settingss_camera_lens_dirt_parameter
		{

			/* Camera Lens Dirt Settings */

			c_flags<e_camerafxparameterenabledflags, short, k_camerafxparameterenabledflags_count> flags;
			char generated_pad28b2[2]; // padding
			real intensity;
			c_typed_tag_reference<BITMAP_TAG> dirt_texture;
			c_enum<e_cameralensdirtdirttype, char> dirt_type;
			char generated_pad409c[3]; // padding
		};
		static_assert(sizeof(s_camera_fx_settingss_camera_lens_dirt_parameter) == 28, "struct s_camera_fx_settingss_camera_lens_dirt_parameter is invalid size");

		struct s_speccontrolnodebool
		{
			c_enum<e_i343speccontrolgraphicsoptions, char> type;
			char generated_padfbf4[1]; // padding
			c_flags<e_speccontrolnodeboolflags, short, k_speccontrolnodeboolflags_count> flags;
		};
		static_assert(sizeof(s_speccontrolnodebool) == 4, "struct s_speccontrolnodebool is invalid size");

		struct s_camera_fx_settingscontactshadowsparameter
		{

			/* Sun Contact Shadow Settings */

			c_flags<e_camerafxparameterenabledflags, short, k_camerafxparameterenabledflags_count> flags;
			char generated_pad3bce[2]; // padding
			c_flags<e_contactshadowflags, long, k_contactshadowflags_count> contact_shadow_flags;
			s_speccontrolnodebool enabled;
			s_speccontrolnodeint ray_steps;
			real ray_steps_first_person_scalar;
			s_speccontrolnodefloat maximum_shadow_ray_length;
			real maximum_shadow_ray_length_first_person_scalar;
			s_speccontrolnodefloat ray_pixel_stride;
			real first_person_pixel_stride_first_person_scalar;
			real average_occluder_thickness;
			real average_occluder_thickness_first_person;
			real shadow_softness_scale;
			real shadow_softness_scale_first_person;
			real shadow_fade_start_distance;
			real shadow_fade_end_distance;
			real global_opacity;
			real global_opacity_first_person;
			real ray_start_bias;
			real ray_start_bias_far_distance;
			real ray_start_bias_offset_at_far_distance;
			real ray_start_bias_first_person;
			real first_person_transition_scalar;
		};
		static_assert(sizeof(s_camera_fx_settingscontactshadowsparameter) == 220, "struct s_camera_fx_settingscontactshadowsparameter is invalid size");

		struct s_c_camera_fx_settings
		{
			s_anytag_struct_definition anytag;
			// custom value
			s_camera_fx_settingss_real_exposure_parameter exposure;
			s_camera_fx_settingscamerafxexposuresensitivity auto_exposure_sensitivity;
			s_camera_fx_settingscamerafxexposurepitchinfluence exposure_pitch_influence;
			s_camera_fx_settingscamerafxexposurecompensation exposure_compensation;
			s_camera_fx_settingscamerafxbloomhighlight bloom_highlight;
			s_camera_fx_settingscamerafxbloomhighlightthreshold bloom_highlight_threshold;
			s_camera_fx_settingscamerafxbloominherent bloom_inherent;
			s_camera_fx_settingscamerafxbloomintensity bloom_intensity;
			s_camera_fx_settingscamerafxbloomlayerintensity bloom_layer_intensity;
			s_camera_fx_settingscamerafxbloomtintcolor bloom_tint_color;
			s_camera_fx_settingscamerafxselfillumexposuresettings self_illum_exposure_settings;
			s_camera_fx_settingscamerafxselfillumscale self_illum_scale;

			/* SELF ILLUM MATERIAL SHADER FUNCTION PARAMETER - (UNSC) */

			s_camera_fx_settingscamerafxselfillumscaleperrace self_illum_scale_unsc;

			/* SELF ILLUM MATERIAL SHADER FUNCTION PARAMETER - (Covenant) */

			s_camera_fx_settingscamerafxselfillumscaleperrace self_illum_scale_covenant;

			/* SELF ILLUM MATERIAL SHADER FUNCTION PARAMETER - (Forerunner) */

			s_camera_fx_settingscamerafxselfillumscaleperrace self_illum_scale_forerunner;

			/* EFFECT EXPOSURE OVERRIDE */

			c_typed_tag_reference<EFFECT_EXPOSURE_TAG> effect_exposure_override$2;
			s_camera_fx_settingss_color_grading_parameter color_grading;
			s_camera_fx_settingss_ssao_parameter ssao_settings;
			s_camera_fx_settingsdeferredreflectionsparameter deferred_reflections_settings;
			s_camera_fx_settingss_camera_lens_dirt_parameter camera_lens_dirt;
			s_camera_fx_settingscontactshadowsparameter contact_shadows;
			// custom value
		};
		static_assert(sizeof(s_c_camera_fx_settings) == 808, "struct s_c_camera_fx_settings is invalid size");

		struct s_s_character_voice_region_permutation_filter
		{
			string_id permutation_name;
		};
		static_assert(sizeof(s_s_character_voice_region_permutation_filter) == 4, "struct s_s_character_voice_region_permutation_filter is invalid size");

		struct s_s_character_voice_region_filter
		{
			string_id region_name;
			c_typed_tag_block<s_s_character_voice_region_permutation_filter> permutation_filters_block;
		};
		static_assert(sizeof(s_s_character_voice_region_filter) == 16, "struct s_s_character_voice_region_filter is invalid size");

		struct s_s_character_voice
		{
			c_typed_tag_reference<DIALOGUE_TAG> dialogue;
			string_id designator;
			real weight;
			c_typed_tag_block<s_s_character_voice_region_filter> region_filters_block;
		};
		static_assert(sizeof(s_s_character_voice) == 36, "struct s_s_character_voice is invalid size");

		struct s_character_variant
		{
			string_id variant_name;
			short variant_index;
			char generated_padedbf[2]; // padding
			string_id style_id;
			c_typed_tag_block<s_s_character_voice> voices_block;
		};
		static_assert(sizeof(s_character_variant) == 24, "struct s_character_variant is invalid size");

		struct s_c_character_voice_properties_internal
		{
			c_typed_tag_block<s_s_character_voice> voices_block;
		};
		static_assert(sizeof(s_c_character_voice_properties_internal) == 12, "struct s_c_character_voice_properties_internal is invalid size");

		struct s_c_character_development_status_properties_internal
		{
			c_enum<e_characterdevelopmentstage, short> stage;
			char padding1[2]; // padding
		};
		static_assert(sizeof(s_c_character_development_status_properties_internal) == 4, "struct s_c_character_development_status_properties_internal is invalid size");

		struct s_s_disallowed_weapons_from_trading
		{
			c_typed_tag_reference<WEAPON_TAG> weapon;
		};
		static_assert(sizeof(s_s_disallowed_weapons_from_trading) == 16, "struct s_s_disallowed_weapons_from_trading is invalid size");

		struct s_c_character_general_properties_internal
		{
			c_flags<e_charactergeneralflags, long, k_charactergeneralflags_count> general_flags;
			c_enum<e_actortype, short> type;
			short rank;
			c_typed_tag_reference<LUA_TAG> prototype_script;
			real max_leader_dist;
			real absolute_max_leader_dist;
			real max_player_dialogue_dist;
			real scariness;
			c_enum<e_unitgrenadetype, char> default_grenade_type;
			char generated_pad6d7e[1]; // padding
			c_enum<e_behaviortreeroots, short> behavior_tree_root;
			c_typed_tag_reference<BEHAVIORTREE_TAG> data_behavior_tree;
			c_typed_tag_block<s_s_disallowed_weapons_from_trading> disallowed_weapons_from_trading_block;
			c_typed_tag_reference<WEAPON_TAG> initial_primary_weapon_;
			c_typed_tag_reference<WEAPON_CONFIGURATION_TAG> primary_weapon_configuration;
			c_typed_tag_reference<WEAPON_TAG> initial_secondary_weapon_;
			c_typed_tag_reference<WEAPON_CONFIGURATION_TAG> secondary_weapon_configuration;
			c_typed_tag_reference<EQUIPMENT_TAG> initial_equipment_;
			string_id shield_frame_attachment;
			short token_priority;
			char generated_padba33[2]; // padding
			c_typed_tag_block<s_s_object_meta_label> designer_metadata_block;
			c_typed_tag_block<s_s_object_meta_label> dialogue_system_metadata_block;
		};
		static_assert(sizeof(s_c_character_general_properties_internal) == 184, "struct s_c_character_general_properties_internal is invalid size");

		struct s_c_character_proto_spawn_properties_internal
		{
			c_enum<e_protospawntype, short> proto_spawn_type_;
		};
		static_assert(sizeof(s_c_character_proto_spawn_properties_internal) == 2, "struct s_c_character_proto_spawn_properties_internal is invalid size");

		struct s_c_character_interact_properties_internal
		{
			c_flags<e_characterinteractflags, char, k_characterinteractflags_count> interact_flags;
			char generated_padb4d2[3]; // padding
			real default_maximum_object_interact_range;
		};
		static_assert(sizeof(s_c_character_interact_properties_internal) == 8, "struct s_c_character_interact_properties_internal is invalid size");

		struct s_s_ai_character_emotion_situational_danger_properties
		{
			c_enum<e_propclassification, short> highest_prop_class;
			char generated_pad78a8[2]; // padding
			real situational_danger;
		};
		static_assert(sizeof(s_s_ai_character_emotion_situational_danger_properties) == 8, "struct s_s_ai_character_emotion_situational_danger_properties is invalid size");

		struct s_c_character_emotions_properties_internal
		{
			c_typed_tag_block<s_s_ai_character_emotion_situational_danger_properties> situational_danger_block;
			real perceived_danger_increase_half_life;
			real perceived_danger_decay_half_life;
			real perceived_danger_alert_threshold;
			real perceived_danger_combat_threshold;
		};
		static_assert(sizeof(s_c_character_emotions_properties_internal) == 28, "struct s_c_character_emotions_properties_internal is invalid size");

		struct s_c_character_vitality_properties_internal
		{
			c_flags<e_charactervitalityflags, long, k_charactervitalityflags_count> vitality_flags;
			real normal_body_vitality;
			real normal_shield_vitality;
			real legendary_body_vitality;
			real legendary_shield_vitality;
			real body_recharge_fraction;
			real soft_ping_threshold_with_shields;
			real soft_ping_threshold_no_shields;
			real medium_ping_threshold_with_shields;
			real medium_ping_threshold_no_shields;
			real medium_ping_cooldown_time;
			real hard_ping_threshold_with_shields;
			real hard_ping_threshold_no_shields;
			real hard_ping_cooldown_time;
			real body_recharge_delay_time;
			real body_recharge_time;
			real shield_recharge_delay_time;
			real shield_recharge_time;
			real extended_shield_damage_threshold;
			real extended_body_damage_threshold;
			real runtime_body_recharge_velocity;
			real runtime_shield_recharge_velocity;
			c_typed_tag_reference<WEAPON_TAG> resurrect_weapon;
			real player_damage_scale;
			c_typed_tag_reference<COLLISION_DAMAGE_TAG> collision_damage_override;
			c_typed_tag_reference<COLLISION_DAMAGE_TAG> knockback_collision_damage_override;
			real stun_threshold_easy;
			real stun_threshold_normal;
			real stun_threshold_heroic;
			real stun_threshold_legendary;
			real stun_time_scale_easy;
			real stun_time_scale_normal;
			real stun_time_scale_heroic;
			real stun_time_scale_legendary;
			real stun_cooldown_easy;
			real stun_cooldown_normal;
			real stun_cooldown_heroic;
			real stun_cooldown_legendary;
		};
		static_assert(sizeof(s_c_character_vitality_properties_internal) == 188, "struct s_c_character_vitality_properties_internal is invalid size");

		struct s_c_character_placement_properties_internal
		{
			real few_upgrade_chance_easy;
			real few_upgrade_chance_normal;
			real few_upgrade_chance_heroic;
			real few_upgrade_chance_legendary;
			real normal_upgrade_chance_easy;
			real normal_upgrade_chance_normal;
			real normal_upgrade_chance_heroic;
			real normal_upgrade_chance_legendary;
			real many_upgrade_chance_easy;
			real many_upgrade_chance_normal;
			real many_upgrade_chance_heroic;
			real many_upgrade_chance_legendary;
		};
		static_assert(sizeof(s_c_character_placement_properties_internal) == 48, "struct s_c_character_placement_properties_internal is invalid size");

		struct s_c_character_base_perception_properties_internal
		{
			c_flags<e_characterbaseperceptionflags, char, k_characterbaseperceptionflags_count> flags;
			char generated_pad16e5[3]; // padding
			real silent_movement_speed_threshold;
			real perception_decay_delay;
			real moving_perception_decay_delay;
			real perception_begin_to_forget_time;
			real perception_forget_time;
			real combat_status_alert_cooldown;
			real combat_status_active_cooldown;
			real postcombat_clump_state_time;

			/* Perceived Danger Impulses */

			real weapon_impact_danger_impulse;
			real bullet_impact_danger_impulse;
			real spartan_abilitiy_impact_danger_impulse;
			real footsteps_danger_impulse;
			real jump_landing_impact_danger_impulse;
		};
		static_assert(sizeof(s_c_character_base_perception_properties_internal) == 56, "struct s_c_character_base_perception_properties_internal is invalid size");

		struct s_s_active_camo_perception_properties
		{
			real_fraction partial_invisibility_amount;
			real partial_invisibility_vision_distance;
			real_fraction full_invisibility_amount;
			real full_invisibility_vision_distance;
		};
		static_assert(sizeof(s_s_active_camo_perception_properties) == 16, "struct s_s_active_camo_perception_properties is invalid size");

		struct s_c_character_perception_properties_internal
		{
			c_enum<e_c_perception_mode, short> perception_mode;
			c_flags<e_characterperceptionflags, short, k_characterperceptionflags_count> flags;
			real maximum_vision_distance;
			real reliable_vision_distance;
			real maximum_peripheral_vision_distance;
			real reliable_peripheral_vision_distance;
			real max_peripheral_vision_distance_at_peripheral_vision_angle;
			real max_reliable_peripheral_vision_distance_at_peripheral_vision_angle;
			real maximum_unmistakable_distance;
			real surprise_distance;
			real min_distance_from_last_known_position_to_surprise;
			real min_time_from_last_clump_surprise;
			real min_time_from_last_seen_to_surprise;
			real_bounds surprise_lerp_distance_range;
			real_bounds surprise_angle_range;
			angle focus_interior_angle;
			angle focus_exterior_angle;
			angle peripheral_vision_angle;
			angle vertical_exterior_up_angle;
			angle vertical_exterior_down_angle;
			real hearing_distance;
			real max_propagation_time;
			real partial_perception_awareness_delay;
			real full_perception_awareness_delay;
			real unmistakable_perception_awareness_delay;
			real partial_perception_acknowledgement_delay;
			real full_perception_acknowledgement_delay;
			real unmistakable_perception_acknowledgement_delay;
			real awareness_glance_level;
			real_fraction identify_hologram_chance;
			real_bounds hologram_ignore_timer;
			real hologram_ignore_timer_shot_penalty;
			// custom parital_perception_distance_distribution_function
			s_functiondefinition mapping;
			// custom normal_active_camo_perception
			s_s_active_camo_perception_properties normal_active_camo_perception;
			// custom value
			// custom legendary_active_camo_perception
			s_s_active_camo_perception_properties legendary_active_camo_perception;
			// custom value
		};
		static_assert(sizeof(s_c_character_perception_properties_internal) == 188, "struct s_c_character_perception_properties_internal is invalid size");

		struct s_c_character_target_properties_internal
		{
			real player_preference;
		};
		static_assert(sizeof(s_c_character_target_properties_internal) == 4, "struct s_c_character_target_properties_internal is invalid size");

		struct s_c_character_look_properties_internal
		{
			real_euler_angles2d maximum_aiming_deviation;
			real_euler_angles2d maximum_looking_deviation;
			real_euler_angles2d runtime_aiming_deviation_cosines;
			real_euler_angles2d runtime_looking_deviation_cosines;
			angle noncombat_look_delta_l;
			angle noncombat_look_delta_r;
			angle combat_look_delta_l;
			angle combat_look_delta_r;
			real_bounds noncombat_idle_looking;
			real_bounds noncombat_idle_aiming;
			real_bounds combat_idle_looking;
			real_bounds combat_idle_aiming;
		};
		static_assert(sizeof(s_c_character_look_properties_internal) == 80, "struct s_c_character_look_properties_internal is invalid size");

		struct s_characterhopdefinition
		{
			real min_hop_distance;
			real min_hop_distance_to_path_end;
			real_bounds hop_wait_timer_min_max;
			real max_hop_distance;
			real pad;
		};
		static_assert(sizeof(s_characterhopdefinition) == 24, "struct s_characterhopdefinition is invalid size");

		struct s_characterhopdefinitionset
		{
			// custom _default
			s_characterhopdefinition _default;
			// custom value
			// custom passive
			s_characterhopdefinition passive;
			// custom value
			// custom aggressive
			s_characterhopdefinition aggressive;
			// custom value
		};
		static_assert(sizeof(s_characterhopdefinitionset) == 72, "struct s_characterhopdefinitionset is invalid size");

		struct s_c_character_hopping_properties_internal
		{
			c_flags<e_characterhoppingflags, long, k_characterhoppingflags_count> hopping_flags;
			c_typed_tag_block<s_characterhopdefinitionset> hopping_definition_block;
		};
		static_assert(sizeof(s_c_character_hopping_properties_internal) == 16, "struct s_c_character_hopping_properties_internal is invalid size");

		struct s_characterwarpdefinition
		{
			real min_warp_distance;
			real max_warp_distance;
			real warp_speed;
			real run_up_distance;
			real linear_distance_until_cooldown;
			real cooldown_duration;
			real min_jump_distance;
		};
		static_assert(sizeof(s_characterwarpdefinition) == 28, "struct s_characterwarpdefinition is invalid size");

		struct s_characterwarpdefinitionset
		{
			// custom _default
			s_characterwarpdefinition _default;
			// custom value
			// custom passive
			s_characterwarpdefinition passive;
			// custom value
			// custom aggressive
			s_characterwarpdefinition aggressive;
			// custom value
		};
		static_assert(sizeof(s_characterwarpdefinitionset) == 84, "struct s_characterwarpdefinitionset is invalid size");

		struct s_c_character_warp_properties_internal
		{
			c_typed_tag_block<s_characterwarpdefinitionset> warp_definition_block;
			c_typed_tag_reference<EFFECT_TAG> intro_effect;
			c_typed_tag_reference<EFFECT_TAG> travel_effect;
			c_typed_tag_reference<EFFECT_TAG> outro_effect;
		};
		static_assert(sizeof(s_c_character_warp_properties_internal) == 60, "struct s_c_character_warp_properties_internal is invalid size");

		struct s_s_character_movement_stationary_pause_settings
		{

			/* Inertial pause settings */

			angle direction_change_angle;
			long stationary_change;
		};
		static_assert(sizeof(s_s_character_movement_stationary_pause_settings) == 8, "struct s_s_character_movement_stationary_pause_settings is invalid size");

		struct s_s_character_movement_throttle_control_settings
		{
			real distance;
			real throttle_scale;
		};
		static_assert(sizeof(s_s_character_movement_throttle_control_settings) == 8, "struct s_s_character_movement_throttle_control_settings is invalid size");

		struct s_s_character_movement_throttle_per_combat_status_settings
		{
			c_enum<e_actorcombatstatus, short> combat_status;
			char generated_padd966[2]; // padding
			c_typed_tag_block<s_s_character_movement_throttle_control_settings> throttle_settings_block;
		};
		static_assert(sizeof(s_s_character_movement_throttle_per_combat_status_settings) == 16, "struct s_s_character_movement_throttle_per_combat_status_settings is invalid size");

		struct s_characterlocomotionsettings
		{
			// custom locomotion_settings
			real_fraction sharp_turn_throttle;
			angle sharp_turn_angle;
			real max_accel_time;
			real max_decel_time;
			// custom value
		};
		static_assert(sizeof(s_characterlocomotionsettings) == 16, "struct s_characterlocomotionsettings is invalid size");

		struct s_c_character_movement_properties_internal
		{
			c_flags<e_charactermovementflags, long, k_charactermovementflags_count> movement_flags;
			real pathfinding_radius;
			real avoidance_radius;
			real destination_radius;
			real friendly_outer_radius;
			real friendly_inner_radius;
			real friendly_player_outer_radius;
			real friendly_player_inner_radius;

			/* Danger Zone Avoidance */

			c_enum<e_objectaisize, short> obstacle_leap_min_size;
			c_enum<e_objectaisize, short> obstacle_leap_max_size;
			c_enum<e_objectaisize, short> obstacle_ignore_size;
			c_enum<e_objectaisize, short> obstacle_smashable_size;

			/* clearance cache */

			c_enum<e_clearancecachebucketsize, short> clearance_cache_bucket_size;
			char generated_pad024b[2]; // padding
			real max_jump_height;
			real max_jump_distance;
			real maximum_leap_height;
			real leap_proximity_fraction;
			real maximum_hoist_height;
			real obstacle_smash_strength;
			c_flags<e_charactermovementhintflags, long, k_charactermovementhintflags_count> movement_hints;
			// custom throttle_and_inertia
			c_typed_tag_block<s_s_character_movement_stationary_pause_settings> change_direction_pause_block;
			real maximum_throttle;
			real minimum_throttle;
			real throttle_smoothing_rate;
			c_typed_tag_block<s_s_character_movement_throttle_per_combat_status_settings> movement_throttle_control_block;
			real minimum_juke_throttle;
			angle minimum_direction_change_juke_angle;
			real non_direction_change_juke_probability;
			real non_direction_change_juke_timeout;
			long minimum_post_juke_movement_ticks;
			// custom value
			real stationary_turn_radius;
			real_bounds move_distance;
			// custom phasing
			real phase_chance;
			real phase_delay_seconds;
			// custom value
			// custom movement_facing

			/* Movement Facing */

			angle maximum_deviation_angle;
			// custom value
			s_characterlocomotionsettings locomotion_settings;
			real wall_climb_cost_multiplier_;
			// custom character_flight
			c_enum<e_i343aifpevalairnavposition, char> air_nav_firing_point_position;
			// custom value
			char generated_padb596[3]; // padding
		};
		static_assert(sizeof(s_c_character_movement_properties_internal) == 176, "struct s_c_character_movement_properties_internal is invalid size");

		struct s_c_character_aimingfacing_properties_internal
		{
			c_flags<e_characteraimingfacingflags, char, k_characteraimingfacingflags_count> flags;
			c_enum<e_i343aifacingmode, char> default_facing_mode;
			char generated_padbf57[2]; // padding
			// custom baseball_run_properties

			/* Baseball run properties */

			real strafe_to_run_rate;
			real run_to_strafe_rate;
			real start_distance_threshold;
			real end_distance_threshold;
			real path_minimum_length;
			real minimum_distance_to_target;
			// custom value
		};
		static_assert(sizeof(s_c_character_aimingfacing_properties_internal) == 28, "struct s_c_character_aimingfacing_properties_internal is invalid size");

		struct s_c_character_deceleratedturns_properties_internal
		{
			// custom turn_slerp_blend_table
			// custom turn_slerp_blend_table_table
			s_functiondefinition turn_slerp_blend_table;
			// custom value
			// custom turn_anticipation_blend_table
			// custom turn_anticipation_blend_table
			s_functiondefinition turn_anticipation_blend_table;
			// custom value
			// custom turn_reaction_blend_table
			// custom turn_reaction_blend_table
			s_functiondefinition turn_reaction_blend_table;
			// custom value
			real turn_reaction_cosine_power;
			real turn_reaction_cosine_factor;
		};
		static_assert(sizeof(s_c_character_deceleratedturns_properties_internal) == 68, "struct s_c_character_deceleratedturns_properties_internal is invalid size");

		struct s_i343bipedmodespecificlocomotionscaledefinition
		{
			string_id mode_name;
			real speed_scale;
			real acceleration_scale;
			real locomotion_turn_rate_scale;
		};
		static_assert(sizeof(s_i343bipedmodespecificlocomotionscaledefinition) == 16, "struct s_i343bipedmodespecificlocomotionscaledefinition is invalid size");

		struct s_i343bipedlocomotionpropertiesdefinition
		{

			/* Walk speed properties */

			real walking_speed;

			/* AI Sprint speed properties */

			real ai_sprinting_speed;

			/* Run speed properties */

			real running_forward_speed;
			real running_backward_speed;
			real running_sideways_speed;

			/* Crouch speed properties */

			real crouching_forward_speed;
			real crouching_backward_speed;
			real crouching_sideways_speed;

			/* Acceleration/deceleration properties */

			real maximum_run_acceleration;
			real maximum_run_deceleration;
			real maximum_crouch_acceleration;
			real maximum_crouch_deceleration;

			/* Airborne Acceleration/Deceleration */

			real maximum_airborne_acceleration;
			real maximum_airborne_deceleration;

			/* Stationary turn properties old action system */

			real low_speed_threshold;
			real high_speed_threshold;
			real acceleration;

			/* Stationary turn properties new action system */

			real stationary_turn_trigger_range_factor;
			real stationary_turn_max_anim_playback_speed_up_factor;

			/* Stationary turn properties new action system (DEPRECATED) */

			angle min_stationary_turn_angle;
			real stationary_turn_max_speed_threshold;
			angle stationary_turn_min_yaw_threshold;
			angle stationary_turn_max_speed_yaw;
			angle min_stationary_turn_speed;
			angle max_stationary_turn_speed;
			real stationary_turn_acceleration_rate;
			real stationary_turn_decceleration_rate;

			/* Non stationary turn properties */

			angle max_angular_velocity_clamp;
			angle turn_accel_decel_rate;

			/* Speed/acceleration scales based on mode */

			c_typed_tag_block<s_i343bipedmodespecificlocomotionscaledefinition> mode_specific_scaling_block;
		};
		static_assert(sizeof(s_i343bipedlocomotionpropertiesdefinition) == 128, "struct s_i343bipedlocomotionpropertiesdefinition is invalid size");

		struct s_c_character_locomotionoverrides_properties_internal
		{
			s_i343bipedlocomotionpropertiesdefinition locomotion_overrides;
		};
		static_assert(sizeof(s_c_character_locomotionoverrides_properties_internal) == 128, "struct s_c_character_locomotionoverrides_properties_internal is invalid size");

		struct s_c_character_movementtweak_properties_internal
		{
			real dive_grenade_chance;
			real brace_grenade_chance;
			real dive_vehicle_chance;
			real brace_vehicle_chance;
			real stand_ground_chance;
			real stand_ground_anticipation_time;
			real brace_for_grenade_time;
			real brace_for_vehicle_impact_time;
			real brace_for_vehicle_impact_prediction_time;
			real brace_for_vehicle_impact_velocity_threshold;
			c_enum<e_characterjumpheight, short> jump_height;
			char generated_pad113f[2]; // padding
		};
		static_assert(sizeof(s_c_character_movementtweak_properties_internal) == 44, "struct s_c_character_movementtweak_properties_internal is invalid size");

		struct s_c_character_throttle_style_properties_internal
		{
			string_id style_name;
			real_fraction desired_throttle;
			real acceleration_time;
			s_scalarfunctionname acceleration_function;
			real deceleration_distance;
			s_scalarfunctionname deceleration_function;
			string_id stance;
		};
		static_assert(sizeof(s_c_character_throttle_style_properties_internal) == 60, "struct s_c_character_throttle_style_properties_internal is invalid size");

		struct s_character_movement_mapping
		{
			real chance;

			/* MAPPING */

			string_id idle;
			string_id alert;
			string_id engage;
			string_id self_preserve;
			string_id search;
			string_id retreat;
			string_id panic;
			string_id flank;
			string_id _protected;
			string_id stunned;
			string_id post_combat;
			string_id hurry;
			string_id custom_1;
			string_id custom_2;
			string_id custom_3;
			string_id custom_4;
		};
		static_assert(sizeof(s_character_movement_mapping) == 68, "struct s_character_movement_mapping is invalid size");

		struct s_character_movement_set
		{
			string_id name;
			c_typed_tag_block<s_character_movement_mapping> variants_block;
		};
		static_assert(sizeof(s_character_movement_set) == 16, "struct s_character_movement_set is invalid size");

		struct s_c_character_flocking_properties_internal
		{

			/* Jaime, don't touch this */

			real deceleration_distance;
			real normalized_speed;
			real buffer_distance;
			real_bounds throttle_threshold_bounds;
			real deceleration_stop_time;
		};
		static_assert(sizeof(s_c_character_flocking_properties_internal) == 24, "struct s_c_character_flocking_properties_internal is invalid size");

		struct s_c_character_swarm_properties_internal
		{
			short scatter_killed_count;
			char generated_pad8e1a[2]; // padding
			real scatter_radius;
			real scatter_time;
			real hound_min_distance;
			real hound_max_distance;
			real perlin_offset_scale;
			real_bounds offset_period;
			real perlin_idle_movement_threshold;
			real perlin_combat_movement_threshold;
			real stuck_time;
			real stuck_distance;
		};
		static_assert(sizeof(s_c_character_swarm_properties_internal) == 48, "struct s_c_character_swarm_properties_internal is invalid size");

		struct s_c_character_ready_properties_internal
		{
			real_bounds ready_time_bounds;
		};
		static_assert(sizeof(s_c_character_ready_properties_internal) == 8, "struct s_c_character_ready_properties_internal is invalid size");

		struct s_animationexception
		{
			string_id animation_exception_name;
		};
		static_assert(sizeof(s_animationexception) == 4, "struct s_animationexception is invalid size");

		struct s_c_character_engage_properties_internal
		{
			c_flags<e_characterengageflags, long, k_characterengageflags_count> flags;
			real_bounds reposition_bounds;
			real_bounds bunkering_reposition_bounds;

			/* Danger Crouch */

			real crouch_danger_threshold;
			real crouch_max_path_distance;
			real stand_danger_threshold;
			real fight_danger_move_threshold;
			short_bounds fight_danger_move_threshold_cooldown;
			c_typed_tag_reference<PROJECTILE_TAG> override_grenade_projectile;
			real_bounds default_combat_range;
			real_bounds default_firing_range;
			real_fraction preferred_engage_fraction_;
			real active_shield_fire_cutoff_delay;
			real friendly_avoid_distance;
			real friendly_close_avoid_distance;
			real teamlead_flocking_distance;
			real enemy_avoid_distance;
			real scary_enemy_avoid_distance;
			c_typed_tag_block<s_animationexception> full_body_animation_exceptions_for_firing_reset_block;

			/* Flying */

			angle max_angle_from_level;
		};
		static_assert(sizeof(s_c_character_engage_properties_internal) == 116, "struct s_c_character_engage_properties_internal is invalid size");

		struct s_kamikazeattachmentmarkers
		{
			string_id attachment_marker;
		};
		static_assert(sizeof(s_kamikazeattachmentmarkers) == 4, "struct s_kamikazeattachmentmarkers is invalid size");

		struct s_character_charge_difficulty_limits
		{

			/* Difficulty Limits */

			short max_kamikaze_count;
			short max_berserk_count;
			short min_berserk_count;
		};
		static_assert(sizeof(s_character_charge_difficulty_limits) == 6, "struct s_character_charge_difficulty_limits is invalid size");

		struct s_c_character_berserk_properties_internal
		{
			c_flags<e_c_character_berserk_properties_internalberserkflags, long, k_c_character_berserk_properties_internalberserkflags_count> flags;
			c_typed_tag_reference<WEAPON_TAG> berserk_weapon;
			real timeout;
			real_bounds shield_down_chance;
			real_bounds shield_down_range;
			real friendly_killed_distance;
			real_fraction peer_killed_chance;
			real_fraction leader_killed_chance;
			real chance_to_play_berserk_anim;
			real chance_to_play_berserk_anim_when_stuck;
			real_fraction proximity_chance;
			real proximity_check_cooldown;
			real proximity_abort_distance;
			real_fraction broken_kamikaze_chance;
			real_fraction surprise_kamikaze_chance;
			c_typed_tag_block<s_kamikazeattachmentmarkers> kamikaze_attachment_markers_block;
			real broken_kamikaze_stuck_delay;
			real max_kamikaze_time;
			real last_man_trigger_distance;
			c_typed_tag_block<s_character_charge_difficulty_limits> difficulty_limits_block;
		};
		static_assert(sizeof(s_c_character_berserk_properties_internal) == 116, "struct s_c_character_berserk_properties_internal is invalid size");

		struct s_c_character_weaponpickup_properties_internal
		{
			real search_range;
			real minimum_target_range;
			real desired_target_range;
			real_fraction search_chance;
			real range_threshold;
			real vehicle_threshold;
			real search_delay_min;
			real search_delay_max;
			c_enum<e_c_character_weaponpickup_properties_internalpickupbias, char> bias;
			char generated_pad5304[3]; // padding
			real danger_threshold;
		};
		static_assert(sizeof(s_c_character_weaponpickup_properties_internal) == 40, "struct s_c_character_weaponpickup_properties_internal is invalid size");

		struct s_c_character_evasion_properties_internal
		{
			real evasion_danger_threshold;
			real evasion_delay_timer;
			real evasion_chance;
			real evasion_proximity_threshold;
			real dive_retreat_chance;
		};
		static_assert(sizeof(s_c_character_evasion_properties_internal) == 20, "struct s_c_character_evasion_properties_internal is invalid size");

		struct s_c_character_dodge_properties_internal
		{
			real danger_threshold;
			real cooldown;
			real chance;
			real stop_proximity;
		};
		static_assert(sizeof(s_c_character_dodge_properties_internal) == 16, "struct s_c_character_dodge_properties_internal is invalid size");

		struct s_characterrunawayfromvehiclepropertiesinternal
		{
			real chance;
			real minimum_time_to_flee;
			real time_to_flee;
			real time_to_keep_path;
		};
		static_assert(sizeof(s_characterrunawayfromvehiclepropertiesinternal) == 16, "struct s_characterrunawayfromvehiclepropertiesinternal is invalid size");

		struct s_c_character_cover_properties_internal
		{
			c_flags<e_coverpropertiesflags, long, k_coverpropertiesflags_count> cover_flags;
			real_bounds hide_behind_cover_time;

			/* Cover conditions */

			real cover_shield_fraction;
			real cover_vitality_threshold;
			real cover_danger_threshold;
			real leave_cover_danger_threshold;
			// custom aggresive_defensive_cover_properties
			real minimum_defensive_distance_from_target;
			real minimum_defensive_distance_from_cover;
			real always_defensive_scary_threshold;
			// custom value

			/* Other */

			real cover_check_delay;
			real cover_pinned_down_check_delay;
			real emerge_from_cover_when_shield_fraction_reaches_threshold;
			real body_vitality_exit_threshold;
			real proximity_self_preserve;
			real unreachable_enemy_danger_threshold;
			real scary_target_threshold;
			real minimum_enemy_distance;
		};
		static_assert(sizeof(s_c_character_cover_properties_internal) == 72, "struct s_c_character_cover_properties_internal is invalid size");

		struct s_c_character_retreat_properties_internal
		{
			c_flags<e_characterretreatflags, long, k_characterretreatflags_count> retreat_flags;
			real shield_threshold;
			real scary_target_threshold;
			real danger_threshold;
			real proximity_threshold;
			real_bounds min_max_forced_cower_time_bounds;
			real_bounds min_max_cower_timeout_bounds;
			real proximity_ambush_threshold;
			real awareness_ambush_threshold;
			real leader_dead_retreat_chance;
			real peer_dead_retreat_chance;
			real second_peer_dead_retreat_chance;
			real flee_timeout;
			angle zig_zag_angle;
			real zig_zag_period;
			real retreat_grenade_chance;
		};
		static_assert(sizeof(s_c_character_retreat_properties_internal) == 72, "struct s_c_character_retreat_properties_internal is invalid size");

		struct s_c_character_search_properties_internal
		{
			c_flags<e_charactersearchflags, long, k_charactersearchflags_count> search_flags;
			real_bounds search_time;
			real search_distance;
			real max_searcher_count_;

			/* Uncover */

			real_bounds uncover_distance_bounds;

			/* Investigate */

			real_bounds vocalization_time;
		};
		static_assert(sizeof(s_c_character_search_properties_internal) == 36, "struct s_c_character_search_properties_internal is invalid size");

		struct s_c_character_presearch_properties_internal
		{
			c_flags<e_presearchgenericflags, long, k_presearchgenericflags_count> pre_search_flags;
			real_bounds min_presearch_time;
			real_bounds max_presearch_time;
			real_bounds peek_time;
			real max_certainty_radius;
			real max_presearcher_count_;
			real max_suppressing_count;
			real max_uncover_count;
			long max_destroy_cover_count;
			real max_suppress_time;
			real fire_to_uncover_chance_;
			real max_destroy_cover_time;
			// custom child_weights
			real suppressing_fire_weight;
			real uncover_weight;
			real leap_on_cover_weight;
			real destroy_cover_weight;
			real guard_weight;
			real investigate_weight;
			real search_by_fire_weight;
			// custom value
		};
		static_assert(sizeof(s_c_character_presearch_properties_internal) == 88, "struct s_c_character_presearch_properties_internal is invalid size");

		struct s_characterrecognizingpropertiesinternal
		{

			/* Recognizing */

			real recognize_min_time;
			real recognize_max_time;
		};
		static_assert(sizeof(s_characterrecognizingpropertiesinternal) == 8, "struct s_characterrecognizingpropertiesinternal is invalid size");

		struct s_c_character_idle_properties_internal
		{
			real_bounds idle_pose_delay_time;
			real_bounds wander_delay_time;
		};
		static_assert(sizeof(s_c_character_idle_properties_internal) == 16, "struct s_c_character_idle_properties_internal is invalid size");

		struct s_systematicrecreationsettings
		{
			string_id required_weapon_class;
			real_bounds cooldown;
			real_bounds duration;
		};
		static_assert(sizeof(s_systematicrecreationsettings) == 20, "struct s_systematicrecreationsettings is invalid size");

		struct s_c_character_precombat_properties_internal
		{
			c_typed_tag_block<s_systematicrecreationsettings> systematic_recreation_settings_block;
		};
		static_assert(sizeof(s_c_character_precombat_properties_internal) == 12, "struct s_c_character_precombat_properties_internal is invalid size");

		struct s_c_character_vocalization_properties_internal
		{

			/* Skip Fraction */

			real character_skip_fraction;
			real speaker_weight_bonus;
			real look_trigger_distance;
			real look_cooldown_time;
			real look_comment_time;
			real look_long_comment_time;
			real look_respond_max_time;
			real look_respond_early_out_time;
		};
		static_assert(sizeof(s_c_character_vocalization_properties_internal) == 32, "struct s_c_character_vocalization_properties_internal is invalid size");

		struct s_s_character_vehicle_boarding_properties
		{
			c_typed_tag_reference<UNIT_TAG> vehicle;
			c_flags<e_charactervehicleboardingflags, long, k_charactervehicleboardingflags_count> flags;
		};
		static_assert(sizeof(s_s_character_vehicle_boarding_properties) == 20, "struct s_s_character_vehicle_boarding_properties is invalid size");

		struct s_charactervehicleboardingpullproperties
		{
			c_typed_tag_reference<UNIT_TAG> vehicle;
			real max_pull;
			real min_linear_acceleration;
			real pull_history_factor;
		};
		static_assert(sizeof(s_charactervehicleboardingpullproperties) == 28, "struct s_charactervehicleboardingpullproperties is invalid size");

		struct s_c_character_boarding_properties_internal
		{
			string_id rule_name;
			c_flags<e_characterboardingflags, long, k_characterboardingflags_count> flags;
			real boarding_distance;
			real abort_distance;
			real minimum_entry_distance;
			real maximum_entry_distance;
			real max_speed;
			real board_time;
			real_bounds boarding_timeout;
			c_typed_tag_block<s_s_character_vehicle_boarding_properties> vehicle_specific_properties_block;
			c_typed_tag_block<s_charactervehicleboardingpullproperties> vehicle_specific_pull_properties_block;

			/* New boarding behavior */

			real max_danger;
			real max_pull;
			real min_linear_acceleration;
			real pull_history_factor;
			real ejection_knockback_time;
			real entry_timeout;
			real boarding_chance;
			real hijack_max_wait_time;
			real min_vehicle_vitality;
			real_bounds melee_cooldown;
		};
		static_assert(sizeof(s_c_character_boarding_properties_internal) == 108, "struct s_c_character_boarding_properties_internal is invalid size");

		struct s_c_character_kungfu_properties_internal
		{
			real kungfu_override_distance;
			real kungfu_cover_danger_threshold;
			real min_allowed_time;
			real min_disallowed_time;
		};
		static_assert(sizeof(s_c_character_kungfu_properties_internal) == 16, "struct s_c_character_kungfu_properties_internal is invalid size");

		struct s_s_bunker_timings
		{
			real_bounds open_time;
			real closed_min_time;
			real close_danger_level;
			real open_chance;
			real peek_chance;
		};
		static_assert(sizeof(s_s_bunker_timings) == 24, "struct s_s_bunker_timings is invalid size");

		struct s_c_character_bunker_properties_internal
		{
			c_flags<e_c_character_bunker_properties_internalflags, long, k_c_character_bunker_properties_internalflags_count> flags;

			/* DEFAULT TIMINGS */

			s_s_bunker_timings _default;

			/* FIGHT TIMINGS */

			s_s_bunker_timings fight;

			/* COVER TIMINGS */

			s_s_bunker_timings cover;

			/* GUARD TIMINGS */

			s_s_bunker_timings guard;
		};
		static_assert(sizeof(s_c_character_bunker_properties_internal) == 100, "struct s_c_character_bunker_properties_internal is invalid size");

		struct s_i343aiformationdescription
		{

			/* Procedural */

			c_enum<e_i343aiformationdescriptionshape, long> shape;
			angle yaw;
			real spacing;
			long max_rectangle_width;

			/* Custom */

			c_typed_tag_reference<FORMATION_TAG> formation_reference;

			/* Common */

			real max_speed;
			angle max_yaw_rate;
		};
		static_assert(sizeof(s_i343aiformationdescription) == 40, "struct s_i343aiformationdescription is invalid size");

		struct s_c_character_shield_wall_properties_internal
		{
			real raise_shield_delay;
			real relocate_delay;
			real max_leader_protect_distance;
			// custom formation
			s_i343aiformationdescription formation_description;
			// custom value
		};
		static_assert(sizeof(s_c_character_shield_wall_properties_internal) == 52, "struct s_c_character_shield_wall_properties_internal is invalid size");

		struct s_c_character_firing_wall_properties_internal
		{
			// custom activation_chance
			real_fraction activation_chance_easy;
			real_fraction activation_chance_normal;
			real_fraction activation_chance_heroic;
			real_fraction activation_chance_legendary;
			// custom value
			real max_distance;
			long min_member_count;
			long max_member_count;
			real_bounds fire_time;
			real cooldown;
			real warp_in_time;
			real min_arrival_time_variation;
			real max_arrival_time_variation;
			real warp_out_time;
			real min_departure_time_variation;
			real max_departure_time_variation;
			angle max_angle_between_formation_and_target;
			// custom formation
			s_i343aiformationdescription formation_description;
			// custom value
		};
		static_assert(sizeof(s_c_character_firing_wall_properties_internal) == 108, "struct s_c_character_firing_wall_properties_internal is invalid size");

		struct s_characterinterposerequestpropertiesinternal
		{
			real danger_level;
			real_bounds wait_time;
			real cooldown;
		};
		static_assert(sizeof(s_characterinterposerequestpropertiesinternal) == 16, "struct s_characterinterposerequestpropertiesinternal is invalid size");

		struct s_characterinterposepropertiesinternal
		{
			real_bounds protect_time;
			real distance_from_protect;
			string_id firing_style;
		};
		static_assert(sizeof(s_characterinterposepropertiesinternal) == 16, "struct s_characterinterposepropertiesinternal is invalid size");

		struct s_c_character_bounding_properties_internal
		{
			real max_wait_time;
			real advance_time;
			real reposition_search_range;
			real max_destination_age;
			byte max_cover_agents;
			char generated_pada6c0[3]; // padding
		};
		static_assert(sizeof(s_c_character_bounding_properties_internal) == 20, "struct s_c_character_bounding_properties_internal is invalid size");

		struct s_projectiledeflectionzone
		{
			real_bounds time_to_target_window;
			real_vector3d target_offset;
			real target_radius;
			angle max_incoming_angle;
			string_id animation_name;
		};
		static_assert(sizeof(s_projectiledeflectionzone) == 32, "struct s_projectiledeflectionzone is invalid size");

		struct s_c_character_deflection_properties_internal
		{

			/* Deflection areas */

			c_typed_tag_block<s_projectiledeflectionzone> target_areas_block;
		};
		static_assert(sizeof(s_c_character_deflection_properties_internal) == 12, "struct s_c_character_deflection_properties_internal is invalid size");

		struct s_c_character_bot_properties_internal
		{
			c_flags<e_botpropertiesflags, long, k_botpropertiesflags_count> movement_flags;

			/* Bot info */

			real crouch_time;
			real_fraction crouch_low_shield_threshold;
			real_fraction jump_chance;
			real_fraction evade_low_shield_threshold;
			real strafing_influence_vector_radius;
			real strafing_influence_vector_weight;
			real firing_point_refresh_distance;
			real influence_rejection_radius;
			real movement_cooldown_min;
			real movement_cooldown_max;
			real min_reload_chance;
			real max_reload_chance;
		};
		static_assert(sizeof(s_c_character_bot_properties_internal) == 52, "struct s_c_character_bot_properties_internal is invalid size");

		struct s_c_character_evasivefight_properties_internal
		{
			real engage_fraction;
			real_bounds stationary_time;
			real move_danger_threshold;
			real shield_threshold;
			real dive_cooldown;
			real dive_shield_threshold;
			real dive_danger_threshold;
		};
		static_assert(sizeof(s_c_character_evasivefight_properties_internal) == 32, "struct s_c_character_evasivefight_properties_internal is invalid size");

		struct s_c_character_aggressivefight_properties_internal
		{
			c_flags<e_aggressivefightflags, char, k_aggressivefightflags_count> flags;
			char generated_padcd38[3]; // padding
			real engage_fraction;
			real_bounds stationary_time;
			real move_danger_threshold;
			real max_speed_percent;
		};
		static_assert(sizeof(s_c_character_aggressivefight_properties_internal) == 24, "struct s_c_character_aggressivefight_properties_internal is invalid size");

		struct s_c_character_linearadvancefight_properties_internal
		{
			real_bounds stationary_time;
			real advance_distance;
		};
		static_assert(sizeof(s_c_character_linearadvancefight_properties_internal) == 12, "struct s_c_character_linearadvancefight_properties_internal is invalid size");

		struct s_characterstaticfightpropertiesinternal
		{
			real_bounds stationary_time;
			real danger_move_threshold;
		};
		static_assert(sizeof(s_characterstaticfightpropertiesinternal) == 12, "struct s_characterstaticfightpropertiesinternal is invalid size");

		struct s_characterstandgroundpropertiesinternal
		{
			real_bounds target_distance;
			real ally_distance;
			real ally_attacker_distance;
			real behavior_linger_time;
		};
		static_assert(sizeof(s_characterstandgroundpropertiesinternal) == 20, "struct s_characterstandgroundpropertiesinternal is invalid size");

		struct s_charactergrenadefightpropertiesinternal
		{
			real_bounds stationary_time;
			real minimum_movement;
			real_fraction ideal_fraction;
		};
		static_assert(sizeof(s_charactergrenadefightpropertiesinternal) == 16, "struct s_charactergrenadefightpropertiesinternal is invalid size");

		struct s_c_character_coversequence_properties_internal
		{
			real shield_start_threshold;
			real shield_end_threshold;
			real danger_start_threshold;
			real danger_end_threshold;
			real minimum_hide_duration;
		};
		static_assert(sizeof(s_c_character_coversequence_properties_internal) == 20, "struct s_c_character_coversequence_properties_internal is invalid size");

		struct s_c_character_covermove_properties_internal
		{
			c_flags<e_covermoveflags, long, k_covermoveflags_count> flags;
			real cover_failed_duration;
		};
		static_assert(sizeof(s_c_character_covermove_properties_internal) == 8, "struct s_c_character_covermove_properties_internal is invalid size");

		struct s_c_character_coverhide_properties_internal
		{
			real minimum_hide_duration;
		};
		static_assert(sizeof(s_c_character_coverhide_properties_internal) == 4, "struct s_c_character_coverhide_properties_internal is invalid size");

		struct s_c_character_longrangeattack_properties_internal
		{
			c_flags<e_longrangeattackflags, long, k_longrangeattackflags_count> flags;
			real potshot_duration;
			real peek_duration;
			real time_between_potshots;
		};
		static_assert(sizeof(s_c_character_longrangeattack_properties_internal) == 16, "struct s_c_character_longrangeattack_properties_internal is invalid size");

		struct s_c_character_hoistattack_properties_internal
		{
			real max_danger_threshold;
			real hoist_attack_chance;
		};
		static_assert(sizeof(s_c_character_hoistattack_properties_internal) == 8, "struct s_c_character_hoistattack_properties_internal is invalid size");

		struct s_c_character_hunkerdown_properties_internal
		{
			real danger_start_threshold;
			real distance_abort_threshold;
			real_fraction shield_health_threshold;
			real_bounds hunker_time;
		};
		static_assert(sizeof(s_c_character_hunkerdown_properties_internal) == 20, "struct s_c_character_hunkerdown_properties_internal is invalid size");

		struct s_c_character_shieldraise_properties_internal
		{
			real danger_threshold;
		};
		static_assert(sizeof(s_c_character_shieldraise_properties_internal) == 4, "struct s_c_character_shieldraise_properties_internal is invalid size");

		struct s_sharedvehiclefightproperties
		{
			real_fraction engage_fraction;
			real max_speed_percent;
		};
		static_assert(sizeof(s_sharedvehiclefightproperties) == 8, "struct s_sharedvehiclefightproperties is invalid size");

		struct s_c_character_vehicleaggressivefight_properties_internal
		{
			s_sharedvehiclefightproperties fight_properties;
			c_flags<e_vehicleboostflags, long, k_vehicleboostflags_count> flags;
			real max_danger_to_boost;
		};
		static_assert(sizeof(s_c_character_vehicleaggressivefight_properties_internal) == 16, "struct s_c_character_vehicleaggressivefight_properties_internal is invalid size");

		struct s_c_character_vehicledefensivefight_properties_internal
		{
			s_sharedvehiclefightproperties fight_properties;
		};
		static_assert(sizeof(s_c_character_vehicledefensivefight_properties_internal) == 8, "struct s_c_character_vehicledefensivefight_properties_internal is invalid size");

		struct s_c_character_engineer_properties_internal
		{
			real death_height;
			real death_rise_time;
			real death_detonation_time;
			real shield_boost_radius_max;
			real shield_boost_period;
			string_id shield_boost_damage_section_name;

			/* Detonation Thresholds */

			real detonation_shield_threshold;
			real detonation_body_vitality;
			real proximity_radius;
			real proximity_detonation_chance;
			c_typed_tag_reference<EQUIPMENT_TAG> proximity_equipment;
		};
		static_assert(sizeof(s_c_character_engineer_properties_internal) == 56, "struct s_c_character_engineer_properties_internal is invalid size");

		struct s_c_character_inspect_properties_internal
		{
			real stop_distance;
			real_bounds inspect_time;
			real_bounds search_range;
		};
		static_assert(sizeof(s_c_character_inspect_properties_internal) == 20, "struct s_c_character_inspect_properties_internal is invalid size");

		struct s_c_character_vehicleentranceexit_properties_internal
		{
			real max_distance_from_actor;
			real minimum_distance_from_player;
			real minimum_distance_from_vehicle;
			real perceived_danger_threshold;

			/* Total Health Percentage */

			real minimum_health_to_enter;
			real health_percentage_to_exit;

			/* Remaining Damage Sections Percentage */

			real threshold_to_enter;
			real threshold_to_exit;
			real chance_to_exit_vehicle;
			real vehicle_exit_impulse_timer;
		};
		static_assert(sizeof(s_c_character_vehicleentranceexit_properties_internal) == 40, "struct s_c_character_vehicleentranceexit_properties_internal is invalid size");

		struct s_characterweaponpreferences
		{
			c_enum<e_characterweaponpreferencestier, char> tier_category;
			char generated_padb31f[3]; // padding
			long weight;
			long multi_tier_multiplier;
		};
		static_assert(sizeof(s_characterweaponpreferences) == 12, "struct s_characterweaponpreferences is invalid size");

		struct s_characterweaponmodeselector
		{
			c_flags<e_characterweaponmodeselectorinitiatorflags, long, k_characterweaponmodeselectorinitiatorflags_count> initiators;
			c_flags<e_characterweaponmodeselectorrequirementflags, long, k_characterweaponmodeselectorrequirementflags_count> required_conditions;
			real cluster_radius;
			long min_cluster_count;
			real_bounds target_range_bounds;
			real_bounds danger_bounds;
			real activation_chance;
			real activation_check_delay;
			real projectile_error;
			real_bounds lifetime;
			long max_burst_count;
			c_enum<e_characterweaponmodeselectortriggerbehavior, char> trigger_behavior;
			char generated_padabe7[3]; // padding
		};
		static_assert(sizeof(s_characterweaponmodeselector) == 60, "struct s_characterweaponmodeselector is invalid size");

		struct s_characterfiringprogram
		{

			/* Precision */

			// custom target_position
			real_bounds tracking;
			real_bounds matching_fraction;
			real_bounds matching_spring_force;
			real_bounds leading;
			// custom value
			// custom aiming_error
			real_bounds error_distance;
			angle_bounds error_angle;
			angle_bounds error_max_angle;
			// custom value
			// custom linear_burst_geo
			c_enum<e_characterfiringprogramlinearburststyle, char> burst_line_style;
			char generated_paddb86[3]; // padding
			angle_bounds burst_line_angle;
			real_bounds burst_origin_radius;
			angle_bounds burst_origin_angle;
			real_bounds burst_return_length_min;
			real_bounds burst_return_length_max;
			angle_bounds burst_return_angle;
			real_bounds burst_maximum_angular_vel;
			angle_bounds burst_maximum_error_angle;
			// custom value

			/* Hostility */

			real_bounds rate_of_fire;
			real_bounds weapon_damage_mod;
			// custom burst_pattern
			real_bounds duration_min;
			real_bounds duration_max;
			real_bounds separation_min;
			real_bounds separation_max;
			// custom value
			// custom burst_noise
			real_bounds amount;
			real_bounds min_period;
			real_bounds max_period;
			// custom value
		};
		static_assert(sizeof(s_characterfiringprogram) == 196, "struct s_characterfiringprogram is invalid size");

		struct s_vehiclevelocitytargeting
		{
			real vehicle_velocity_override_preference;
			real velocity_threshold;
		};
		static_assert(sizeof(s_vehiclevelocitytargeting) == 8, "struct s_vehiclevelocitytargeting is invalid size");

		struct s_characterweaponunittargeting
		{
			c_enum<e_i343modelmodeltargetcategory, char> category;
			char generated_pad0052[3]; // padding
			real preference;

			/* Vehicle Velocity Targeting Prefernces */

			c_typed_tag_block<s_vehiclevelocitytargeting> vehicle_velocity_based_targeting_block;
		};
		static_assert(sizeof(s_characterweaponunittargeting) == 20, "struct s_characterweaponunittargeting is invalid size");

		struct s_characterweaponmodeprefirebeam
		{
			angle initial_error_angle;

			/* Radius Decay */

			// custom radius_decay_function
			s_functiondefinition radius_decay_function;

			/* Beam Spin */

			// custom beam_spin_function
			s_functiondefinition beam_spin_function;
			c_typed_tag_reference<EFFECT_TAG> beam_effect;
			c_typed_tag_reference<AREA_SCREEN_EFFECT_TAG> full_screen_effect;

			/* Marker overrides */

			string_id start_marker;
			string_id fallback_marker;
		};
		static_assert(sizeof(s_characterweaponmodeprefirebeam) == 84, "struct s_characterweaponmodeprefirebeam is invalid size");

		struct s_characterweaponmode
		{
			string_id mode_name;
			c_flags<e_weaponpropertiesflags, long, k_weaponpropertiesflags_count> weapons_flags;

			/* Combat ranges */

			real maximum_firing_range;
			real minimum_firing_range;
			real_bounds normal_combat_range;
			real bombardment_range;
			real max_special_target_distance;
			real max_extreme_target_distance;
			c_enum<e_combatrangeignorelowerboundoption, char> lower_bound_option;
			char generated_pad6ff4[3]; // padding

			/* Ballistic Firing */

			real_bounds ballistic_firing_bounds;
			real_bounds ballistic_fraction_bounds;

			/* Use Preferences */

			real_vector3d favored_ranges;
			real_vector3d range_ratings;
			real anti_vehicle_rating_;
			real scariness_threshold;

			/* Behavior */

			real_bounds first_burst_delay_time;
			real death_fire_wildly_chance;
			real death_fire_wildly_time;
			real_fraction heat_vent_min_percent;
			real_fraction ammo_reload_min_percent;
			real_fraction reload_chance_if_not_empty;
			real heat_vent_cooldown;
			real_vector3d custom_stand_gun_offset;
			real_vector3d custom_crouch_gun_offset;
			long blocked_shot_count;
			real max_pre_fire_time_normal;
			real max_pre_fire_time_heroic;
			real max_pre_fire_time_legendary;
			c_typed_tag_block<s_characterweaponmodeselector> selection_properties_block;
			c_enum<e_i343aitokensystemlevel, char> threat_level;
			char generated_pad89d5[3]; // padding
			real effectiveness_token_close_player_distance;
			c_typed_tag_block<s_characterfiringprogram> firing_program_block;

			/* Unit Target Preference */

			c_typed_tag_block<s_characterweaponunittargeting> unit_target_preference_block;
			c_typed_tag_block<s_characterweaponmodeprefirebeam> prefire_beam_block;
		};
		static_assert(sizeof(s_characterweaponmode) == 216, "struct s_characterweaponmode is invalid size");

		struct s_characterprototypeweaponpropertiesinternal
		{
			c_typed_tag_reference<WEAPON_TAG> weapon;

			/* Weapon drop when killed */

			real_bounds drop_weapon_loaded;
			short_bounds drop_weapon_ammo;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> weapon_melee_damage;

			/* Accuracy */

			real_bounds normal_accuracy_bounds;
			real normal_accuracy_time;
			real_bounds heroic_accuracy_bounds;
			real heroic_accuracy_time;
			real_bounds legendary_accuracy_bounds;
			real legendary_accuracy_time;
			c_typed_tag_block<s_characterweaponpreferences> weapon_preferences_block;
			c_typed_tag_block<s_characterweaponmode> weapon_modes_block;
		};
		static_assert(sizeof(s_characterprototypeweaponpropertiesinternal) == 104, "struct s_characterprototypeweaponpropertiesinternal is invalid size");

		struct s_prototypecharacterstyle
		{
			string_id style_name;
			real precision;
			real hostility;
			real_bounds precision_range;
			real_bounds hostility_range;
		};
		static_assert(sizeof(s_prototypecharacterstyle) == 28, "struct s_prototypecharacterstyle is invalid size");

		struct s_c_character_grenade_properties_internal
		{
			c_flags<e_charactergrenadesflags, long, k_charactergrenadesflags_count> grenades_flags;
			c_enum<e_unitgrenadetype, char> grenade_type;
			char generated_padcce0[1]; // padding
			c_enum<e_grenadetrajectorytypes, short> trajectory_type;
			short minimum_enemy_count;
			char generated_pade6c1[2]; // padding
			real enemy_radius;
			// custom throw_error
			angle throw_error_easy;
			angle throw_error_normal;
			angle throw_error_heroic;
			angle throw_error_legendary;
			// custom value
			// custom damage_modifier
			real damage_modifier_easy;
			real damage_modifier_normal;
			real damage_modifier_heroic;
			real damage_modifier_legendary;
			// custom value
			real grenade_ideal_velocity;
			real grenade_velocity;
			real_bounds grenade_ranges;
			real collateral_damage_radius;
			real_fraction grenade_chance;
			real active_shield_modifier;
			real grenade_throw_delay;
			real global_grenade_delay;
			real_fraction grenade_uncover_chance;
			real_fraction anti_vehicle_grenade_chance;

			/* Grenade drop when killed */

			short_bounds grenade_count;
			real dont_drop_grenades_chance;
		};
		static_assert(sizeof(s_c_character_grenade_properties_internal) == 100, "struct s_c_character_grenade_properties_internal is invalid size");

		struct s_vehiclestrafingproperties
		{
			real strafe_min_distance;
			real strafe_abort_distance;
			real defensive_strafe_abort_distance;
		};
		static_assert(sizeof(s_vehiclestrafingproperties) == 12, "struct s_vehiclestrafingproperties is invalid size");

		struct s_vehicleflyingholdingpatternproperties
		{
			real holding_pattern_elevation;
			real_fraction holding_pattern_speed_percentage;
			real holding_pattern_radius;
			real_fraction max_turn_angle_percentage;
		};
		static_assert(sizeof(s_vehicleflyingholdingpatternproperties) == 16, "struct s_vehicleflyingholdingpatternproperties is invalid size");

		struct s_vehicleflyingpreengageproperties
		{
			real_bounds pre_engage_time;
			real pre_engage_elevation;
			real pre_engage_radius;
		};
		static_assert(sizeof(s_vehicleflyingpreengageproperties) == 16, "struct s_vehicleflyingpreengageproperties is invalid size");

		struct s_vehicleflyingsuppressedproperties
		{
			real_bounds suppressed_time;
			real suppressed_damage_threshold;
			real suppressed_retreat_distance;
			real suppressed_elevation;
			real suppressed_radius;
		};
		static_assert(sizeof(s_vehicleflyingsuppressedproperties) == 24, "struct s_vehicleflyingsuppressedproperties is invalid size");

		struct s_vehicleflyingaggressiveengageproperties
		{
			short_bounds aggressive_loops;
		};
		static_assert(sizeof(s_vehicleflyingaggressiveengageproperties) == 4, "struct s_vehicleflyingaggressiveengageproperties is invalid size");

		struct s_vehicleflyingdefensiveengageproperties
		{
			real_bounds defensive_time;
		};
		static_assert(sizeof(s_vehicleflyingdefensiveengageproperties) == 8, "struct s_vehicleflyingdefensiveengageproperties is invalid size");

		struct s_vehicleflyingfallbackproperties
		{
			real_bounds combat_elevation;
			real fallback_minimum_distance;
			real flyby_distance;
		};
		static_assert(sizeof(s_vehicleflyingfallbackproperties) == 16, "struct s_vehicleflyingfallbackproperties is invalid size");

		struct s_c_character_vehicle_properties_internal
		{
			c_typed_tag_reference<UNIT_TAG> unit;
			c_typed_tag_reference<STYLE_TAG> style;
			c_typed_tag_reference<BEHAVIORTREE_TAG> behavior_tree;
			c_typed_tag_reference<BEHAVIORTREE_TAG> nondriver_behavior_tree;

			/* Flying Avoidance */

			real lookahead_time;
			real roll_change_magnitude;
			real roll_decay_multiplier;
			real throttle_grace_period;
			real minimum_throttle;

			/* Vehicle flags */

			c_flags<e_charactervehicleflags, long, k_charactervehicleflags_count> vehicle_flags$2;

			/* Hover Perturbation New */

			real hover_deceleration_distance;
			real hover_offset_distance;

			/* Hover Perturbation Fallback */

			real hover_allow_perturbation_speed;
			real hover_random_x_axis_period;
			real hover_random_y_axis_period;
			real hover_random_z_axis_period;
			real hover_random_radius;
			real hover_anchor_approach_speed_limit;
			real_bounds hover_anchor_throttle_scale_distance;
			real_bounds hover_anchor_xy_throttle_scale;
			real_bounds hover_anchor_z_throttle_scale;
			real hover_throttle_min_z;

			/* Pathfinding */

			real ai_pathfinding_radius;
			real ai_avoidance_radius;
			real ai_destination_radius;
			real ai_deceleration_distance;
			real roughly_the_time_it_would_take_this_vehicle_to_stop_default_is_2_seconds;

			/* Turning */

			real ai_turning_radius;

			/* Steering */

			angle ai_banshee_steering_maximum;
			real ai_max_steering_angle;
			real ai_max_steering_delta;
			real ai_oversteering_scale;
			real ai_sideslip_distance_combat;
			real ai_sideslip_distance_non_combat;
			real ai_avoidance_distance;
			real ai_min_urgency;
			angle destination_behind_angle;
			real skid_scale;
			angle aiming_velocity_maximum;
			angle aiming_acceleration_maximum;

			/* Throttle */

			real ai_throttle_maximum;
			real ai_reverse_throttle_maximum;
			real ai_goal_min_throttle_scale;
			real ai_turn_min_throttle_scale;
			real ai_direction_min_throttle_scale;
			real ai_skid_min_throttle_scale;
			angle skid_attentuation_max_angle;
			real ai_acceleration_scale;
			real ai_throttle_blend;
			real theoretical_max_speed;
			real error_scale;
			real throttle_ramp_step;

			/* Speed */

			real target_speed;

			/* Boost For Locomotion - Directional Ground Vehicles */

			real_fraction ai_boost_forward_facing_angle;
			real ai_min_throttle_to_boost;

			/* Combat */

			angle ai_allowable_aim_deviation_angle;
			real melee_cooldown;

			/* Behavior */

			real ai_charge_tight_angle_distance;
			real ai_charge_tight_angle;
			real ai_charge_repeat_timeout;
			real ai_charge_look_ahead_time;
			real ai_charge_consider_distance;
			real ai_charge_abort_distance;
			real ai_charge_abort_close_distance;
			real ai_charge_max_out_of_area_distance;
			real vehicle_ram_timeout;
			real ram_paralysis_time;
			real ai_cover_damage_threshold;
			real ai_cover_shield_damage_threshold;
			real ai_cover_min_distance;
			real ai_cover_time;
			real ai_cover_min_boost_distance;
			real turtling_recent_damage_threshold;
			real turtling_min_time;
			real turtling_timeout;
			c_typed_tag_block<s_vehiclestrafingproperties> vehicle_strafing_properties_block;
			c_typed_tag_block<s_vehicleflyingholdingpatternproperties> vehicle_flying_holding_pattern_properties_block;
			c_typed_tag_block<s_vehicleflyingpreengageproperties> vehicle_flying_preengage_properties_block;
			c_typed_tag_block<s_vehicleflyingsuppressedproperties> vehicle_flying_suppressed_properties_block;
			c_typed_tag_block<s_vehicleflyingaggressiveengageproperties> vehicle_flying_aggressive_engage_properties_block;
			c_typed_tag_block<s_vehicleflyingdefensiveengageproperties> vehicle_flying_defensive_engage_properties_block;
			c_typed_tag_block<s_vehicleflyingfallbackproperties> vehicle_flying_fallback_properties_block;
			c_enum<e_objectaisize, short> obstacle_ignore_size;
			char generated_pad354a[2]; // padding
		};
		static_assert(sizeof(s_c_character_vehicle_properties_internal) == 448, "struct s_c_character_vehicle_properties_internal is invalid size");

		struct s_c_character_flying_movement_properties_internal
		{
			c_typed_tag_reference<UNIT_TAG> vehicle;
			// custom default_values

			/* Vector Weights */

			real facing;
			real perturbation;
			real volume_avoidance;
			real volume_perturbation;
			real volume_cover;
			real flocking;
			real target;
			real target_tail;

			/* Area Selection */

			real_bounds area_reselect_time;

			/* Idle */

			real_bounds idle_time;

			/* Cover */

			real_bounds unsafe_cover_reselect_time;
			real_bounds cover_heading_reselect_time;
			real max_cover_search_distance;
			real max_cover_impulse_distance;
			real_bounds spline_cooldown_time;

			/* Volume Avoidance */

			real volume_influence_distance;
			real volume_perturbation_phase;
			real volume_bounding_distance;

			/* Approach */

			real volume_approach_distance;
			real volume_break_off_distance;
			real minimum_approach_distance;
			real_bounds collision_avoidance_range;

			/* Evasion */

			real_bounds evade_time;
			real_fraction evade_body_damage_threshold;
			real_fraction evade_shield_damage_threshold;
			real bogey_retreat_time;
			real bogey_retreat_distance;

			/* Flocking */

			real_bounds flock_radius;
			angle forward_follow_angle;
			angle behind_follow_angle;

			/* Tailing */

			real min_tailing_time;
			real_bounds tailing_radius;
			angle tailing_cone_angle;

			/* Strafing */

			real volume_strafe_distance;
			real strafe_min_distance;
			real strafe_above_distance;
			real strafe_abort_distance;
			real strafe_timeout;

			/* Attitude Control */

			angle max_descend_angle;
			angle max_ascend_angle;

			/* Shooting */

			angle shooting_cone_angle;

			/* Evasive Maneuvers */

			real_fraction missile_dodge_change;
			real ideal_missile_dodge_distance;
			real_bounds dodge_timeout;
		};
		static_assert(sizeof(s_c_character_flying_movement_properties_internal) == 232, "struct s_c_character_flying_movement_properties_internal is invalid size");

		struct s_characterequipmentuseconditions
		{

			/* Use Conditions */

			c_enum<e_equipmentusewhen, short> use_when;
			char generated_padd2ce[2]; // padding
			real health_shield_use_threshold;
		};
		static_assert(sizeof(s_characterequipmentuseconditions) == 8, "struct s_characterequipmentuseconditions is invalid size");

		struct s_characterequipmentusage
		{

			/* Equipment Use */

			c_typed_tag_block<s_characterequipmentuseconditions> use_conditions_block;
			c_enum<e_equipmentusehow, short> use_how;
			char generated_padd6c8[2]; // padding

			/* Skip Fraction */

			real easy_normal;
			real legendary;
			real chance_per_second;
		};
		static_assert(sizeof(s_characterequipmentusage) == 28, "struct s_characterequipmentusage is invalid size");

		struct s_character_equipment_definition
		{

			/* Equipment */

			c_typed_tag_reference<EQUIPMENT_TAG> equipment$2;
			c_flags<e_characterequipmentflags, long, k_characterequipmentflags_count> flags;
			real relative_drop_chance;
			string_id animation;
			c_typed_tag_block<s_characterequipmentusage> equipment_use_block;
		};
		static_assert(sizeof(s_character_equipment_definition) == 40, "struct s_character_equipment_definition is invalid size");

		struct s_s_character_stimuli_response_definition
		{

			/* Stimulus Response */

			string_id stimulus_name;
			c_typed_tag_reference<CHARACTER_TAG> override_character;
			char resolved_stimulus[8]; // skip
		};
		static_assert(sizeof(s_s_character_stimuli_response_definition) == 28, "struct s_s_character_stimuli_response_definition is invalid size");

		struct s_s_campaign_metagame_bucket
		{
			c_flags<e_c_campaign_metagame_bucket_flags, char, k_c_campaign_metagame_bucket_flags_count> flags;
			c_enum<e_c_campaign_metagame_bucket_type, char> type;
			c_enum<e_c_campaign_metagame_bucket_class, char> _class;
			char generated_pad6695[1]; // padding
			short point_count;
		};
		static_assert(sizeof(s_s_campaign_metagame_bucket) == 6, "struct s_s_campaign_metagame_bucket is invalid size");

		struct s_character_activity_objects
		{
			string_id activity_name;
			c_typed_tag_reference<CRATE_TAG> crate;
			// custom value
			string_id crate_marker_name;
			// custom value
			string_id unit_marker_name;
		};
		static_assert(sizeof(s_character_activity_objects) == 28, "struct s_character_activity_objects is invalid size");

		struct s_c_character_pain_screen_properties_internal
		{

			/* Pain Reactions */

			real pain_screen_duration;
			real pain_screen_region_fade_out_duration;
			real_fraction pain_screen_region_fade_out_weight_threshold;
			angle pain_screen_angle_tolerance;
			angle pain_screen_angle_randomness;

			/* Defensive Reactions */

			real defensive_screen_duration;
			real_fraction defensive_screen_scrub_fallback_fraction;
		};
		static_assert(sizeof(s_c_character_pain_screen_properties_internal) == 28, "struct s_c_character_pain_screen_properties_internal is invalid size");

		struct s_charactermeleeanimationscalingpropertiesinternal
		{

			/* Easy Scaling */

			real easy_windup_scaling;
			real easy_recovery_scaling;

			/* Normal Scaling */

			real normal_windup_scaling;
			real normal_recovery_scaling;

			/* Heroic Scaling */

			real heroic_windup_scaling;
			real heroic_recovery_scaling;

			/* Legendary Scaling */

			real legendary_windup_scaling;
			real legendary_recovery_scaling;
		};
		static_assert(sizeof(s_charactermeleeanimationscalingpropertiesinternal) == 32, "struct s_charactermeleeanimationscalingpropertiesinternal is invalid size");

		struct s_c_character_closequartersdefenseblast_properties_internal
		{
			// custom close_quarters_defense_blast_parameters
			// custom activation_chance
			real_fraction activation_chance_easy;
			real_fraction activation_chance_normal;
			real_fraction activation_chance_heroic;
			real_fraction activation_chance_legendary;
			// custom value
			real cooldown;
			real_bounds attack_range;
			string_id marker;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> damage_effect;
			c_typed_tag_reference<EFFECT_TAG> effect;
			// custom value
		};
		static_assert(sizeof(s_c_character_closequartersdefenseblast_properties_internal) == 64, "struct s_c_character_closequartersdefenseblast_properties_internal is invalid size");

		struct s_c_character_bishop_properties_internal
		{

			/* Repair */

			c_typed_tag_reference<EFFECT_TAG> repair_beam_effect;

			/* Protect Allies */

			real min_follow_distance_;

			/* Resurrect Allies */

			real resurrection_initiation_delay_time_seconds_;
			real resurrection_charge_up_time_seconds_;
			real resurrection_give_up_time_seconds_;
			c_typed_tag_reference<EFFECT_TAG> resurrection_ground_effect_;
			c_typed_tag_reference<EFFECT_TAG> res_area_scan_start_effect_;
			c_typed_tag_reference<EFFECT_TAG> res_area_scan_success_effect_;
			c_typed_tag_reference<EFFECT_TAG> res_area_scan_failure_effect_;

			/* Shard Spawning */

			c_typed_tag_reference<EFFECT_TAG> shard_spawn_ground_effect_;
			real shard_creation_delay_seconds_;
			real_bounds spawn_delay_seconds_;

			/* Healing Allies */

			real healing_time;
		};
		static_assert(sizeof(s_c_character_bishop_properties_internal) == 128, "struct s_c_character_bishop_properties_internal is invalid size");

		struct s_characterhealingpropertiesinternal
		{
			real healing_delay_time;
			real healing_standby_time;
		};
		static_assert(sizeof(s_characterhealingpropertiesinternal) == 8, "struct s_characterhealingpropertiesinternal is invalid size");

		struct s_c_character_packmaster_properties_internal
		{
			c_typed_tag_reference<CHARACTER_TAG> pack_character_ancestor_;
			real command_radius;
			long group_fire_min_count;
			long group_fire_max_count;
			// custom group_fire_chance
			real_fraction group_fire_chance_easy;
			real_fraction group_fire_chance_normal;
			real_fraction group_fire_chance_heroic;
			real_fraction group_fire_chance_legendary;
			// custom value
			real group_fire_burst_time;
			real group_fire_cooldown_time;
			long group_fire_burst_count;
			real group_fire_burst_delay;
			real group_fire_target_range;
			real lion_charge_max_range;
			real lion_charge_chance;
			real lion_charge_melee_range;
			real lion_charge_fire_duration;
			real lion_charge_throttle_override;
			real lion_charge_abort_range;
			real pack_charge_distance;
			real pack_charge_cooldown;
		};
		static_assert(sizeof(s_c_character_packmaster_properties_internal) == 96, "struct s_c_character_packmaster_properties_internal is invalid size");

		struct s_c_character_dynamic_task_properties_internal
		{
			c_flags<e_i343aiopportunityrequirementflags, long, k_i343aiopportunityrequirementflags_count> agent_filter_flags_;
			c_flags<e_taskgenerationflags, long, k_taskgenerationflags_count> task_generation_flags_;
			real_fraction protect_request_shield_level_;
			real_fraction protect_request_body_level_;
			real_fraction resurrection_req_chance_;
			real shield_task_priority_;
			real_bounds protect_task_priorities_min_health___max_health_;
			real resurrection_task_priority_;
			real shield_during_resurrection_task_priority_;
			c_typed_tag_reference<CRATE_TAG> shield_crate_override_;
			real heal_request_shield_level_;
			real heal_request_body_level_;
		};
		static_assert(sizeof(s_c_character_dynamic_task_properties_internal) == 64, "struct s_c_character_dynamic_task_properties_internal is invalid size");

		struct s_slowadvance
		{

			/* Slow Advance */

			real slow_range;
			string_id slow_throttle_style;
			real exit_range;
		};
		static_assert(sizeof(s_slowadvance) == 12, "struct s_slowadvance is invalid size");

		struct s_genericadvanceattack
		{
			c_flags<e_genericadvanceattackadvanceattackflags, long, k_genericadvanceattackadvanceattackflags_count> flags;
			real_bounds range;
			real max_scariness;
			c_enum<e_i343aitokensystemlevel, char> threat_level;
			char generated_pad8a75[3]; // padding
			// custom activation_chance
			real_fraction activation_chance_easy;
			real_fraction activation_chance_normal;
			real_fraction activation_chance_heroic;
			real_fraction activation_chance_legendary;
			// custom value
			real attack_timeout;
			real melee_range;
			real_fraction shield_down_threshold;
			real abort_danger_threshold;
			real abort_distance;
			real outside_area_range;
			real berserk_abort_distance;
			real cooldown;
			real_fraction tell_animation_chance;
			real tell_animation_cooldown;
			string_id throttle_style;
			s_slowadvance slow_advance;
		};
		static_assert(sizeof(s_genericadvanceattack) == 92, "struct s_genericadvanceattack is invalid size");

		struct s_meleeattackdefinition
		{
			c_flags<e_meleeattackdefinitiondirectionflags, long, k_meleeattackdefinitiondirectionflags_count> direction_flags;
			string_id animation_name;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> damage_override;
		};
		static_assert(sizeof(s_meleeattackdefinition) == 24, "struct s_meleeattackdefinition is invalid size");

		struct s_meleecombodefinition
		{
			c_flags<e_meleecombodefinitionflags, long, k_meleecombodefinitionflags_count> combo_flags;
			real weight_modifier;
			c_typed_tag_block<s_meleeattackdefinition> attacks_block;
		};
		static_assert(sizeof(s_meleecombodefinition) == 20, "struct s_meleecombodefinition is invalid size");

		struct s_c_character_rushattack_properties_internal
		{

			/* Rush Attack */

			s_genericadvanceattack generic_advance_attack;

			/* Rush specific settings */

			c_flags<e_c_character_rushattack_properties_internalrushflags, long, k_c_character_rushattack_properties_internalrushflags_count> rush_flags;
			real leader_abandoned_chance;
			real_fraction berserk_chance;
			real berserk_recheck_cooldown;
			real min_abort_time;
			real min_abort_dist_travelled;
			real_fraction zig_zag_chance;
			angle zig_zag_angle;
			real zig_zag_period;
			angle tackle_angle;
			real tackle_wait;
			c_typed_tag_block<s_meleecombodefinition> combo_definitions_block;
			string_id taunt_animation_name;
		};
		static_assert(sizeof(s_c_character_rushattack_properties_internal) == 152, "struct s_c_character_rushattack_properties_internal is invalid size");

		struct s_c_character_leapattack_properties_internal
		{

			/* Leap Attack */

			s_genericadvanceattack generic_advance_attack;

			/* Leap specific settings */

			c_flags<e_c_character_leapattack_properties_internalleapflags, long, k_c_character_leapattack_properties_internalleapflags_count> leap_flags;
			real ideal_leap_speed;
			real max_leap_speed;
			real_fraction ballistic_fraction;
			real prediction_percent;
			real shortfall;
			real swoop_accel_rate;
			real swoop_accel_time;
			angle swoop_max_deviation;
		};
		static_assert(sizeof(s_c_character_leapattack_properties_internal) == 128, "struct s_c_character_leapattack_properties_internal is invalid size");

		struct s_c_character_teleportattack_properties_internal
		{

			/* Teleport attack */

			s_genericadvanceattack generic_advance_attack;

			/* Teleport specific settings */

			real destination_distance;
			real side_step_distance;
			real forward_distance;
			real tracking_distance;
			real runup_time;
			real position_pause;
			real escape_cooldown;
			real lock_distance;
			c_typed_tag_reference<EFFECT_TAG> launch_effect;
			c_typed_tag_reference<EFFECT_TAG> land_effect;
		};
		static_assert(sizeof(s_c_character_teleportattack_properties_internal) == 156, "struct s_c_character_teleportattack_properties_internal is invalid size");

		struct s_characterjinkandshootpropertiesinternal
		{

			/* Jink and Shoot */

			real_bounds start_distance;
			real start_max_offset_angle;
			real min_start_teleport_distance;
			long number_of_intermediate_teleports;
			real max_offset_angle;
			real_bounds side_step_distance;
			real_bounds forward_distance;
			c_typed_tag_reference<EFFECT_TAG> launch_effect;
			c_typed_tag_reference<EFFECT_TAG> land_effect;
			string_id effect_marker;
			c_typed_tag_reference<WEAPON_TAG> jink_and_shoot_weapon;
		};
		static_assert(sizeof(s_characterjinkandshootpropertiesinternal) == 92, "struct s_characterjinkandshootpropertiesinternal is invalid size");

		struct s_characterteleportandtacklepropertiesinternal
		{

			/* Teleport and Tackle */

			real_bounds destination_distance;
			real max_offset_angle;
			real duration_to_align;
			real min_teleport_distance;
			c_typed_tag_reference<EFFECT_TAG> launch_effect;
			c_typed_tag_reference<EFFECT_TAG> land_effect;
			string_id effect_marker;
			c_typed_tag_reference<WEAPON_TAG> teleport_and_tackle_weapon;
		};
		static_assert(sizeof(s_characterteleportandtacklepropertiesinternal) == 72, "struct s_characterteleportandtacklepropertiesinternal is invalid size");

		struct s_characterteleportandtauntpropertiesinternal
		{

			/* Teleport and Taunt Behavior */

			string_id custom_animation_name;
			real taunt_frequency;
			real taunt_chance;
			real_bounds destination_distance;
			real max_offset_angle;
			real min_teleport_distance;
			c_typed_tag_reference<EFFECT_TAG> launch_effect;
			c_typed_tag_reference<EFFECT_TAG> land_effect;
			string_id effect_marker;
		};
		static_assert(sizeof(s_characterteleportandtauntpropertiesinternal) == 64, "struct s_characterteleportandtauntpropertiesinternal is invalid size");

		struct s_c_character_desperationrush_properties_internal
		{
			c_flags<e_c_character_desperationrush_properties_internalflags, long, k_c_character_desperationrush_properties_internalflags_count> properties;
			real range;
		};
		static_assert(sizeof(s_c_character_desperationrush_properties_internal) == 8, "struct s_c_character_desperationrush_properties_internal is invalid size");

		struct s_characterproximitymeleepropertiesinternal
		{

			/* Proximity Melee Impulse */

			real range;
			real cooldown;
			real outside_area_range;
		};
		static_assert(sizeof(s_characterproximitymeleepropertiesinternal) == 12, "struct s_characterproximitymeleepropertiesinternal is invalid size");

		struct s_characterdivebombkamikazepropertiesinternal
		{
			real_fraction ally_target_chance;
			real_fraction enemy_target_chance;
			real_bounds travel_distance;
			real travel_time_before_exploding;
			c_typed_tag_reference<PROJECTILE_TAG> impact_detonation_projectile;
			real_bounds target_error_range;
			c_flags<e_divebombkamikazeflags, char, k_divebombkamikazeflags_count> behavior_flags;
			char generated_pad94ce[3]; // padding
			real_fraction kamikaze_below_health_percentage;
			real_fraction chance_to_kamikaze_at_low_health_per_second;
			real_fraction chance_to_kamikaze_when_last_man_per_second;
			real a_pause_between_kamikaze_anim_and_dive_bomb_actiondefault_2_seconds;
		};
		static_assert(sizeof(s_characterdivebombkamikazepropertiesinternal) == 64, "struct s_characterdivebombkamikazepropertiesinternal is invalid size");

		struct s_characterpostcombatpropertiesinternal
		{
			real_fraction shoot_corpse_chance;
			real_bounds postcombat_phase_1_time;
		};
		static_assert(sizeof(s_characterpostcombatpropertiesinternal) == 12, "struct s_characterpostcombatpropertiesinternal is invalid size");

		struct s_c_character_pack_stalk_properties_internal
		{
			real min_wander_distance_;
			real outside_area_border_;
			real_bounds position_update_delay_;
			real_fraction throttle_in_cover_;
		};
		static_assert(sizeof(s_c_character_pack_stalk_properties_internal) == 20, "struct s_c_character_pack_stalk_properties_internal is invalid size");

		struct s_c_character_fight_circle_properties_internal
		{
			real_bounds strafe_time_;
			real_bounds extra_firing_time_;
			real target_patience_time_;
			angle max_angle_from_threataxis_;
			angle nearby_inner_angle_;
			angle nearby_outer_angle_;
			string_id strafe_throttle_style_;
			string_id move_throttle_style_;
		};
		static_assert(sizeof(s_c_character_fight_circle_properties_internal) == 40, "struct s_c_character_fight_circle_properties_internal is invalid size");

		struct s_c_character_hamstring_charge_properties_internal
		{
			angle flank_angle_;
			real flank_distance_;
			real outer_engage_distance_;
			real hamstring_delay_;
			real initiate_chance_;
			real max_rush_time_;
			real melee_attack_time_min_;
			real melee_attack_time_max_;
			real max_charge_range;
		};
		static_assert(sizeof(s_c_character_hamstring_charge_properties_internal) == 36, "struct s_c_character_hamstring_charge_properties_internal is invalid size");

		struct s_c_character_forerunner_properties_internal
		{
			c_flags<e_forerunnerflags, long, k_forerunnerflags_count> forerunner_flags;
			real order_minion_charge_chance_;
			real order_minion_charge_radius_;
			real minion_charge_min_time_;
			real minion_charge_max_time_;
			real_bounds phase_to_position_distance_bounds_;
			real_bounds phase_to_position_probability_range_;
		};
		static_assert(sizeof(s_c_character_forerunner_properties_internal) == 36, "struct s_c_character_forerunner_properties_internal is invalid size");

		struct s_c_character_gravity_jump_properties_internal
		{
			// custom activation_chance
			real_fraction activation_chance_easy;
			real_fraction activation_chance_normal;
			real_fraction activation_chance_heroic;
			real_fraction activation_chance_legendary;
			// custom value
			real float_time_;
			real float_gravity_scale;
			// custom descent_gravity_scale_function
			s_functiondefinition descendgravityscalefunction;
			real slow_descend_time_;
			real jump_target_height_;
			real cooldown_;
			real trigger_distance_;
		};
		static_assert(sizeof(s_c_character_gravity_jump_properties_internal) == 60, "struct s_c_character_gravity_jump_properties_internal is invalid size");

		struct s_c_character_coop_modifier_properties_internal
		{
			real body_vitality_scale_for_2_3_players;
			real body_vitality_scale_for_4_players;
			real shield_vitality_scale_for_2_3_players;
			real shield_vitality_scale_for_4_players;
		};
		static_assert(sizeof(s_c_character_coop_modifier_properties_internal) == 16, "struct s_c_character_coop_modifier_properties_internal is invalid size");

		struct s_charactermultitargettrackedattackpropertiesinternal
		{
			// custom activation_chance
			real_fraction activation_chance_easy;
			real_fraction activation_chance_normal;
			real_fraction activation_chance_heroic;
			real_fraction activation_chance_legendary;
			// custom value
			angle targeting_angle;
			real_bounds activation_range;
			byte min_targets_in_range;
			byte bursts;
			c_enum<e_i343weapontriggerslot, char> trigger;
			char generated_pade74f[1]; // padding
			real cooldown;
		};
		static_assert(sizeof(s_charactermultitargettrackedattackpropertiesinternal) == 36, "struct s_charactermultitargettrackedattackpropertiesinternal is invalid size");

		struct s_dropobject
		{
			real_fraction easy_normal_drop_chance;
			real_fraction heroic_drop_chance;
			real_fraction legendary_drop_chance;
			c_typed_tag_reference<OBJECT_TAG> drop_object;
		};
		static_assert(sizeof(s_dropobject) == 28, "struct s_dropobject is invalid size");

		struct s_c_character_drop_objects_properties_internal
		{
			long number_of_rolls;
			real min_item_launch_velocity;
			real max_item_launch_velocity;
			real_fraction max_trajectory_radius;
			c_typed_tag_block<s_dropobject> drop_objects_block;
		};
		static_assert(sizeof(s_c_character_drop_objects_properties_internal) == 28, "struct s_c_character_drop_objects_properties_internal is invalid size");

		struct s_thresholdscript
		{

			/* Scripted Thresholds */

			c_flags<e_thresholdscriptthresholdscriptflags, long, k_thresholdscriptthresholdscriptflags_count> flags;
			c_enum<e_thresholdscriptattributetype, short> tracked_attribute;
			c_enum<e_thresholdscriptcomparisontype, short> trigger_when;
			real threshold_value;
			real recheck_buffer;
			real recheck_cooldown;
			c_static_string<256> function;
		};
		static_assert(sizeof(s_thresholdscript) == 276, "struct s_thresholdscript is invalid size");

		struct s_c_character_customscript_properties_internal
		{
			c_typed_tag_block<s_thresholdscript> scripted_threshold_block;
		};
		static_assert(sizeof(s_c_character_customscript_properties_internal) == 12, "struct s_c_character_customscript_properties_internal is invalid size");

		struct s_character_definition
		{
			s_anytag_struct_definition anytag;
			c_flags<e_characterflags, long, k_characterflags_count> character_flags;
			c_typed_tag_reference<CHARACTER_TAG> parent_character;
			c_typed_tag_reference<UNIT_TAG> unit;
			c_typed_tag_reference<CREATURE_TAG> creature;
			c_typed_tag_reference<STYLE_TAG> style;
			c_typed_tag_reference<CHARACTER_TAG> major_character;
			c_typed_tag_reference<CHARACTER_TAG> mythic_skull_character;
			c_typed_tag_block<s_character_variant> variants_block;
			c_typed_tag_block<s_c_character_voice_properties_internal> voice_block;
			c_typed_tag_block<s_c_character_development_status_properties_internal> development_status_block;
			c_typed_tag_block<s_c_character_general_properties_internal> general_properties_block;
			c_typed_tag_block<s_c_character_proto_spawn_properties_internal> proto_spawn_properties_block;
			c_typed_tag_block<s_c_character_interact_properties_internal> interact_properties_block;
			c_typed_tag_block<s_c_character_emotions_properties_internal> emotion_properties_block;
			c_typed_tag_block<s_c_character_vitality_properties_internal> vitality_properties_block;
			c_typed_tag_block<s_c_character_placement_properties_internal> placement_properties_block;
			c_typed_tag_block<s_c_character_base_perception_properties_internal> base_perception_properties_block;
			c_typed_tag_block<s_c_character_perception_properties_internal> perception_properties_block;
			c_typed_tag_block<s_c_character_target_properties_internal> target_properties_block;
			c_typed_tag_block<s_c_character_look_properties_internal> look_properties_block;
			c_typed_tag_block<s_c_character_hopping_properties_internal> hopping_properties_block;
			c_typed_tag_block<s_c_character_warp_properties_internal> warp_properties_block;
			c_typed_tag_block<s_c_character_movement_properties_internal> movement_properties_block;
			c_typed_tag_block<s_c_character_aimingfacing_properties_internal> aiming_facing_properties_block;
			c_typed_tag_block<s_c_character_deceleratedturns_properties_internal> decelerated_turns_properties_block;
			c_typed_tag_block<s_c_character_locomotionoverrides_properties_internal> locomotion_overrides_block;
			c_typed_tag_block<s_c_character_movementtweak_properties_internal> movement_tweak_properties_block;
			c_typed_tag_block<s_c_character_throttle_style_properties_internal> throttle_styles_block;
			c_typed_tag_block<s_character_movement_set> movement_sets_block;
			c_typed_tag_block<s_c_character_flocking_properties_internal> flocking_properties_block;
			c_typed_tag_block<s_c_character_swarm_properties_internal> swarm_properties_block;
			c_typed_tag_block<s_c_character_ready_properties_internal> ready_properties_block;
			c_typed_tag_block<s_c_character_engage_properties_internal> engage_properties_block;
			c_typed_tag_block<s_c_character_berserk_properties_internal> berserk_properties_block;
			c_typed_tag_block<s_c_character_weaponpickup_properties_internal> weapon_pickup_properties_block;

			/* Danger Values */

			c_typed_tag_block<s_c_character_evasion_properties_internal> evasion_properties_block;
			c_typed_tag_block<s_c_character_dodge_properties_internal> dodge_properties_block;
			c_typed_tag_block<s_characterrunawayfromvehiclepropertiesinternal> run_away_from_vehicle_properties_block;
			c_typed_tag_block<s_c_character_cover_properties_internal> cover_properties_block;
			c_typed_tag_block<s_c_character_retreat_properties_internal> retreat_properties_block;
			c_typed_tag_block<s_c_character_search_properties_internal> search_properties_block;
			c_typed_tag_block<s_c_character_presearch_properties_internal> pre_search_properties_block;
			c_typed_tag_block<s_characterrecognizingpropertiesinternal> recognizing_properties_block;
			c_typed_tag_block<s_c_character_idle_properties_internal> idle_properties_block;
			c_typed_tag_block<s_c_character_precombat_properties_internal> precombat_properties_block;
			c_typed_tag_block<s_c_character_vocalization_properties_internal> vocalization_properties_block;
			c_typed_tag_block<s_c_character_boarding_properties_internal> boarding_properties_block;
			c_typed_tag_block<s_c_character_kungfu_properties_internal> kungfu_properties_block;
			c_typed_tag_block<s_c_character_bunker_properties_internal> bunker_properties_block;
			c_typed_tag_block<s_c_character_shield_wall_properties_internal> shield_wall_properties_block;
			c_typed_tag_block<s_c_character_firing_wall_properties_internal> firing_wall_properties_block;
			c_typed_tag_block<s_characterinterposerequestpropertiesinternal> interpose_request_properties_block;
			c_typed_tag_block<s_characterinterposepropertiesinternal> interpose_properties_block;
			c_typed_tag_block<s_c_character_bounding_properties_internal> bounding_properties_block;
			c_typed_tag_block<s_c_character_deflection_properties_internal> projectile_deflection_properties_block;
			c_typed_tag_block<s_c_character_bot_properties_internal> bot_properties_block;
			c_typed_tag_block<s_c_character_evasivefight_properties_internal> evasive_fight_properties_block;
			c_typed_tag_block<s_c_character_aggressivefight_properties_internal> aggressive_fight_properties_block;
			c_typed_tag_block<s_c_character_linearadvancefight_properties_internal> linear_advance_fight_properties_block;
			c_typed_tag_block<s_characterstaticfightpropertiesinternal> static_fight_properties_block;
			c_typed_tag_block<s_characterstandgroundpropertiesinternal> stand_ground_properties_block;
			c_typed_tag_block<s_charactergrenadefightpropertiesinternal> grenade_fight_properties_block;
			c_typed_tag_block<s_c_character_coversequence_properties_internal> cover_sequence_properties_block;
			c_typed_tag_block<s_c_character_covermove_properties_internal> cover_move_properties_block;
			c_typed_tag_block<s_c_character_coverhide_properties_internal> cover_hide_properties_block;
			c_typed_tag_block<s_c_character_longrangeattack_properties_internal> long_range_attack_properties_block;
			c_typed_tag_block<s_c_character_hoistattack_properties_internal> hoist_attack_properties_block;
			c_typed_tag_block<s_c_character_hunkerdown_properties_internal> hunker_down_properties_block;
			c_typed_tag_block<s_c_character_shieldraise_properties_internal> shield_raise_properties_block;
			c_typed_tag_block<s_c_character_vehicleaggressivefight_properties_internal> vehicle_aggressive_fight_properties_block;
			c_typed_tag_block<s_c_character_vehicledefensivefight_properties_internal> vehicle_defensive_fight_properties_block;
			c_typed_tag_block<s_c_character_engineer_properties_internal> engineer_properties_block;
			c_typed_tag_block<s_c_character_inspect_properties_internal> inspect_properties_block;
			c_typed_tag_block<s_c_character_vehicleentranceexit_properties_internal> vehicle_entrance_properties_block;
			c_typed_tag_block<s_characterprototypeweaponpropertiesinternal> test_only_weapons_properties_block;
			c_typed_tag_block<s_prototypecharacterstyle> firing_styles_block;
			c_typed_tag_block<s_c_character_grenade_properties_internal> grenades_properties_block;
			c_typed_tag_block<s_c_character_vehicle_properties_internal> vehicle_properties_block;
			c_typed_tag_block<s_c_character_flying_movement_properties_internal> flying_movement_properties_block;
			c_typed_tag_block<s_character_equipment_definition> equipment_definitions_block;
			c_typed_tag_block<s_s_character_stimuli_response_definition> stimuli_responses_block;
			c_typed_tag_block<s_s_campaign_metagame_bucket> campaign_metagame_bucket_block;
			c_typed_tag_block<s_character_activity_objects> activity_objects_block;
			c_typed_tag_block<s_c_character_pain_screen_properties_internal> pain_screen_properties_block;
			c_typed_tag_block<s_charactermeleeanimationscalingpropertiesinternal> melee_animation_scaling_properties_block;
			c_typed_tag_block<s_c_character_closequartersdefenseblast_properties_internal> close_quarters_defense_blast_block;
			c_typed_tag_block<s_c_character_bishop_properties_internal> bishop_properties_block;
			c_typed_tag_block<s_characterhealingpropertiesinternal> healing_properties_block;
			c_typed_tag_block<s_c_character_packmaster_properties_internal> packmaster_properties_block;
			c_typed_tag_block<s_c_character_dynamic_task_properties_internal> dynamic_task_block;
			c_typed_tag_block<s_c_character_rushattack_properties_internal> rush_attack_block;
			c_typed_tag_block<s_c_character_leapattack_properties_internal> leap_attack_block;
			c_typed_tag_block<s_c_character_teleportattack_properties_internal> teleport_attack_block;
			c_typed_tag_block<s_characterjinkandshootpropertiesinternal> jink_and_shoot_block;
			c_typed_tag_block<s_characterteleportandtacklepropertiesinternal> teleport_and_tackle_block;
			c_typed_tag_block<s_characterteleportandtauntpropertiesinternal> teleport_and_taunt_animation_block;
			c_typed_tag_block<s_c_character_desperationrush_properties_internal> desperation_rush_block;
			c_typed_tag_block<s_characterproximitymeleepropertiesinternal> proximity_melee_block;
			c_typed_tag_block<s_characterdivebombkamikazepropertiesinternal> dive_bomb_kamikaze_block;
			c_typed_tag_block<s_characterpostcombatpropertiesinternal> post_combat_block;
			c_typed_tag_block<s_c_character_pack_stalk_properties_internal> pack_stalk_block;
			c_typed_tag_block<s_c_character_fight_circle_properties_internal> fight_circle_block;
			c_typed_tag_block<s_c_character_hamstring_charge_properties_internal> hamstring_block;
			c_typed_tag_block<s_c_character_forerunner_properties_internal> forerunner_block;
			c_typed_tag_block<s_c_character_gravity_jump_properties_internal> gravity_jump_block;
			c_typed_tag_block<s_c_character_coop_modifier_properties_internal> co_op_modifiers_block;
			c_typed_tag_block<s_charactermultitargettrackedattackpropertiesinternal> multi_target_tracked_attack_block;
			c_typed_tag_block<s_c_character_drop_objects_properties_internal> drop_objects_block;
			c_typed_tag_block<s_c_character_customscript_properties_internal> custom_scripting_block;
			char generated_pad539d[4]; // padding
		};
		static_assert(sizeof(s_character_definition) == 1344, "struct s_character_definition is invalid size");

		struct s_chromaeventdevicefiles
		{
			c_typed_tag_reference<CHROMA_TAG> keyboard_file;
			c_typed_tag_reference<CHROMA_TAG> mouse_file;
			c_typed_tag_reference<CHROMA_TAG> headset_file;
			c_typed_tag_reference<CHROMA_TAG> keypad_file;
			c_typed_tag_reference<CHROMA_TAG> mousepad_file;
			c_typed_tag_reference<CHROMA_TAG> chromalink_file;
		};
		static_assert(sizeof(s_chromaeventdevicefiles) == 96, "struct s_chromaeventdevicefiles is invalid size");

		struct s_chromaeventanimation
		{
			c_enum<e_i343chromasupporteventtype, short> event;
			c_enum<e_i343chromasupportlayering, short> layering;
			short priority;
			char generated_padd53a[2]; // padding
			// custom files
			s_chromaeventdevicefiles event_files;
			// custom value
		};
		static_assert(sizeof(s_chromaeventanimation) == 104, "struct s_chromaeventanimation is invalid size");

		struct s_chromaanimationsdefinition
		{
			s_anytag_struct_definition anytag;
			s_chromaeventanimation event_animations[15];
		};
		static_assert(sizeof(s_chromaanimationsdefinition) == 1576, "struct s_chromaanimationsdefinition is invalid size");

		struct s_chromafiletag
		{
			s_anytag_struct_definition anytag;
			s_tag_data file_data;
		};
		static_assert(sizeof(s_chromafiletag) == 36, "struct s_chromafiletag is invalid size");

		struct s_i343physicscollisionlayerauditconfigstring
		{
			c_static_string<256> _string;
		};
		static_assert(sizeof(s_i343physicscollisionlayerauditconfigstring) == 256, "struct s_i343physicscollisionlayerauditconfigstring is invalid size");

		struct s_i343physicscollisionlayerauditconfigurationtag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343physicscollisionlayerauditconfigstring> ignored_directories_block;
			c_typed_tag_block<s_i343physicscollisionlayerauditconfigstring> ignored_files_block;
		};
		static_assert(sizeof(s_i343physicscollisionlayerauditconfigurationtag) == 40, "struct s_i343physicscollisionlayerauditconfigurationtag is invalid size");

		struct s_animtranslation
		{
			long beginframe;
			long endframe;
			real_point3d value;
		};
		static_assert(sizeof(s_animtranslation) == 20, "struct s_animtranslation is invalid size");

		struct s_animrotation
		{
			long beginframe;
			long endframe;
			real_quaternion value;
		};
		static_assert(sizeof(s_animrotation) == 24, "struct s_animrotation is invalid size");

		struct s_animfloat
		{
			long beginframe;
			long endframe;
			real value;
		};
		static_assert(sizeof(s_animfloat) == 12, "struct s_animfloat is invalid size");

		struct s_animjoint
		{
			string_id name;
			c_typed_tag_block<s_animtranslation> perframetranslations_block;
			c_typed_tag_block<s_animrotation> perframerotations_block;
			c_typed_tag_block<s_animfloat> perframescales_block;
			long processingperframetranslationcount;
			long processingperframerotationcount;
			long processingperframescalecount;
		};
		static_assert(sizeof(s_animjoint) == 52, "struct s_animjoint is invalid size");

		struct s_animuserparameter
		{
			string_id name;
			c_typed_tag_block<s_animfloat> perframevalues_block;
			long processingperframevaluecount;
		};
		static_assert(sizeof(s_animuserparameter) == 20, "struct s_animuserparameter is invalid size");

		struct s_animikevent
		{
			string_id targetmarkername;
			string_id chainname;
			c_enum<e_animikusagetype, char> usagetype;
			char generated_pade6b5[3]; // padding
			c_typed_tag_block<s_animfloat> perframeeffect_block;
			c_typed_tag_block<s_animtranslation> targetmarkertranslations_block;
			c_typed_tag_block<s_animrotation> targetmarkerrotations_block;
			c_typed_tag_block<s_animfloat> targetmarkerscales_block;
			long processingperframeeffectcount;
			long processingperframetranslationcount;
			long processingperframerotationcount;
			long processingperframescalecount;
		};
		static_assert(sizeof(s_animikevent) == 76, "struct s_animikevent is invalid size");

		struct s_animjointreference
		{
			short jointreferenceindex;
		};
		static_assert(sizeof(s_animjointreference) == 2, "struct s_animjointreference is invalid size");

		struct s_animcamera
		{
			string_id name;
			c_typed_tag_block<s_animtranslation> perframetranslations_block;
			c_typed_tag_block<s_animrotation> perframerotations_block;
			c_typed_tag_block<s_animfloat> perframefocallengths_block;
			c_typed_tag_block<s_animfloat> perframefocusdistances_block;
			c_typed_tag_block<s_animfloat> perframefstops_block;
			long processingperframetranslationcount;
			long processingperframerotationcount;
			long processingperframefocallengthcount;
			long processingperframefocusdistancecount;
			long processingperframefstopcount;
		};
		static_assert(sizeof(s_animcamera) == 84, "struct s_animcamera is invalid size");

		struct s_animcliptag
		{
			s_anytag_struct_definition anytag;
			long framecount;
			real fps;
			c_typed_tag_block<s_animjoint> joints_block;
			c_typed_tag_block<s_animuserparameter> userparameters_block;
			c_typed_tag_reference<ASSET_TAG> asset;
			c_typed_tag_block<s_animikevent> ikevents_block;
			c_typed_tag_block<s_animjointreference> objectspaceoffsetjoint_block;
			c_typed_tag_block<s_animjointreference> replacementcorrectionjoint_block;
			c_typed_tag_block<s_animjointreference> fikanchorjoint_block;
			c_typed_tag_block<s_animcamera> cameras_block;
		};
		static_assert(sizeof(s_animcliptag) == 124, "struct s_animcliptag is invalid size");

		struct s_s_cloth_collision_sphere
		{
			string_id object_marker_name;
			real radius;
		};
		static_assert(sizeof(s_s_cloth_collision_sphere) == 8, "struct s_s_cloth_collision_sphere is invalid size");

		struct s_cloth_properties
		{
			c_enum<e_clothintegrationtype, short> integration_type;
			short number_iterations;
			real weight;
			real drag;
			real wind_scale;
			real wind_flappiness_scale;
			real longest_rod;
		};
		static_assert(sizeof(s_cloth_properties) == 24, "struct s_cloth_properties is invalid size");

		struct s_cloth_vertex_definition
		{
			real_point3d initial_position;
			real_vector2d uv;
		};
		static_assert(sizeof(s_cloth_vertex_definition) == 20, "struct s_cloth_vertex_definition is invalid size");

		struct s_cloth_index_definition
		{
			short index;
		};
		static_assert(sizeof(s_cloth_index_definition) == 2, "struct s_cloth_index_definition is invalid size");

		struct s_cloth_link_definition
		{
			real default_distance;
			long index1;
			long index2;
			char pad[4]; // padding
		};
		static_assert(sizeof(s_cloth_link_definition) == 16, "struct s_cloth_link_definition is invalid size");

		struct s_cloth_definition
		{
			s_anytag_struct_definition anytag;
			c_flags<e_clothflags, long, k_clothflags_count> flags;
			string_id marker_attachment_name;
			string_id secondary_axis_attachment_name;
			c_typed_tag_reference<MATERIAL_TAG> shader;

			/* Default cloth vertices */

			short grid_x_dimension;
			short grid_y_dimension;
			real grid_spacing_x;
			real grid_spacing_y;
			c_typed_tag_block<s_s_cloth_collision_sphere> collision_spheres_block;

			/* Cloth Properties */

			s_cloth_properties properties;

			/* Import or grid data */

			c_typed_tag_block<s_cloth_vertex_definition> vertices_block;
			c_typed_tag_block<s_cloth_index_definition> indices_block;
			c_typed_tag_block<s_cloth_index_definition> strip_indices_block;
			c_typed_tag_block<s_cloth_link_definition> links_block;
			long long m_pipelinestates;
		};
		static_assert(sizeof(s_cloth_definition) == 148, "struct s_cloth_definition is invalid size");

		struct s_camoscalarfunction
		{
			string_id input_variable;
			string_id range_variable;
			// custom mapping
			s_functiondefinition mapping;
		};
		static_assert(sizeof(s_camoscalarfunction) == 28, "struct s_camoscalarfunction is invalid size");

		struct s_s_camo_effect_definition
		{
			s_anytag_struct_definition anytag;

			/* Active Camo Controls */

			c_flags<e_s_camo_effect_definitionflag, short, k_s_camo_effect_definitionflag_count> flags;
			char generated_padb4a4[2]; // padding
			s_camoscalarfunction active_camo_amount;
			s_camoscalarfunction shadow_amount;
			char generated_padce85[4]; // padding
		};
		static_assert(sizeof(s_s_camo_effect_definition) == 80, "struct s_s_camo_effect_definition is invalid size");

		struct s_i343s_campaign_mission_map_definition
		{
			long map_id;
			string_id map_name;
		};
		static_assert(sizeof(s_i343s_campaign_mission_map_definition) == 8, "struct s_i343s_campaign_mission_map_definition is invalid size");

		struct s_i343s_game_globals_campaign
		{
			c_typed_tag_block<s_i343s_campaign_mission_map_definition> maps_block;
			string_id mission_name;
			string_id mission_description;
			string_id mission_background_image_uri;
			string_id mission_cms_guid;
			string_id mission_team;
		};
		static_assert(sizeof(s_i343s_game_globals_campaign) == 32, "struct s_i343s_game_globals_campaign is invalid size");

		struct s_i343campaignglobals
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343s_game_globals_campaign> campaign_globals_block;
			c_typed_tag_reference<SPAWNSETTINGS_TAG> influencer_default_spawn_settings;
			c_typed_tag_reference<CAMPAIGNUPGRADES_TAG> campaign_upgrades_definition;
			c_typed_tag_reference<COLLECTIBLESDEFINITION_TAG> collectibles;
			c_typed_tag_reference<VALORUNLOCKS_TAG> valor_rewards_definition;
			c_typed_tag_reference<GAMEPLAYMENUUIINFO_TAG> gameplay_menu_ui_info;
		};
		static_assert(sizeof(s_i343campaignglobals) == 108, "struct s_i343campaignglobals is invalid size");

		struct s_soundeventdefinitionreference
		{
			c_typed_tag_reference<SOUND_TAG> soundevent;
		};
		static_assert(sizeof(s_soundeventdefinitionreference) == 16, "struct s_soundeventdefinitionreference is invalid size");

		struct s_composerscript
		{
			c_flags<e_composerscriptflags, char, k_composerscriptflags_count> flags;
			char generated_pad585d[3]; // padding
			s_tag_data data;
			byte boolean_expression;
			char generated_pad3e7c[3]; // padding
			s_tag_data runtime_script_binary;
			c_static_string<32> runtime_script_name;
			dword runtime_script_crc;
		};
		static_assert(sizeof(s_composerscript) == 84, "struct s_composerscript is invalid size");

		struct s_composeraction
		{
			string_id name;
			long id;
			long blend_in;
			c_enum<e_i343curvecurvebuiltin, char> blend_in_curve;
			char generated_pad61be[3]; // padding
			long length;
			c_flags<e_composeractionflags, char, k_composeractionflags_count> flags;
			c_enum<e_composeractiontypeenum, char> type;
			c_enum<e_composersimulationtypeenum, char> simulation_type;
			char generated_padae73[1]; // padding
			short data_index;
			short condition_check_rate;
			s_composerscript condition_script;
		};
		static_assert(sizeof(s_composeraction) == 112, "struct s_composeraction is invalid size");

		struct s_composertextdata
		{
			s_tag_data data;
			dword script_crc;
		};
		static_assert(sizeof(s_composertextdata) == 24, "struct s_composertextdata is invalid size");

		struct s_composereditoraction
		{
			c_static_string<256> comment;
			dword color;
			c_flags<e_composereditorflags, char, k_composereditorflags_count> editor_flags;
			char generated_padd075[3]; // padding
			// custom condition_script
			s_composertextdata condition_script;
			// custom value
		};
		static_assert(sizeof(s_composereditoraction) == 288, "struct s_composereditoraction is invalid size");

		struct s_levelobjectreferenceelement
		{
			long guid;
			string_id name;
		};
		static_assert(sizeof(s_levelobjectreferenceelement) == 8, "struct s_levelobjectreferenceelement is invalid size");

		struct s_levelobjectreference
		{
			c_typed_tag_block<s_levelobjectreferenceelement> path_block;
			long guid;
		};
		static_assert(sizeof(s_levelobjectreference) == 16, "struct s_levelobjectreference is invalid size");

		struct s_composersubject
		{
			string_id object_name;
			s_tag_data raw_object_name;
			s_levelobjectreference object;
			c_enum<e_composerobjectresolutiontypeenum, char> object_resolution_type;
			char generated_padc9c6[3]; // padding
		};
		static_assert(sizeof(s_composersubject) == 44, "struct s_composersubject is invalid size");

		struct s_composerpathpoint
		{
			c_enum<e_composerpathpointtypeenum, short> type;
			c_flags<e_composerpathpointflags, char, k_composerpathpointflags_count> flags;
			char generated_pad5f87[1]; // padding
			s_composersubject subject;
			string_id marker;
			real_point3d position;
			real_euler_angles3d rotation;
		};
		static_assert(sizeof(s_composerpathpoint) == 76, "struct s_composerpathpoint is invalid size");

		struct s_composeractioncamera
		{
			c_flags<e_composercameraflags, char, k_composercameraflags_count> flags;
			char generated_padb1af[3]; // padding
			string_id animation_name;
			long animation_index;
			// custom position
			s_composerpathpoint position;
			// custom value
			long start_frame;
			long end_frame;
			long repeat_count;
			real scale;
		};
		static_assert(sizeof(s_composeractioncamera) == 104, "struct s_composeractioncamera is invalid size");

		struct s_composercagepoint
		{
			s_composersubject subject;
			c_typed_tag_reference<CAGEDEFINITION_TAG> cage;
			string_id cage_point;
			real weight;
		};
		static_assert(sizeof(s_composercagepoint) == 68, "struct s_composercagepoint is invalid size");

		struct s_composeractioncageblendsettings
		{
			long blend_time;
			c_enum<e_i343curvecurvebuiltin, char> transform_curve;
			c_enum<e_i343curvecurvebuiltin, char> properties_curve;
			char generated_paddf02[2]; // padding
		};
		static_assert(sizeof(s_composeractioncageblendsettings) == 8, "struct s_composeractioncageblendsettings is invalid size");

		struct s_i343curvecurve1dcontrolpoint
		{
			real value;
			real tangent_in;
			real tangent_out;
			real curviness;
			c_enum<e_i343curvesegmenttype, char> segment_type;
			c_enum<e_i343curvetangentmode, char> tangent_mode;
			char generated_pad7103[2]; // padding
		};
		static_assert(sizeof(s_i343curvecurve1dcontrolpoint) == 20, "struct s_i343curvecurve1dcontrolpoint is invalid size");

		struct s_i343curvecurve1ddefinition
		{
			c_typed_tag_block<s_i343curvecurve1dcontrolpoint> control_points_block;
		};
		static_assert(sizeof(s_i343curvecurve1ddefinition) == 12, "struct s_i343curvecurve1ddefinition is invalid size");

		struct s_i343curveanimatedcurvemetadata
		{
			real time;
		};
		static_assert(sizeof(s_i343curveanimatedcurvemetadata) == 4, "struct s_i343curveanimatedcurvemetadata is invalid size");

		struct s_i343curveanimatedcurve1d
		{
			string_id name;
			c_flags<e_i343curveanimatedcurveflags, char, k_i343curveanimatedcurveflags_count> flags;
			char generated_pad94fd[3]; // padding
			s_i343curvecurve1ddefinition value_curve;
			c_typed_tag_block<s_i343curveanimatedcurvemetadata> animatedcurvemetadata_block;
		};
		static_assert(sizeof(s_i343curveanimatedcurve1d) == 32, "struct s_i343curveanimatedcurve1d is invalid size");

		struct s_composeractioncagecameraproperties
		{
			real focal_length;
			real focus_distance;
			real f_stop;
			long bokeh_side_count;
			s_i343curveanimatedcurve1d focal_length_curve;
			s_i343curveanimatedcurve1d focus_distance_curve;
			s_i343curveanimatedcurve1d f_stop_curve;
		};
		static_assert(sizeof(s_composeractioncagecameraproperties) == 112, "struct s_composeractioncagecameraproperties is invalid size");

		struct s_i343narrativestringandspring
		{
			c_enum<e_i343curvecurvebuiltin, char> curve_type;
			char generated_padc5da[3]; // padding
			string_id curve_name;
			byte dampen_percentage;
			char generated_pad128f[3]; // padding
			real dampen_time;
		};
		static_assert(sizeof(s_i343narrativestringandspring) == 16, "struct s_i343narrativestringandspring is invalid size");

		struct s_i343narrativecagecamerazoomsettings
		{
			c_typed_tag_reference<CURVEDEFINITION_TAG> curve_definition;
			s_i343narrativestringandspring positional_curve_adjustments;
			s_i343narrativestringandspring focal_length_curve_adjustments;
		};
		static_assert(sizeof(s_i343narrativecagecamerazoomsettings) == 48, "struct s_i343narrativecagecamerazoomsettings is invalid size");

		struct s_composeractioncameracage
		{
			// custom placement
			s_composerpathpoint placement;
			// custom value
			s_composersubject position_subject;
			s_tag_reference position_cage_or_abc;
			long start_frame;
			long end_frame;
			long repeat_count;
			real scale;
			angle max_look_drift_angle;
			real_euler_angles2d look_drift_speed;
			byte look_drift_dampen_percentage;
			char generated_pad2bb7[3]; // padding
			real look_drift_dampen_time;
			real look_drift_no_input_delay;
			string_id position_cage_point;
			string_id camera_name;
			c_typed_tag_block<s_composercagepoint> target_points_block;
			s_composeractioncageblendsettings blend_settings;
			s_composeractioncagecameraproperties camera_properties;
			real blur_amount;
			c_flags<e_cameracagevibrationflags, char, k_cameracagevibrationflags_count> vibration_flags;
			c_flags<e_cameracageplayercontrolflags, char, k_cameracageplayercontrolflags_count> player_control_flags;
			char generated_paddf02[2]; // padding
			real walk_run_weight;
			real camera_weight;
			c_flags<e_composercameracageflags, char, k_composercameracageflags_count> flags;
			char generated_pad924d[3]; // padding
			s_tag_reference resolved_camera_position;
			// custom player_controlled_zoom
			c_typed_tag_block<s_i343narrativecagecamerazoomsettings> zoom_settings_block;
			// custom value
		};
		static_assert(sizeof(s_composeractioncameracage) == 364, "struct s_composeractioncameracage is invalid size");

		struct s_composeranimation
		{
			string_id name;
			long weight;
			string_id ikpointset;
			string_id weapon_class;
			string_id abc_anim_token;
		};
		static_assert(sizeof(s_composeranimation) == 20, "struct s_composeranimation is invalid size");

		struct s_composerpuppetgraph
		{
			s_tag_reference puppet_object_type;
			s_tag_reference model_animation_graph;
			c_enum<e_animationtype, char> abc_animation_type;
			c_enum<e_animationcompressiontype, char> abc_compression_type;
			char generated_padfe48[2]; // padding
			c_typed_tag_reference<SKELETON_TAG> abc_skeleton_tag_optional;
			c_typed_tag_reference<MODEL_ANIMATION_GRAPH_TAG> generatedmodelanimationinternal;
		};
		static_assert(sizeof(s_composerpuppetgraph) == 68, "struct s_composerpuppetgraph is invalid size");

		struct s_composeractiontransitionsettings
		{
			c_enum<e_composeractiontransitiontypes, char> type;
			char generated_pad6308[3]; // padding
			long interpolation_time;
			string_id interpolator_set;
		};
		static_assert(sizeof(s_composeractiontransitionsettings) == 12, "struct s_composeractiontransitionsettings is invalid size");

		struct s_composeranimationeventdata
		{
			short event_type;
			short frame_index;
			short data_index;
			c_flags<e_composeranimationeventflags, char, k_composeranimationeventflags_count> event_flags;
			char generated_pad2246[1]; // padding
			string_id data_identifier;
			string_id anim_data_identifier;
		};
		static_assert(sizeof(s_composeranimationeventdata) == 16, "struct s_composeranimationeventdata is invalid size");

		struct s_composeroverlaychanneldata
		{
			c_enum<e_i343composercomposeroverlaychanneltypes, char> type;
			char generated_pad2a65[3]; // padding
			c_typed_tag_reference<MODEL_ANIMATION_GRAPH_TAG> channel_graph;
			string_id overlay_name;
			real playback_data;
			long frame_start;
			long frame_end;
			s_composerpathpoint proximity_object;
			real radius;
		};
		static_assert(sizeof(s_composeroverlaychanneldata) == 116, "struct s_composeroverlaychanneldata is invalid size");

		struct s_composeractionanimation
		{
			c_typed_tag_block<s_composeranimation> animations_block;
			c_typed_tag_block<s_composerpuppetgraph> model_animation_graphs_block;
			// custom point
			s_composerpathpoint position;
			// custom value
			c_enum<e_composeranimpositiontypeenum, char> position_type;
			char generated_pad0dd6[1]; // padding
			c_flags<e_composeranimationflags, short, k_composeranimationflags_count> flags;
			string_id sync_puppet;
			long start_frame;
			long end_frame;
			long repeat_count;
			real scale;
			c_typed_tag_reference<MODEL_ANIMATION_GRAPH_TAG> overlay_group_graph;
			string_id overlay_group_name;
			string_id animation_mode;
			s_composeractiontransitionsettings override_transition_settings;
			c_typed_tag_block<s_composeranimationeventdata> override_animation_events_block;
			c_typed_tag_block<s_composeroverlaychanneldata> overlay_channels_block;
		};
		static_assert(sizeof(s_composeractionanimation) == 184, "struct s_composeractionanimation is invalid size");

		struct s_composeralembicanimation
		{
			c_typed_tag_reference<ABC_TAG> animation_source;
			c_enum<e_animationtype, char> abc_animation_type;
			c_enum<e_animationcompressiontype, char> abc_compression_type;
			char generated_padbc6d[2]; // padding
			long weight;
			c_typed_tag_reference<MODEL_ANIMATION_GRAPH_TAG> generatedmodelanimationinternal;
		};
		static_assert(sizeof(s_composeralembicanimation) == 40, "struct s_composeralembicanimation is invalid size");

		struct s_composeractionalembicanimation
		{
			c_typed_tag_block<s_composeralembicanimation> animations_block;
			// custom point
			s_composerpathpoint position;
			// custom value
			c_enum<e_composeranimpositiontypeenum, char> position_type;
			char generated_pad49af[1]; // padding
			c_flags<e_composeranimationflags, short, k_composeranimationflags_count> flags;
			string_id sync_puppet;
			long start_frame;
			long end_frame;
			long repeat_count;
			real scale;
			string_id animation_mode;
			s_composeractiontransitionsettings override_transition_settings;
			c_typed_tag_block<s_composeranimationeventdata> override_animation_events_block;
			c_typed_tag_block<s_composeroverlaychanneldata> overlay_channels_block;
		};
		static_assert(sizeof(s_composeractionalembicanimation) == 152, "struct s_composeractionalembicanimation is invalid size");

		struct s_composeranimatedmesh
		{
			string_id name;
			long weight;
		};
		static_assert(sizeof(s_composeranimatedmesh) == 8, "struct s_composeranimatedmesh is invalid size");

		struct s_composeractionanimatedmesh
		{
			c_typed_tag_block<s_composeranimatedmesh> animated_meshes_block;
			c_flags<e_composeranimatedmeshflags, short, k_composeranimatedmeshflags_count> flags;
			char generated_pad65ba[2]; // padding
			real scale;
			long start_frame;
			long end_frame;
		};
		static_assert(sizeof(s_composeractionanimatedmesh) == 28, "struct s_composeractionanimatedmesh is invalid size");

		struct s_composeractionpath
		{
			real throttle;
			c_typed_tag_block<s_composerpathpoint> points_block;
			real destination_tolerance;
			string_id animation_mode;
			c_typed_tag_block<s_composeroverlaychanneldata> overlay_channels_block;
		};
		static_assert(sizeof(s_composeractionpath) == 36, "struct s_composeractionpath is invalid size");

		struct s_composeractionunitrecording
		{
			string_id recording_unit_type;
			string_id recording_name;
			real scale;
			long start_frame;
			long end_frame;
			short smoothing_time;
			c_flags<e_composerunitrecordingflags, char, k_composerunitrecordingflags_count> flags;
			char generated_pad3413[1]; // padding
		};
		static_assert(sizeof(s_composeractionunitrecording) == 24, "struct s_composeractionunitrecording is invalid size");

		struct s_composeractioncommandscript
		{
			s_composerscript script;
		};
		static_assert(sizeof(s_composeractioncommandscript) == 84, "struct s_composeractioncommandscript is invalid size");

		struct s_subtracksreference
		{
			c_typed_tag_reference<COMPOSER_SUBTRACKS_TAG> subtracks_reference;
		};
		static_assert(sizeof(s_subtracksreference) == 16, "struct s_subtracksreference is invalid size");

		struct s_composersubaction
		{
			c_enum<e_composersubactiontypeenum, long> type;
			c_enum<e_composertimetypeenum, char> start_type;
			c_enum<e_composertimetypeenum, char> end_type;
			short data_index;
			long start_action;
			long start_offset;
			s_composerscript start_condition_script;
			s_composerscript end_condition_script;
			long end_action;
			long end_offset;
			c_flags<e_composersubactionflags, char, k_composersubactionflags_count> subaction_flags;
			char generated_pad6d2e[3]; // padding
		};
		static_assert(sizeof(s_composersubaction) == 196, "struct s_composersubaction is invalid size");

		struct s_composereditorsubaction
		{
			c_static_string<256> comment;
			dword color;
			byte subtrack;
			c_flags<e_composereditorflags, char, k_composereditorflags_count> editor_flags;
			char generated_pad8687[2]; // padding
			// custom start_condition_script
			s_composertextdata start_condition_script;
			// custom value
			// custom end_condition_script
			s_composertextdata end_condition_script;
			// custom value
			// custom custom_script
			s_composertextdata custom_script;
			// custom value
			c_typed_tag_block<s_composertextdata> branch_scripts_block;
		};
		static_assert(sizeof(s_composereditorsubaction) == 348, "struct s_composereditorsubaction is invalid size");

		struct s_subactionpoint
		{
			c_flags<e_subactionflags, char, k_subactionflags_count> flags;
			char generated_pad00d4[3]; // padding
			// custom point
			s_composerpathpoint point;
			// custom value
			s_tag_reference asset;
		};
		static_assert(sizeof(s_subactionpoint) == 96, "struct s_subactionpoint is invalid size");

		struct s_composerbranchelement
		{
			long target_action;
			s_composerscript condition_script;
		};
		static_assert(sizeof(s_composerbranchelement) == 88, "struct s_composerbranchelement is invalid size");

		struct s_subactionbranch
		{
			c_typed_tag_block<s_composerbranchelement> elements_block;
			short check_rate;
			char generated_padb7d8[2]; // padding
		};
		static_assert(sizeof(s_subactionbranch) == 16, "struct s_subactionbranch is invalid size");

		struct s_composerdialog
		{
			c_typed_tag_reference<SOUND_TAG> dialog;
			long weight;
			real scale;
			s_composerscript dialog_script;
		};
		static_assert(sizeof(s_composerdialog) == 108, "struct s_composerdialog is invalid size");

		struct s_subactiondialog
		{

			/* Dialog Sub-Action information */

			c_typed_tag_block<s_composerdialog> dialogs_block;
			s_composersubject subject;
		};
		static_assert(sizeof(s_subactiondialog) == 56, "struct s_subactiondialog is invalid size");

		struct s_subactionsubtitle
		{
			string_id subtitle;
			string_id character;
		};
		static_assert(sizeof(s_subactionsubtitle) == 8, "struct s_subactionsubtitle is invalid size");

		struct s_subactioneffect
		{

			/* Effect Sub-Action information */

			c_flags<e_composereffectflags, char, k_composereffectflags_count> flags;
			char generated_pad6b33[3]; // padding
			c_typed_tag_reference<EFFECT_TAG> effect;
			// custom point
			s_composerpathpoint point;
			// custom value
			real scale;
			string_id function_a;
			string_id function_b;
		};
		static_assert(sizeof(s_subactioneffect) == 108, "struct s_subactioneffect is invalid size");

		struct s_subactionlensflare
		{
			c_typed_tag_reference<LENS_FLARE_TAG> lens_flare;
			// custom point
			s_composerpathpoint point;
			// custom value
			string_id function;
			c_flags<e_composerlensflareflags, char, k_composerlensflareflags_count> flags;
			char generated_pad13c6[3]; // padding
		};
		static_assert(sizeof(s_subactionlensflare) == 100, "struct s_subactionlensflare is invalid size");

		struct s_i343curveroadcurvecontrolpointmetadata
		{
			real width;
			real opacity;
			real falloffleft;
			real falloffright;
			real bank;
		};
		static_assert(sizeof(s_i343curveroadcurvecontrolpointmetadata) == 20, "struct s_i343curveroadcurvecontrolpointmetadata is invalid size");

		struct s_i343curveroaddecalbitmapreference
		{
			c_typed_tag_reference<BITMAP_TAG> reference;
		};
		static_assert(sizeof(s_i343curveroaddecalbitmapreference) == 16, "struct s_i343curveroaddecalbitmapreference is invalid size");

		struct s_i343curveroaddecalcontrolpointmetadata
		{
			c_typed_tag_block<s_i343curveroaddecalbitmapreference> road_decal_textures_block;
			real_vector2d road_decal_scale;
			real_vector2d road_decal_offset;
			real road_decal_tile_repeat_count;
			real road_decal_height_strength;
			real road_decal_mask_strength;
			real road_decal_height_contrast;
			real road_decal_mask_contrast;
			real road_decal_edge_fade;
			long road_decal_random_seed;
		};
		static_assert(sizeof(s_i343curveroaddecalcontrolpointmetadata) == 56, "struct s_i343curveroaddecalcontrolpointmetadata is invalid size");

		struct s_i343curveanimatedsplinecontrolpointmetadata
		{
			real time;
		};
		static_assert(sizeof(s_i343curveanimatedsplinecontrolpointmetadata) == 4, "struct s_i343curveanimatedsplinecontrolpointmetadata is invalid size");

		struct s_i343curvecurvecontrolpointmetadata
		{
			c_typed_tag_block<s_i343curveroadcurvecontrolpointmetadata> spline_road_metadata_block;
			c_typed_tag_block<s_i343curveroaddecalcontrolpointmetadata> road_decal_metadata_block;
			c_typed_tag_block<s_i343curveanimatedsplinecontrolpointmetadata> animated_spline_metadata_block;
		};
		static_assert(sizeof(s_i343curvecurvecontrolpointmetadata) == 36, "struct s_i343curvecurvecontrolpointmetadata is invalid size");

		struct s_i343curvecurve3dcontrolpoint
		{
			real_vector3d value;
			real_vector3d tangent_in;
			real_vector3d tangent_out;
			real curviness;
			c_enum<e_i343curvesegmenttype, char> segment_type_x;
			c_enum<e_i343curvesegmenttype, char> segment_type_y;
			c_enum<e_i343curvesegmenttype, char> segment_type_z;
			c_enum<e_i343curvetangentmode, char> tangent_mode_x;
			c_enum<e_i343curvetangentmode, char> tangent_mode_y;
			c_enum<e_i343curvetangentmode, char> tangent_mode_z;
			char generated_pad30cd[2]; // padding
			c_typed_tag_block<s_i343curvecurvecontrolpointmetadata> pointmetadata_block;
		};
		static_assert(sizeof(s_i343curvecurve3dcontrolpoint) == 60, "struct s_i343curvecurve3dcontrolpoint is invalid size");

		struct s_i343curvecurve3ddefinition
		{
			c_typed_tag_block<s_i343curvecurve3dcontrolpoint> control_points_block;
		};
		static_assert(sizeof(s_i343curvecurve3ddefinition) == 12, "struct s_i343curvecurve3ddefinition is invalid size");

		struct s_i343curveanimatedcurve3d
		{
			c_flags<e_i343curveanimatedcurveflags, char, k_i343curveanimatedcurveflags_count> flags;
			char generated_padc23f[3]; // padding
			s_i343curvecurve3ddefinition value_curve;
		};
		static_assert(sizeof(s_i343curveanimatedcurve3d) == 16, "struct s_i343curveanimatedcurve3d is invalid size");

		struct s_transformcurve
		{
			c_enum<e_transformcurvetranslationtypeenum, char> translation_type;
			c_enum<e_transformcurverotationtypeenum, char> rotation_type;
			char generated_paddcfb[2]; // padding
			s_i343curveanimatedcurve3d translation_curve;
			s_i343curveanimatedcurve3d rotation_curve;
			s_i343curveanimatedcurve1d blend_curve;
			// custom translation_point
			s_composerpathpoint translation_point;
			// custom value
			// custom rotation_point
			s_composerpathpoint rotation_point;
			// custom value
		};
		static_assert(sizeof(s_transformcurve) == 220, "struct s_transformcurve is invalid size");

		struct s_i343curvecurve2dcontrolpoint
		{
			real_vector2d value;
			real_vector2d tangent_in;
			real_vector2d tangent_out;
			real curviness;
			c_enum<e_i343curvesegmenttype, char> segment_type_x;
			c_enum<e_i343curvesegmenttype, char> segment_type_y;
			c_enum<e_i343curvetangentmode, char> tangent_mode_x;
			c_enum<e_i343curvetangentmode, char> tangent_mode_y;
		};
		static_assert(sizeof(s_i343curvecurve2dcontrolpoint) == 32, "struct s_i343curvecurve2dcontrolpoint is invalid size");

		struct s_i343curvecurve2ddefinition
		{
			c_typed_tag_block<s_i343curvecurve2dcontrolpoint> control_points_block;
		};
		static_assert(sizeof(s_i343curvecurve2ddefinition) == 12, "struct s_i343curvecurve2ddefinition is invalid size");

		struct s_i343curveanimatedcurve2d
		{
			c_flags<e_i343curveanimatedcurveflags, char, k_i343curveanimatedcurveflags_count> flags;
			char generated_paddf2c[3]; // padding
			s_i343curvecurve2ddefinition value_curve;
			c_typed_tag_block<s_i343curveanimatedcurvemetadata> animatedcurvemetadata_block;
		};
		static_assert(sizeof(s_i343curveanimatedcurve2d) == 28, "struct s_i343curveanimatedcurve2d is invalid size");

		struct s_i343curveanimatedcurvekeyframe
		{
			real_vector2d position;
			real leftslope;
			real rightslope;
			c_enum<e_i343curvesegmenttype, char> segmenttype;
			c_enum<e_i343curvetangentmode, char> tangentmode;
			char generated_pad4bfe[2]; // padding
		};
		static_assert(sizeof(s_i343curveanimatedcurvekeyframe) == 20, "struct s_i343curveanimatedcurvekeyframe is invalid size");

		struct s_i343curveanimatedcurve
		{
			c_typed_tag_block<s_i343curveanimatedcurvekeyframe> keyframes_block;
			c_flags<e_i343curveanimatedcurvecurveflags, char, k_i343curveanimatedcurvecurveflags_count> flags;
			char generated_pad5cd6[3]; // padding
		};
		static_assert(sizeof(s_i343curveanimatedcurve) == 16, "struct s_i343curveanimatedcurve is invalid size");

		struct s_i343curvedepthoffieldcurve
		{
			c_flags<e_i343curvedepthoffieldcurvecurveflags, char, k_i343curvedepthoffieldcurvecurveflags_count> flags;
			char generated_pad134b[3]; // padding
			s_i343curveanimatedcurve focallength;
			s_i343curveanimatedcurve focusdistance;
			s_i343curveanimatedcurve fstop;
			s_i343curveanimatedcurve gameplay_fov_blend;
		};
		static_assert(sizeof(s_i343curvedepthoffieldcurve) == 68, "struct s_i343curvedepthoffieldcurve is invalid size");

		struct s_i343curvepropertycurve
		{
			string_id name;
			c_enum<e_i343curvecurvestructtype, char> curve_type;
			char generated_pad711a[3]; // padding
			s_i343curveanimatedcurve2d animated_curve_2d;
			s_i343curveanimatedcurve3d animated_curve_3d;
			s_i343curvedepthoffieldcurve depth_of_field_curve;
			s_i343curveanimatedcurve1d animated_curve_1d;
		};
		static_assert(sizeof(s_i343curvepropertycurve) == 152, "struct s_i343curvepropertycurve is invalid size");

		struct s_subactionlight
		{
			s_levelobjectreference light;
			string_id light_name;
			long light_guid;
			c_typed_tag_block<s_composersubject> linked_objects_block;
			s_transformcurve transform_curve;
			c_flags<e_composerlightcurveflags, char, k_composerlightcurveflags_count> curves;
			char generated_pad018e[3]; // padding
			c_typed_tag_block<s_i343curvepropertycurve> curve_list_block;
			c_flags<e_subactionlightflags, char, k_subactionlightflags_count> light_flags;
			char generated_pad4e43[3]; // padding
		};
		static_assert(sizeof(s_subactionlight) == 276, "struct s_subactionlight is invalid size");

		struct s_subactionclipplane
		{
			real_point3d plane_center;
			real_point3d plane_direction;
			c_typed_tag_block<s_composersubject> subjects_block;
		};
		static_assert(sizeof(s_subactionclipplane) == 36, "struct s_subactionclipplane is invalid size");

		struct s_subactionfunction
		{

			/* Function Sub-Action information */

			c_flags<e_composerfunctionflags, char, k_composerfunctionflags_count> flags;
			char generated_pade2ec[3]; // padding
			string_id function_name;
			s_scalarfunctionnamedefaultone function;
		};
		static_assert(sizeof(s_subactionfunction) == 28, "struct s_subactionfunction is invalid size");

		struct s_subactionfunctioncurve
		{

			/* Function Sub-Action information */

			c_flags<e_composerfunctionflags, char, k_composerfunctionflags_count> flags;
			char generated_pade687[3]; // padding
			s_i343curveanimatedcurve1d curve;
		};
		static_assert(sizeof(s_subactionfunctioncurve) == 36, "struct s_subactionfunctioncurve is invalid size");

		struct s_subactionuserinputconstraints
		{
			s_rectangle2d maximum_look_angles;
			real frictional_force;
		};
		static_assert(sizeof(s_subactionuserinputconstraints) == 12, "struct s_subactionuserinputconstraints is invalid size");

		struct s_subactiongeneric
		{
			s_tag_reference asset;
			long blend_frames;
		};
		static_assert(sizeof(s_subactiongeneric) == 20, "struct s_subactiongeneric is invalid size");

		struct s_subactionobject
		{
			s_composersubject subject;
			long object_guid;
			s_transformcurve transform_curve;
			c_flags<e_subactionobjectflags, char, k_subactionobjectflags_count> flags;
			c_flags<e_composersubactionobjectcurveflags, char, k_composersubactionobjectcurveflags_count> curves;
			char generated_pad69f5[2]; // padding
			c_typed_tag_block<s_i343curvepropertycurve> curve_list_block;
		};
		static_assert(sizeof(s_subactionobject) == 284, "struct s_subactionobject is invalid size");

		struct s_subactionvalue
		{
			c_enum<e_subactionvaluetypeenum, char> type;
			char generated_pad0885[3]; // padding
			real start_value;
			real end_value;
			s_i343curveanimatedcurve1d value_curve;
		};
		static_assert(sizeof(s_subactionvalue) == 44, "struct s_subactionvalue is invalid size");

		struct s_subactioncamerafadescreen
		{
			c_flags<e_composercamerafadescreenflags, char, k_composercamerafadescreenflags_count> fade_screen_flags;
			char generated_pad8ae3[3]; // padding
			rgb_color fade_color;
			s_i343curveanimatedcurve1d fade_curve;
		};
		static_assert(sizeof(s_subactioncamerafadescreen) == 48, "struct s_subactioncamerafadescreen is invalid size");

		struct s_subactioncameratrigger
		{
			c_flags<e_subactioncameratriggerflags, char, k_subactioncameratriggerflags_count> flags;
		};
		static_assert(sizeof(s_subactioncameratrigger) == 1, "struct s_subactioncameratrigger is invalid size");

		struct s_composerplayerdata
		{
			c_enum<e_composerplayerpuppettypeenum, char> player_type;
			c_enum<e_i343netprotocolgameoptionsmultiplayerteamdesignatorenum, char> multiplayer_team;
			c_flags<e_composerplayerpuppetflags, char, k_composerplayerpuppetflags_count> flags;
			char generated_padf92f[1]; // padding
			long player_index;
			long forge_spectator_player_index;
		};
		static_assert(sizeof(s_composerplayerdata) == 12, "struct s_composerplayerdata is invalid size");

		struct s_subactionuiscene
		{
			c_flags<e_composeruisceneflags, char, k_composeruisceneflags_count> flags;
			char generated_pad2864[3]; // padding
			c_typed_tag_reference<NODE_GRAPH_STACK_TAG> ui_scene;
			// custom point
			s_composerpathpoint point;
			// custom value
			real scale;
			c_typed_tag_block<s_composerplayerdata> player_data_block;
		};
		static_assert(sizeof(s_subactionuiscene) == 112, "struct s_subactionuiscene is invalid size");

		struct s_subactionnodegraphevent
		{
			string_id event_name;
			c_flags<e_composernodegrapheventflags, char, k_composernodegrapheventflags_count> flags;
			char generated_pad5d68[3]; // padding
		};
		static_assert(sizeof(s_subactionnodegraphevent) == 8, "struct s_subactionnodegraphevent is invalid size");

		struct s_subactiongameenginevignetteevent
		{
			string_id event_name;
		};
		static_assert(sizeof(s_subactiongameenginevignetteevent) == 4, "struct s_subactiongameenginevignetteevent is invalid size");

		struct s_subactioncameralensdirt
		{
			real intensity;
			c_typed_tag_reference<BITMAP_TAG> dirt_texture;
			c_enum<e_cameralensdirtdirttype, char> dirt_type;
			char generated_pad40de[3]; // padding
		};
		static_assert(sizeof(s_subactioncameralensdirt) == 24, "struct s_subactioncameralensdirt is invalid size");

		struct s_subactiontransform
		{
			c_flags<e_subactiontransformflags, char, k_subactiontransformflags_count> flags;
			char generated_pad6ca2[3]; // padding
			// custom point_1
			s_composerpathpoint point_1;
			// custom value
			// custom point_2
			s_composerpathpoint point_2;
			// custom value
			s_scalarfunctionname mapping;
		};
		static_assert(sizeof(s_subactiontransform) == 176, "struct s_subactiontransform is invalid size");

		struct s_subactiontransformcurve
		{
			s_transformcurve transform_curve;
		};
		static_assert(sizeof(s_subactiontransformcurve) == 220, "struct s_subactiontransformcurve is invalid size");

		struct s_subactiongenericai
		{
			// custom point
			s_composerpathpoint point;
			// custom value
			real scalar;
			word flags;
			char generated_pade30f[2]; // padding
		};
		static_assert(sizeof(s_subactiongenericai) == 84, "struct s_subactiongenericai is invalid size");

		struct s_subactionikinfluencer
		{
			// custom target
			s_composerpathpoint ik_target;
			// custom value
			string_id chain_name;
			real weight;
			real current_influence_scale;
			real influence_priority;
		};
		static_assert(sizeof(s_subactionikinfluencer) == 92, "struct s_subactionikinfluencer is invalid size");

		struct s_subactioncameradofcurve
		{
			s_i343curvedepthoffieldcurve camera_dof_curve;
			long bokeh_side_count;
		};
		static_assert(sizeof(s_subactioncameradofcurve) == 72, "struct s_subactioncameradofcurve is invalid size");

		struct s_subactionscriptcurves
		{
			s_composerscript script;
			s_i343curveanimatedcurve1d script_curve_value_1;
			s_i343curveanimatedcurve1d script_curve_value_2;
			s_i343curveanimatedcurve1d script_curve_value_3;
			s_i343curveanimatedcurve1d script_curve_value_4;
		};
		static_assert(sizeof(s_subactionscriptcurves) == 212, "struct s_subactionscriptcurves is invalid size");

		struct s_subactionpuppetvariant
		{
			string_id variant_name;
			string_id style_id;
		};
		static_assert(sizeof(s_subactionpuppetvariant) == 8, "struct s_subactionpuppetvariant is invalid size");

		struct s_subactioncolorrgba
		{
			c_enum<e_subactionvaluetypeenum, char> type;
			char generated_padc5f1[3]; // padding
			real red_start_value;
			real red_end_value;
			real green_start_value;
			real green_end_value;
			real blue_start_value;
			real blue_end_value;
			real alpha_start_value;
			real alpha_end_value;
			s_i343curveanimatedcurve1d red_curve;
			s_i343curveanimatedcurve1d green_curve;
			s_i343curveanimatedcurve1d blue_curve;
			s_i343curveanimatedcurve1d alpha_curve;
		};
		static_assert(sizeof(s_subactioncolorrgba) == 164, "struct s_subactioncolorrgba is invalid size");

		struct s_subactiondwscolorgrading
		{
			c_flags<e_composerdwscolorgradingcurveflags, short, k_composerdwscolorgradingcurveflags_count> curves;
			char generated_padc74f[2]; // padding
			c_typed_tag_block<s_i343curvepropertycurve> curve_list_block;
			s_i343curveanimatedcurve1d blending_curve;
		};
		static_assert(sizeof(s_subactiondwscolorgrading) == 48, "struct s_subactiondwscolorgrading is invalid size");

		struct s_subactiondwschromaticaberration
		{
			s_i343curveanimatedcurve1d weight;
			s_i343curveanimatedcurve1d blending_curve;
		};
		static_assert(sizeof(s_subactiondwschromaticaberration) == 64, "struct s_subactiondwschromaticaberration is invalid size");

		struct s_subactionrumble
		{
			c_typed_tag_reference<RUMBLE_TAG> rumble_definition;
			// custom basic
			real low_frequency_level;
			real high_frequency_level;
			real primary_trigger_level;
			real secondary_trigger_level;
			// custom value
		};
		static_assert(sizeof(s_subactionrumble) == 32, "struct s_subactionrumble is invalid size");

		struct s_i343narrativecagedampingproperties
		{
			byte position_dampen_percentage;
			char generated_pad6a9e[3]; // padding
			real position_dampen_time;
			byte rotation_dampen_percentage;
			char generated_padb753[3]; // padding
			real rotation_dampen_time;
		};
		static_assert(sizeof(s_i343narrativecagedampingproperties) == 16, "struct s_i343narrativecagedampingproperties is invalid size");

		struct s_i343narrativecageshakeproperties
		{
			s_i343narrativecagedampingproperties scale_damping;
			// custom position
			real_vector3d position_sample_values;
			real_vector3d position_offset_scale;
			real_vector2d position_offset_velocity_range;
			real_vector3d position_offset_velocity_scale_min;
			real_vector3d position_offset_velocity_scale_max;
			real_vector2d position_time_velocity_scale;
			// custom value
			// custom rotation
			real_vector3d rotation_sample_values;
			real_euler_angles3d rotation_offset_scale;
			real_vector2d rotation_offset_velocity_range;
			real_vector3d rotation_offset_velocity_scale_min;
			real_vector3d rotation_offset_velocity_scale_max;
			real_vector2d rotation_time_velocity_scale;
			// custom value
		};
		static_assert(sizeof(s_i343narrativecageshakeproperties) == 144, "struct s_i343narrativecageshakeproperties is invalid size");

		struct s_subactioncamerashake
		{
			s_i343curveanimatedcurve1d blending_curve;
			s_i343narrativecageshakeproperties camera_shake_properties;
		};
		static_assert(sizeof(s_subactioncamerashake) == 176, "struct s_subactioncamerashake is invalid size");

		struct s_composersubtrack
		{
			string_id name;
			dword color;
			c_enum<e_composersubactioncategoryenum, char> category;
			char generated_padbc0b[3]; // padding
			c_typed_tag_block<s_composersubaction> subactions_block;
			c_typed_tag_block<s_composereditorsubaction> editor_subactions_block;
			c_typed_tag_block<s_subactionpoint> points_block;
			c_typed_tag_block<s_subactionbranch> branches_block;
			c_typed_tag_block<s_subactiondialog> dialog_block;
			c_typed_tag_block<s_subactionsubtitle> subtitles_block;
			c_typed_tag_block<s_subactioneffect> effects_block;
			c_typed_tag_block<s_subactionlensflare> lens_flares_block;
			c_typed_tag_block<s_subactionlight> lights_block;
			c_typed_tag_block<s_subactionclipplane> clip_planes_block;
			c_typed_tag_block<s_subactionfunction> functions_block;
			c_typed_tag_block<s_subactionfunctioncurve> function_curves_block;
			c_typed_tag_block<s_subactionuserinputconstraints> input_constraints_block;
			c_typed_tag_block<s_subactiongeneric> generic_subactions_block;
			c_typed_tag_block<s_subactionobject> object_subactions_block;
			c_typed_tag_block<s_subactionvalue> value_subactions_block;
			c_typed_tag_block<s_subactioncamerafadescreen> camera_fade_screens_block;
			c_typed_tag_block<s_subactioncameratrigger> camera_trigger_subactions_block;
			c_typed_tag_block<s_composerscript> scripts_block;
			c_typed_tag_block<s_subactionuiscene> ui_scenes_block;
			c_typed_tag_block<s_subactionnodegraphevent> nodegraph_events_block;
			c_typed_tag_block<s_subactiongameenginevignetteevent> game_engine_vignette_events_block;
			c_typed_tag_block<s_subactioncameralensdirt> camera_lens_dirt_block;
			c_typed_tag_block<s_subactiontransform> transform_subactions_block;
			c_typed_tag_block<s_subactiontransformcurve> transform_curve_subactions_block;
			c_typed_tag_block<s_subactiongenericai> generic_ai_subactions_block;
			c_typed_tag_block<s_subactionikinfluencer> ik_influencer_subactions_block;
			c_typed_tag_block<s_subactioncameradofcurve> camera_dof_curve_subactions_block;
			c_typed_tag_block<s_subactionscriptcurves> script_curves_subactions_block;
			c_typed_tag_block<s_subactionpuppetvariant> puppet_variant_subactions_block;
			c_typed_tag_block<s_subactioncolorrgba> color_rgba_subactions_block;
			c_typed_tag_block<s_subactiondwscolorgrading> dws_color_grading_subactions_block;
			c_typed_tag_block<s_subactiondwschromaticaberration> dws_chromatic_aberration_subactions_block;
			c_typed_tag_block<s_subactionrumble> rumble_subactions_block;
			c_typed_tag_block<s_subactioncamerashake> camera_shake_subactions_block;
		};
		static_assert(sizeof(s_composersubtrack) == 432, "struct s_composersubtrack is invalid size");

		struct s_composersubtracks
		{
			c_typed_tag_block<s_subtracksreference> subtracks_references_block;
			c_typed_tag_block<s_composersubtrack> subtracks_block;
		};
		static_assert(sizeof(s_composersubtracks) == 24, "struct s_composersubtracks is invalid size");

		struct s_composertrack
		{
			string_id name;
			c_enum<e_composertracktypeenum, char> type;
			char generated_padec1b[3]; // padding
			long id;
			short data_index;
			short subaction_count;
			c_typed_tag_block<s_composeraction> actions_block;
			c_typed_tag_block<s_composereditoraction> editor_actions_block;
			c_typed_tag_block<s_composeractioncamera> cameras_block;
			c_typed_tag_block<s_composeractioncameracage> camera_cages_block;
			c_typed_tag_block<s_composeractionanimation> animations_block;
			c_typed_tag_block<s_composeractionalembicanimation> alembic_animations_block;
			c_typed_tag_block<s_composeractionanimatedmesh> animated_meshes_block;
			c_typed_tag_block<s_composeractionpath> paths_block;
			c_typed_tag_block<s_composeractionunitrecording> unit_recordings_block;
			c_typed_tag_block<s_composeractioncommandscript> command_scripts_block;
			s_composersubtracks subtracks;
			s_composerscript start_script;
			s_composerscript end_script;
		};
		static_assert(sizeof(s_composertrack) == 328, "struct s_composertrack is invalid size");

		struct s_guidbyte
		{
			byte byte_value;
		};
		static_assert(sizeof(s_guidbyte) == 1, "struct s_guidbyte is invalid size");

		struct s_tagguid
		{
			s_guidbyte guid_bytes[16];
		};
		static_assert(sizeof(s_tagguid) == 16, "struct s_tagguid is invalid size");

		struct s_composereditortrack
		{
			c_static_string<256> comment;
			dword color;
			short height;
			c_flags<e_composereditorflags, char, k_composereditorflags_count> editor_flags;
			char generated_padf616[1]; // padding
			// custom start_script
			s_composertextdata start_script;
			// custom value
			// custom end_script
			s_composertextdata end_script;
			// custom value
			s_tagguid editor_guid_bytes;
		};
		static_assert(sizeof(s_composereditortrack) == 328, "struct s_composereditortrack is invalid size");

		struct s_composertrackpuppet
		{
			string_id variant_name;
			string_id style_id;
			string_id object_attachment_name;
			string_id graphics_scene_override;
			c_typed_tag_reference<CAGEDEFINITION_TAG> cage_definition_tag_handle;
			s_composersubject subject;
			c_flags<e_composerpuppetflags, long, k_composerpuppetflags_count> flags;
			s_tag_reference type;
			c_typed_tag_reference<MODEL_ANIMATION_GRAPH_TAG> parent_model_animation_graph;
			c_typed_tag_block<s_composerpuppetgraph> model_animation_graphs_block;
			// custom position
			s_composerpathpoint position;
			// custom value
			// custom bounding_sphere_override
			string_id bone_for_bounding_sphere_center;
			real bounding_sphere_radius;
			// custom value
			c_typed_tag_block<s_composerplayerdata> player_puppet_data_block;
			c_typed_tag_reference<RUNTIMEANIMSET_TAG> runtime_animset_used_by_code_only;
			c_typed_tag_reference<MODEL_ANIMATION_GRAPH_TAG> reference_to_generated_anim_pool_tag;
		};
		static_assert(sizeof(s_composertrackpuppet) == 252, "struct s_composertrackpuppet is invalid size");

		struct s_composertrackcamera
		{
			c_typed_tag_reference<CAMERA_ANIMATION_GRAPH_TAG> camera_animation_graph;
			s_composersubject subject;
			// custom position
			s_composerpathpoint position;
			// custom value
			c_enum<e_i343netprotocolgameoptionsmultiplayerteamdesignatorenum, char> team_camera;
			char generated_pad8b2a[3]; // padding
		};
		static_assert(sizeof(s_composertrackcamera) == 140, "struct s_composertrackcamera is invalid size");

		struct s_composerscene
		{
			string_id name;
			string_id anchor_marker;
			real_point3d anchor_position;
			real_euler_angles3d anchor_rotation;
			c_enum<e_composerresetlightingtypeenum, char> reset_lighting;
			c_flags<e_composersceneflags, char, k_composersceneflags_count> flags;
			char generated_padd502[2]; // padding
			c_typed_tag_reference<SOUND_TAG> skip_sound_event;
			c_typed_tag_reference<SOUND_TAG> start_sound_event;
			c_typed_tag_reference<SOUND_TAG> end_sound_event;
			c_typed_tag_reference<MUSIC_CONTROL_TAG> skip_music_event;
			c_typed_tag_reference<MUSIC_CONTROL_TAG> start_music_event;
			c_typed_tag_reference<MUSIC_CONTROL_TAG> end_music_event;
			c_typed_tag_reference<SOUND_TAG> skip_dialog_event;
			c_typed_tag_reference<SOUND_TAG> start_dialog_event;
			c_typed_tag_reference<SOUND_TAG> end_dialog_event;
			c_typed_tag_block<s_soundeventdefinitionreference> synced_audio_tracks_block;
			c_typed_tag_block<s_composertrack> tracks_block;
			c_typed_tag_block<s_composereditortrack> editor_tracks_block;
			c_typed_tag_block<s_composertrackpuppet> puppet_tracks_block;
			c_typed_tag_block<s_composertrackcamera> camera_tracks_block;
			long lastactionid;
			long lasttrackid;
		};
		static_assert(sizeof(s_composerscene) == 248, "struct s_composerscene is invalid size");

		struct s_compositionscene
		{
			s_anytag_struct_definition anytag;
			s_composerscene scene;
			char generated_pad059c[4]; // padding
		};
		static_assert(sizeof(s_compositionscene) == 268, "struct s_compositionscene is invalid size");

		struct s_composertransitionelement
		{
			c_flags<e_composertransitionflags, char, k_composertransitionflags_count> flags;
			char generated_pad569d[1]; // padding
			short fade_hold;
			long fade_time;
			rgb_color fade_color;
		};
		static_assert(sizeof(s_composertransitionelement) == 20, "struct s_composertransitionelement is invalid size");

		struct s_composertransition
		{
			s_anytag_struct_definition anytag;
			// custom fade_out_from_game
			s_composertransitionelement fade_out_from_game;
			// custom value
			// custom fade_in
			s_composertransitionelement fade_in;
			// custom value
			// custom fade_out
			s_composertransitionelement fade_out;
			// custom value
			// custom fade_post_load
			s_composertransitionelement fade_post_load;
			// custom value
			// custom fade_in_to_game
			s_composertransitionelement fade_in_to_game;
			// custom value
			char generated_padb275[4]; // padding
		};
		static_assert(sizeof(s_composertransition) == 120, "struct s_composertransition is invalid size");

		struct s_interfaceuiiteminfo
		{
			string_id name;
			string_id alt_name_;
			string_id description;
			string_id help_text;
			string_id icon_string_id;
			c_typed_tag_reference<BITMAP_TAG> sprite;
			long sprite_index;
			c_typed_tag_reference<BITMAP_TAG> alt_sprite;
			long alt_sprite_index;
			long damage_sprite_index;
			c_typed_tag_reference<CUI_SCREEN_TAG> ui_vehicle_screen_reference;
		};
		static_assert(sizeof(s_interfaceuiiteminfo) == 80, "struct s_interfaceuiiteminfo is invalid size");

		struct s_i343equipmentupgradenode
		{
			string_id node_name;
		};
		static_assert(sizeof(s_i343equipmentupgradenode) == 4, "struct s_i343equipmentupgradenode is invalid size");

		struct s_i343equipmentupgradepath
		{
			string_id path_name;
			c_enum<e_i343equipmentupgradeequipmentupgradetype, short> path_upgrade_type;
			char generated_pad72a0[2]; // padding
			string_id path_description;
			string_id persistence_key_levels;
			string_id persistence_key_read_levels;
			string_id persistence_key_discovered;
			c_flags<e_equipmentunlockedbydefault, char, k_equipmentunlockedbydefault_count> unlocked_by_default;
			char generated_pad8c81[3]; // padding
			// custom ui_info
			s_interfaceuiiteminfo uiinfo;
			// custom value
			c_typed_tag_block<s_i343equipmentupgradenode> nodes_block;
		};
		static_assert(sizeof(s_i343equipmentupgradepath) == 120, "struct s_i343equipmentupgradepath is invalid size");

		struct s_i343equipmentupgradepoints
		{
			string_id persistence_key;
		};
		static_assert(sizeof(s_i343equipmentupgradepoints) == 4, "struct s_i343equipmentupgradepoints is invalid size");

		struct s_i343equipmentupgradeshieldupgrade
		{
			string_id persistence_key;
		};
		static_assert(sizeof(s_i343equipmentupgradeshieldupgrade) == 4, "struct s_i343equipmentupgradeshieldupgrade is invalid size");

		struct s_i343equipmentupgradecampaignupgrades
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343equipmentupgradepath> equipment_paths_block;
			c_typed_tag_block<s_i343equipmentupgradepoints> equipment_points_block;
			c_typed_tag_block<s_i343equipmentupgradeshieldupgrade> shield_upgrades_block;
			char generated_pad9564[4]; // padding
		};
		static_assert(sizeof(s_i343equipmentupgradecampaignupgrades) == 56, "struct s_i343equipmentupgradecampaignupgrades is invalid size");

		struct s_s_controller_mapping_definition
		{
			s_anytag_struct_definition anytag;

			/* Start/Back */

			c_enum<e_e_gamepad_button, short> jump;
			c_enum<e_e_gamepad_button, short> switch_weapon;
			c_enum<e_e_gamepad_button, short> switch_ability_0;
			c_enum<e_e_gamepad_button, short> switch_ability_1;
			c_enum<e_e_gamepad_button, short> switch_ability_2;
			c_enum<e_e_gamepad_button, short> switch_ability_3;
			c_enum<e_e_gamepad_button, short> switch_grenade;
			c_enum<e_e_gamepad_button, short> switch_grenade_prev;
			c_enum<e_e_gamepad_button, short> equipment_grenade_next;
			c_enum<e_e_gamepad_button, short> equipment_grenade_prev;
			c_enum<e_e_gamepad_button, short> contextual_action;
			c_enum<e_e_gamepad_button, short> melee_attack;
			c_enum<e_e_gamepad_button, short> equipment;
			c_enum<e_e_gamepad_button, short> throw_grenade;
			c_enum<e_e_gamepad_button, short> primary_fire;
			c_enum<e_e_gamepad_button, short> secondary_fire;
			c_enum<e_e_gamepad_button, short> crouch;
			c_enum<e_e_gamepad_button, short> zoom_zoom_scope;
			c_enum<e_e_gamepad_button, short> mobility;
			c_enum<e_e_gamepad_button, short> suit;
			c_enum<e_e_gamepad_button, short> toggle_quick_drop_hud;
			c_enum<e_e_gamepad_button, short> request_quick_drop_1;
			c_enum<e_e_gamepad_button, short> request_quick_drop_2;
			c_enum<e_e_gamepad_button, short> request_quick_drop_3;
			c_enum<e_e_gamepad_button, short> vehicle_ability_primary;
			c_enum<e_e_gamepad_button, short> vehicle_ability_secondary;
			c_enum<e_e_gamepad_button, short> vehicle_ability_tertiary;
			c_enum<e_e_gamepad_button, short> secondary_contextual_action;
			c_enum<e_e_gamepad_button, short> player_callout;
			char start[2]; // skip
			char back[2]; // skip
			c_enum<e_e_gamepad_button, short> accept;
			c_enum<e_e_gamepad_button, short> cancel;
			c_enum<e_e_gamepad_button, short> machinima_lower_weapon;
			c_enum<e_e_gamepad_button, short> machinima_camera_enable;
			c_enum<e_e_gamepad_button, short> machinima_camera_control;
			c_enum<e_e_gamepad_button, short> machinima_camera_debug;
			c_enum<e_e_gamepad_button, short> lift_editor;
			c_enum<e_e_gamepad_button, short> drop_editor;
			c_enum<e_e_gamepad_button, short> cinematic_skip;
			c_enum<e_e_gamepad_button, short> loadout_menu;
			c_enum<e_e_gamepad_button, short> sprint;
			c_enum<e_e_gamepad_button, short> skip_killcam;
			c_enum<e_e_gamepad_button, short> change_zoom_level;

			/* Button Labels */

			string_id button_preset_display_name;
			string_id button_preset_help_text;
			string_id unassigned;
			string_id dpad_up;
			string_id dpad_down;
			string_id dpad_left;
			string_id dpad_right;
			string_id start_button;
			string_id back_button;
			string_id left_thumb_stick;
			string_id right_thumb_stick;
			string_id button_a;
			string_id button_b;
			string_id button_x;
			string_id button_y;
			string_id left_bumper;
			string_id right_bumper;
			string_id left_trigger;
			string_id right_trigger;
			char generated_pad4ce3[4]; // padding
		};
		static_assert(sizeof(s_s_controller_mapping_definition) == 184, "struct s_s_controller_mapping_definition is invalid size");

		struct s_i343narrativeconversationtag
		{
			s_anytag_struct_definition anytag;
			c_flags<e_i343narrativeconversationflags, short, k_i343narrativeconversationflags_count> flags;
			c_enum<e_i343narrativeconversationtype, char> conversation_type;
			char generated_pad56e4[1]; // padding
			short relative_priority;
			short timeout_duration;
			short maximum_duration;
			char generated_pad70c5[2]; // padding
			real pre_convo_delay;
			real pre_convo_delay_max;
			real post_convo_delay;
			real post_convo_delay_max;
			char generated_padbd7a[4]; // padding
		};
		static_assert(sizeof(s_i343narrativeconversationtag) == 48, "struct s_i343narrativeconversationtag is invalid size");

		struct s_i343narrativeconversationtypeitem
		{
			c_enum<e_i343narrativeconversationtype, char> conversation_type;
			char generated_padc653[1]; // padding
			short priority;
			c_flags<e_i343narrativeconversationtypeflags, short, k_i343narrativeconversationtypeflags_count> flags;
		};
		static_assert(sizeof(s_i343narrativeconversationtypeitem) == 6, "struct s_i343narrativeconversationtypeitem is invalid size");

		struct s_i343narrativeconversationtypestag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343narrativeconversationtypeitem> type_items_block;
			char generated_pad0e0f[4]; // padding
		};
		static_assert(sizeof(s_i343narrativeconversationtypestag) == 32, "struct s_i343narrativeconversationtypestag is invalid size");

		struct s_i343collectiblesquicktipdata
		{
			string_id title_id;
			string_id text_id;
		};
		static_assert(sizeof(s_i343collectiblesquicktipdata) == 8, "struct s_i343collectiblesquicktipdata is invalid size");

		struct s_i343collectiblesgameskullunlock
		{
			c_enum<e_i343collectiblesgameskull, char> game_skull;
		};
		static_assert(sizeof(s_i343collectiblesgameskullunlock) == 1, "struct s_i343collectiblesgameskullunlock is invalid size");

		struct s_i343collectiblesunlockedequipment
		{
			string_id frame_attachment_name;
			long input_slot;
		};
		static_assert(sizeof(s_i343collectiblesunlockedequipment) == 8, "struct s_i343collectiblesunlockedequipment is invalid size");

		struct s_i343collectiblesunlockedpoi
		{
			string_id intel_poi_key;
		};
		static_assert(sizeof(s_i343collectiblesunlockedpoi) == 4, "struct s_i343collectiblesunlockedpoi is invalid size");

		struct s_i343collectiblesgameplayunlocks
		{
			c_typed_tag_block<s_i343collectiblesgameskullunlock> skull_unlock_block;
			c_typed_tag_block<s_i343collectiblesunlockedequipment> equipment_unlock_block;
			c_typed_tag_block<s_i343collectiblesunlockedpoi> poi_unlock_block;
		};
		static_assert(sizeof(s_i343collectiblesgameplayunlocks) == 36, "struct s_i343collectiblesgameplayunlocks is invalid size");

		struct s_i343collectiblescollectibleentry
		{
			c_enum<e_i343collectiblescollectibletype, char> collectible_type;
			char generated_padea46[3]; // padding
			string_id persistence_key;
			short codex_list_entry_reference;
			char generated_pad36fb[2]; // padding
			c_typed_tag_block<s_i343collectiblesquicktipdata> quick_tip_override_block;
			c_typed_tag_block<s_i343collectiblesgameplayunlocks> gameplay_unlocks_block;
		};
		static_assert(sizeof(s_i343collectiblescollectibleentry) == 36, "struct s_i343collectiblescollectibleentry is invalid size");

		struct s_i343collectiblescodexpercategoryinfo
		{
			c_enum<e_i343collectiblescodexcategory, char> codex_category;
			char generated_pad598a[3]; // padding
			c_enum<e_i343collectiblescodexunlockkeytype, long> unlock_persistence_key_type;
			c_enum<e_i343collectiblescodexunlockfunctype, long> unlock_function;
			long unlock_compare_value;
			c_typed_tag_reference<BITMAP_TAG> sprite;
		};
		static_assert(sizeof(s_i343collectiblescodexpercategoryinfo) == 32, "struct s_i343collectiblescodexpercategoryinfo is invalid size");

		struct s_i343collectiblesfirstacquisitiondata
		{
			string_id first_acquisition_persistence_key;
			string_id tutorial_title_id;
			string_id tutorial_text_id;
		};
		static_assert(sizeof(s_i343collectiblesfirstacquisitiondata) == 12, "struct s_i343collectiblesfirstacquisitiondata is invalid size");

		struct s_i343collectiblessplashbannerdata
		{
			string_id banner_text_override;
		};
		static_assert(sizeof(s_i343collectiblessplashbannerdata) == 4, "struct s_i343collectiblessplashbannerdata is invalid size");

		struct s_i343collectiblesbackmenuscreentabindex
		{
			long back_menu_screen_tab_index;
		};
		static_assert(sizeof(s_i343collectiblesbackmenuscreentabindex) == 4, "struct s_i343collectiblesbackmenuscreentabindex is invalid size");

		struct s_i343collectiblespercollectipletypedata
		{
			c_enum<e_i343collectiblescollectibletype, char> collectible_type;
			char generated_pad2d83[3]; // padding

			/* Quick Tip Data */

			s_i343collectiblesquicktipdata defualt_tip_data;

			/* First Acquisition Data */

			s_i343collectiblesfirstacquisitiondata first_acquisition_data$2;

			/* Splash Banner Data */

			s_i343collectiblessplashbannerdata splash_banner_data$2;
			c_typed_tag_block<s_i343collectiblesbackmenuscreentabindex> back_menu_screen_tab_index_block;
		};
		static_assert(sizeof(s_i343collectiblespercollectipletypedata) == 40, "struct s_i343collectiblespercollectipletypedata is invalid size");

		struct s_i343collectiblescodexentrydesctext
		{
			string_id paragraph_id;
		};
		static_assert(sizeof(s_i343collectiblescodexentrydesctext) == 4, "struct s_i343collectiblescodexentrydesctext is invalid size");

		struct s_i343collectiblescodexentry
		{
			string_id title;
			string_id read_key_id;
			c_typed_tag_block<s_i343collectiblescodexentrydesctext> description_block;
			long sprite_index;
			c_static_string<256> audio_log_id_as_string;
			string_id audio_log_id;
			long display_order;
			c_enum<e_i343gameplaymenufaction, char> faction;
			char generated_padf1c7[3]; // padding
			// custom uiiteminfo
			s_interfaceuiiteminfo uiiteminfo;
			// custom value
		};
		static_assert(sizeof(s_i343collectiblescodexentry) == 372, "struct s_i343collectiblescodexentry is invalid size");

		struct s_i343collectiblescollectibleentryblockindex
		{
			short collectibleentryindex;
		};
		static_assert(sizeof(s_i343collectiblescollectibleentryblockindex) == 2, "struct s_i343collectiblescollectibleentryblockindex is invalid size");

		struct s_i343collectiblescodexentrylist
		{
			string_id name;
			c_enum<e_i343collectiblescodexcategory, char> codex_screen_category;
			char generated_padc51f[3]; // padding
			string_id codex_screen_category_name;
			c_typed_tag_block<s_i343collectiblescodexentry> codex_entries_block;
			c_typed_tag_block<s_i343collectiblescollectibleentryblockindex> unlock_collectibles_block;
			byte unlock_compare_value;
			c_enum<e_i343collectiblescodexunlock, char> unlockmethod;
			char generated_pad786a[2]; // padding
		};
		static_assert(sizeof(s_i343collectiblescodexentrylist) == 40, "struct s_i343collectiblescodexentrylist is invalid size");

		struct s_i343collectiblescollectiblesdefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343collectiblescollectibleentry> collectible_entry_block;
			c_typed_tag_block<s_i343collectiblescodexpercategoryinfo> codex_category_info_block;
			c_typed_tag_block<s_i343collectiblespercollectipletypedata> per_collectible_data_block;
			long codex_screen_index;
			long upgrade_screen_index;
			c_typed_tag_block<s_i343collectiblescodexentrylist> codex_lists_block;
		};
		static_assert(sizeof(s_i343collectiblescollectiblesdefinition) == 72, "struct s_i343collectiblescollectiblesdefinition is invalid size");

		struct s_errorreportnodeindex
		{
			byte node_index;
		};
		static_assert(sizeof(s_errorreportnodeindex) == 1, "struct s_errorreportnodeindex is invalid size");

		struct s_errorreportnodeweight
		{
			real node_weight;
		};
		static_assert(sizeof(s_errorreportnodeweight) == 4, "struct s_errorreportnodeweight is invalid size");

		struct s_error_report_point
		{
			real_point3d position;
			s_errorreportnodeindex node_indices[4];
			s_errorreportnodeweight node_weights[4];
		};
		static_assert(sizeof(s_error_report_point) == 32, "struct s_error_report_point is invalid size");

		struct s_error_report_vertex
		{
			s_error_report_point point;
			argb_color color;
			real screen_size;
		};
		static_assert(sizeof(s_error_report_vertex) == 52, "struct s_error_report_vertex is invalid size");

		struct s_error_report_vector
		{
			s_error_report_point point;
			argb_color color;
			real_vector3d normal;
			real screen_length;
		};
		static_assert(sizeof(s_error_report_vector) == 64, "struct s_error_report_vector is invalid size");

		struct s_errorreportlinepoint
		{
			s_error_report_point point;
		};
		static_assert(sizeof(s_errorreportlinepoint) == 32, "struct s_errorreportlinepoint is invalid size");

		struct s_error_report_line
		{
			s_errorreportlinepoint points[2];
			argb_color color;
		};
		static_assert(sizeof(s_error_report_line) == 80, "struct s_error_report_line is invalid size");

		struct s_errorreporttrianglepoint
		{
			s_error_report_point point;
		};
		static_assert(sizeof(s_errorreporttrianglepoint) == 32, "struct s_errorreporttrianglepoint is invalid size");

		struct s_error_report_triangle
		{
			s_errorreporttrianglepoint points[3];
			argb_color color;
		};
		static_assert(sizeof(s_error_report_triangle) == 112, "struct s_error_report_triangle is invalid size");

		struct s_errorreportquadpoint
		{
			s_error_report_point point;
		};
		static_assert(sizeof(s_errorreportquadpoint) == 32, "struct s_errorreportquadpoint is invalid size");

		struct s_error_report_quad
		{
			s_errorreportquadpoint points[4];
			argb_color color;
		};
		static_assert(sizeof(s_error_report_quad) == 144, "struct s_error_report_quad is invalid size");

		struct s_error_report_comment
		{
			s_tag_data text;
			s_error_report_point point;
			argb_color color;
		};
		static_assert(sizeof(s_error_report_comment) == 68, "struct s_error_report_comment is invalid size");

		struct s_error_report
		{
			c_enum<e_errorreporttypes, char> type;
			c_enum<e_e_error_report_source, char> source;
			c_flags<e_errorreportflags, short, k_errorreportflags_count> flags;
			s_tag_data text;
			long source_identifier;
			c_static_string<32> source_filename;
			long source_line_number;
			c_typed_tag_block<s_error_report_vertex> vertices_block;
			c_typed_tag_block<s_error_report_vector> vectors_block;
			c_typed_tag_block<s_error_report_line> lines_block;
			c_typed_tag_block<s_error_report_triangle> triangles_block;
			c_typed_tag_block<s_error_report_quad> quads_block;
			c_typed_tag_block<s_error_report_comment> comments_block;
			long report_key;
			long node_index;
			real_bounds bounds_x;
			real_bounds bounds_y;
			real_bounds bounds_z;
			argb_color color;
		};
		static_assert(sizeof(s_error_report) == 184, "struct s_error_report is invalid size");

		struct s_error_report_category
		{
			c_static_string<256> name;
			c_enum<e_errorreporttypes, char> report_type;
			char generated_padf276[1]; // padding
			c_flags<e_errorreportflags, short, k_errorreportflags_count> flags;
			word runtime_generation_flags;
			char generated_pad3f2b[2]; // padding
			long runtime_something;
			c_typed_tag_block<s_error_report> reports_block;
		};
		static_assert(sizeof(s_error_report_category) == 280, "struct s_error_report_category is invalid size");

		struct s_collision_model_material
		{
			string_id name;
		};
		static_assert(sizeof(s_collision_model_material) == 4, "struct s_collision_model_material is invalid size");

		struct s_bsp3d_node
		{
			long long node_data_designator;
		};
		static_assert(sizeof(s_bsp3d_node) == 8, "struct s_bsp3d_node is invalid size");

		struct s_s_bsp3d_kd_super_node
		{
			real plane_0;
			real plane_1;
			real plane_2;
			real plane_3;
			real plane_4;
			real plane_5;
			real plane_6;
			real plane_7;
			real plane_8;
			real plane_9;
			real plane10;
			real plane11;
			real plane12;
			real plane13;
			real plane14;
			long plane_dimensions;
			long child_index_0;
			long child_index_1;
			long child_index_2;
			long child_index_3;
			long child_index_4;
			long child_index_5;
			long child_index_6;
			long child_index_7;
			long child_index_8;
			long child_index_9;
			long child_index10;
			long child_index11;
			long child_index12;
			long child_index13;
			long child_index14;
			long child_index15;
		};
		static_assert(sizeof(s_s_bsp3d_kd_super_node) == 128, "struct s_s_bsp3d_kd_super_node is invalid size");

		struct s_planesparams
		{
			real_plane3d plane;
		};
		static_assert(sizeof(s_planesparams) == 16, "struct s_planesparams is invalid size");

		struct s_collision_leaf
		{
			c_flags<e_leafflags, char, k_leafflags_count> flags;
			char generated_padd325[1]; // padding
			word bsp2d_reference_count;
			dword first_bsp2d_reference;
		};
		static_assert(sizeof(s_collision_leaf) == 8, "struct s_collision_leaf is invalid size");

		struct s_bsp2d_reference
		{
			short plane;
			short bsp2d_node;
		};
		static_assert(sizeof(s_bsp2d_reference) == 4, "struct s_bsp2d_reference is invalid size");

		struct s_bsp2d_node
		{
			real_plane2d plane;
			short left_child;
			short right_child;
		};
		static_assert(sizeof(s_bsp2d_node) == 16, "struct s_bsp2d_node is invalid size");

		struct s_collision_surface
		{
			word plane_index;
			word first_edge;
			short material;
			c_flags<e_surfaceflags, char, k_surfaceflags_count> flags;
			byte best_plane_calculation_vertex_index_;
		};
		static_assert(sizeof(s_collision_surface) == 8, "struct s_collision_surface is invalid size");

		struct s_collision_edge
		{
			word start_vertex;
			word end_vertex;
			word forward_edge;
			word reverse_edge;
			word left_surface;
			word right_surface;
		};
		static_assert(sizeof(s_collision_edge) == 12, "struct s_collision_edge is invalid size");

		struct s_collision_vertex
		{
			real_point3d point;
			word first_edge;
			short sink;
		};
		static_assert(sizeof(s_collision_vertex) == 16, "struct s_collision_vertex is invalid size");

		struct s_collision_bsp
		{
			c_typed_tag_block<s_bsp3d_node> bsp3d_nodes_block;
			c_typed_tag_block<s_s_bsp3d_kd_super_node> bsp3d_supernodes_block;
			c_typed_tag_block<s_planesparams> planes_block;
			c_typed_tag_block<s_collision_leaf> leaves_block;
			c_typed_tag_block<s_bsp2d_reference> bsp2d_references_block;
			c_typed_tag_block<s_bsp2d_node> bsp2d_nodes_block;
			c_typed_tag_block<s_collision_surface> surfaces_block;
			c_typed_tag_block<s_collision_edge> edges_block;
			c_typed_tag_block<s_collision_vertex> vertices_block;
		};
		static_assert(sizeof(s_collision_bsp) == 108, "struct s_collision_bsp is invalid size");

		struct s_collision_model_bsp
		{
			short node_index;
			char generated_pad8a4c[2]; // padding
			s_collision_bsp bsp;
		};
		static_assert(sizeof(s_collision_model_bsp) == 112, "struct s_collision_model_bsp is invalid size");

		struct s_moppcodedatadefinitionparams
		{
			byte mopp_data;
		};
		static_assert(sizeof(s_moppcodedatadefinitionparams) == 1, "struct s_moppcodedatadefinitionparams is invalid size");

		struct s_s_havok_mopp_code_definition
		{
			long long field_pointer_skip;
			long long property_bag_skip;
			short size;
			short count;
			char pad0[12]; // padding
			real vi;
			real vj;
			real vk;
			real vw;
			char pad64_0[4]; // padding
			long long m_data_pointer;
			long int_m_size;
			long int_m_capacityandflags;
			char int8_m_buildtype;
			char pad1_0[1]; // padding
			char pad1_1[2]; // padding
			char pad1_2[4]; // padding
			char pad64_1[4]; // padding
			// custom value
			c_typed_tag_block<s_moppcodedatadefinitionparams> mopp_data_block__block;
			// custom value
			char mopp_build_type;
			char pad2_0[1]; // padding
			char pad2_1[2]; // padding
			char generated_pad27be[8]; // padding
		};
		static_assert(sizeof(s_s_havok_mopp_code_definition) == 104, "struct s_s_havok_mopp_code_definition is invalid size");

		struct s_collision_model_permutation
		{
			string_id name;
			short resourcebspoffset;
			short resourcebspcount;
			c_typed_tag_block<s_collision_model_bsp> bsps_block;
			c_typed_tag_block<s_s_havok_mopp_code_definition> mopp_codes_block;
		};
		static_assert(sizeof(s_collision_model_permutation) == 32, "struct s_collision_model_permutation is invalid size");

		struct s_collision_model_region
		{
			string_id name;
			c_typed_tag_block<s_collision_model_permutation> permutations_block;
		};
		static_assert(sizeof(s_collision_model_region) == 16, "struct s_collision_model_region is invalid size");

		struct s_collision_model_pathfinding_sphere
		{
			short node;
			c_flags<e_pathfindingsphereflags, short, k_pathfindingsphereflags_count> flags;
			real_point3d center;
			real radius;
		};
		static_assert(sizeof(s_collision_model_pathfinding_sphere) == 20, "struct s_collision_model_pathfinding_sphere is invalid size");

		struct s_collision_model_node
		{
			string_id name;
			c_flags<e_collisionnodeflags, short, k_collisionnodeflags_count> flags;
			short parent_node;
			short next_sibling_node;
			short first_child_node;
		};
		static_assert(sizeof(s_collision_model_node) == 12, "struct s_collision_model_node is invalid size");

		struct s_collision_model_definition
		{
			s_anytag_struct_definition anytag;
			long import_info_checksum;
			c_typed_tag_block<s_error_report_category> errors_block;
			c_flags<e_collisionmodelflags, long, k_collisionmodelflags_count> flags;
			c_typed_tag_block<s_collision_model_material> materials_block;
			c_typed_tag_block<s_collision_model_region> regions_block;
			c_typed_tag_block<s_collision_model_region> cookie_cutters_block;
			c_typed_tag_block<s_collision_model_pathfinding_sphere> pathfinding_spheres_block;
			c_typed_tag_block<s_collision_model_node> nodes_block;
			s_tag_resource regions_resource;
			s_nodeflagstoragearray flags_for_nodes_driving_collision_geo[32];
		};
		static_assert(sizeof(s_collision_model_definition) == 232, "struct s_collision_model_definition is invalid size");

		struct s_color_table_color
		{
			c_static_string<32> name;
			argb_color color;
		};
		static_assert(sizeof(s_color_table_color) == 48, "struct s_color_table_color is invalid size");

		struct s_color_table
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_color_table_color> colors_block;
			char generated_pad9dec[4]; // padding
		};
		static_assert(sizeof(s_color_table) == 32, "struct s_color_table is invalid size");

		struct s_authoredlightprobelights
		{
			// custom authored_light_probe
			// custom direction_1
			real direction_1;
			// custom front_back_1
			real front_back_1;
			rgb_color direct_color_1;
			// custom direct_intensity_1
			real direct_intensity_1;
			// custom direction_2
			real direction_2;
			// custom front_back_2
			real front_back_2;
			rgb_color direct_color_2;
			// custom direct_intensity_2
			real direct_intensity_2;
			rgb_color ambient_color;
			// custom ambient_intensity
			real ambient_intensity;
			rgb_color sun_color;
			// custom sun_intensity
			real sun_intensity;
			rgb_color cubemap_scale_color;
			// custom cubemap_scale_intensity
			real cubemap_scale_intensity;
			// custom authored_light_probe_intensity_scale
			real authored_light_probe_intensity_scale;
			// custom generated_air_probe_intensity_scale
			real generated_air_probe_intensity_scale;
		};
		static_assert(sizeof(s_authoredlightprobelights) == 104, "struct s_authoredlightprobelights is invalid size");

		struct s_rgblightprobe
		{
			real sh_data;
		};
		static_assert(sizeof(s_rgblightprobe) == 4, "struct s_rgblightprobe is invalid size");

		struct s_authoredlightprobe
		{
			c_typed_tag_block<s_authoredlightprobelights> lights_block;
			// custom generated_air_probe_intensity_scale
			real generated_air_probe_intensity_scale;
			s_rgblightprobe raw_sh_data[27];
			s_rgblightprobe per_frame_sh_data[27];
			real_point3d sun_color;
			real_point3d cubemap_scale;

			/* value */

			c_flags<e_authoredlightprobeflags, short, k_authoredlightprobeflags_count> flags;
			char generated_padb28a[2]; // padding
		};
		static_assert(sizeof(s_authoredlightprobe) == 260, "struct s_authoredlightprobe is invalid size");

		struct s_customobjectlighting
		{

			/* Character Lighting */

			c_typed_tag_block<s_authoredlightprobe> authored_light_probes_block;
			c_enum<e_lightboolean, char> is_camera_space;
			c_flags<e_customobjectlightingflags, char, k_customobjectlightingflags_count> flags;
			char generated_pad79fe[2]; // padding
			c_typed_tag_reference<BITMAP_TAG> cubemap_override;
		};
		static_assert(sizeof(s_customobjectlighting) == 32, "struct s_customobjectlighting is invalid size");

		struct s_customobjectlightingtag
		{
			s_anytag_struct_definition anytag;
			s_customobjectlighting probe;
			char generated_pad8a18[4]; // padding
		};
		static_assert(sizeof(s_customobjectlightingtag) == 52, "struct s_customobjectlightingtag is invalid size");

		struct s_composerscenario
		{
			c_typed_tag_reference<LEVEL_TAG> scenario;
		};
		static_assert(sizeof(s_composerscenario) == 16, "struct s_composerscenario is invalid size");

		struct s_composerbink
		{
			c_flags<e_composerbinkflags, long, k_composerbinkflags_count> flags;
			c_typed_tag_reference<BINK_TAG> bink_movie;
			c_static_string<32> bink_movie_on_disc;
		};
		static_assert(sizeof(s_composerbink) == 52, "struct s_composerbink is invalid size");

		struct s_composerscenereference
		{
			c_typed_tag_reference<COMPOSITION_SCENE_TAG> scene;
		};
		static_assert(sizeof(s_composerscenereference) == 16, "struct s_composerscenereference is invalid size");

		struct s_stringidtoshortnamemappingid
		{
			string_id id;
		};
		static_assert(sizeof(s_stringidtoshortnamemappingid) == 4, "struct s_stringidtoshortnamemappingid is invalid size");

		struct s_stringidtoshortnamemappingindex
		{
			long string_index;
		};
		static_assert(sizeof(s_stringidtoshortnamemappingindex) == 4, "struct s_stringidtoshortnamemappingindex is invalid size");

		struct s_stringidtoshortnamemapping
		{
			c_typed_tag_block<s_stringidtoshortnamemappingid> ids_block;
			c_typed_tag_block<s_stringidtoshortnamemappingindex> string_indices_block;
			s_tag_data string_table;
		};
		static_assert(sizeof(s_stringidtoshortnamemapping) == 44, "struct s_stringidtoshortnamemapping is invalid size");

		struct s_soundbankdefinitionreference
		{
			c_typed_tag_reference<SOUNDBANK_TAG> soundbank;
		};
		static_assert(sizeof(s_soundbankdefinitionreference) == 16, "struct s_soundbankdefinitionreference is invalid size");

		struct s_composerfirsttofirsttransition
		{
			string_id preset;
			c_flags<e_composercagetransitionoverrideflags, short, k_composercagetransitionoverrideflags_count> override_flags;
			c_flags<e_composercagetransitionflags, char, k_composercagetransitionflags_count> flags;
			char generated_pad1960[1]; // padding
			real close_enough_distance_min;
			real close_enough_distance_max;
			angle close_enough_angle_min;
			angle close_enough_angle_max;
			real linear_velocity_min;
			real linear_velocity_max;
			angle angular_velocity_min;
			angle angular_velocity_max;
			real lower_weapon_time;
			real raise_weapon_time;
			real hide_player_time;
			c_enum<e_i343curvecurvebuiltin, char> move_to_slide_curve;
			char generated_pad3341[3]; // padding
			real move_to_time;
			real lower_weapon_delay_override;
			real raise_weapon_delay_override;
			real hud_off_delay_override;
			real hud_on_delay_override;
			real move_to_delay_override;
		};
		static_assert(sizeof(s_composerfirsttofirsttransition) == 80, "struct s_composerfirsttofirsttransition is invalid size");

		struct s_composerfirsttothirdtransition
		{
			c_flags<e_composercagetransitionflags, char, k_composercagetransitionflags_count> flags;
			char generated_pad1bd9[3]; // padding
			real close_enough_distance;
			angle close_enough_angle;
			angle angular_velocity;
			real lower_weapon_time;
			real raise_weapon_time;
			real hide_player_time;
			s_levelobjectreference destination;
		};
		static_assert(sizeof(s_composerfirsttothirdtransition) == 44, "struct s_composerfirsttothirdtransition is invalid size");

		struct s_compositiondefinition
		{
			s_anytag_struct_definition anytag;
			// custom scenario
			s_composerscenario scenario;
			// custom value
			string_id name;
			c_flags<e_composerflags, long, k_composerflags_count> flags;
			real animation_blend_in;
			real cage_camera_blend_in_time;
			c_enum<e_i343curvecurvebuiltin, char> cage_camera_blend_in_curve;
			char generated_pada339[3]; // padding
			string_id cage_camera_blend_in_variant;
			real cage_camera_blend_out_time;
			c_enum<e_i343curvecurvebuiltin, char> cage_camera_blend_out_curve;
			char generated_pad8958[3]; // padding
			string_id cage_camera_blend_out_variant;
			real cinematic_lod_scale;
			string_id lighting_variant;
			c_typed_tag_reference<COMPOSER_TRANSITION_TAG> transition;
			c_typed_tag_reference<SOUND_TAG> skip_sound_event;
			c_typed_tag_reference<SOUND_TAG> start_sound_event;
			c_typed_tag_reference<SOUND_TAG> end_sound_event;
			c_typed_tag_reference<MUSIC_CONTROL_TAG> skip_music_event;
			c_typed_tag_reference<MUSIC_CONTROL_TAG> start_music_event;
			c_typed_tag_reference<MUSIC_CONTROL_TAG> end_music_event;
			c_typed_tag_reference<SOUND_TAG> skip_dialog_event;
			c_typed_tag_reference<SOUND_TAG> start_dialog_event;
			c_typed_tag_reference<SOUND_TAG> end_dialog_event;
			// custom bink
			s_composerbink bink;
			// custom value
			// custom ics_points
			c_static_string<32> ics_point_0;
			c_static_string<32> ics_point_1;
			c_static_string<32> ics_point_2;
			c_static_string<32> ics_point_3;
			// custom value
			s_composerscript start_script;
			s_composerscript end_script;
			s_composerscript skip_script;
			c_typed_tag_block<s_composerscene> scenes_block;
			c_typed_tag_block<s_composerscenereference> scene_references_block;
			s_stringidtoshortnamemapping name_map;
			c_typed_tag_block<s_soundbankdefinitionreference> required_sound_banks_block;
			c_typed_tag_block<s_soundeventdefinitionreference> synced_audio_tracks_block;
			c_typed_tag_block<s_composerfirsttofirsttransition> first_to_first_transition_block;
			c_typed_tag_block<s_composerfirsttothirdtransition> first_to_third_transition_block;
			char generated_pad3ca3[4]; // padding
		};
		static_assert(sizeof(s_compositiondefinition) == 788, "struct s_compositiondefinition is invalid size");

		struct s_cheapparticlescalarfunction
		{
			string_id input_variable;
			string_id range_variable;
			// custom mapping
			s_functiondefinition mapping;
		};
		static_assert(sizeof(s_cheapparticlescalarfunction) == 28, "struct s_cheapparticlescalarfunction is invalid size");

		struct s_cheapparticleemitter
		{
			s_anytag_struct_definition anytag;
			c_flags<e_cheapparticleemitterflags, short, k_cheapparticleemitterflags_count> flags;
			word version;
			real spawn_rate;

			/* SPAWN RATE */

			s_cheapparticlescalarfunction spawnrate;

			/* LOD */

			real distance_fade_start;
			real distance_fade_end;

			/* TYPES */

			// custom types
			string_id type_0;
			real weight_0;
			string_id type_1;
			real weight_1;
			string_id type_2;
			real weight_2;
			string_id type_3;
			real weight_3;
			// custom value

			/* LIFETIME */

			real_bounds lifetime$2;

			/* EMITTER PARAMETERS */

			c_typed_tag_reference<BITMAP_TAG> position_texture;
			real position_scale;
			real position_flatten;
			c_typed_tag_reference<BITMAP_TAG> velocity_texture;
			real_bounds directionality;
			real_bounds speed_scale;
			real_bounds subframe_offset;

			/* PARTICLE PARAMETERS */

			real rotation_randomness;
			real particle_scale_modifier;

			/* LIGHTING PARAMETERS */

			real lighting_contrast;
			real lighting_offset;
			real lighting_min;
			real lighting_max;
			real_quaternion spawn_params0;
			real_quaternion spawn_params1;
			real_quaternion spawn_params2;
			real_quaternion spawn_params3;
			real_quaternion spawn_params4;
			c_typed_tag_reference<CHEAP_PARTICLE_TYPE_LIBRARY_TAG> global_type_library;
			char generated_pad1e19[4]; // padding
		};
		static_assert(sizeof(s_cheapparticleemitter) == 288, "struct s_cheapparticleemitter is invalid size");

		struct s_cheapparticletype
		{
			string_id name;
			// custom physics
			real drag;
			real gravity;
			real turbulence;
			long turbulence_type;
			// custom value
			// custom collision
			real depth_range;
			real elasticity;
			real death;
			long change_type;
			// custom value
			// custom render
			c_enum<e_cheapparticletypee_orientation, long> orientation;

			/* render parameters */

			argb_color color0;
			real intensity0;
			real fade_start;
			real_bounds size;
			real motion_blur_stretch;
			long texture;
			real texture_y_scale;
			real taa_mask_strength;
			// custom value
		};
		static_assert(sizeof(s_cheapparticletype) == 88, "struct s_cheapparticletype is invalid size");

		struct s_cheapparticletexture
		{
			c_typed_tag_reference<BITMAP_TAG> bitmap;
		};
		static_assert(sizeof(s_cheapparticletexture) == 16, "struct s_cheapparticletexture is invalid size");

		struct s_cheapparticleturbulencetype
		{
			string_id name;
			c_typed_tag_reference<BITMAP_TAG> turbulence;
			real turb_du_dt;
			real turb_dv_dt;
			real turb_du_dp;
			real turb_dv_dp;
		};
		static_assert(sizeof(s_cheapparticleturbulencetype) == 36, "struct s_cheapparticleturbulencetype is invalid size");

		struct s_cheapparticletypelibrary
		{
			s_anytag_struct_definition anytag;
			// custom compile
			c_typed_tag_block<s_cheapparticletype> types_block;
			c_typed_tag_block<s_cheapparticletexture> textures_block;
			c_typed_tag_reference<BITMAP_TAG> random;
			c_typed_tag_block<s_cheapparticleturbulencetype> turbulence_types_block;
			c_typed_tag_reference<BITMAP_TAG> type_texture;
			c_typed_tag_reference<BITMAP_TAG> render_texture;
			c_typed_tag_reference<BITMAP_TAG> turbulencetexture;
			char generated_pad3c2a[4]; // padding
		};
		static_assert(sizeof(s_cheapparticletypelibrary) == 120, "struct s_cheapparticletypelibrary is invalid size");

		struct s_s_camera_impulse
		{
			real impulse_duration;
			// custom mapping_function
			s_functiondefinition mapping;
			angle rotation;
			real pushback;
			real_bounds jitter;
		};
		static_assert(sizeof(s_s_camera_impulse) == 40, "struct s_s_camera_impulse is invalid size");

		struct s_s_camera_shake
		{
			real shake_duration;

			/* procedural camera shake */

			// custom mapping_function
			s_functiondefinition mapping;
			real random_translation;
			angle random_rotation;
			real wobble_function_period;
			real_fraction wobble_weight;
			c_enum<e_periodicfunction, short> wobble_function;

			/* animated camera shake */

			c_enum<e_c_animated_camera_shake_playback_type, char> animated_shake_playback;
			c_enum<e_c_animated_camera_shake_weight_type, char> animated_shake_weight;
			c_typed_tag_reference<MODEL_ANIMATION_GRAPH_TAG> animation_graph;
			string_id animation_name;
			real zoom_penalty_linear_;
			real zoom_penalty_squareroot_;
		};
		static_assert(sizeof(s_s_camera_shake) == 72, "struct s_s_camera_shake is invalid size");

		struct s_s_camera_shake_definition
		{
			s_anytag_struct_definition anytag;

			/* camera impulse */

			s_s_camera_impulse camera_impulse$2;

			/* camera shake */

			s_s_camera_shake camera_shake$2;
			char generated_padd4ac[4]; // padding
		};
		static_assert(sizeof(s_s_camera_shake_definition) == 132, "struct s_s_camera_shake_definition is invalid size");

		struct s_s_cui_property_value_long_definition
		{
			string_id name;
			string_id resourcename;
			long value;
		};
		static_assert(sizeof(s_s_cui_property_value_long_definition) == 12, "struct s_s_cui_property_value_long_definition is invalid size");

		struct s_s_cui_property_value_real_definition
		{
			string_id name;
			string_id resourcename;
			real value;
		};
		static_assert(sizeof(s_s_cui_property_value_real_definition) == 12, "struct s_s_cui_property_value_real_definition is invalid size");

		struct s_s_cui_property_value_string_id_definition
		{
			string_id name;
			string_id resourcename;
			string_id value;
		};
		static_assert(sizeof(s_s_cui_property_value_string_id_definition) == 12, "struct s_s_cui_property_value_string_id_definition is invalid size");

		struct s_cuipropertyvaluecomponentptrdefinition
		{
			string_id name;
			string_id resourcename;
			qword component_id;
			string_id value;
			char generated_padccc5[4]; // padding
		};
		static_assert(sizeof(s_cuipropertyvaluecomponentptrdefinition) == 24, "struct s_cuipropertyvaluecomponentptrdefinition is invalid size");

		struct s_s_cui_property_value_tag_reference_definition
		{
			string_id name;
			string_id resourcename;
			s_tag_reference value;
		};
		static_assert(sizeof(s_s_cui_property_value_tag_reference_definition) == 24, "struct s_s_cui_property_value_tag_reference_definition is invalid size");

		struct s_s_cui_property_value_text_definition
		{
			string_id name;
			string_id resourcename;
			c_static_string<256> value;
		};
		static_assert(sizeof(s_s_cui_property_value_text_definition) == 264, "struct s_s_cui_property_value_text_definition is invalid size");

		struct s_s_cui_property_value_argb_color_definition
		{
			string_id name;
			string_id resourcename;
			argb_color value;
		};
		static_assert(sizeof(s_s_cui_property_value_argb_color_definition) == 24, "struct s_s_cui_property_value_argb_color_definition is invalid size");

		struct s_cuieventhandlerdefinition
		{
			string_id event;
			string_id filter;
			string_id name;
			c_static_string<256> action;
		};
		static_assert(sizeof(s_cuieventhandlerdefinition) == 268, "struct s_cuieventhandlerdefinition is invalid size");

		struct s_s_cui_properties_definition
		{
			c_typed_tag_block<s_s_cui_property_value_long_definition> long_properties_block;
			c_typed_tag_block<s_s_cui_property_value_real_definition> real_properties_block;
			c_typed_tag_block<s_s_cui_property_value_string_id_definition> string_id_properties_block;
			c_typed_tag_block<s_cuipropertyvaluecomponentptrdefinition> component_ptr_properties_block;
			c_typed_tag_block<s_s_cui_property_value_tag_reference_definition> tag_reference_properties_block;
			c_typed_tag_block<s_s_cui_property_value_text_definition> string_properties_block;
			c_typed_tag_block<s_s_cui_property_value_argb_color_definition> argb_color_properties_block;
			c_typed_tag_block<s_cuieventhandlerdefinition> event_handlers_block;
		};
		static_assert(sizeof(s_s_cui_properties_definition) == 96, "struct s_s_cui_properties_definition is invalid size");

		struct s_cuiresourcesdefinition
		{
			s_anytag_struct_definition anytag;
			s_s_cui_properties_definition resource_values;
		};
		static_assert(sizeof(s_cuiresourcesdefinition) == 112, "struct s_cuiresourcesdefinition is invalid size");

		struct s_i343curvecurvedefinitiontagmetadata
		{
			real input;
		};
		static_assert(sizeof(s_i343curvecurvedefinitiontagmetadata) == 4, "struct s_i343curvecurvedefinitiontagmetadata is invalid size");

		struct s_i343curvenamed1dcurve
		{
			string_id name;
			s_i343curvecurve1ddefinition definition;
			c_typed_tag_block<s_i343curvecurvedefinitiontagmetadata> metadata_block;
		};
		static_assert(sizeof(s_i343curvenamed1dcurve) == 28, "struct s_i343curvenamed1dcurve is invalid size");

		struct s_i343curvenamed2dcurve
		{
			string_id name;
			s_i343curvecurve2ddefinition definition;
			c_typed_tag_block<s_i343curvecurvedefinitiontagmetadata> metadata_block;
		};
		static_assert(sizeof(s_i343curvenamed2dcurve) == 28, "struct s_i343curvenamed2dcurve is invalid size");

		struct s_i343curvenamed3dcurve
		{
			string_id name;
			s_i343curvecurve3ddefinition definition;
			c_typed_tag_block<s_i343curvecurvedefinitiontagmetadata> metadata_block;
		};
		static_assert(sizeof(s_i343curvenamed3dcurve) == 28, "struct s_i343curvenamed3dcurve is invalid size");

		struct s_i343curvenamedtransformcurve
		{
			string_id name;
			s_i343curvecurve3ddefinition position_definition;
			s_i343curvecurve3ddefinition orientation_definition;
			c_typed_tag_block<s_i343curvecurvedefinitiontagmetadata> metadata_block;
		};
		static_assert(sizeof(s_i343curvenamedtransformcurve) == 40, "struct s_i343curvenamedtransformcurve is invalid size");

		struct s_i343curvecurvedefinitiontag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343curvenamed1dcurve> curves_1d_block;
			c_typed_tag_block<s_i343curvenamed2dcurve> curves_2d_block;
			c_typed_tag_block<s_i343curvenamed3dcurve> curves_3d_block;
			c_typed_tag_block<s_i343curvenamedtransformcurve> curves_transform_block;
		};
		static_assert(sizeof(s_i343curvecurvedefinitiontag) == 64, "struct s_i343curvecurvedefinitiontag is invalid size");

		struct s_stringfilereferences
		{
			c_typed_tag_reference<MULTILINGUAL_UNICODE_STRING_LIST_TAG> string_list;
			c_typed_tag_reference<STRINGLIST_TAG> new_string_list;
		};
		static_assert(sizeof(s_stringfilereferences) == 32, "struct s_stringfilereferences is invalid size");

		struct s_resourcefilereferences
		{
			c_typed_tag_reference<CUI_RESOURCES_TAG> resources_list;
		};
		static_assert(sizeof(s_resourcefilereferences) == 16, "struct s_resourcefilereferences is invalid size");

		struct s_cuitemplatecomponentdefinition
		{
			qword component_id;
			string_id original_name;
			string_id name;
		};
		static_assert(sizeof(s_cuitemplatecomponentdefinition) == 16, "struct s_cuitemplatecomponentdefinition is invalid size");

		struct s_cuitemplateinstantiationdefinition
		{
			qword template_instance_id;
			c_typed_tag_reference<CUI_SCREEN_TAG> screen_reference;
			string_id parent;
			qword parent_id;
			long child_order;
			c_typed_tag_block<s_cuitemplatecomponentdefinition> components_block;
		};
		static_assert(sizeof(s_cuitemplateinstantiationdefinition) == 52, "struct s_cuitemplateinstantiationdefinition is invalid size");

		struct s_s_cui_component_definition
		{
			qword component_id;
			string_id type;
			string_id name;
			string_id parent;
			char generated_padecfb[4]; // padding
			qword parent_id;
			long child_order;
			c_flags<e_f_cui_component_definition_flags, short, k_f_cui_component_definition_flags_count> flags;
			char generated_pada046[2]; // padding
		};
		static_assert(sizeof(s_s_cui_component_definition) == 40, "struct s_s_cui_component_definition is invalid size");

		struct s_s_cui_component_index_definition
		{
			qword component_id;
			string_id name;
			short component_definition_index;
			char generated_pad855c[2]; // padding
		};
		static_assert(sizeof(s_s_cui_component_index_definition) == 16, "struct s_s_cui_component_index_definition is invalid size");

		struct s_cuidonotcreatecomponentdefinition
		{
			qword component_id;
		};
		static_assert(sizeof(s_cuidonotcreatecomponentdefinition) == 8, "struct s_cuidonotcreatecomponentdefinition is invalid size");

		struct s_cuidonotcreatescreendefinition
		{
			c_typed_tag_reference<CUI_SCREEN_TAG> screen_reference;
			c_typed_tag_block<s_cuidonotcreatecomponentdefinition> components_block;
		};
		static_assert(sizeof(s_cuidonotcreatescreendefinition) == 28, "struct s_cuidonotcreatescreendefinition is invalid size");

		struct s_s_cui_component_properties_definition
		{
			qword component_id;
			string_id name;
			s_s_cui_properties_definition property_values;
			char generated_pad00cf[4]; // padding
		};
		static_assert(sizeof(s_s_cui_component_properties_definition) == 112, "struct s_s_cui_component_properties_definition is invalid size");

		struct s_s_cui_animation_scalar_function
		{
			// custom scalar_function
			s_functiondefinition scalar_function;
		};
		static_assert(sizeof(s_s_cui_animation_scalar_function) == 20, "struct s_s_cui_animation_scalar_function is invalid size");

		struct s_s_cui_animation_property_keyframe_value_real_definition
		{
			long duration;
			string_id resourcename;
			real value;
			s_s_cui_animation_scalar_function transition_function;
		};
		static_assert(sizeof(s_s_cui_animation_property_keyframe_value_real_definition) == 32, "struct s_s_cui_animation_property_keyframe_value_real_definition is invalid size");

		struct s_s_cui_animation_component_property_real_definition
		{
			string_id name;
			c_enum<e_e_cui_animation_property_composition_type, short> composition;
			c_enum<e_cuianimationendingtype, char> ending_type;
			char generated_pad83f4[1]; // padding
			long iteration_count;
			long total_milliseconds;
			c_typed_tag_block<s_s_cui_animation_property_keyframe_value_real_definition> real_keyframes_block;
		};
		static_assert(sizeof(s_s_cui_animation_component_property_real_definition) == 28, "struct s_s_cui_animation_component_property_real_definition is invalid size");

		struct s_s_cui_animation_property_keyframe_value_argb_color_definition
		{
			long duration;
			string_id resourcename;
			argb_color color;
			s_s_cui_animation_scalar_function transition_function;
		};
		static_assert(sizeof(s_s_cui_animation_property_keyframe_value_argb_color_definition) == 44, "struct s_s_cui_animation_property_keyframe_value_argb_color_definition is invalid size");

		struct s_s_cui_animation_component_property_argb_color_definition
		{
			string_id name;
			c_enum<e_e_cui_animation_property_composition_type, short> composition;
			c_enum<e_cuianimationendingtype, char> ending_type;
			char generated_pad83f4[1]; // padding
			long iteration_count;
			long total_milliseconds;
			c_typed_tag_block<s_s_cui_animation_property_keyframe_value_argb_color_definition> argb_color_keyframes_block;
		};
		static_assert(sizeof(s_s_cui_animation_component_property_argb_color_definition) == 28, "struct s_s_cui_animation_component_property_argb_color_definition is invalid size");

		struct s_cuianimationpropertykeyframevaluestringiddefinition
		{
			long duration;
			string_id resourcename;
			string_id stringid;
		};
		static_assert(sizeof(s_cuianimationpropertykeyframevaluestringiddefinition) == 12, "struct s_cuianimationpropertykeyframevaluestringiddefinition is invalid size");

		struct s_cuianimationcomponentpropertystringiddefinition
		{
			string_id name;
			c_enum<e_e_cui_animation_property_composition_type, short> composition;
			c_enum<e_cuianimationendingtype, char> ending_type;
			char generated_pad83f4[1]; // padding
			long iteration_count;
			long total_milliseconds;
			c_typed_tag_block<s_cuianimationpropertykeyframevaluestringiddefinition> stringid_keyframes_block;
		};
		static_assert(sizeof(s_cuianimationcomponentpropertystringiddefinition) == 28, "struct s_cuianimationcomponentpropertystringiddefinition is invalid size");

		struct s_s_cui_animation_component_definition
		{
			qword component_id;
			string_id name;
			long total_milliseconds;
			c_typed_tag_block<s_s_cui_animation_component_property_real_definition> real_properties_block;
			c_typed_tag_block<s_s_cui_animation_component_property_argb_color_definition> argb_color_properties_block;
			c_typed_tag_block<s_cuianimationcomponentpropertystringiddefinition> stringid_properties_block;
			char generated_pad9eda[4]; // padding
		};
		static_assert(sizeof(s_s_cui_animation_component_definition) == 56, "struct s_s_cui_animation_component_definition is invalid size");

		struct s_s_cui_animation_definition
		{
			string_id name;
			real time_base_offset;
			real time_exponential_offset;
			c_enum<e_cuianimationinputtype, char> animation_input;
			char generated_pad21f2[3]; // padding
			c_typed_tag_block<s_s_cui_animation_component_definition> components_block;
		};
		static_assert(sizeof(s_s_cui_animation_definition) == 28, "struct s_s_cui_animation_definition is invalid size");

		struct s_cuianimatedcomponentlookup
		{
			qword component_id;
		};
		static_assert(sizeof(s_cuianimatedcomponentlookup) == 8, "struct s_cuianimatedcomponentlookup is invalid size");

		struct s_s_cui_overlay_definition
		{
			string_id resolution;
			string_id theme;
			c_typed_tag_block<s_s_cui_component_properties_definition> components_block;
			c_typed_tag_block<s_s_cui_animation_definition> animations_block;
			c_typed_tag_block<s_cuianimatedcomponentlookup> animated_component_lookup_block;
		};
		static_assert(sizeof(s_s_cui_overlay_definition) == 44, "struct s_s_cui_overlay_definition is invalid size");

		struct s_s_cui_property_editor_only_definition
		{
			string_id name;
			c_flags<e_f_cui_editor_property_info_flags, char, k_f_cui_editor_property_info_flags_count> flags;
			char generated_padd370[3]; // padding
		};
		static_assert(sizeof(s_s_cui_property_editor_only_definition) == 8, "struct s_s_cui_property_editor_only_definition is invalid size");

		struct s_s_cui_component_editor_only_definition
		{
			qword component_id;
			string_id name;
			c_typed_tag_block<s_s_cui_property_editor_only_definition> properties_editor_only_block;
		};
		static_assert(sizeof(s_s_cui_component_editor_only_definition) == 24, "struct s_s_cui_component_editor_only_definition is invalid size");

		struct s_s_cui_animation_editor_only_definition
		{
			string_id name;
			c_typed_tag_block<s_s_cui_component_editor_only_definition> components_editor_only_block;
		};
		static_assert(sizeof(s_s_cui_animation_editor_only_definition) == 16, "struct s_s_cui_animation_editor_only_definition is invalid size");

		struct s_s_cui_overlay_editor_only_definition
		{
			string_id resolution;
			string_id theme;
			c_flags<e_f_cui_editor_overlay_info_flags, char, k_f_cui_editor_overlay_info_flags_count> flags;
			char generated_pade8bb[3]; // padding
			c_typed_tag_block<s_s_cui_component_editor_only_definition> components_editor_only_block;
			c_typed_tag_block<s_s_cui_animation_editor_only_definition> animations_editor_only_block;
		};
		static_assert(sizeof(s_s_cui_overlay_editor_only_definition) == 36, "struct s_s_cui_overlay_editor_only_definition is invalid size");

		struct s_s_cui_binding_conversion_long_comparison_definition
		{
			c_enum<e_e_cui_binding_conversion_comparison_operator, char> comparison_operator;
			char generated_pad0669[3]; // padding
			long comparison_value;
		};
		static_assert(sizeof(s_s_cui_binding_conversion_long_comparison_definition) == 8, "struct s_s_cui_binding_conversion_long_comparison_definition is invalid size");

		struct s_s_cui_property_binding_definition
		{
			c_flags<e_c_cui_property_binding_definition_flags, short, k_c_cui_property_binding_definition_flags_count> flags;
			c_enum<e_e_cui_binding_conversion_function, short> conversion_function;
			string_id source_component_typename;
			qword source_component_id;
			string_id source_component_name;
			string_id source_property_name;
			qword target_component_id;
			string_id target_component_name;
			string_id target_property_name;
			c_typed_tag_block<s_s_cui_binding_conversion_long_comparison_definition> binding_conversion_long_comparison_block;
			char generated_padd9a1[4]; // padding
		};
		static_assert(sizeof(s_s_cui_property_binding_definition) == 56, "struct s_s_cui_property_binding_definition is invalid size");

		struct s_s_cui_static_data_column_definition
		{
			string_id name;
			c_enum<e_e_cui_property_type, short> type;
			char generated_pad3684[2]; // padding
		};
		static_assert(sizeof(s_s_cui_static_data_column_definition) == 8, "struct s_s_cui_static_data_column_definition is invalid size");

		struct s_s_cui_static_data
		{
			c_typed_tag_block<s_s_cui_static_data_column_definition> columns_block;
			c_typed_tag_block<s_s_cui_properties_definition> rows_block;
		};
		static_assert(sizeof(s_s_cui_static_data) == 24, "struct s_s_cui_static_data is invalid size");

		struct s_s_cui_static_data_definition
		{
			qword definition_id;
			string_id name;
			string_id mock_data_for_component;
			s_s_cui_static_data static_data;
		};
		static_assert(sizeof(s_s_cui_static_data_definition) == 40, "struct s_s_cui_static_data_definition is invalid size");

		struct s_s_cui_expression_step_definition
		{
			c_enum<e_e_cui_expression_step_type, char> step_type;
			c_enum<e_e_cui_expression_operator, char> _operator;
			c_enum<e_e_cui_expression_variable, char> variable;
			char generated_pad656d[1]; // padding
			real value;
			string_id string_id_value;
		};
		static_assert(sizeof(s_s_cui_expression_step_definition) == 12, "struct s_s_cui_expression_step_definition is invalid size");

		struct s_s_cui_expression_definition
		{
			qword expression_id;
			string_id name;
			c_static_string<256> expression_text;
			c_typed_tag_block<s_s_cui_expression_step_definition> steps_block;
		};
		static_assert(sizeof(s_s_cui_expression_definition) == 280, "struct s_s_cui_expression_definition is invalid size");

		struct s_s_cuivisualstatedefinition
		{
			qword visual_state_id;

			/* Trigger Binding */

			s_s_cui_property_binding_definition trigger_binding$2;

			/* Animation */

			s_s_cui_animation_definition animation$2;
			char generated_pad3137[4]; // padding
		};
		static_assert(sizeof(s_s_cuivisualstatedefinition) == 96, "struct s_s_cuivisualstatedefinition is invalid size");

		struct s_s_cuivisualstategroupdefinition
		{
			string_id name;
			char generated_pada5a8[4]; // padding
			qword visual_state_group_id;
			qword context_component_id;
			c_typed_tag_block<s_s_cuivisualstatedefinition> visual_states_block;
			char generated_padbf89[4]; // padding
		};
		static_assert(sizeof(s_s_cuivisualstategroupdefinition) == 40, "struct s_s_cuivisualstategroupdefinition is invalid size");

		struct s_telemetryblock
		{
			c_flags<e_enabletelemetry, char, k_enabletelemetry_count> should_track_telemetry;
			c_static_string<32> telemetry_category_name;
			c_static_string<32> telemetry_sub_category_name;
		};
		static_assert(sizeof(s_telemetryblock) == 65, "struct s_telemetryblock is invalid size");

		struct s_cuisystemdefinition
		{
			c_typed_tag_block<s_cuitemplateinstantiationdefinition> template_instantiations_block;
			c_typed_tag_block<s_s_cui_component_definition> components_block;
			c_typed_tag_block<s_s_cui_component_index_definition> component_indices_block;
			c_typed_tag_block<s_cuidonotcreatescreendefinition> do_not_create_list_block;
			c_typed_tag_block<s_s_cui_overlay_definition> overlays_block;
			c_typed_tag_block<s_s_cui_overlay_editor_only_definition> overlays_editor_only_block;
			c_typed_tag_block<s_s_cui_property_binding_definition> property_bindings_block;
			c_typed_tag_block<s_s_cui_static_data_definition> static_data_tables_block;
			c_typed_tag_block<s_s_cui_expression_definition> expressions_block;
			c_typed_tag_block<s_s_cuivisualstategroupdefinition> visual_state_groups_block;
			c_typed_tag_block<s_cuianimatedcomponentlookup> visual_state_component_lookup_block;
			c_typed_tag_reference<UI_SAMPLE_DATA_TAG> sample_data_tag_path;
			// custom telemetry_data
			s_telemetryblock telemetry_data;
			// custom value
			c_enum<e_layouttype, char> layout_type;
			char generated_pad6c61[2]; // padding
		};
		static_assert(sizeof(s_cuisystemdefinition) == 216, "struct s_cuisystemdefinition is invalid size");

		struct s_cuiscreendefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_stringfilereferences> string_references_block;
			c_typed_tag_block<s_resourcefilereferences> resource_references_block;
			s_cuisystemdefinition system;
			c_typed_tag_reference<LUA_SCRIPT_TAG> script;
			string_id name;
			long object_count_budget;
		};
		static_assert(sizeof(s_cuiscreendefinition) == 280, "struct s_cuiscreendefinition is invalid size");

		struct s_s_cui_static_data_group_definition
		{
			s_anytag_struct_definition anytag;
			s_s_cui_static_data static_data;
		};
		static_assert(sizeof(s_s_cui_static_data_group_definition) == 40, "struct s_s_cui_static_data_group_definition is invalid size");

		struct s_coatingparameterregisterinfo
		{
			word register_offset;
			word register_size;
		};
		static_assert(sizeof(s_coatingparameterregisterinfo) == 4, "struct s_coatingparameterregisterinfo is invalid size");

		struct s_coatingmaterialtemplatereference
		{
			c_typed_tag_reference<MATERIAL_TAG> coatingmaterialtemplate;
			c_flags<e_coatingtemplateoptionflags, char, k_coatingtemplateoptionflags_count> supported_coating_features_flags;
			char generated_pad410b[3]; // padding
			c_typed_tag_block<s_coatingparameterregisterinfo> parameterregisterinfo_block;
		};
		static_assert(sizeof(s_coatingmaterialtemplatereference) == 32, "struct s_coatingmaterialtemplatereference is invalid size");

		struct s_coatingmaterialsettag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_coatingmaterialtemplatereference> defaultmaterial_block;
			c_typed_tag_block<s_coatingmaterialtemplatereference> perlayeremissivematerial_block;
			long long m_pipelinestates;
		};
		static_assert(sizeof(s_coatingmaterialsettag) == 48, "struct s_coatingmaterialsettag is invalid size");

		struct s_i343malleablepropertybasefloatstructdefinition
		{
			real base_value;
			real_bounds value_bounds;
		};
		static_assert(sizeof(s_i343malleablepropertybasefloatstructdefinition) == 12, "struct s_i343malleablepropertybasefloatstructdefinition is invalid size");

		struct s_i343contenttagsrechargespeedmultipliercurve
		{
			// custom mapping
			s_functiondefinition mapping;
		};
		static_assert(sizeof(s_i343contenttagsrechargespeedmultipliercurve) == 20, "struct s_i343contenttagsrechargespeedmultipliercurve is invalid size");

		struct s_i343contenttagssegmentedrechargefraction
		{
			real_fraction vitality_percentage;
		};
		static_assert(sizeof(s_i343contenttagssegmentedrechargefraction) == 4, "struct s_i343contenttagssegmentedrechargefraction is invalid size");

		struct s_i343contenttagsvariantspecification
		{
			string_id name;
		};
		static_assert(sizeof(s_i343contenttagsvariantspecification) == 4, "struct s_i343contenttagsvariantspecification is invalid size");

		struct s_i343contenttagsregiontransition
		{
			string_id region_name;
			c_enum<e_i343contenttagsdamagestate, char> next_state;
			char generated_padf208[3]; // padding
		};
		static_assert(sizeof(s_i343contenttagsregiontransition) == 8, "struct s_i343contenttagsregiontransition is invalid size");

		struct s_i343contenttagsdamagetransfer
		{
			c_flags<e_i343contenttagsdamagetransferflags, long, k_i343contenttagsdamagetransferflags_count> flags;
			real transfer_amount;
			c_enum<e_i343contenttagsdamagetransferfunction, short> transfer_function;
			short damage_section;
			string_id seat_label;
		};
		static_assert(sizeof(s_i343contenttagsdamagetransfer) == 16, "struct s_i343contenttagsdamagetransfer is invalid size");

		struct s_i343contenttagsejectionseat
		{
			string_id seat_label;
		};
		static_assert(sizeof(s_i343contenttagsejectionseat) == 4, "struct s_i343contenttagsejectionseat is invalid size");

		struct s_i343contenttagsinstantresponse
		{
			string_id label;
			c_flags<e_i343contenttagsdamageresponsepart1flags, long, k_i343contenttagsdamageresponsepart1flags_count> flags;
			c_flags<e_i343contenttagsdamageresponsepart2flags, long, k_i343contenttagsdamageresponsepart2flags_count> flags2;
			c_typed_tag_block<s_i343contenttagsvariantspecification> included_variants_block;
			c_typed_tag_block<s_i343contenttagsvariantspecification> excluded_variants_block;
			real damage_threshold;
			real_fraction minimum_damage_threshold;
			real_fraction skip_fraction;
			string_id forced_hard_ping_anim_;
			c_typed_tag_reference<EFFECT_TAG> generic_effect;
			string_id generic_effect_marker_name;
			c_typed_tag_reference<EFFECT_TAG> specific_effect;
			string_id specific_effect_marker_name;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> damage_effect;
			string_id damage_effect_marker_name;
			c_typed_tag_reference<EFFECT_TAG> looping_effect;
			// custom contextual_effects

			/* Contextual Transition Effects */

			string_id ray_cast_marker;
			real ray_cast_length;
			c_typed_tag_reference<VISUALMATERIALEFFECTSDEFINITION_TAG> visual_material_effects;
			c_typed_tag_reference<SOUNDMATERIALEFFECTSDEFINITION_TAG> sound_material_effects;
			c_typed_tag_reference<EFFECT_TAG> fallback_effect;
			string_id fallback_effect_marker;
			// custom value
			c_typed_tag_block<s_i343contenttagsregiontransition> region_transitions_block;
			c_typed_tag_block<s_i343contenttagsdamagetransfer> response_damage_transfers_block;
			// custom custom_response
			c_enum<e_i343contenttagsdamageresponsecustomresponsebehaviortype, short> custom_response_behavior;
			char generated_paddbdf[2]; // padding
			string_id custom_response_label;
			real response_delay;
			c_typed_tag_reference<EFFECT_TAG> delay_effect;
			// custom value
			string_id constraint_or_group_name;
			c_enum<e_i343contenttagsdamageresponseconstraintdamagetype, short> constraint_damage_type;
			char generated_pad8f2a[2]; // padding
			c_enum<e_i343contenttagsdamageresponseaidialogueeventtype, long> ai_dialog_event;
			c_typed_tag_block<s_i343contenttagsejectionseat> ejection_seats_block;
		};
		static_assert(sizeof(s_i343contenttagsinstantresponse) == 264, "struct s_i343contenttagsinstantresponse is invalid size");

		struct s_i343contenttagsdamagesection
		{
			string_id name;
			c_flags<e_i343contenttagsdamagesectionflags, long, k_i343contenttagsdamagesectionflags_count> flags;
			c_enum<e_i343contenttagsdamagepart, char> damage_part;
			char generated_pad46c5[3]; // padding
			// custom maximum_vitality_percentage
			s_i343malleablepropertybasefloatstructdefinition maximum_vitality_percentage;
			string_id shield_material_name;
			// custom stun
			real minimum_stun_damage;
			// custom stun_duration
			s_i343malleablepropertybasefloatstructdefinition stun_duration;
			// custom value
			// custom recharge
			real recharge_time;
			// custom recharge_speed_base_scalar
			s_i343malleablepropertybasefloatstructdefinition recharge_speed_base_scalar;
			c_typed_tag_block<s_i343contenttagsrechargespeedmultipliercurve> recharge_speed_curve_block;
			c_typed_tag_block<s_i343contenttagssegmentedrechargefraction> recharge_fractions_block;
			c_typed_tag_reference<EFFECT_TAG> recharging_effect;
			real pre_recharge_effect_warn_time;
			c_typed_tag_reference<EFFECT_TAG> pre_recharge_effect;
			string_id pre_recharge_effect_marker;
			c_typed_tag_reference<EFFECT_TAG> pre_recharge_abort_effect;
			string_id pre_recharge_abort_effect_marker;
			// custom value
			// custom overcharge
			real overcharge_time;
			real overcharge_fraction;
			// custom value
			// custom decay
			real pre_decay_time;
			real decay_time;
			// custom value
			// custom impact_fx
			c_typed_tag_reference<GENERATOR_SYSTEM_TAG> _3rd_person_impact_generator;
			c_typed_tag_reference<GENERATOR_SYSTEM_TAG> _1st_person_impact_generator;
			// custom value
			c_typed_tag_block<s_i343contenttagsinstantresponse> instant_responses_block;
			c_typed_tag_block<s_i343contenttagsdamagetransfer> section_damage_transfers_block;
		};
		static_assert(sizeof(s_i343contenttagsdamagesection) == 216, "struct s_i343contenttagsdamagesection is invalid size");

		struct s_i343contenttagsdamageconstraintinfo
		{
			string_id damage_constraint_name;
			string_id damage_constraint_group_name;
			real group_probability_scale;
		};
		static_assert(sizeof(s_i343contenttagsdamageconstraintinfo) == 12, "struct s_i343contenttagsdamageconstraintinfo is invalid size");

		struct s_i343contenttagsdamageinfo
		{
			real body_vitality_temp;
			c_flags<e_i343contenttagsdamageinfoflags, short, k_i343contenttagsdamageinfoflags_count> flags;
			char generated_padcbca[2]; // padding
			string_id indirect_material_name;
			short indirect_damage_section;
			short shielded_state_damage_section;
			c_typed_tag_block<s_i343contenttagsdamagesection> damage_sections_block;
			c_typed_tag_block<s_i343contenttagsdamageconstraintinfo> damage_constraints_block;
		};
		static_assert(sizeof(s_i343contenttagsdamageinfo) == 40, "struct s_i343contenttagsdamageinfo is invalid size");

		struct s_i343contenttagsmodeltarget
		{
			c_flags<e_i343contenttagsmodeltargetflags, char, k_i343contenttagsmodeltargetflags_count> flags;
			c_enum<e_i343contenttagsmodeltargettype, char> type;
			c_enum<e_i343contenttagsmodeltargetcategory, char> category;
			char generated_pad4a55[1]; // padding
			string_id marker_name;
			real radius;
			angle cone_angle;
			short damage_section;
			char generated_pad3074[2]; // padding
			string_id variant;
			real_fraction aim_assist_magnetism_scale;
			real_fraction ai_selection_priority_scale;
			real aoe_exclusion_radius;

			/* Lock-on fields */

			real lock_on_distance;
			string_id tracking_type;
		};
		static_assert(sizeof(s_i343contenttagsmodeltarget) == 44, "struct s_i343contenttagsmodeltarget is invalid size");

		struct s_damagetag
		{
			s_anytag_struct_definition anytag;
			s_i343contenttagsdamageinfo damage_info;
			c_typed_tag_block<s_i343contenttagsmodeltarget> model_targets_block;
			char generated_pada5a5[4]; // padding
		};
		static_assert(sizeof(s_damagetag) == 72, "struct s_damagetag is invalid size");

		struct s_lodtransition
		{
			real transition_start;
			real transition_end;
		};
		static_assert(sizeof(s_lodtransition) == 8, "struct s_lodtransition is invalid size");

		struct s_lodparameters
		{
			c_typed_tag_block<s_lodtransition> lod_transitions_block;
			real max_shadow_distance;
		};
		static_assert(sizeof(s_lodparameters) == 16, "struct s_lodparameters is invalid size");

		struct s_s_throttle_spec_control_setting_float
		{
			real_bounds very_low;
			real_bounds low;
			real_bounds medium;
			real_bounds high;
			real_bounds ultra;
			real _2_player_splitscreen;
			real _3_player_splitscreen;
			real _4_player_splitscreen;
		};
		static_assert(sizeof(s_s_throttle_spec_control_setting_float) == 52, "struct s_s_throttle_spec_control_setting_float is invalid size");

		struct s_s_basic_spec_control_setting_float
		{
			real very_low;
			real low;
			real medium;
			real high;
			real ultra;
			real _2_player_splitscreen;
			real _3_player_splitscreen;
			real _4_player_splitscreen;
		};
		static_assert(sizeof(s_s_basic_spec_control_setting_float) == 32, "struct s_s_basic_spec_control_setting_float is invalid size");

		struct s_parameteroverride
		{
			c_enum<e_overridenames, long> name;
			real value;
		};
		static_assert(sizeof(s_parameteroverride) == 8, "struct s_parameteroverride is invalid size");

		struct s_decoratorvariant
		{
			string_id visual_region_name;
			string_id geometry_name;
			string_id preset_name;
			c_enum<e_alignments, long> alignment;
			c_enum<e_tristate, long> random_rotate;
			// custom color_tint_triangle
			rgb_color tint_scale0;
			rgb_color tint_scale1;
			rgb_color tint_scale2;
			// custom value
			c_typed_tag_block<s_parameteroverride> parameter_overrides_block;
		};
		static_assert(sizeof(s_decoratorvariant) == 68, "struct s_decoratorvariant is invalid size");

		struct s_decoratorassettag
		{
			s_anytag_struct_definition anytag;
			// custom general
			c_typed_tag_reference<ASSET_TAG> asset;
			c_typed_tag_reference<DECORATOR_SETTINGS_TAG> settings;
			// custom value
			// custom lod_overrides
			s_lodparameters lod_settings;
			real first_lod_fade_factor;
			real last_lod_fade_factor;
			c_enum<e_lastloddesignation, long> last_lod_designation;
			// custom spec_control___lod_multiplier
			s_s_throttle_spec_control_setting_float lod_multiplier;
			s_s_basic_spec_control_setting_float distance_dither_start;
			real distance_dither_transition_width;
			s_s_basic_spec_control_setting_float distance_dither_density_multiplier;
			// custom value
			// custom value
			// custom terrain_influence
			real terrain_albedo_distance;
			real terrain_normal_distance;
			// custom value
			c_typed_tag_block<s_decoratorvariant> variants_block;
			c_typed_tag_reference<RUNTIME_DEC_TAG> reference_to_generated_decorator;
			long loaderror;
		};
		static_assert(sizeof(s_decoratorassettag) == 236, "struct s_decoratorassettag is invalid size");

		struct s_dispositioncolorentry
		{
			string_id name;

			/* sRGB Colors */

			argb_color in_world_color;
			argb_color outline_color;
			argb_color fx_color;

			/* Linear Colors */

			argb_color bitmap_color;
			argb_color kill_feed_color;
			argb_color motion_tracker_color;
			argb_color text_color;
			argb_color navpoint_color;
		};
		static_assert(sizeof(s_dispositioncolorentry) == 132, "struct s_dispositioncolorentry is invalid size");

		struct s_dispositioncolorgroupdefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_dispositioncolorentry> enemy_colors_block;
			c_typed_tag_block<s_dispositioncolorentry> friendly_colors_block;
			c_typed_tag_block<s_dispositioncolorentry> fireteam_colors_block;
			// custom neutral_colors
			s_dispositioncolorentry neutral_colors;
			// custom value
			// custom self_colors
			s_dispositioncolorentry self_colors;
			// custom value
			char generated_padbd10[4]; // padding
		};
		static_assert(sizeof(s_dispositioncolorgroupdefinition) == 320, "struct s_dispositioncolorgroupdefinition is invalid size");

		struct s_i343decoratorsdecoratorpaletteentry
		{
			c_typed_tag_reference<DECORATOR_ASSET_TAG> asset;
			word weight;
			char generated_pad3dd3[2]; // padding
		};
		static_assert(sizeof(s_i343decoratorsdecoratorpaletteentry) == 20, "struct s_i343decoratorsdecoratorpaletteentry is invalid size");

		struct s_i343decoratorsdecoratorpalette
		{
			string_id name;
			c_typed_tag_block<s_i343decoratorsdecoratorpaletteentry> entries_block;
		};
		static_assert(sizeof(s_i343decoratorsdecoratorpalette) == 16, "struct s_i343decoratorsdecoratorpalette is invalid size");

		struct s_i343decoratorsdecoratorpalettetag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343decoratorsdecoratorpalette> palettes_block;
			char generated_pade45f[4]; // padding
		};
		static_assert(sizeof(s_i343decoratorsdecoratorpalettetag) == 32, "struct s_i343decoratorsdecoratorpalettetag is invalid size");

		struct s_i343decoratorsdecoratorruntimetaglodparameters
		{
			long lod;
			c_enum<e_i343decoratorsruntimelodrenderfeatures, long> lod_features;
			real lod_start_distance;
			real lod_end_distance;
		};
		static_assert(sizeof(s_i343decoratorsdecoratorruntimetaglodparameters) == 16, "struct s_i343decoratorsdecoratorruntimetaglodparameters is invalid size");

		struct s_i343decoratorsdecoratorruntimetagvariantsettings
		{
			long mesh_index;
			c_flags<e_i343decoratorsruntimeplacementflagsdefinition, long, k_i343decoratorsruntimeplacementflagsdefinition_count> placement_flags;
			real_vector3d special_align_axis;
			real normalized_placement_weight;
			real min_separation;
			real min_block_size;
			real max_block_size;
			long max_block_items;
			real scale_min;
			real scale_max;
			real tilt_min;
			real tilt_max;
			real stiffness_min;
			real stiffness_max;
			real ground_tint_min;
			real ground_tint_max;
			real hover_min;
			real hover_max;
			real roughness_min;
			real roughness_max;
			real slope_cos_min;
			real slope_cos_max;
			real rotate_cos_min;
			real rotate_cos_max;
			rgb_color color_0;
			rgb_color color_1;
			rgb_color color_2;
		};
		static_assert(sizeof(s_i343decoratorsdecoratorruntimetagvariantsettings) == 140, "struct s_i343decoratorsdecoratorruntimetagvariantsettings is invalid size");

		struct s_geometry_material
		{
			c_typed_tag_reference<MATERIAL_TAG> material;
		};
		static_assert(sizeof(s_geometry_material) == 16, "struct s_geometry_material is invalid size");

		struct s_meshimportinfo
		{
			dword crc;
			real_point3d position_bounds_0;
			real_point3d position_bounds_1;
			real_point2d texcoord_bounds_0;
			real_point2d texcoord_bounds_1;
		};
		static_assert(sizeof(s_meshimportinfo) == 44, "struct s_meshimportinfo is invalid size");

		struct s_geometrynodeindex
		{
			byte node_index;
		};
		static_assert(sizeof(s_geometrynodeindex) == 1, "struct s_geometrynodeindex is invalid size");

		struct s_geometrynodeweight
		{
			real node_weight;
		};
		static_assert(sizeof(s_geometrynodeweight) == 4, "struct s_geometrynodeweight is invalid size");

		struct s_rawvertex
		{
			real_point3d position;
			real_point2d texcoord;
			real_point3d normal;
			real_point3d binormal;
			real_point3d tangent;
			real_point2d lightmap_texcoord;
			s_geometrynodeindex node_indices[8];
			s_geometrynodeweight node_weights[8];
			real_point3d vertex_color;
			real_point2d texcoord1;
			real dual_quat_weight;
			real vertex_alpha;
			real_point3d tangent_uv2;
			real_point2d texcoord2;
			real_point3d tangent_uv3;
		};
		static_assert(sizeof(s_rawvertex) == 164, "struct s_rawvertex is invalid size");

		struct s_wordindex
		{
			word _word;
		};
		static_assert(sizeof(s_wordindex) == 2, "struct s_wordindex is invalid size");

		struct s_dwordindex
		{
			dword _dword;
		};
		static_assert(sizeof(s_dwordindex) == 4, "struct s_dwordindex is invalid size");

		struct s_s_raw_water_append
		{
			real_point2d base_texcoord;
		};
		static_assert(sizeof(s_s_raw_water_append) == 8, "struct s_s_raw_water_append is invalid size");

		struct s_s_raw_water_data
		{
			c_typed_tag_block<s_wordindex> raw_water_indices_block;
			c_typed_tag_block<s_s_raw_water_append> raw_water_vertices_block;
		};
		static_assert(sizeof(s_s_raw_water_data) == 24, "struct s_s_raw_water_data is invalid size");

		struct s_rawblendshapevertex
		{
			real_vector3d position;
			real_vector3d normal;
			argb_color tension_and_ambient_occlusion;
			dword target_id;
		};
		static_assert(sizeof(s_rawblendshapevertex) == 44, "struct s_rawblendshapevertex is invalid size");

		struct s_rawtensionedge
		{
			dword start_vertex_index;
			dword end_vertex_index;
			real edge_rest_length;
		};
		static_assert(sizeof(s_rawtensionedge) == 12, "struct s_rawtensionedge is invalid size");

		struct s_rawtriangleedgeindexinfo
		{
			dword triangle_and_edge_index_pos;
			dword encoded_triangle_and_edge_size;
		};
		static_assert(sizeof(s_rawtriangleedgeindexinfo) == 8, "struct s_rawtriangleedgeindexinfo is invalid size");

		struct s_s_per_mesh_raw_data
		{
			c_typed_tag_block<s_rawvertex> raw_vertices_block;
			c_typed_tag_block<s_wordindex> raw_indices_block;
			c_typed_tag_block<s_dwordindex> raw_indices32_block;
			c_typed_tag_block<s_s_raw_water_data> raw_water_data_block;
			c_typed_tag_block<s_rawblendshapevertex> raw_blendshapes_block;
			c_typed_tag_block<s_dwordindex> raw_blendshapes_indices_block;
			c_typed_tag_block<s_rawtensionedge> raw_tension_edges_block;
			c_typed_tag_block<s_dwordindex> raw_blendshapes_triangle_and_edge_indices_block;
			c_typed_tag_block<s_rawtriangleedgeindexinfo> raw_blendshapes_triangle_and_edge_index_info_block;
			c_flags<e_permeshrawdataflags, long, k_permeshrawdataflags_count> flags;
		};
		static_assert(sizeof(s_s_per_mesh_raw_data) == 112, "struct s_s_per_mesh_raw_data is invalid size");

		struct s_positioningnodeweight
		{
			real node_weight;
		};
		static_assert(sizeof(s_positioningnodeweight) == 4, "struct s_positioningnodeweight is invalid size");

		struct s_s_positioning
		{
			real_plane3d plane;
			real_point3d position;
			real radius;
			s_geometrynodeindex node_indices[8];
			s_positioningnodeweight node_weights[7];
		};
		static_assert(sizeof(s_s_positioning) == 68, "struct s_s_positioning is invalid size");

		struct s_s_part
		{
			short material_index;
			short transparent_sorting_index;
			long index_start;
			long index_count;
			long permeshpartconstantsoffset;
			byte part_type;
			char generated_pad5c53[1]; // padding
			c_flags<e_partflags, short, k_partflags_count> part_flags;
			word budget_vertex_count;
			char generated_pad0f9e[2]; // padding
		};
		static_assert(sizeof(s_s_part) == 24, "struct s_s_part is invalid size");

		struct s_s_subpart
		{
			long index_start;
			long index_count;
			short part_index;
			word budget_vertex_count;
		};
		static_assert(sizeof(s_s_subpart) == 12, "struct s_s_subpart is invalid size");

		struct s_materialstreamingscale
		{
			long material_index;
			real material_scale;
		};
		static_assert(sizeof(s_materialstreamingscale) == 8, "struct s_materialstreamingscale is invalid size");

		struct s_lodrenderdatavertexbufferindex
		{
			word vertex_buffer_index;
		};
		static_assert(sizeof(s_lodrenderdatavertexbufferindex) == 2, "struct s_lodrenderdatavertexbufferindex is invalid size");

		struct s_lodrenderdata
		{
			c_typed_tag_block<s_s_per_mesh_raw_data> per_mesh_temporary_block;
			c_typed_tag_block<s_s_positioning> part_sorting_position_block;
			c_typed_tag_block<s_s_part> parts_block;
			c_typed_tag_block<s_s_subpart> subparts_block;
			c_typed_tag_block<s_materialstreamingscale> material_streaming_scale_block;
			s_lodrenderdatavertexbufferindex vertex_buffer_indices[19];
			word index_buffer_index;
			c_flags<e_lodflags, short, k_lodflags_count> lod_flags;
			c_flags<e_lodrenderflags, short, k_lodrenderflags_count> lod_render_flags;
		};
		static_assert(sizeof(s_lodrenderdata) == 104, "struct s_lodrenderdata is invalid size");

		struct s_meshvertexkey
		{
			long key1;
			long key2;
		};
		static_assert(sizeof(s_meshvertexkey) == 8, "struct s_meshvertexkey is invalid size");

		struct s_s_mesh
		{
			c_typed_tag_block<s_lodrenderdata> lod_render_data_block;
			c_flags<e_meshflags, short, k_meshflags_count> mesh_flags;
			byte rigid_node_index;
			c_enum<e_vertextype, char> vertex_type;
			char use_dual_quat;
			c_enum<e_indexbufferprimitivetype, char> index_buffer_type;
			short pca_mesh_index;
			c_typed_tag_block<s_meshvertexkey> vertex_keys_block;
			short clone_index;
			short optional_lod_volume_index;
			short procedural_deformation_remap_table;
			char generated_pad8fb3[2]; // padding
			long lod_state_cache_slot;
		};
		static_assert(sizeof(s_s_mesh) == 44, "struct s_s_mesh is invalid size");

		struct s_pcameshindex
		{
			long mesh_index;
		};
		static_assert(sizeof(s_pcameshindex) == 4, "struct s_pcameshindex is invalid size");

		struct s_s_compression_info
		{
			c_flags<e_compressionflags, short, k_compressionflags_count> compression_flags;
			char generated_pad1711[2]; // padding

			/* WARNING */

			real_point3d position_bounds_0;
			real_point3d position_bounds_1;
			real_point2d texcoord_bounds_0;
			real_point2d texcoord_bounds_1;
			real_point2d texcoord_bounds2_0;
			real_point2d texcoord_bounds2_1;
			real_point2d texcoord_bounds3_0;
			real_point2d texcoord_bounds3_1;
			real unused0;
			real unused1;
		};
		static_assert(sizeof(s_s_compression_info) == 84, "struct s_s_compression_info is invalid size");

		struct s_nodeindexstruct
		{
			word node_index;
		};
		static_assert(sizeof(s_nodeindexstruct) == 2, "struct s_nodeindexstruct is invalid size");

		struct s_s_per_mesh_node_map
		{
			c_typed_tag_block<s_nodeindexstruct> node_map_block;
		};
		static_assert(sizeof(s_s_per_mesh_node_map) == 12, "struct s_s_per_mesh_node_map is invalid size");

		struct s_rendergeometryanimatedmeshref
		{
			c_typed_tag_reference<ANIMATEDMESH_TAG> animated_mesh_tag_reference;
			string_id name;
		};
		static_assert(sizeof(s_rendergeometryanimatedmeshref) == 20, "struct s_rendergeometryanimatedmeshref is invalid size");

		struct s_s_render_geometry_lod_volume
		{
			real_point3d position_bounds_0;
			real_point3d position_bounds_1;
			c_typed_tag_block<s_s_positioning> position_data_block;
		};
		static_assert(sizeof(s_s_render_geometry_lod_volume) == 36, "struct s_s_render_geometry_lod_volume is invalid size");

		struct s_rendergeometrymeshpackageresourcegroup
		{
			s_tag_resource mesh_resource;
		};
		static_assert(sizeof(s_rendergeometrymeshpackageresourcegroup) == 8, "struct s_rendergeometrymeshpackageresourcegroup is invalid size");

		struct s_rendergeometrymeshpackageresourcelookup
		{
			short resource_group_index;
			short group_item_index;
		};
		static_assert(sizeof(s_rendergeometrymeshpackageresourcelookup) == 4, "struct s_rendergeometrymeshpackageresourcelookup is invalid size");

		struct s_rendergeometrymeshpackage
		{
			word flags;
			c_enum<e_rendergeometrymeshpackagepolicy, short> mesh_resource_packing_policy;
			word total_index_buffer_count;
			word total_vertex_buffer_count;
			c_typed_tag_block<s_rendergeometrymeshpackageresourcegroup> mesh_resource_groups_block;
			c_typed_tag_block<s_rendergeometrymeshpackageresourcelookup> index_resource_look_up_block;
			c_typed_tag_block<s_rendergeometrymeshpackageresourcelookup> vertex_resource_look_up_block;
		};
		static_assert(sizeof(s_rendergeometrymeshpackage) == 44, "struct s_rendergeometrymeshpackage is invalid size");

		struct s_s_blendshape_compression_info
		{
			real_point3d position_scale;
			real_point3d position_offset;
			real_point3d normal_scale;
			real_point3d normal_offset;
			c_typed_tag_block<s_dwordindex> raw_target_hash_name_block;
		};
		static_assert(sizeof(s_s_blendshape_compression_info) == 60, "struct s_s_blendshape_compression_info is invalid size");

		struct s_rendergeometrydeformationparameter
		{
			string_id parameter_name;
			byte parameter_mode;
			char generated_pad8065[3]; // padding
			real constant_input;
		};
		static_assert(sizeof(s_rendergeometrydeformationparameter) == 12, "struct s_rendergeometrydeformationparameter is invalid size");

		struct s_rendergeometryproceduraldeformation
		{
			c_typed_tag_block<s_rendergeometrydeformationparameter> parameter_list_block;
			string_id procedural_deformation_function_name;
		};
		static_assert(sizeof(s_rendergeometryproceduraldeformation) == 16, "struct s_rendergeometryproceduraldeformation is invalid size");

		struct s_rendergeometryproceduralremaptable
		{
			c_typed_tag_block<s_wordindex> procedural_remap_table_block;
		};
		static_assert(sizeof(s_rendergeometryproceduralremaptable) == 12, "struct s_rendergeometryproceduralremaptable is invalid size");

		struct s_deformationparameterdefaultvalue
		{
			string_id parameter_name;
			real parameter_default_value;
		};
		static_assert(sizeof(s_deformationparameterdefaultvalue) == 8, "struct s_deformationparameterdefaultvalue is invalid size");

		struct s_s_render_geometry
		{
			c_flags<e_rendergeometryflags, long, k_rendergeometryflags_count> runtime_flags;
			c_typed_tag_block<s_meshimportinfo> meshes_import_info_block;
			c_typed_tag_block<s_s_mesh> meshes_block;
			c_typed_tag_block<s_pcameshindex> pca_mesh_indices_block;
			c_typed_tag_block<s_s_compression_info> compression_info_block;
			c_typed_tag_block<s_s_per_mesh_node_map> per_mesh_node_map_block;
			c_typed_tag_block<s_rendergeometryanimatedmeshref> optional_animated_mesh_tag_references_block;
			c_typed_tag_block<s_s_render_geometry_lod_volume> optional_lod_volumes_data_block;
			s_rendergeometrymeshpackage mesh_package;
			c_typed_tag_block<s_s_blendshape_compression_info> blendshape_compression_info_block;
			c_typed_tag_block<s_rendergeometryproceduraldeformation> blendshape_procedural_deformation_function_list_block;
			c_typed_tag_block<s_rendergeometryproceduralremaptable> procedural_deformation_function_remap_table_list_block;
			c_typed_tag_block<s_deformationparameterdefaultvalue> deformation_parameter_default_value_table_from_skeleton_block;
			char generated_paddf2d[4]; // padding
			long long permeshpartconstantbuffer;
		};
		static_assert(sizeof(s_s_render_geometry) == 192, "struct s_s_render_geometry is invalid size");

		struct s_materialconstant
		{
			real_quaternion _register;
		};
		static_assert(sizeof(s_materialconstant) == 16, "struct s_materialconstant is invalid size");

		struct s_i343decoratorsdecoratorruntimetag
		{
			s_anytag_struct_definition anytag;
			// custom lod_settings_and_transitions_ranges
			real first_lod_fadeout_factor;
			real last_lod_fadeout_factor;
			real max_shadow_range;
			real max_render_range;
			// custom spec_control___lod_multiplier
			s_s_throttle_spec_control_setting_float lod_multiplier;
			// custom value
			c_typed_tag_block<s_i343decoratorsdecoratorruntimetaglodparameters> lod_transitions_block;
			s_s_basic_spec_control_setting_float distance_dither_start;
			real distance_dither_transition_width;
			s_s_basic_spec_control_setting_float distance_dither_density_multiplier;
			// custom value
			// custom decorator_variant_settings
			c_typed_tag_block<s_i343decoratorsdecoratorruntimetagvariantsettings> settings_block;
			// custom value
			// custom terrain_influence
			real terrain_albedo_distance;
			real terrain_normal_distance;
			// custom value
			// custom geometry
			c_typed_tag_block<s_geometry_material> materials_block;
			char generated_pad96ec[4]; // padding
			s_s_render_geometry render_geometry;
			// custom value
			c_typed_tag_block<s_materialconstant> bounding_spheres_block;
			char generated_padb0cd[4]; // padding
			long long m_pipelinestates;
		};
		static_assert(sizeof(s_i343decoratorsdecoratorruntimetag) == 416, "struct s_i343decoratorsdecoratorruntimetag is invalid size");

		struct s_decoratorcontentparameters
		{
			c_enum<e_alignments, long> alignment;
			c_enum<e_tristate, long> random_rotate;
			real placement_weight;
			real separation_min;
			real scale_min;
			real scale_max;
			real tilt_min;
			real tilt_max;
			real stiffness_min;
			real stiffness_max;
			real ground_tint_min;
			real ground_tint_max;
			real hover_min;
			real hover_max;
			real roughness_min;
			real roughness_max;
			real slope_min;
			real slope_max;
			real rotate_min;
			real rotate_max;
		};
		static_assert(sizeof(s_decoratorcontentparameters) == 80, "struct s_decoratorcontentparameters is invalid size");

		struct s_decoratorpreset
		{
			string_id name;
			s_decoratorcontentparameters parameters;
		};
		static_assert(sizeof(s_decoratorpreset) == 84, "struct s_decoratorpreset is invalid size");

		struct s_decoratorsettingstag
		{
			s_anytag_struct_definition anytag;
			s_lodparameters lod_settings;
			c_typed_tag_block<s_decoratorpreset> presets_block;
			char generated_pad84de[4]; // padding
		};
		static_assert(sizeof(s_decoratorsettingstag) == 48, "struct s_decoratorsettingstag is invalid size");

		struct s_materialshaderfunctionparameter
		{
			c_enum<e_materialanimatedparametertype, long> type;
			string_id input_name;
			string_id range_name;
			c_enum<e_materialshaderfunctionparametermaterialfunctionoutputmodenum, char> output_modifier;
			char generated_pad8305[3]; // padding
			string_id output_modifier_input;
			real time_period;

			/* FUNCTION */

			// custom function
			s_functiondefinition function$2;
		};
		static_assert(sizeof(s_materialshaderfunctionparameter) == 44, "struct s_materialshaderfunctionparameter is invalid size");

		struct s_shaderparameter
		{
			string_id parameter_name;
			c_enum<e_materialparametertype, long> parameter_type;
			s_tag_reference bitmap;
			argb_color color;
			real _real;
			real_vector3d vector;
			long int_bool;
			s_tag_data _string;
			word bitmap_flags;
			word bitmap_filter_mode;
			word bitmap_address_mode;
			word bitmap_address_mode_x;
			word bitmap_address_mode_y;
			byte bitmap_extern_mode;
			byte bitmap_min_mipmap;
			byte bitmap_max_mipmap;
			char generated_padea44[3]; // padding
			real bitmap_blur_and_sharpen;
			c_flags<e_shaderparametershaderparameterflags, char, k_shaderparametershaderparameterflags_count> parameter_flags;
			char generated_pad0425[3]; // padding
			dword render_phases_used;
			dword shader_types_used;
			c_typed_tag_block<s_materialshaderfunctionparameter> function_parameters_block;
			word register_offset;
			word register_size;
			byte bitmap_extern_index;
			char generated_pad50da[3]; // padding
		};
		static_assert(sizeof(s_shaderparameter) == 132, "struct s_shaderparameter is invalid size");

		struct s_materialpostprocesstexture
		{
			c_typed_tag_reference<BITMAP_TAG> bitmap_reference;
			dword render_phase_mask;
			dword shader_stage_mask;
			word frame_index_parameter;
			word sampler_index;
			word transform_register_index;
			word bindless_parameter_register_offset;
			byte extern_texture_mode;
			byte extern_texture_index;
			char generated_pad0c27[2]; // padding
			long long m_samplerstateview;
		};
		static_assert(sizeof(s_materialpostprocesstexture) == 44, "struct s_materialpostprocesstexture is invalid size");

		struct s_materialfunctionparameter
		{
			byte function_index;
			byte register_offset;
			byte parameter_group;
			char generated_padfe04[1]; // padding
			dword render_phase_mask;
		};
		static_assert(sizeof(s_materialfunctionparameter) == 8, "struct s_materialfunctionparameter is invalid size");

		struct s_materialexternparameter
		{
			byte extern_index;
			byte extern_offset;
			byte parameter_group;
			char generated_paddcf2[1]; // padding
			word bindless_parameter_register_offset;
			char generated_pad29a7[2]; // padding
			dword render_phase_mask;
		};
		static_assert(sizeof(s_materialexternparameter) == 12, "struct s_materialexternparameter is invalid size");

		struct s_materialpostprocessdefinitionruntimequeryableproperty
		{
			byte index;
		};
		static_assert(sizeof(s_materialpostprocessdefinitionruntimequeryableproperty) == 1, "struct s_materialpostprocessdefinitionruntimequeryableproperty is invalid size");

		struct s_materialpostprocessdefinition
		{
			c_typed_tag_block<s_materialpostprocesstexture> textures_block;
			long textures_to_clear;
			c_typed_tag_block<s_materialshaderfunctionparameter> functions_block;
			c_typed_tag_block<s_materialfunctionparameter> function_parameters_block;
			c_typed_tag_block<s_materialexternparameter> extern_parameters_block;
			c_enum<e_alphablendmode, char> alpha_blend_mode;
			c_flags<e_materialpostprocessdefinitionruntimeflags, char, k_materialpostprocessdefinitionruntimeflags_count> runtime_flags;
			c_flags<e_materialpostprocessdefinitionmaterialpostprocessflags, short, k_materialpostprocessdefinitionmaterialpostprocessflags_count> flags;
			c_typed_tag_block<s_materialconstant> material_constants_block;
			c_typed_tag_block<s_materialconstant> alternate_constants_block;
			long long materialconstantbuffer;
			long long alternateconstantbuffer;
			dword material_constant_shader_stage_mask;
			s_materialpostprocessdefinitionruntimequeryableproperty runtime_queryable_properties_table[4];
		};
		static_assert(sizeof(s_materialpostprocessdefinition) == 104, "struct s_materialpostprocessdefinition is invalid size");

		struct s_material
		{
			s_tag_reference material_shader;
			c_typed_tag_block<s_shaderparameter> material_parameters_block;
			c_typed_tag_block<s_materialpostprocessdefinition> postprocess_definition_block;
			string_id physics_material_name;
			string_id physics_material_name_2;
			string_id physics_material_name_3;
			string_id physics_material_name_4;
			real sort_offset;
			c_enum<e_alphablendmode, char> alpha_blend_mode;
			c_enum<e_e_transparent_sort_layer, char> sort_layer;
			c_flags<e_materialmaterialflags, char, k_materialmaterialflags_count> flags;
			c_flags<e_materialmaterialrenderflags, char, k_materialmaterialrenderflags_count> render_flags;
			real taa_mask_threshold_start;
			real taa_mask_threshold_end;
		};
		static_assert(sizeof(s_material) == 72, "struct s_material is invalid size");

		struct s_c_decal_definition
		{
			c_typed_tag_reference<BITMAP_TAG> albedo_bitmap_reference;
			c_typed_tag_reference<BITMAP_TAG> normal_bitmap_reference;
			c_typed_tag_reference<BITMAP_TAG> control_bitmap_reference;
			c_typed_tag_reference<BITMAP_TAG> emissive_bitmap_reference;
			string_id decal_name;
			c_flags<e_c_decal_definitiondecalflags, long, k_c_decal_definitiondecalflags_count> flags;
			// custom material
			// custom value
			s_material actual_material;
			// custom value
			real_bounds radius;
			real_bounds lifespan;
			real clamp_angle;
			real cull_angle;
			real depth_bias;
			real runtime_bitmap_aspect;
			char generated_padf6b1[4]; // padding
			long long m_pipelinestates;
		};
		static_assert(sizeof(s_c_decal_definition) == 188, "struct s_c_decal_definition is invalid size");

		struct s_c_decal_system_definition
		{
			s_anytag_struct_definition anytag;
			c_flags<e_c_decal_system_definitiondecalsystemflags, long, k_c_decal_system_definitiondecalsystemflags_count> flags;
			real material_shader_fade_time;
			real_point2d decal_scale_override;

			/* Decal bucket sharing */

			short_bounds random_sprite_index_bounds;
			c_typed_tag_block<s_c_decal_definition> decals_block;
			real runtime_max_radius;
			char generated_pad2745[4]; // padding
			long long decaldefinitionconstants;
		};
		static_assert(sizeof(s_c_decal_system_definition) == 64, "struct s_c_decal_system_definition is invalid size");

		struct s_i343damagedamageeffectsoundsdefinition
		{
			s_anytag_struct_definition anytag;
			real dealt_cooldown;
			real received_cooldown;
			// custom player_dealt_damage
			s_tag_reference dealt_normal_hit;
			s_tag_reference dealt_weakpoint_hit;
			s_tag_reference dealt_stuck;
			s_tag_reference dealt_ineffective_hit;
			s_tag_reference dealt_vehicle_hit;
			s_tag_reference dealt_vehicle_weakpoint_hit;
			s_tag_reference dealt_vehicle_stuck;
			s_tag_reference dealt_friendly_hit;
			s_tag_reference dealt_lethal_hit;
			s_tag_reference dealt_lethal_weakpoint_hit;
			s_tag_reference dealt_aoe_hit;
			s_tag_reference dealt_aoe_vehicle_hit;
			s_tag_reference dealt_vehicle_passenger_hit;
			s_tag_reference dealt_shield_break;
			s_tag_reference model_hit;
			s_tag_reference dealt_lethal_minor;
			s_tag_reference dealt_boss_hit;
			// custom value
			// custom player_received_damage
			s_tag_reference received_normal_hit;
			s_tag_reference received_weakpoint_hit;
			s_tag_reference received_stuck;
			s_tag_reference received_ineffective_hit;
			s_tag_reference received_vehicle_hit;
			s_tag_reference received_vehicle_weakpoint_hit;
			s_tag_reference received_vehicle_stuck;
			s_tag_reference received_friendly_hit;
			s_tag_reference received_lethal_hit;
			s_tag_reference received_lethal_weakpoint_hit;
			s_tag_reference received_aoe_hit;
			s_tag_reference received_aoe_vehicle_hit;
			// custom value
			char generated_pad82f1[4]; // padding
		};
		static_assert(sizeof(s_i343damagedamageeffectsoundsdefinition) == 492, "struct s_i343damagedamageeffectsoundsdefinition is invalid size");

		struct s_i343darkroomdarkroomlightingspecreferencedefinition
		{
			c_typed_tag_reference<DARKROOMLIGHTINGSPEC_TAG> lighting_specs;
		};
		static_assert(sizeof(s_i343darkroomdarkroomlightingspecreferencedefinition) == 16, "struct s_i343darkroomdarkroomlightingspecreferencedefinition is invalid size");

		struct s_i343darkroomdarkroomassetspecreferencedefinition
		{
			c_typed_tag_reference<DARKROOMASSETSPEC_TAG> asset_spec;
		};
		static_assert(sizeof(s_i343darkroomdarkroomassetspecreferencedefinition) == 16, "struct s_i343darkroomdarkroomassetspecreferencedefinition is invalid size");

		struct s_i343darkroomdarkroomcameraspecreferencedefinition
		{
			c_typed_tag_reference<DARKROOMCAMERASPEC_TAG> camera_spec;
		};
		static_assert(sizeof(s_i343darkroomdarkroomcameraspecreferencedefinition) == 16, "struct s_i343darkroomdarkroomcameraspecreferencedefinition is invalid size");

		struct s_i343darkroomdarkroomrenderspecreferencedefinition
		{
			c_typed_tag_reference<DARKROOMRENDERSETTINGSSPEC_TAG> render_spec;
		};
		static_assert(sizeof(s_i343darkroomdarkroomrenderspecreferencedefinition) == 16, "struct s_i343darkroomdarkroomrenderspecreferencedefinition is invalid size");

		struct s_i343darkroomdarkroomscreenshotspecreferencedefinition
		{
			c_typed_tag_reference<DARKROOMSCREENSHOTSETTINGSSPEC_TAG> screenshot_spec;
		};
		static_assert(sizeof(s_i343darkroomdarkroomscreenshotspecreferencedefinition) == 16, "struct s_i343darkroomdarkroomscreenshotspecreferencedefinition is invalid size");

		struct s_i343darkroomdarkroomanimationspecreferencedefinition
		{
			c_typed_tag_reference<DARKROOMANIMATIONSPEC_TAG> animation_specs;
		};
		static_assert(sizeof(s_i343darkroomdarkroomanimationspecreferencedefinition) == 16, "struct s_i343darkroomdarkroomanimationspecreferencedefinition is invalid size");

		struct s_i343darkroomdarkroomassemblydefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343darkroomdarkroomlightingspecreferencedefinition> lighting_specs_block;
			c_typed_tag_block<s_i343darkroomdarkroomassetspecreferencedefinition> asset_specs_block;
			c_typed_tag_block<s_i343darkroomdarkroomcameraspecreferencedefinition> camera_specs_block;
			c_typed_tag_block<s_i343darkroomdarkroomrenderspecreferencedefinition> render_specs_block;
			c_typed_tag_block<s_i343darkroomdarkroomscreenshotspecreferencedefinition> screenshot_specs_block;
			c_typed_tag_block<s_i343darkroomdarkroomanimationspecreferencedefinition> animation_specs_block;
		};
		static_assert(sizeof(s_i343darkroomdarkroomassemblydefinition) == 88, "struct s_i343darkroomdarkroomassemblydefinition is invalid size");

		struct s_i343darkroomassetspecdefinition
		{
			s_anytag_struct_definition anytag;
			c_flags<e_i343darkroomassetspecflags, long, k_i343darkroomassetspecflags_count> assetspecflags;
			c_typed_tag_reference<OBJECT_TAG> object;
			string_id variant;
			string_id external_name;
			c_typed_tag_reference<OBJECT_CONFIGURATION_TAG> configuration;
			c_typed_tag_reference<OBJECT_TAG> equipped_weapon;
			real weapon_scale;
			c_typed_tag_reference<DARKROOMASSETSPEC_TAG> inherit_transforms;
			real_vector3d position;
			real_vector3d rotation;
			real scale;
			char generated_pad7450[4]; // padding
		};
		static_assert(sizeof(s_i343darkroomassetspecdefinition) == 128, "struct s_i343darkroomassetspecdefinition is invalid size");

		struct s_i343darkroomcameraspecdefinition
		{
			s_anytag_struct_definition anytag;
			c_flags<e_i343darkroomcamerasettingsflags, char, k_i343darkroomcamerasettingsflags_count> flags;
			char generated_pad10db[3]; // padding
			c_typed_tag_reference<OBJECT_TAG> composition;
			real field_of_view;
			real_vector3d dof;
			c_typed_tag_reference<DARKROOMASSETSPEC_TAG> inherit_transforms;
			real_vector3d position;
			real_vector3d rotation;
			real_vector3d worldposition;
			real_vector3d worldrotation;
			real scale;
		};
		static_assert(sizeof(s_i343darkroomcameraspecdefinition) == 120, "struct s_i343darkroomcameraspecdefinition is invalid size");

		struct s_i343darkroomlightingspecdefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<LEVEL_TAG> level;
			string_id lighting_variant;
			string_id futurelightingrigfileordpk;
			char generated_pad5062[4]; // padding
		};
		static_assert(sizeof(s_i343darkroomlightingspecdefinition) == 44, "struct s_i343darkroomlightingspecdefinition is invalid size");

		struct s_i343darkroomanimationspecdefinition
		{
			s_anytag_struct_definition anytag;
			c_flags<e_i343darkroomanimationspecflags, char, k_i343darkroomanimationspecflags_count> flags;
			char generated_padc276[3]; // padding
			c_typed_tag_reference<OBJECT_TAG> animationfile;
			string_id animationvariation;
			string_id frames;
		};
		static_assert(sizeof(s_i343darkroomanimationspecdefinition) == 44, "struct s_i343darkroomanimationspecdefinition is invalid size");

		struct s_i343darkroomrendersettingspassspecdefinition
		{
			argb_color backgroundcolour;
			c_flags<e_i343darkroomrendersettingspassflags, long, k_i343darkroomrendersettingspassflags_count> flags;
		};
		static_assert(sizeof(s_i343darkroomrendersettingspassspecdefinition) == 20, "struct s_i343darkroomrendersettingspassspecdefinition is invalid size");

		struct s_i343darkroomrendersettingsspecdefinition
		{
			s_anytag_struct_definition anytag;
			c_static_string<32> resolutionvariant;
			c_typed_tag_block<s_i343darkroomrendersettingspassspecdefinition> renderingpasssequence_block;
			char generated_pada4f1[4]; // padding
		};
		static_assert(sizeof(s_i343darkroomrendersettingsspecdefinition) == 64, "struct s_i343darkroomrendersettingsspecdefinition is invalid size");

		struct s_i343darkroomassemblyreferencedefinition
		{
			c_typed_tag_reference<DARKROOMASSEMBLY_TAG> assembly;
		};
		static_assert(sizeof(s_i343darkroomassemblyreferencedefinition) == 16, "struct s_i343darkroomassemblyreferencedefinition is invalid size");

		struct s_i343darkroomshotlistdefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343darkroomassemblyreferencedefinition> shot_list_block;
			c_flags<e_i343darkroomshotlistflags, long, k_i343darkroomshotlistflags_count> screenshot_flags;
			real shot_pause_time;
			char generated_pad702b[4]; // padding
		};
		static_assert(sizeof(s_i343darkroomshotlistdefinition) == 40, "struct s_i343darkroomshotlistdefinition is invalid size");

		struct s_i343darkroomscreenshotsettingsspecdefinition
		{
			s_anytag_struct_definition anytag;
			short uprezfactor;
			c_static_string<256> outputdirectory;
			char generated_padd5ed[2]; // padding
			string_id nameprefix;
			string_id namesuffix;
			short namepadding;
			char generated_padbc0c[2]; // padding
			c_flags<e_i343darkroomscreenshotsettingspassflags, long, k_i343darkroomscreenshotsettingspassflags_count> flags;
			char generated_pad6f57[4]; // padding
		};
		static_assert(sizeof(s_i343darkroomscreenshotsettingsspecdefinition) == 296, "struct s_i343darkroomscreenshotsettingsspecdefinition is invalid size");

		struct s_s_damage_response_directional_flash_definition
		{
			real indicator_duration;
			real flash_duration_;
			c_enum<e_reversetransitionfunction, short> fade_function;
			char generated_pad5fa7[2]; // padding
			real center_size;
			real offscreen_size;
			real center_alpha;
			real offscreen_alpha;
			real inner_alpha;
			real outer_alpha;
			argb_color flash_color;
			argb_color arrow_color;
		};
		static_assert(sizeof(s_s_damage_response_directional_flash_definition) == 68, "struct s_s_damage_response_directional_flash_definition is invalid size");

		struct s_s_damage_response_motion_sensor_ping_definition
		{
			short ping_duration;
			short ping_scale;
		};
		static_assert(sizeof(s_s_damage_response_motion_sensor_ping_definition) == 4, "struct s_s_damage_response_motion_sensor_ping_definition is invalid size");

		struct s_s_damage_response_global_sound_effect_definition
		{
			string_id effect_name;
			// custom scale____duration
			s_functiondefinition scale____duration;
		};
		static_assert(sizeof(s_s_damage_response_global_sound_effect_definition) == 24, "struct s_s_damage_response_global_sound_effect_definition is invalid size");

		struct s_s_damage_response_class_definition
		{
			c_enum<e_damageresponseclasstype, short> type;
			c_flags<e_damageresponseclassflags, short, k_damageresponseclassflags_count> flags;

			/* directional flash */

			s_s_damage_response_directional_flash_definition directional_flash$2;

			/* motion sensor ping */

			s_s_damage_response_motion_sensor_ping_definition motion_sensor_ping$2;

			/* rumble */

			c_typed_tag_reference<RUMBLE_TAG> rumble$2;
			c_typed_tag_reference<RUMBLE_TAG> rumble_descope;

			/* camera shake and impulse data */

			c_typed_tag_reference<CAMERA_SHAKE_TAG> camera_shake;
			c_typed_tag_reference<CAMERA_SHAKE_TAG> camera_shake_zoomed;
			c_typed_tag_reference<CAMERA_SHAKE_TAG> camera_shake_descope;

			/* Flinch */

			c_typed_tag_reference<FLINCH_IMPULSE_TAG> flinch_impulse;
			c_typed_tag_reference<FLINCH_IMPULSE_TAG> flinch_impulse_ads;
			c_typed_tag_reference<FLINCH_IMPULSE_TAG> flinch_impulse_descope;

			/* simulated input */

			c_typed_tag_reference<SIMULATED_INPUT_TAG> simulated_input$2;
			c_typed_tag_reference<SIMULATED_INPUT_TAG> simulated_input_zoomed_;
			c_typed_tag_reference<SIMULATED_INPUT_TAG> simulated_input_descope_;

			/* global sound effect */

			c_typed_tag_block<s_s_damage_response_global_sound_effect_definition> global_sound_effect_block;
		};
		static_assert(sizeof(s_s_damage_response_class_definition) == 264, "struct s_s_damage_response_class_definition is invalid size");

		struct s_s_area_control_scalar_function
		{
			// custom mapping
			s_functiondefinition mapping;
		};
		static_assert(sizeof(s_s_area_control_scalar_function) == 20, "struct s_s_area_control_scalar_function is invalid size");

		struct s_s_area_control_scalar_object_function
		{
			string_id input_variable;
			string_id range_variable;
			// custom mapping
			s_functiondefinition mapping;
		};
		static_assert(sizeof(s_s_area_control_scalar_object_function) == 28, "struct s_s_area_control_scalar_object_function is invalid size");

		struct s_s_area_control_definition
		{

			/* AREA CONTROL */

			c_flags<e_areacontrolflags, short, k_areacontrolflags_count> flags;
			char generated_pad1e45[2]; // padding

			/* Distance Falloff */

			real maximum_distance;
			s_s_area_control_scalar_function distance_falloff$2;

			/* Angle Falloff */

			s_s_area_control_scalar_function angle_falloff$2;

			/* Object Falloff */

			s_s_area_control_scalar_object_function object_falloff$2;
		};
		static_assert(sizeof(s_s_area_control_definition) == 76, "struct s_s_area_control_definition is invalid size");

		struct s_s_damage_response_definition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_s_damage_response_class_definition> classes_block;
			c_typed_tag_block<s_s_area_control_definition> area_control_block;
		};
		static_assert(sizeof(s_s_damage_response_definition) == 40, "struct s_s_damage_response_definition is invalid size");

		struct s_i343damagedamagesourcereference
		{

			/* NOTE */

			string_id damage_source_name;
		};
		static_assert(sizeof(s_i343damagedamagesourcereference) == 4, "struct s_i343damagedamagesourcereference is invalid size");

		struct s_i343damageattachmentnamereference
		{

			/* NOTE */

			string_id attachment_name;
		};
		static_assert(sizeof(s_i343damageattachmentnamereference) == 4, "struct s_i343damageattachmentnamereference is invalid size");

		struct s_i343damageattachmentnamereferenceparam
		{
			// custom attachment_name

			/* Explanation */

			s_i343damageattachmentnamereference attachmentname;
			// custom value
		};
		static_assert(sizeof(s_i343damageattachmentnamereferenceparam) == 4, "struct s_i343damageattachmentnamereferenceparam is invalid size");

		struct s_i343damagedamagetypereference
		{

			/* NOTE */

			string_id damage_type_name;
		};
		static_assert(sizeof(s_i343damagedamagetypereference) == 4, "struct s_i343damagedamagetypereference is invalid size");

		struct s_interfacedamagedisplaydefinition
		{
			string_id display_name;
			c_typed_tag_reference<BITMAP_TAG> sprite_sheet;
			long sprite_index;
		};
		static_assert(sizeof(s_interfacedamagedisplaydefinition) == 24, "struct s_interfacedamagedisplaydefinition is invalid size");

		struct s_interfacedamagedisplaybydamagetype
		{
			// custom damage_type

			/* Explanation */

			s_i343damagedamagetypereference damagetype;
			// custom value
			s_interfacedamagedisplaydefinition displaydefinition;
		};
		static_assert(sizeof(s_interfacedamagedisplaybydamagetype) == 28, "struct s_interfacedamagedisplaybydamagetype is invalid size");

		struct s_interfacedamagedisplaybyattachmentlist
		{
			// custom attachment_list

			/* Explanation */

			c_typed_tag_block<s_i343damageattachmentnamereferenceparam> attachmentlist_block;
			// custom value
			c_typed_tag_block<s_interfacedamagedisplaybydamagetype> displaybydamagetype_block;
		};
		static_assert(sizeof(s_interfacedamagedisplaybyattachmentlist) == 24, "struct s_interfacedamagedisplaybyattachmentlist is invalid size");

		struct s_interfacedamagedisplaybydamagesource
		{
			// custom damage_source

			/* Explanation */

			s_i343damagedamagesourcereference damagesource;
			// custom value
			c_typed_tag_block<s_interfacedamagedisplaybyattachmentlist> displaybyattachmentlist_block;
		};
		static_assert(sizeof(s_interfacedamagedisplaybydamagesource) == 16, "struct s_interfacedamagedisplaybydamagesource is invalid size");

		struct s_interfacedamagereportingdisplayglobals
		{
			s_anytag_struct_definition anytag;

			/* Damage Reporting Display Map */

			c_typed_tag_block<s_interfacedamagedisplaybydamagesource> damagedisplaymap_block;
			char generated_padfae4[4]; // padding
		};
		static_assert(sizeof(s_interfacedamagereportingdisplayglobals) == 32, "struct s_interfacedamagereportingdisplayglobals is invalid size");

		struct s_response
		{
			string_id vocalization_name;
			short vocalization_index;
			c_enum<e_responsetype, char> response_type;
			char generated_padcb8f[1]; // padding
			c_enum<e_c_dialogue_event_enum, short> dialogue_event;
			c_enum<e_responsebehavior, char> response_behavior;
			char generated_pad7eda[1]; // padding
			long vocalization_index_offset_from_owner;
		};
		static_assert(sizeof(s_response) == 16, "struct s_response is invalid size");

		struct s_vocalization
		{
			string_id vocalization;
			short offset_from_parent;
			c_enum<e_dialoguepriority, short> priority;
			c_flags<e_vocalizationflags, char, k_vocalizationflags_count> flags;
			char generated_padbcab[1]; // padding
			c_enum<e_i343dialoguespeakervoice2d, short> _2d_speaker_voice;
			c_enum<e_glancetype, char> glance_behavior;
			c_enum<e_glancetype, char> glance_recipient_behavior;
			c_enum<e_perceptiontype, char> perception_type;
			char generated_pad6ff6[1]; // padding
			c_enum<e_actorcombatstatus, short> max_combat_status;
			c_enum<e_dialogueanimation, char> animation_impulse;
			char generated_pad2341[1]; // padding
			short proxy_dialogue_index;
			char generated_padd68c[2]; // padding
			real sound_repetition_delay;
			real allowable_queue_delay;
			real pre_voc_delay;
			real notification_delay;
			real post_voc_delay;
			real repeat_delay;
			real weight;
			real speaker_freeze_time;
			real listener_freeze_time;
			c_enum<e_e_facial_animation_emotions, short> speaker_emotion;
			c_enum<e_e_facial_animation_emotions, short> listener_emotion;
			real player_speaker_skip_fraction;
			real player_skip_fraction;
			real flood_skip_fraction;
			real skip_fraction;
			short mission_min_value;
			short mission_max_value;
			string_id sample_line;
			c_typed_tag_block<s_response> reponses_block;
		};
		static_assert(sizeof(s_vocalization) == 100, "struct s_vocalization is invalid size");

		struct s_dialoguestatetableexpressiontoken
		{
			string_id an_expression_token;
			long numeric_constant_if_applicable;
		};
		static_assert(sizeof(s_dialoguestatetableexpressiontoken) == 8, "struct s_dialoguestatetableexpressiontoken is invalid size");

		struct s_vocalizationpattern
		{
			c_enum<e_c_dialogue_event_enum, short> dialogue_type;
			short vocalization_index;
			string_id vocalization_name;
			c_enum<e_audiencetype, char> audience_type;
			c_enum<e_speakertypeenum, char> listener_target;
			c_enum<e_gametype, char> game_type;
			c_enum<e_hostilitytype, char> hostility;
			c_flags<e_patternflags, long, k_patternflags_count> flags;

			/* Subject */

			c_enum<e_actortype, short> subject_actor_type;
			c_enum<e_dialogueobjecttype, char> subject_type;
			char generated_padb5a9[1]; // padding
			string_id subject_ai_type_name;
			string_id subject_dialogue_system_metadata_label;
			string_id subject_weapon_name;
			string_id subject_location_influence;
			c_enum<e_dangerlevel, char> subject_min_danger_level;
			c_enum<e_dangerlevel, char> subject_max_danger_level;
			short subject_min_team_count;
			short subject_max_team_count;

			/* Cause */

			c_enum<e_actortype, short> cause_actor_type;
			c_enum<e_dialogueobjecttype, char> cause_type;
			char generated_pad9bc8[3]; // padding
			string_id cause_ai_type_name;
			string_id cause_dialogue_system_metadata_label;
			string_id cause_equipment_type_name;
			string_id cause_weapon_name;
			string_id cause_location_influence;
			c_enum<e_dangerlevel, char> cause_min_danger_level;
			c_enum<e_dangerlevel, char> cause_max_danger_level;
			short cause_min_team_count;
			short cause_max_team_count;

			/* Speaker */

			c_enum<e_speakertypeenum, char> speaker_type;
			c_enum<e_dialogueobjecttype, char> speaker_object_type;
			c_enum<e_speakerbehavior, char> speaker_behavior;
			c_enum<e_dangerlevel, char> speaker_min_danger_level;
			c_enum<e_dangerlevel, char> speaker_max_danger_level;
			c_enum<e_distancetype, char> speaker_subject_min_distance;
			c_enum<e_distancetype, char> speaker_subject_max_distance;
			c_enum<e_spatialrelation, char> speaker_subject_position;
			c_enum<e_distancetype, char> speaker_cause_min_distance;
			c_enum<e_distancetype, char> speaker_cause_max_distance;
			c_enum<e_spatialrelation, char> speaker_cause_position;
			char generated_pad4f13[3]; // padding
			c_flags<e_dialogueconditionflags, long, k_dialogueconditionflags_count> conditions;

			/* Matching */

			c_enum<e_distancetype, char> subject_cause_min_distance;
			c_enum<e_distancetype, char> subject_cause_max_distance;
			c_enum<e_spatialrelation, char> spatial_relation;
			char generated_padcf8a[1]; // padding
			c_enum<e_damagecategories, short> damage_category;
			char generated_pad82d5[2]; // padding
			// custom damage_type

			/* Explanation */

			s_i343damagedamagetypereference damage_type;
			// custom value
			// custom damage_source_name

			/* Explanation */

			s_i343damagedamagesourcereference damage_source_name;
			// custom value
			string_id vocalization_triggered;
			string_id dst_expression;
			c_typed_tag_block<s_dialoguestatetableexpressiontoken> dst_expression_tokens_block;
		};
		static_assert(sizeof(s_vocalizationpattern) == 128, "struct s_vocalizationpattern is invalid size");

		struct s_patterntypelookupdata
		{
			short start_index_postprocess;
			short length_postprocess;
		};
		static_assert(sizeof(s_patterntypelookupdata) == 4, "struct s_patterntypelookupdata is invalid size");

		struct s_involuntarydata
		{
			long involuntary_vocalization_index;
		};
		static_assert(sizeof(s_involuntarydata) == 4, "struct s_involuntarydata is invalid size");

		struct s_customeventdefinition
		{
			string_id event_name;
		};
		static_assert(sizeof(s_customeventdefinition) == 4, "struct s_customeventdefinition is invalid size");

		struct s_dialoguesystemdatatag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_vocalization> vocalizations_block;
			c_typed_tag_block<s_vocalizationpattern> patterns_block;
			c_typed_tag_block<s_patterntypelookupdata> pattern_type_look_up_data_block;
			c_typed_tag_block<s_involuntarydata> involuntary_data_block;
			c_typed_tag_block<s_customeventdefinition> content_defined_events_block;
			char generated_paddcb7[4]; // padding
		};
		static_assert(sizeof(s_dialoguesystemdatatag) == 80, "struct s_dialoguesystemdatatag is invalid size");

		struct s_primarysunresourcedefinition
		{
			long lens_flare_guid;
		};
		static_assert(sizeof(s_primarysunresourcedefinition) == 4, "struct s_primarysunresourcedefinition is invalid size");

		struct s_secondarysunresourcedefinition
		{
			long lens_flare_guid;
		};
		static_assert(sizeof(s_secondarysunresourcedefinition) == 4, "struct s_secondarysunresourcedefinition is invalid size");

		struct s_sunresourcesdefinition
		{
			s_primarysunresourcedefinition primary_sun_resource;
			c_typed_tag_block<s_secondarysunresourcedefinition> secondary_suns_resources_block;
		};
		static_assert(sizeof(s_sunresourcesdefinition) == 16, "struct s_sunresourcesdefinition is invalid size");

		struct s_dwsresourcesdefinition
		{
			s_sunresourcesdefinition suns_resources;
			real volume_poll_time;
		};
		static_assert(sizeof(s_dwsresourcesdefinition) == 20, "struct s_dwsresourcesdefinition is invalid size");

		struct s_dynamicsundefinition
		{
			c_flags<e_dynamicsunoverrideflagsdefinition, short, k_dynamicsunoverrideflagsdefinition_count> flags;
			char generated_pad846e[2]; // padding
			rgb_color primary_sun_color;
			short secondary_sun_resource_index;
			char generated_padd123[2]; // padding
			real intensity;
			real intensity_ev_scalar;
			real distance;
			real time_of_day_angle;
			real latitude_modifier;
			real azimuth;
			real season_modifier;
			real size;
		};
		static_assert(sizeof(s_dynamicsundefinition) == 52, "struct s_dynamicsundefinition is invalid size");

		struct s_dynamicprobedefinition
		{
			c_flags<e_dynamicprobeoverrideflagsdefinition, char, k_dynamicprobeoverrideflagsdefinition_count> flags;
			char generated_pad6cba[3]; // padding
			real probe_set_scalar;
			rgb_color probe_set_tint;
		};
		static_assert(sizeof(s_dynamicprobedefinition) == 20, "struct s_dynamicprobedefinition is invalid size");

		struct s_dynamicskydefinition
		{
			c_flags<e_dynamicskyoverrideflagsdefinition, long, k_dynamicskyoverrideflagsdefinition_count> flags;
			rgb_color static_tint;
			real static_tint_intensity;
			rgb_color sky_tint;
			rgb_color sky_color_positive_z;
			rgb_color sky_color_positive_x;
			rgb_color sky_color_negative_x;
			rgb_color sky_color_positive_y;
			rgb_color sky_color_negative_y;
			real sky_intensity;
			real sky_lighting_depth_scalar_near;
			real sky_lighting_depth_scalar_near_distance;
			real sky_lighting_depth_scalar_far;
			real sky_lighting_depth_scalar_far_distance;
			real probe_lighting_depth_scalar_near;
			real probe_lighting_depth_scalar_near_distance;
			real probe_lighting_depth_scalar_far;
			real probe_lighting_depth_scalar_far_distance;
			s_dynamicprobedefinition probe_set_0;
			s_dynamicprobedefinition probe_set_1;
			s_dynamicprobedefinition probe_set_2;
			s_dynamicprobedefinition probe_set_3;
		};
		static_assert(sizeof(s_dynamicskydefinition) == 208, "struct s_dynamicskydefinition is invalid size");

		struct s_dynamicatmospheredefinition
		{
			c_flags<e_dynamicatmosphereoverrideflagsdefinition, long, k_dynamicatmosphereoverrideflagsdefinition_count> flags;
			rgb_color sun_light_color;
			real_vector3d wavelength_variance;
			real sun_disk_size;
			real atmosphere_density;
			real aerosol_density;
			real ozone_contribution;
			real camera_height;
			real rayleigh_scale;
			real mie_scale;
			real rayleigh_multiplied_tint_strength;
			rgb_color rayleigh_multiplied_tint;
			real rayleigh_additive_tint_strength;
			rgb_color rayleigh_additive_tint;
			real mie_multiplied_tint_strength;
			rgb_color mie_multiplied_tint;
			real mie_additive_tint_strength;
			rgb_color mie_additive_tint;
			real atmospheric_scattering_alpha;
			real falloff_min_alpha;
			real falloff_start;
			real falloff_end;
			real auto_exposure_scalar;
			real_vector3d falloff_direction;
		};
		static_assert(sizeof(s_dynamicatmospheredefinition) == 152, "struct s_dynamicatmospheredefinition is invalid size");

		struct s_dynamiccubemaptintingdefinition
		{
			c_flags<e_dynamiccubemaptintingoverrideflagsdefinition, char, k_dynamiccubemaptintingoverrideflagsdefinition_count> flags;
			char generated_pade3cc[3]; // padding
			rgb_color cubemap_tint;
			real cubemap_tint_intensity;
		};
		static_assert(sizeof(s_dynamiccubemaptintingdefinition) == 20, "struct s_dynamiccubemaptintingdefinition is invalid size");

		struct s_cameraexposureparameterdefinition
		{
			c_flags<e_cameraexposureoverrideflagsdefinition, long, k_cameraexposureoverrideflagsdefinition_count> flags;
			real exposure_lock;
			s_camera_fx_settingss_real_exposure_parameter exposure_parameters;
			s_camera_fx_settingscamerafxexposuresensitivity auto_exposure_sensitivity;
			s_camera_fx_settingscamerafxexposurepitchinfluence exposure_pitch_influence;
			s_camera_fx_settingscamerafxexposurecompensation exposure_compensation;

			/* EFFECT EXPOSURE OVERRIDE */

			c_typed_tag_reference<EFFECT_EXPOSURE_TAG> effect_exposure_override$2;
		};
		static_assert(sizeof(s_cameraexposureparameterdefinition) == 120, "struct s_cameraexposureparameterdefinition is invalid size");

		struct s_bloomparameterdefinition
		{
			c_flags<e_bloomoverrideflagsdefinition, long, k_bloomoverrideflagsdefinition_count> flags;
			s_camera_fx_settingscamerafxbloomhighlight highlight;
			real highlight_offset;
			s_camera_fx_settingscamerafxbloomhighlightthreshold highlight_threshold;
			s_camera_fx_settingscamerafxbloominherent inherent;
			s_camera_fx_settingscamerafxbloomintensity intensity;
			s_camera_fx_settingscamerafxbloomlayerintensity layer_intensity;
			s_camera_fx_settingscamerafxbloomtintcolor tint_color;
		};
		static_assert(sizeof(s_bloomparameterdefinition) == 112, "struct s_bloomparameterdefinition is invalid size");

		struct s_selfillumscaleunscparameterdefinition
		{
			c_flags<e_selfillumscaleperraceoverrideflagsdefinition, char, k_selfillumscaleperraceoverrideflagsdefinition_count> flags;
			char generated_pad0718[3]; // padding
			c_flags<e_camerafxparameternoautoadjustflags, short, k_camerafxparameternoautoadjustflags_count> flags$2;
			char generated_pad7166[2]; // padding
			real parameter_value;
			real maximum_change;
			real blend_speed_0_1;
		};
		static_assert(sizeof(s_selfillumscaleunscparameterdefinition) == 20, "struct s_selfillumscaleunscparameterdefinition is invalid size");

		struct s_selfillumscalecovenantparameterdefinition
		{
			c_flags<e_selfillumscaleperraceoverrideflagsdefinition, char, k_selfillumscaleperraceoverrideflagsdefinition_count> flags;
			char generated_pad9d65[3]; // padding
			c_flags<e_camerafxparameternoautoadjustflags, short, k_camerafxparameternoautoadjustflags_count> flags$2;
			char generated_pad7166[2]; // padding
			real parameter_value;
			real maximum_change;
			real blend_speed_0_1;
		};
		static_assert(sizeof(s_selfillumscalecovenantparameterdefinition) == 20, "struct s_selfillumscalecovenantparameterdefinition is invalid size");

		struct s_selfillumscaleforerunnerparameterdefinition
		{
			c_flags<e_selfillumscaleperraceoverrideflagsdefinition, char, k_selfillumscaleperraceoverrideflagsdefinition_count> flags;
			char generated_padf24d[3]; // padding
			c_flags<e_camerafxparameternoautoadjustflags, short, k_camerafxparameternoautoadjustflags_count> flags$2;
			char generated_pad7166[2]; // padding
			real parameter_value;
			real maximum_change;
			real blend_speed_0_1;
		};
		static_assert(sizeof(s_selfillumscaleforerunnerparameterdefinition) == 20, "struct s_selfillumscaleforerunnerparameterdefinition is invalid size");

		struct s_selfillumparameterdefinition
		{
			c_flags<e_selfillumoverrideflagsdefinition, short, k_selfillumoverrideflagsdefinition_count> flags;
			char generated_pade077[2]; // padding
			s_camera_fx_settingscamerafxselfillumexposuresettings exposure;
			s_camera_fx_settingscamerafxselfillumscale scale;

			/* SELF ILLUM MATERIAL SHADER FUNCTION PARAMETER - (UNSC) */

			s_selfillumscaleunscparameterdefinition scale_unsc;

			/* SELF ILLUM MATERIAL SHADER FUNCTION PARAMETER - (Covenant) */

			s_selfillumscalecovenantparameterdefinition scale_covenant;

			/* SELF ILLUM MATERIAL SHADER FUNCTION PARAMETER - (Forerunner) */

			s_selfillumscaleforerunnerparameterdefinition scale_forerunner;
		};
		static_assert(sizeof(s_selfillumparameterdefinition) == 96, "struct s_selfillumparameterdefinition is invalid size");

		struct s_colorgradingparameterdefinition
		{
			c_flags<e_colorgradingoverrideflagsdefinition, long, k_colorgradingoverrideflagsdefinition_count> flags;
			s_camera_fx_settingss_color_grading_parameter parameters;
			real weight;
			real exposure;
			real saturation;
			real contrast;
			real contrast_midpoint;
			real_vector3d lift;
			real lift_luma;
			real_vector3d gamma;
			real gamma_luma;
			real_vector3d gain;
			real gain_luma;
		};
		static_assert(sizeof(s_colorgradingparameterdefinition) == 112, "struct s_colorgradingparameterdefinition is invalid size");

		struct s_deferredreflectionsparameterdefinition
		{
			c_flags<e_deferredreflectionsoverrideflagsdefinition, long, k_deferredreflectionsoverrideflagsdefinition_count> flags;
			s_camera_fx_settingsdeferredreflectionsparameter parameters;
		};
		static_assert(sizeof(s_deferredreflectionsparameterdefinition) == 152, "struct s_deferredreflectionsparameterdefinition is invalid size");

		struct s_ssaoparameterdefinition
		{
			c_flags<e_ssaooverrideflagsdefinition, char, k_ssaooverrideflagsdefinition_count> flags;
			char generated_pad05dc[1]; // padding
			c_flags<e_camerafxparameterenabledflags, short, k_camerafxparameterenabledflags_count> ssao_flags;
			c_flags<e_camerafxssaoflags, short, k_camerafxssaoflags_count> enable_flags;
			char generated_pad1fbd[2]; // padding
			real hemi_rejection_falloff;
			real gtao_intensity;
			real sun_ao;
			real spot_light_ao;
			real omni_light_ao;
		};
		static_assert(sizeof(s_ssaoparameterdefinition) == 28, "struct s_ssaoparameterdefinition is invalid size");

		struct s_lensdirtparameterdefinition
		{
			c_flags<e_lensdirtoverrideflagsdefinition, char, k_lensdirtoverrideflagsdefinition_count> flags;
			char generated_pad6457[3]; // padding
			s_camera_fx_settingss_camera_lens_dirt_parameter parameters;
		};
		static_assert(sizeof(s_lensdirtparameterdefinition) == 32, "struct s_lensdirtparameterdefinition is invalid size");

		struct s_contactshadowsparameterdefinition
		{
			c_flags<e_contactshadowsoverrideflagsdefinition, long, k_contactshadowsoverrideflagsdefinition_count> flags;
			s_camera_fx_settingscontactshadowsparameter parameters;
		};
		static_assert(sizeof(s_contactshadowsparameterdefinition) == 224, "struct s_contactshadowsparameterdefinition is invalid size");

		struct s_chromaticaberrationparameterdefinition
		{
			c_flags<e_chromaticaberrationoverrideflagsdefinition, short, k_chromaticaberrationoverrideflagsdefinition_count> flags;
			char generated_pad60a5[2]; // padding
			long enabled;
			real weight;
		};
		static_assert(sizeof(s_chromaticaberrationparameterdefinition) == 12, "struct s_chromaticaberrationparameterdefinition is invalid size");

		struct s_dynamiccamerafxdefinition
		{
			c_flags<e_dynamiccamerafxoverrideflagsdefinition, short, k_dynamiccamerafxoverrideflagsdefinition_count> flags;
			char generated_pad44bb[2]; // padding
			s_cameraexposureparameterdefinition exposure;
			s_bloomparameterdefinition bloom;
			s_selfillumparameterdefinition self_illum;
			s_colorgradingparameterdefinition color_grading;
			s_deferredreflectionsparameterdefinition deferred_reflections;
			s_ssaoparameterdefinition ssao;
			s_lensdirtparameterdefinition lens_dirt;
			s_contactshadowsparameterdefinition contact_shadows;
			s_chromaticaberrationparameterdefinition chromatic_aberration;
		};
		static_assert(sizeof(s_dynamiccamerafxdefinition) == 892, "struct s_dynamiccamerafxdefinition is invalid size");

		struct s_atmosphericscatteringfogparameterdefinition
		{
			c_flags<e_atmosphericscatteringfogoverrideflagsdefinition, long, k_atmosphericscatteringfogoverrideflagsdefinition_count> flags;
			real fog_extinction_offset;
			real fog_extinction_fade_distance;
			real fog_mie_extinction_fade_distance;
			real fog_depth_scale;
			real bruneton_fog_intensity;
			real old_height_fog_intensity;
			real fog_falloff_start;
			real fog_falloff_end;
			real fog_sky_falloff_start;
			real fog_sky_falloff_end;
			real bruneton_fog_falloff_start_up;
			real bruneton_fog_falloff_end_up;
			real bruneton_fog_falloff_start_down;
			real bruneton_fog_falloff_end_down;
			real bruneton_fog_falloff_power;
			real sky_contribution;
			real rayleigh_strength;
			real mie_strength;
			real inscattering_strength;
			real fake_inscattering_intensity;
			real fake_inscattering_distance;
			real fake_inscattering_extinction;
			rgb_color fake_inscattering_color;
		};
		static_assert(sizeof(s_atmosphericscatteringfogparameterdefinition) == 104, "struct s_atmosphericscatteringfogparameterdefinition is invalid size");

		struct s_s_ceiling_fog_parameters
		{
			c_flags<e_ceilingfogflags, long, k_ceilingfogflags_count> flags;
			real base_height;
			real fog_height;
			real fog_thickness;
			real fog_falloff_end;
			rgb_color fog_color;
			real fog_color_intensity;
		};
		static_assert(sizeof(s_s_ceiling_fog_parameters) == 36, "struct s_s_ceiling_fog_parameters is invalid size");

		struct s_ceilingfogparameterdefinition
		{
			c_flags<e_ceilingfogoverrideflagsdefinition, short, k_ceilingfogoverrideflagsdefinition_count> flags;
			char generated_pad488b[2]; // padding
			s_s_ceiling_fog_parameters fog_parameters;
		};
		static_assert(sizeof(s_ceilingfogparameterdefinition) == 40, "struct s_ceilingfogparameterdefinition is invalid size");

		struct s_s_solofogfunction
		{
			// custom fog_function
			s_functiondefinition mapping;
		};
		static_assert(sizeof(s_s_solofogfunction) == 20, "struct s_s_solofogfunction is invalid size");

		struct s_s_solo_fog_parameters
		{
			c_flags<e_solofogflags, long, k_solofogflags_count> flags;
			real base_height;
			real fog_height;
			real fog_thickness;
			real fog_falloff_end;
			rgb_color fog_color;
			real fog_color_intensity;
			c_typed_tag_block<s_s_solofogfunction> function_block;
		};
		static_assert(sizeof(s_s_solo_fog_parameters) == 48, "struct s_s_solo_fog_parameters is invalid size");

		struct s_depthfogparameterdefinition
		{
			c_flags<e_depthfogoverrideflagsdefinition, short, k_depthfogoverrideflagsdefinition_count> flags;
			char generated_pad1b09[2]; // padding
			s_s_solo_fog_parameters fog_parameters;
		};
		static_assert(sizeof(s_depthfogparameterdefinition) == 52, "struct s_depthfogparameterdefinition is invalid size");

		struct s_volumetricfogparameterdefinition
		{
			c_flags<e_volumetricfogoverrideflagsdefinition, long, k_volumetricfogoverrideflagsdefinition_count> flags;
			// custom volumetric_fog
			c_flags<e_volumetricfogflags, long, k_volumetricfogflags_count> volfog_flags;
			rgb_color volfog_color_1;
			rgb_color volfog_color_2;
			real volfog_density;
			real volfog_indirect_light_intensity;
			real volfog_light_intensity;
			real volfog_ambient_intensity;
			real volfog_sun_intensity;
			real volfog_near_range;
			real volfog_far_range;
			real volfog_range_exponent;
			real volfog_reprojection_weight;
			real volfog_inscatter_scale;
			real volfog_terrain_density_low;
			real volfog_terrain_density_high;
			real volfog_maximum_terrain_fog_height;
			real volfog_terrain_fog_falloff_exponent;
			real volfog_noise_scale;
			real volfog_noise_wind_influence;
			real volfog_noise_input_min;
			real volfog_noise_input_max;
			real volfog_noise_output_min;
			real volfog_noise_output_max;
			real volfog_noise_terrain_follow_intensity;
			real volfog_natural_light_near_intensity;
			real volfog_natural_light_far_intensity;
			real volfog_natural_light_range_near;
			real volfog_natural_light_range_far;
			real volfog_local_light_near_intensity;
			real volfog_local_light_far_intensity;
			real volfog_local_light_range_near;
			real volfog_local_light_range_far;
			// custom value
		};
		static_assert(sizeof(s_volumetricfogparameterdefinition) == 148, "struct s_volumetricfogparameterdefinition is invalid size");

		struct s_speccontrolsplitscreenvaluesfloat
		{
			real single_player;
			real _2_player_splitscreen;
			real _3_player_splitscreen;
			real _4_player_splitscreen;
		};
		static_assert(sizeof(s_speccontrolsplitscreenvaluesfloat) == 16, "struct s_speccontrolsplitscreenvaluesfloat is invalid size");

		struct s_speccontrolnodefloatexact
		{
			c_enum<e_i343speccontrolgraphicsoptions, char> type;
			char generated_pad4417[3]; // padding
			s_speccontrolsplitscreenvaluesfloat low;
			s_speccontrolsplitscreenvaluesfloat medium;
			s_speccontrolsplitscreenvaluesfloat high;
			s_speccontrolsplitscreenvaluesfloat ultra;
		};
		static_assert(sizeof(s_speccontrolnodefloatexact) == 68, "struct s_speccontrolnodefloatexact is invalid size");

		struct s_volumetricfogperformancedefinition
		{
			c_flags<e_volumetricfogperformanceoverrideflagsdefinition, long, k_volumetricfogperformanceoverrideflagsdefinition_count> flags;
			s_speccontrolnodefloatexact resolution_scalar;
		};
		static_assert(sizeof(s_volumetricfogperformancedefinition) == 72, "struct s_volumetricfogperformancedefinition is invalid size");

		struct s_s_fog_light_parameters
		{
			c_flags<e_foglightflags, long, k_foglightflags_count> flags;
			real pitch_angle;
			real yaw_angle;
			real angular_radius;
			rgb_color tint_color;
			real tint_color_intensity;
			real angular_falloff_steepness;
			real distance_falloff_steepness;
			real nearby_cutoff_percentage;
		};
		static_assert(sizeof(s_s_fog_light_parameters) == 44, "struct s_s_fog_light_parameters is invalid size");

		struct s_foglightparameterdefinition
		{
			c_flags<e_foglightoverrideflagsdefinition, short, k_foglightoverrideflagsdefinition_count> flags;
			char generated_padc796[2]; // padding
			s_s_fog_light_parameters parameters;
		};
		static_assert(sizeof(s_foglightparameterdefinition) == 48, "struct s_foglightparameterdefinition is invalid size");

		struct s_volumetexturefogglobalsparameterdefinition
		{
			c_flags<e_volumetexturefogglobalsoverrideflagsdefinition, short, k_volumetexturefogglobalsoverrideflagsdefinition_count> flags;
			char generated_pad31ad[2]; // padding

			/* @@@ CAUTION  */

			s_volumetexturefogglobals parameters;
		};
		static_assert(sizeof(s_volumetexturefogglobalsparameterdefinition) == 60, "struct s_volumetexturefogglobalsparameterdefinition is invalid size");

		struct s_volumetexturefogparameterdefinition
		{
			c_flags<e_volumetexturefogoverrideflagsdefinition, short, k_volumetexturefogoverrideflagsdefinition_count> flags;
			char generated_pad43b9[2]; // padding

			/* Volume Texture Fog Per-Cluster Parameters */

			c_flags<e_volumetexturefogflags, long, k_volumetexturefogflags_count> flags$2;
			real sheet_density;
			rgb_color color_tint;
			rgb_color color_tint_inner;
			real intensity;
			real full_intensity_height;
			real half_intensity_height;
			real reference_plane_height;
		};
		static_assert(sizeof(s_volumetexturefogparameterdefinition) == 52, "struct s_volumetexturefogparameterdefinition is invalid size");

		struct s_crepuscularrayparams
		{
			c_flags<e_crepuscularraysflags, long, k_crepuscularraysflags_count> flags;
			real pitch_angle;
			real yaw_angle;
			real angular_radius;
			real_point3d source_position;
			rgb_color light_shaft_tint_color;
			real light_shaft_intensity;
			real saturation;
			real time_variation_scale;
			real light_shaft_decay_rate;
			real maximum_screen_distance;
			real sample_density;
			real minimum_caster_distance;
		};
		static_assert(sizeof(s_crepuscularrayparams) == 68, "struct s_crepuscularrayparams is invalid size");

		struct s_crepuscularrayparameterdefinition
		{
			c_flags<e_crepuscularrayoverrideflagsdefinition, short, k_crepuscularrayoverrideflagsdefinition_count> flags;
			char generated_pada717[2]; // padding
			s_crepuscularrayparams parameters;
		};
		static_assert(sizeof(s_crepuscularrayparameterdefinition) == 72, "struct s_crepuscularrayparameterdefinition is invalid size");

		struct s_dynamicfogdefinition
		{
			c_flags<e_dynamicfogoverrideflagsdefinition, short, k_dynamicfogoverrideflagsdefinition_count> flags;
			char generated_pad0794[2]; // padding
			real fog_distance_bias;
			s_atmosphericscatteringfogparameterdefinition atmospheric_scattering_fog;
			s_ceilingfogparameterdefinition ceiling_fog;
			s_depthfogparameterdefinition ground_fog;
			s_depthfogparameterdefinition sky_fog;
			s_volumetricfogparameterdefinition volumetric_fog;
			s_volumetricfogperformancedefinition volumetric_fog_performance;
			s_foglightparameterdefinition fog_light;
			s_volumetexturefogglobalsparameterdefinition non_blending;
			s_volumetexturefogparameterdefinition per_cluster;
			s_crepuscularrayparameterdefinition crepuscular_ray;
		};
		static_assert(sizeof(s_dynamicfogdefinition) == 708, "struct s_dynamicfogdefinition is invalid size");

		struct s_dynamicwinddefinition
		{
			c_flags<e_dynamicwindflagsdefinition, char, k_dynamicwindflagsdefinition_count> flags;
			char generated_pad25ce[3]; // padding
			real_vector3d wind_direction;
			real wind_speed;
		};
		static_assert(sizeof(s_dynamicwinddefinition) == 20, "struct s_dynamicwinddefinition is invalid size");

		struct s_cloudshapedefinition
		{
			c_flags<e_cloudshapeflagsdefinition, short, k_cloudshapeflagsdefinition_count> flags;
			char generated_padeb47[2]; // padding
			real low_frequency_noise_scale;
			real low_frequency_noise_strength;
			real_vector3d low_frequency_noise_axis_scale;
			real high_frequency_noise_scale;
			real high_frequency_noise_strength;
			real curl_noise_scale;
			real curl_noise_strength;
			real bottom_erosion_strength;
			real top_erosion_strength;
			real top_offset;
		};
		static_assert(sizeof(s_cloudshapedefinition) == 52, "struct s_cloudshapedefinition is invalid size");

		struct s_cloudlightingdefinition
		{
			c_flags<e_cloudlightingflagsdefinition, short, k_cloudlightingflagsdefinition_count> flags;
			char generated_padf4f8[2]; // padding
			real beer_strength;
			real powder_strength;
			real cornette_shanks_strength;
			real cornette_shanks_spread;
			real bottom_light;
			real clouds_fog_scale;
			real clouds_fog_intensity;
			real clouds_mie_intensity;
			real sunlight_intensity;
			rgb_color sunlight_color_tint;
			real skylight_intensity;
			rgb_color skylight_color_tint;
			real skylight_top_intensity;
			rgb_color skylight_top_color_tint;
			real global_alpha;
		};
		static_assert(sizeof(s_cloudlightingdefinition) == 88, "struct s_cloudlightingdefinition is invalid size");

		struct s_cloudshadowsdefinition
		{
			c_flags<e_cloudshadowsflagsdefinition, short, k_cloudshadowsflagsdefinition_count> flags;
			char generated_pad43e7[2]; // padding
			real minimum_strength;
			real gradient;
			real maximum_strength;
			real contrast_factor;
			real contrast_threshold;
			real opacity;
			real panning_clouds_shadows_scalar;
		};
		static_assert(sizeof(s_cloudshadowsdefinition) == 32, "struct s_cloudshadowsdefinition is invalid size");

		struct s_dynamicvolumetriccloudsdefinition
		{
			c_flags<e_dynamicvolumetriccloudsflagsdefinition, long, k_dynamicvolumetriccloudsflagsdefinition_count> flags;
			c_typed_tag_reference<BITMAP_TAG> coverage_texture;
			real coverage_scale;
			real_vector2d coverage_offset;
			real_vector2d coverage_scroll_speed;
			real coverage_strength;
			real horizon_distance;
			real atmosphere_start_height;
			real atmosphere_end_height;
			real lod_distance;
			real global_wind_interpolation;
			real_vector3d wind_direction;
			real_vector3d highf_noise_animation_speed;
			real_vector3d lowf_noise_animation_speed;
			real raymarch_step_scale;
			real depth_threshold;
			real max_depth;
			real min_distance_horizon_clouds;
			real min_distance_horizon_fade_start;
			real max_distance_center_fade_start;
			real max_distance_center_fade_end;
			real_vector2d center_fade_position;
			s_cloudshapedefinition cloud_shape;
			s_cloudlightingdefinition cloud_lighting;
			s_cloudshadowsdefinition cloud_shadows;
		};
		static_assert(sizeof(s_dynamicvolumetriccloudsdefinition) == 308, "struct s_dynamicvolumetriccloudsdefinition is invalid size");

		struct s_speccontrolnodeshadowquality
		{
			c_enum<e_floatingshadowqualitydefinition, char> very_low;
			c_enum<e_floatingshadowqualitydefinition, char> low;
			c_enum<e_floatingshadowqualitydefinition, char> medium;
			c_enum<e_floatingshadowqualitydefinition, char> high;
			c_enum<e_floatingshadowqualitydefinition, char> ultra;
		};
		static_assert(sizeof(s_speccontrolnodeshadowquality) == 5, "struct s_speccontrolnodeshadowquality is invalid size");

		struct s_speccontrolsplitscreenvaluesbyte
		{
			byte single_player;
			byte _2_player_splitscreen;
			byte _3_player_splitscreen;
			byte _4_player_splitscreen;
		};
		static_assert(sizeof(s_speccontrolsplitscreenvaluesbyte) == 4, "struct s_speccontrolsplitscreenvaluesbyte is invalid size");

		struct s_speccontrolnodebyteexact
		{
			c_enum<e_i343speccontrolgraphicsoptions, char> type;
			s_speccontrolsplitscreenvaluesbyte low;
			s_speccontrolsplitscreenvaluesbyte medium;
			s_speccontrolsplitscreenvaluesbyte high;
			s_speccontrolsplitscreenvaluesbyte ultra;
		};
		static_assert(sizeof(s_speccontrolnodebyteexact) == 17, "struct s_speccontrolnodebyteexact is invalid size");

		struct s_speccontrolnodeshort
		{
			c_enum<e_i343speccontrolgraphicsoptions, char> type;
			char generated_pad07fc[3]; // padding
			c_flags<e_speccontrolnodeoverrideflags, long, k_speccontrolnodeoverrideflags_count> flags;
			short input;
			char generated_pad21dd[2]; // padding
			real very_low;
			real low;
			real medium;
			real high;
			real ultra;
			c_enum<e_i343speccontrolsplitscreenlogictype, char> splitscreen_logic;
			char generated_pad6e92[3]; // padding
			real _2_player_splitscreen;
			real _3_player_splitscreen;
			real _4_player_splitscreen;
		};
		static_assert(sizeof(s_speccontrolnodeshort) == 48, "struct s_speccontrolnodeshort is invalid size");

		struct s_speccontrolsplitscreenvaluesbool
		{
			c_flags<e_speccontrolnodeboolexactflags, char, k_speccontrolnodeboolexactflags_count> single_player;
			c_flags<e_speccontrolnodeboolexactflags, char, k_speccontrolnodeboolexactflags_count> _2_player_splitscreen;
			c_flags<e_speccontrolnodeboolexactflags, char, k_speccontrolnodeboolexactflags_count> _3_player_splitscreen;
			c_flags<e_speccontrolnodeboolexactflags, char, k_speccontrolnodeboolexactflags_count> _4_player_splitscreen;
		};
		static_assert(sizeof(s_speccontrolsplitscreenvaluesbool) == 4, "struct s_speccontrolsplitscreenvaluesbool is invalid size");

		struct s_speccontrolnodeboolexact
		{
			c_enum<e_i343speccontrolgraphicsoptions, char> type;
			s_speccontrolsplitscreenvaluesbool low;
			s_speccontrolsplitscreenvaluesbool medium;
			s_speccontrolsplitscreenvaluesbool high;
			s_speccontrolsplitscreenvaluesbool ultra;
		};
		static_assert(sizeof(s_speccontrolnodeboolexact) == 17, "struct s_speccontrolnodeboolexact is invalid size");

		struct s_floatingshadowcascadesettings
		{
			// custom cascade
			s_speccontrolnodefloatexact cascade_half_width;
			real bias;
			s_speccontrolnodefloat filter_width;
			s_speccontrolnodeshort resolution;
			c_flags<e_floatingshadowcascadesettingsflags, short, k_floatingshadowcascadesettingsflags_count> flags;
			s_speccontrolnodeboolexact disabledynamicobjectshadows;
			s_speccontrolnodeboolexact islowfrequency;
			real interpolation_occluder_search_step;
			s_speccontrolnodefloat minimum_shadow_caster_static_geo_bounding_sphere_radius;
			s_speccontrolnodefloat minimum_shadow_caster_dynamic_object_bounding_sphere_radius;
			s_speccontrolnodeshort shadow_caster_lod_bias;
			s_speccontrolnodeshort force_shadow_lod_0___use_default_behavior_1___force_lowest_lod_2___next_higher_lod_and_so_forth;
			s_speccontrolnodeshort hexgrid_shadows_0___render_as_hexes_1___render_simplified_anything_else___disable_hex_shadows;
			// custom value
		};
		static_assert(sizeof(s_floatingshadowcascadesettings) == 448, "struct s_floatingshadowcascadesettings is invalid size");

		struct s_panningcloudsettings
		{
			real cloud_scale;
			real cloud_range_start;
			real cloud_range_end;
			real cloud_wind_influence;
			real cloud_texture_offset_x;
			real cloud_texture_offset_y;
			real cloud_texture_ws_x;
			real cloud_texture_ws_y;
			real cloud_texture_ws_z;
			c_typed_tag_reference<BITMAP_TAG> cloud_texture;
		};
		static_assert(sizeof(s_panningcloudsettings) == 52, "struct s_panningcloudsettings is invalid size");

		struct s_dynamicsunshadowdefinition
		{
			c_flags<e_dynamicsunshadowflagsdefinition, long, k_dynamicsunshadowflagsdefinition_count> flags;
			real max_shadow_count_scale;
			// custom floating_shadows_settings
			s_speccontrolnodeshadowquality floating_shadow_quality;
			c_enum<e_firstpersonfloatingshadowmode, char> first_person_floating_shadow_mode;
			char generated_pad1856[2]; // padding
			real cascade_overlap;
			real min_shadow_caster_pixel_radius;
			// custom pcss_settings
			real pcss_light_size;
			real pcss_minimum_filter_width;
			real pcss_maximum_filter_width;
			// custom value
			s_speccontrolnodebyteexact number_of_cascades;
			char generated_pad650b[3]; // padding
			s_floatingshadowcascadesettings frustum_1;
			s_floatingshadowcascadesettings frustum_2;
			s_floatingshadowcascadesettings frustum_3;
			s_floatingshadowcascadesettings frustum_4;
			s_floatingshadowcascadesettings frustum_5;
			s_floatingshadowcascadesettings frustum_6;
			long number_of_parallax_sampling_steps;
			real sun_direction_parallax_sampling_weight;
			c_typed_tag_block<s_panningcloudsettings> panning_cloud_settings_block;
			// custom value
		};
		static_assert(sizeof(s_dynamicsunshadowdefinition) == 2764, "struct s_dynamicsunshadowdefinition is invalid size");

		struct s_globalcubemapdefinition
		{
			c_flags<e_globalcubemapoverrideflagsdefinition, short, k_globalcubemapoverrideflagsdefinition_count> flags;
			char generated_pada0cb[2]; // padding
			c_typed_tag_reference<BITMAP_TAG> global_cubemap_texture;
		};
		static_assert(sizeof(s_globalcubemapdefinition) == 20, "struct s_globalcubemapdefinition is invalid size");

		struct s_cvwlightcontrolsdefinition
		{
			c_flags<e_cvwlightsoverrideflagsdefinition, long, k_cvwlightsoverrideflagsdefinition_count> flags;
			long cvw_enabled;
			long cvw_enabled_for_first_person_objects;
			real_vector3d cvw_light_direction;
			real_vector3d cvw_light_color;
			real cvw_direct_light_intensity;
			real cvw_direct_near_distance;
			real cvw_direct_far_distance;
			real cvw_direct_near_amount;
			real cvw_direct_far_amount;
			real cvw_sky_scalar;
			real cvw_bounce_scalar;
			real cvw_indirect_near_distance;
			real cvw_indirect_far_distance;
			real cvw_indirect_near_amount;
			real cvw_indirect_far_amount;
			real cvw_indirect_bounce_shaping;
			c_flags<e_cvwmultiplayerflagsdefinition, short, k_cvwmultiplayerflagsdefinition_count> cvw_multiplayer_team_override;
			char generated_pad0e91[2]; // padding
		};
		static_assert(sizeof(s_cvwlightcontrolsdefinition) == 88, "struct s_cvwlightcontrolsdefinition is invalid size");

		struct s_dynamicvistadefinition
		{
			c_flags<e_dynamicvistaoverrideflagsdefinition, short, k_dynamicvistaoverrideflagsdefinition_count> flags;
			char generated_pad1297[2]; // padding
			rgb_color color_map_tint;
			real color_map_intensity;
			rgb_color emissive_tint;
			real transparency;
			real depth_fade_range;
			real star_intensity;
			real nebula_intensity;
			real emissive_intensity;
		};
		static_assert(sizeof(s_dynamicvistadefinition) == 52, "struct s_dynamicvistadefinition is invalid size");

		struct s_dwsuidefinition
		{
			c_flags<e_dwsuioverrideflagsdefinition, char, k_dwsuioverrideflagsdefinition_count> flags;
			char generated_pad32e7[3]; // padding
			real ui_hdr_brightness_scalar;
		};
		static_assert(sizeof(s_dwsuidefinition) == 8, "struct s_dwsuidefinition is invalid size");

		struct s_statedefinition
		{
			c_flags<e_stateflagsdefinition, short, k_stateflagsdefinition_count> flags;
			char generated_pad9190[2]; // padding
			long interpolation_steps;
			real interpolation_time;
			c_typed_tag_block<s_dynamicsundefinition> dynamic_suns_block;
			s_dynamicskydefinition dynamic_sky;
			s_dynamicatmospheredefinition dynamic_atmosphere;
			s_dynamiccubemaptintingdefinition dynamic_cubemap_tinting;
			s_dynamiccamerafxdefinition dynamic_camera_fx;
			s_dynamicfogdefinition dynamic_fog;
			s_dynamicwinddefinition dynamic_wind;
			s_dynamicvolumetriccloudsdefinition dynamic_volumetric_clouds;
			s_dynamicsunshadowdefinition dynamic_sun_shadow;
			s_globalcubemapdefinition global_cubemap;
			s_cvwlightcontrolsdefinition cvw_light_controls;
			s_dynamicvistadefinition dynamic_vista;
			s_dwsuidefinition ui;
		};
		static_assert(sizeof(s_statedefinition) == 5264, "struct s_statedefinition is invalid size");

		struct s_localstatedefinition
		{
			long guid;
			string_id name;
			s_statedefinition state;
			short volume_index;
			char generated_pad87f5[2]; // padding
		};
		static_assert(sizeof(s_localstatedefinition) == 5276, "struct s_localstatedefinition is invalid size");

		struct s_eventlistdefinition
		{
			string_id name;
			c_enum<e_eventlistexecutiondirectionenumdefinition, char> execution_type;
			c_enum<e_eventlistrepeattypeenumdefinition, char> repeat_type;
			char generated_pad8aff[2]; // padding
			long number_of_runs;
			c_typed_tag_block<s_localstatedefinition> states_block;
			long start_state_index;
			long priority;
			c_flags<e_eventlistflagsdefinition, char, k_eventlistflagsdefinition_count> flags;
			char generated_pad3e4a[3]; // padding
		};
		static_assert(sizeof(s_eventlistdefinition) == 36, "struct s_eventlistdefinition is invalid size");

		struct s_eventlistmapping
		{
			string_id event_list_name;
			c_enum<e_eventlistcategoryenumdefinition, char> event_list_category;
			char generated_pad4488[3]; // padding
		};
		static_assert(sizeof(s_eventlistmapping) == 8, "struct s_eventlistmapping is invalid size");

		struct s_dynamicworldstateglobals
		{
			s_anytag_struct_definition anytag;
			s_dwsresourcesdefinition resources;
			s_statedefinition global_state;
			c_typed_tag_block<s_eventlistdefinition> event_lists_block;
			c_typed_tag_block<s_eventlistmapping> event_list_mappings_block;
			char generated_paddc42[4]; // padding
		};
		static_assert(sizeof(s_dynamicworldstateglobals) == 5328, "struct s_dynamicworldstateglobals is invalid size");

		struct s_ebtnodeidentifier
		{
			c_enum<e_ebtnodetype, char> type;
			char generated_padc09a[3]; // padding
			long block_index;
		};
		static_assert(sizeof(s_ebtnodeidentifier) == 8, "struct s_ebtnodeidentifier is invalid size");

		struct s_ebtnodelink
		{
			s_ebtnodeidentifier source_node_identifier;
			s_ebtnodeidentifier destination_node_identifier;
		};
		static_assert(sizeof(s_ebtnodelink) == 16, "struct s_ebtnodelink is invalid size");

		struct s_ebtrootnode
		{
			string_id pretty_name;
		};
		static_assert(sizeof(s_ebtrootnode) == 4, "struct s_ebtrootnode is invalid size");

		struct s_ebtinputnode
		{
			string_id pretty_name;
		};
		static_assert(sizeof(s_ebtinputnode) == 4, "struct s_ebtinputnode is invalid size");

		struct s_ebtfollowplayerordernode
		{
			string_id bounding_ez_pretty_name;
			real follow_radius;
		};
		static_assert(sizeof(s_ebtfollowplayerordernode) == 8, "struct s_ebtfollowplayerordernode is invalid size");

		struct s_ebtselectornode
		{
			long respects_initial_placement;
		};
		static_assert(sizeof(s_ebtselectornode) == 4, "struct s_ebtselectornode is invalid size");

		struct s_ebtsequencenode
		{
			long respects_initial_placement;
		};
		static_assert(sizeof(s_ebtsequencenode) == 4, "struct s_ebtsequencenode is invalid size");

		struct s_ebtboolconditionnode
		{
			c_enum<e_i343aibooloperator, char> bool_operation;
			char generated_padd184[3]; // padding
			s_ebtnodeidentifier action_node_identifier;
		};
		static_assert(sizeof(s_ebtboolconditionnode) == 12, "struct s_ebtboolconditionnode is invalid size");

		struct s_ebtprioritysorternode
		{
			c_enum<e_i343aibehaviortreepropertyquerytype, char> sort_property;
			c_enum<e_i343aibehaviortreeprioritysorttype, char> sort_type;
		};
		static_assert(sizeof(s_ebtprioritysorternode) == 2, "struct s_ebtprioritysorternode is invalid size");

		struct s_ebtassignmentlimitnode
		{
			c_flags<e_i343aidecoratorflags, short, k_i343aidecoratorflags_count> flags;
			char generated_pad1df7[2]; // padding
			long max_limit;
		};
		static_assert(sizeof(s_ebtassignmentlimitnode) == 8, "struct s_ebtassignmentlimitnode is invalid size");

		struct s_ebtbodycountnode
		{
			c_flags<e_i343aidecoratorflags, short, k_i343aidecoratorflags_count> flags;
			char generated_padff86[2]; // padding
			long max_count;
		};
		static_assert(sizeof(s_ebtbodycountnode) == 8, "struct s_ebtbodycountnode is invalid size");

		struct s_ebtcombatstatusfilternode
		{
			c_flags<e_i343aidecoratorflags, short, k_i343aidecoratorflags_count> flags;
			c_enum<e_i343aiboolcomparison, char> comparison;
			char generated_pad4a13[1]; // padding
			c_enum<e_actorcombatstatus, short> combat_status;
		};
		static_assert(sizeof(s_ebtcombatstatusfilternode) == 6, "struct s_ebtcombatstatusfilternode is invalid size");

		struct s_ebtkeywordfilternode
		{
			c_flags<e_i343aidecoratorflags, short, k_i343aidecoratorflags_count> flags;
			char generated_pad6ddc[2]; // padding
			string_id keyword;
		};
		static_assert(sizeof(s_ebtkeywordfilternode) == 8, "struct s_ebtkeywordfilternode is invalid size");

		struct s_ebtlivingcountnode
		{
			c_flags<e_i343aidecoratorflags, short, k_i343aidecoratorflags_count> flags;
			char generated_pad574b[2]; // padding
			long min_count;
		};
		static_assert(sizeof(s_ebtlivingcountnode) == 8, "struct s_ebtlivingcountnode is invalid size");

		struct s_ebtvehiclefilternode
		{
			c_flags<e_i343aidecoratorflags, short, k_i343aidecoratorflags_count> flags;
			char generated_pad41e5[2]; // padding
			long check_vehicle;
		};
		static_assert(sizeof(s_ebtvehiclefilternode) == 8, "struct s_ebtvehiclefilternode is invalid size");

		struct s_ebtscripttriggernode
		{
			c_flags<e_i343aidecoratorflags, short, k_i343aidecoratorflags_count> flags;
			char generated_padc36c[2]; // padding
			string_id label;
		};
		static_assert(sizeof(s_ebtscripttriggernode) == 8, "struct s_ebtscripttriggernode is invalid size");

		struct s_ebtplayertriggervolumenode
		{
			c_flags<e_i343aidecoratorflags, short, k_i343aidecoratorflags_count> flags;
			char generated_pad426c[2]; // padding
			string_id volume_pretty_name;
		};
		static_assert(sizeof(s_ebtplayertriggervolumenode) == 8, "struct s_ebtplayertriggervolumenode is invalid size");

		struct s_ebtminrelevancenode
		{
			c_flags<e_i343aidecoratorflags, short, k_i343aidecoratorflags_count> flags;
			c_enum<e_i343aibehaviortreerelevance, char> min_relevance;
			char generated_pad8fa2[1]; // padding
		};
		static_assert(sizeof(s_ebtminrelevancenode) == 4, "struct s_ebtminrelevancenode is invalid size");

		struct s_exportedebtdefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<ENCOUNTERBEHAVIORTREEDEFINITION_TAG> source_graph;
			c_typed_tag_block<s_ebtnodelink> links_block;
			c_typed_tag_block<s_ebtrootnode> root_nodes_block;
			c_typed_tag_block<s_ebtinputnode> input_nodes_block;
			c_typed_tag_block<s_ebtfollowplayerordernode> follow_player_order_nodes_block;
			c_typed_tag_block<s_ebtselectornode> selector_nodes_block;
			c_typed_tag_block<s_ebtsequencenode> sequence_nodes_block;
			c_typed_tag_block<s_ebtboolconditionnode> bool_condition_nodes_block;
			c_typed_tag_block<s_ebtprioritysorternode> priority_sorter_nodes_block;
			c_typed_tag_block<s_ebtassignmentlimitnode> assignment_limit_nodes_block;
			c_typed_tag_block<s_ebtbodycountnode> body_count_nodes_block;
			c_typed_tag_block<s_ebtcombatstatusfilternode> combat_status_filter_nodes_block;
			c_typed_tag_block<s_ebtkeywordfilternode> keyword_filter_nodes_block;
			c_typed_tag_block<s_ebtlivingcountnode> living_count_nodes_block;
			c_typed_tag_block<s_ebtvehiclefilternode> vehicle_type_filter_nodes_block;
			c_typed_tag_block<s_ebtscripttriggernode> script_trigger_nodes_block;
			c_typed_tag_block<s_ebtplayertriggervolumenode> trigger_volume_nodes_block;
			c_typed_tag_block<s_ebtminrelevancenode> min_relevance_nodes_block;
		};
		static_assert(sizeof(s_exportedebtdefinition) == 236, "struct s_exportedebtdefinition is invalid size");

		struct s_effectexposureoverride
		{
			real min_exposure;
			real max_exposure;
			real underexposed_slope;
			real overexposed_slope;
		};
		static_assert(sizeof(s_effectexposureoverride) == 16, "struct s_effectexposureoverride is invalid size");

		struct s_effectexposuredefinition
		{
			s_anytag_struct_definition anytag;
			// custom alpha_blend_override
			s_effectexposureoverride alpha_blend_override;
			// custom value
			// custom additive_override
			s_effectexposureoverride additive_override;
			// custom value
			// custom lit_alpha_blend_override
			s_effectexposureoverride lit_alpha_blend_override;
			// custom value
			// custom lit_additive_override
			s_effectexposureoverride lit_additive_override;
			// custom value
			// custom surface_alpha_blend_override
			s_effectexposureoverride surface_alpha_blend_override;
			// custom value
			// custom surface_additive_override
			s_effectexposureoverride surface_additive_override;
			// custom value
			// custom cheap_light_override
			s_effectexposureoverride cheap_light_override;
			// custom value
		};
		static_assert(sizeof(s_effectexposuredefinition) == 128, "struct s_effectexposuredefinition is invalid size");

		struct s_effect_definitionannotation
		{
			string_id name;
			s_tag_data text;
		};
		static_assert(sizeof(s_effect_definitionannotation) == 24, "struct s_effect_definitionannotation is invalid size");

		struct s_effect_location_definition
		{

			/* MARKER NAMES */

			string_id marker_name;
			c_flags<e_effect_location_definitioneffectlocationflags, short, k_effect_location_definitioneffectlocationflags_count> flags;
			char generated_pad1a4b[2]; // padding
		};
		static_assert(sizeof(s_effect_location_definition) == 8, "struct s_effect_location_definition is invalid size");

		struct s_effect_part_definition
		{
			c_enum<e_effectdisposition, short> violence_mode;
			short location;
			short secondary_location_beams;
			c_flags<e_effect_part_definitioneffectpartflags, short, k_effect_part_definitioneffectpartflags_count> flags;
			c_enum<e_partpriority, char> priority;
			c_enum<e_effectcameramode, char> camera_mode;
			char generated_padc859[2]; // padding
			tag runtime_base_group_tag;
			c_enum<e_effectgamemode, char> game_mode;
			c_enum<e_partaccessibilitytype, char> accessibility_type;
			char generated_padae78[2]; // padding
			s_tag_reference type;
			// custom velocity_bounds
			real_bounds velocity_bounds;
			angle velocity_cone_angle;
			angle_bounds angular_velocity_bounds;
			// custom radius_modifier_bounds
			real_bounds radius_modifier_bounds;
			real_point3d relative_offset;
			real_euler_angles3d relative_orientation;

			/* SCALE MODIFIERS */

			c_flags<e_effect_part_definitionscalablevaluesflags, long, k_effect_part_definitionscalablevaluesflags_count> a_scales_values;
			c_flags<e_effect_part_definitionscalablevaluesflags, long, k_effect_part_definitionscalablevaluesflags_count> b_scales_values;
			string_id name;
		};
		static_assert(sizeof(s_effect_part_definition) == 100, "struct s_effect_part_definition is invalid size");

		struct s_effect_acceleration_definition
		{
			c_enum<e_effectdisposition, short> violence_mode;
			short location;
			real acceleration;
			real inner_cone_angle;
			real outer_cone_angle;
		};
		static_assert(sizeof(s_effect_acceleration_definition) == 16, "struct s_effect_acceleration_definition is invalid size");

		struct s_gpupropertysubarray
		{
			real runtime_gpu_property_real;
		};
		static_assert(sizeof(s_gpupropertysubarray) == 4, "struct s_gpupropertysubarray is invalid size");

		struct s_gpupropertyparam
		{
			s_gpupropertysubarray runtime_gpu_property_sub_array[4];
		};
		static_assert(sizeof(s_gpupropertyparam) == 16, "struct s_gpupropertyparam is invalid size");

		struct s_gpufunctionsubarray
		{
			real runtime_gpu_function_real;
		};
		static_assert(sizeof(s_gpufunctionsubarray) == 4, "struct s_gpufunctionsubarray is invalid size");

		struct s_gpufunctionparam
		{
			s_gpufunctionsubarray runtime_gpu_function_sub_array[16];
		};
		static_assert(sizeof(s_gpufunctionparam) == 64, "struct s_gpufunctionparam is invalid size");

		struct s_gpucolorsubarray
		{
			real runtime_gpu_color_real;
		};
		static_assert(sizeof(s_gpucolorsubarray) == 4, "struct s_gpucolorsubarray is invalid size");

		struct s_gpucolorparam
		{
			s_gpucolorsubarray runtime_gpu_color_sub_array[4];
		};
		static_assert(sizeof(s_gpucolorparam) == 16, "struct s_gpucolorparam is invalid size");

		struct s_gpupropertyfunctioncolor
		{
			c_typed_tag_block<s_gpupropertyparam> runtime_gpu_property_block;
			c_typed_tag_block<s_gpufunctionparam> runtime_gpu_functions_block;
			c_typed_tag_block<s_gpucolorparam> runtime_gpu_colors_block;
		};
		static_assert(sizeof(s_gpupropertyfunctioncolor) == 36, "struct s_gpupropertyfunctioncolor is invalid size");

		struct s_emittersharedvalues
		{
			c_flags<e_emittersharedvaluesdebugflags, char, k_emittersharedvaluesdebugflags_count> emitter_debug_flags;
			c_flags<e_emittersharedvaluesemitterflags, char, k_emittersharedvaluesemitterflags_count> flags;
			char generated_paddf4f[2]; // padding
			real bounding_radius_estimate;
			real bounding_radius_override;
			s_gpupropertyfunctioncolor runtime_m_gpu_data;
			long long cachedconstants;
			long long updatedatastatic;
		};
		static_assert(sizeof(s_emittersharedvalues) == 64, "struct s_emittersharedvalues is invalid size");

		struct s_emittertagreference
		{
			string_id emitter_reference_name;
			c_typed_tag_reference<EMITTER_TAG> emitter_reference;
			s_emittersharedvalues emitter_shared_values;
		};
		static_assert(sizeof(s_emittertagreference) == 84, "struct s_emittertagreference is invalid size");

		struct s_particlepropertyscalar
		{
			c_enum<e_c_particle_state_liste_particle_state_input, char> input_variable;
			c_enum<e_c_particle_state_liste_particle_state_input, char> range_variable;
			c_enum<e_editablepropertybaseoutputmodifier, char> output_modifier;
			c_enum<e_c_particle_state_liste_particle_state_input, char> output_modifier_input;
			// custom mapping
			s_functiondefinition mapping;
			real runtime_m_constant_value;
			word runtime_m_flags;
			c_flags<e_editablepropertybaseforceflags, char, k_editablepropertybaseforceflags_count> force_flags;
			char generated_pad859b[1]; // padding
		};
		static_assert(sizeof(s_particlepropertyscalar) == 32, "struct s_particlepropertyscalar is invalid size");

		struct s_s_particle_attachment
		{
			c_flags<e_s_particle_attachmentflags, char, k_s_particle_attachmentflags_count> flags;
			char generated_pade010[3]; // padding
			s_tag_reference type;
			c_enum<e_s_particle_attachmenttype, char> trigger;
			byte skip_fraction;
			c_enum<e_c_particle_state_liste_particle_state_input, char> primary_scale;
			c_enum<e_c_particle_state_liste_particle_state_input, char> secondary_scale;
		};
		static_assert(sizeof(s_s_particle_attachment) == 24, "struct s_s_particle_attachment is invalid size");

		struct s_particlepropertyrealeulerangles3d
		{
			c_enum<e_c_particle_state_liste_particle_state_input, char> input_variable;
			c_enum<e_c_particle_state_liste_particle_state_input, char> range_variable;
			c_enum<e_editablepropertybaseoutputmodifier, char> output_modifier;
			c_enum<e_c_particle_state_liste_particle_state_input, char> output_modifier_input;
			// custom mapping
			s_functiondefinition mapping;
			real runtime_m_constant_value;
			word runtime_m_flags;
			c_flags<e_editablepropertybaseforceflags, char, k_editablepropertybaseforceflags_count> force_flags;
			char generated_pade3e1[1]; // padding
			real_euler_angles3d direction_at_0;
			real_euler_angles3d direction_at_1;
		};
		static_assert(sizeof(s_particlepropertyrealeulerangles3d) == 56, "struct s_particlepropertyrealeulerangles3d is invalid size");

		struct s_particlepropertyrealpoint3d
		{
			c_enum<e_c_particle_state_liste_particle_state_input, char> input_variable;
			c_enum<e_c_particle_state_liste_particle_state_input, char> range_variable;
			c_enum<e_editablepropertybaseoutputmodifier, char> output_modifier;
			c_enum<e_c_particle_state_liste_particle_state_input, char> output_modifier_input;
			// custom mapping
			s_functiondefinition mapping;
			real runtime_m_constant_value;
			word runtime_m_flags;
			c_flags<e_editablepropertybaseforceflags, char, k_editablepropertybaseforceflags_count> force_flags;
			char generated_pad0e18[1]; // padding
			real_point3d starting_interpolant;
			real_point3d ending_interpolant;
		};
		static_assert(sizeof(s_particlepropertyrealpoint3d) == 56, "struct s_particlepropertyrealpoint3d is invalid size");

		struct s_particlepropertyrealvector3d
		{
			c_enum<e_c_particle_state_liste_particle_state_input, char> input_variable;
			c_enum<e_c_particle_state_liste_particle_state_input, char> range_variable;
			c_enum<e_editablepropertybaseoutputmodifier, char> output_modifier;
			c_enum<e_c_particle_state_liste_particle_state_input, char> output_modifier_input;
			// custom mapping
			s_functiondefinition mapping;
			real runtime_m_constant_value;
			word runtime_m_flags;
			c_flags<e_editablepropertybaseforceflags, char, k_editablepropertybaseforceflags_count> force_flags;
			char generated_pad67a3[1]; // padding
			real_vector3d starting_interpolant;
			real_vector3d ending_interpolant;
		};
		static_assert(sizeof(s_particlepropertyrealvector3d) == 56, "struct s_particlepropertyrealvector3d is invalid size");

		struct s_effectglobalforcedefinition
		{
			c_flags<e_effectglobalforcedefinitionflags, char, k_effectglobalforcedefinitionflags_count> flags;
			c_enum<e_effectglobalforcedefinitionshape, char> shape;
			byte version;
			char generated_pad5f24[1]; // padding
			real normal_force_strength;
			real tangent_force_strength;
			real binormal_force_strength;
			real falloff_begin;
			real falloff_end;
			real max_speed;
			real_vector3d direction_override;
		};
		static_assert(sizeof(s_effectglobalforcedefinition) == 40, "struct s_effectglobalforcedefinition is invalid size");

		struct s_c_particle_emitter_definitionparticleemitterglobalforce
		{
			s_effectglobalforcedefinition global_force;
			real_vector3d offset;
			real_vector3d axis;
		};
		static_assert(sizeof(s_c_particle_emitter_definitionparticleemitterglobalforce) == 64, "struct s_c_particle_emitter_definitionparticleemitterglobalforce is invalid size");

		struct s_c_particle_emitter_definitionparticleemitterclipsphere
		{
			real_vector3d offset;
			real radius;
		};
		static_assert(sizeof(s_c_particle_emitter_definitionparticleemitterclipsphere) == 16, "struct s_c_particle_emitter_definitionparticleemitterclipsphere is invalid size");

		struct s_c_particle_controller_parameter
		{
			long parameter_id;
			s_particlepropertyscalar property;
		};
		static_assert(sizeof(s_c_particle_controller_parameter) == 36, "struct s_c_particle_controller_parameter is invalid size");

		struct s_c_particle_controller
		{
			c_enum<e_c_particle_movement_definitioncontrollertype, short> type;
			c_flags<e_c_particle_controllerflags, char, k_c_particle_controllerflags_count> flags;
			char generated_padc087[1]; // padding
			c_typed_tag_block<s_c_particle_controller_parameter> parameters_block;
			dword runtime_m_constant_parameters;
			dword runtime_m_used_particle_states;
		};
		static_assert(sizeof(s_c_particle_controller) == 24, "struct s_c_particle_controller is invalid size");

		struct s_c_particle_movement_definition
		{
			c_typed_tag_reference<PARTICLE_PHYSICS_TAG> _template;
			c_flags<e_c_particle_movement_definitionflags, short, k_c_particle_movement_definitionflags_count> flags;
			char collision_controller_index;
			char turbulence_controller_index;
			char global_force_controller_index;
			char generated_pad0c06[3]; // padding
			c_typed_tag_block<s_c_particle_controller> movements_block;
			c_typed_tag_reference<BITMAP_TAG> turbulence_texture;
		};
		static_assert(sizeof(s_c_particle_movement_definition) == 52, "struct s_c_particle_movement_definition is invalid size");

		struct s_particlepropertycolor
		{
			c_enum<e_c_particle_state_liste_particle_state_input, char> input_variable;
			c_enum<e_c_particle_state_liste_particle_state_input, char> range_variable;
			c_enum<e_editablepropertybaseoutputmodifier, char> output_modifier;
			c_enum<e_c_particle_state_liste_particle_state_input, char> output_modifier_input;
			// custom mapping
			s_functiondefinition mapping;
			real runtime_m_constant_value;
			word runtime_m_flags;
			c_flags<e_editablepropertybaseforceflags, char, k_editablepropertybaseforceflags_count> force_flags;
			char generated_padd216[1]; // padding
		};
		static_assert(sizeof(s_particlepropertycolor) == 32, "struct s_particlepropertycolor is invalid size");

		struct s_c_particle_emitter_definition
		{
			real estimatedsize;
			dword runtime_m_constant_per_particle_properties;
			dword runtime_m_constant_over_time_properties;
			dword runtime_m_used_particle_states;
			c_flags<e_c_particle_emitter_definitionparticleappearanceflags, long, k_c_particle_emitter_definitionparticleappearanceflags_count> particle_appearance;
			c_flags<e_c_particle_emitter_definitionparticlemainflags, long, k_c_particle_emitter_definitionparticlemainflags_count> particle_flags;
			c_flags<e_c_particle_emitter_definitionvisibleemitterflags, char, k_c_particle_emitter_definitionvisibleemitterflags_count> emitter_flags;
			c_enum<e_c_particle_emitter_definitionemissionshape, char> emission_shape;
			c_enum<e_c_particle_emitter_definitione_emission_axis, char> particle_axis_for_models;
			c_enum<e_c_particle_emitter_definitione_emission_reference_axis, char> particle_reference_axis;
			c_typed_tag_reference<PARTICLE_EMITTER_CUSTOM_POINTS_TAG> custom_shape;
			real_point3d axis_scale;
			real_vector3d particle_emission_direction;
			s_particlepropertyscalar emission_radius;
			c_enum<e_c_particle_emitter_definitionc_particle_emitter_billboard_type, short> particle_billboard_style;
			char generated_pad4219[2]; // padding
			real curvature;
			real angle_fade_range;
			real angle_fade_cutoff;
			c_typed_tag_block<s_s_particle_attachment> particle_attachments_block;
			s_particlepropertyrealeulerangles3d relative_direction;
			s_particlepropertyscalar emission_angle;
			s_particlepropertyrealpoint3d translational_offset;
			real_point2d particle_center_offset;
			s_particlepropertyscalar particle_lifespan;
			// custom emission_settings
			s_particlepropertyscalar particle_starting_count;
			s_particlepropertyscalar particle_max_count;
			s_particlepropertyscalar particle_emission_rate;
			s_particlepropertyscalar particle_emission_per_distance;
			// custom value
			s_particlepropertyscalar particle_size;
			s_particlepropertyscalar particle_scale;
			s_particlepropertyscalar particle_scale_x;
			s_particlepropertyscalar particle_scale_y;
			s_particlepropertyscalar particle_aspect_ratio;
			s_particlepropertyscalar particle_rotation;
			s_particlepropertyscalar particle_initial_rotation_rate;
			s_particlepropertyscalar particle_initial_velocity;
			s_particlepropertyrealvector3d particle_self_acceleration;
			real min_velocity;
			real max_velocity;
			c_typed_tag_block<s_c_particle_emitter_definitionparticleemitterglobalforce> particle_attractor_repulsor_block;
			c_typed_tag_block<s_c_particle_emitter_definitionparticleemitterclipsphere> particle_clip_sphere_block;
			// custom particle_motion
			// custom particle_physics_template
			// custom value
			s_c_particle_movement_definition particle_movement;
			// custom value
			// custom value
			s_particlepropertyscalar particle_intensity;
			c_enum<e_i343effectscoloroverridemode, char> particle_tint_override_mode;
			char generated_pad2838[3]; // padding
			s_particlepropertycolor particle_tint;
			c_enum<e_i343effectscoloroverridemode, char> particle_tint_2_override_mode;
			char generated_paddb83[3]; // padding
			s_particlepropertycolor particle_tint_2;
			s_particlepropertyscalar particle_alpha;
			s_particlepropertyscalar particle_alpha_2;
			s_particlepropertyscalar particle_alpha_black_point;
			s_particlepropertyscalar particle_alpha_white_point;
			c_enum<e_i343effectslightingresolutionmode, char> lighting_resolution_max;
			char generated_pad5bfa[3]; // padding
			s_particlepropertyscalar frame_index;
			s_particlepropertyscalar animation_rate;
			s_particlepropertyscalar palette_animation;
		};
		static_assert(sizeof(s_c_particle_emitter_definition) == 1168, "struct s_c_particle_emitter_definition is invalid size");

		struct s_emitterinternal
		{
			// custom export_to_emitter_tag
			string_id emitter_name;
			char generated_pada31d[4]; // padding
			s_emittersharedvalues emitter_shared_values;
			s_c_particle_emitter_definition emitter;
			char generated_pad893c[4]; // padding
		};
		static_assert(sizeof(s_emitterinternal) == 1244, "struct s_emitterinternal is invalid size");

		struct s_c_particle_system_definition
		{
			// custom value
			c_enum<e_partpriority, char> priority;
			c_enum<e_effectgamemode, char> game_mode;
			short sort_bias;
			c_typed_tag_reference<PARTICLE_TAG> particle;
			long location;
			c_enum<e_particlecoordinatesystem, char> coordinate_system;
			c_enum<e_partaccessibilitytype, char> accessibility_type;
			c_enum<e_effectdisposition, short> disposition;
			c_enum<e_effectcameramode, char> camera_mode;
			char generated_pad75fa[3]; // padding
			c_flags<e_particlesystemflagsdefinition, long, k_particlesystemflagsdefinition_count> flags;
			real_bounds percent_velocity_to_inherit;
			real max_bounding_radius;
			real size_scale;
			real camera_offset;
			real near_fade_cutoff;
			real near_fade_range;
			real far_fade_range;
			real far_fade_cutoff;
			real_bounds camera_distance_range_override;
			// custom value
			c_typed_tag_block<s_emittertagreference> emitter_references_block;
			c_typed_tag_block<s_emitterinternal> emitters_block;
			real runtime_max_lifespan;
			string_id name;
		};
		static_assert(sizeof(s_c_particle_system_definition) == 112, "struct s_c_particle_system_definition is invalid size");

		struct s_effect_event_definition
		{
			string_id event_name;
			c_flags<e_effect_event_definitioneffecteventflags, short, k_effect_event_definitioneffecteventflags_count> flags;
			char generated_padbcea[2]; // padding
			real_fraction skip_fraction;
			// custom delay_bounds
			real_bounds delay_bounds;
			// custom duration_bounds
			real_bounds duration_bounds;

			/* event age duration override */

			real event_age_duration_override$2;
			c_typed_tag_block<s_effect_part_definition> parts_block;
			c_typed_tag_block<s_effect_acceleration_definition> accelerations_block;
			c_typed_tag_block<s_c_particle_system_definition> particle_systems_block;
		};
		static_assert(sizeof(s_effect_event_definition) == 68, "struct s_effect_event_definition is invalid size");

		struct s_s_effect_conical_distribution_definition
		{

			/* conical_projection - AKA shotgun */

			short yaw_count;
			short pitch_count;
			real distribution_exponent;
			angle spread;
		};
		static_assert(sizeof(s_s_effect_conical_distribution_definition) == 12, "struct s_s_effect_conical_distribution_definition is invalid size");

		struct s_effectloddefinition
		{
			string_id lod_name;
			real lod_distance;
			real lod_timer;
			s_scalarfunctionnamedefaultone camera_distance_curve;
			real_bounds camera_distance_range;
			c_typed_tag_reference<EFFECT_TAG> lod_import_effect;
			short lod_import_index;
			c_flags<e_effectloddefinitioneffectlodflags, short, k_effectloddefinitioneffectlodflags_count> lod_flags;
			short lod_loop_start_event;
			char generated_padb48f[2]; // padding
			c_typed_tag_block<s_effect_location_definition> lod_locations_block;
			c_typed_tag_block<s_effect_event_definition> lod_events_block;
			c_typed_tag_block<s_s_effect_conical_distribution_definition> lod_conical_distribution_block;
		};
		static_assert(sizeof(s_effectloddefinition) == 100, "struct s_effectloddefinition is invalid size");

		struct s_effect_sound_event_lod_definition
		{
			short lod_name;
			short location;
			short event;
		};
		static_assert(sizeof(s_effect_sound_event_lod_definition) == 6, "struct s_effect_sound_event_lod_definition is invalid size");

		struct s_effect_sound_definition
		{
			s_tag_reference sound;
			// custom value
			string_id marker_name;
			c_typed_tag_block<s_effect_sound_event_lod_definition> events_block;
		};
		static_assert(sizeof(s_effect_sound_definition) == 32, "struct s_effect_sound_definition is invalid size");

		struct s_effect_definition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_effect_definitionannotation> annotations_block;
			c_flags<e_effect_definitioneffectdefinitionflags, long, k_effect_definitioneffectdefinitionflags_count> flags;
			dword fixed_random_seed;
			real restart_if_within;
			real continue_if_within;
			real death_delay;
			c_enum<e_effectallocationpriority, char> allocation_priority;
			c_flags<e_i343effectscustomlocationflags, char, k_i343effectscustomlocationflags_count> customlocationflags;
			char generated_padae91[2]; // padding
			real global_size_scale;
			string_id scale_a_override;
			string_id scale_b_override;
			real runtime_danger_radius;

			/* Standalone Damage Source */

			s_i343damagedamagesourcedefinition standalonedamagesource;
			real always_play_distance;
			real never_play_distance;
			real runtime_local_space_death_delay;
			c_typed_tag_block<s_effectloddefinition> lods_block;
			c_typed_tag_block<s_effect_sound_definition> sounds_block;
			char generated_pad94b0[4]; // padding
		};
		static_assert(sizeof(s_effect_definition) == 112, "struct s_effect_definition is invalid size");

		struct s_globalspawneffects
		{
			c_typed_tag_reference<EFFECT_TAG> biped_spawn_effect;
			c_typed_tag_reference<EFFECT_TAG> vehicle_spawn_effect;
			c_typed_tag_reference<EFFECT_TAG> weapon_spawn_effect;
			c_typed_tag_reference<EFFECT_TAG> first_person_player_spawn_effect;
		};
		static_assert(sizeof(s_globalspawneffects) == 64, "struct s_globalspawneffects is invalid size");

		struct s_effectglobalsdefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<EFFECT_TAG> grunt_birthday_effect;
			c_typed_tag_reference<MATERIALEFFECTSGLOBALS_TAG> material_effects_globals;

			/* Spawn Effects */

			c_typed_tag_block<s_globalspawneffects> multiplayer_block;
			c_typed_tag_block<s_globalspawneffects> campaign_block;
		};
		static_assert(sizeof(s_effectglobalsdefinition) == 72, "struct s_effectglobalsdefinition is invalid size");

		struct s_i343effectsgeneratordefinition
		{
			string_id name;
			c_flags<e_i343effectsgeneratordefinitionflags, long, k_i343effectsgeneratordefinitionflags_count> generator_flags;
			real bounding_radius;
			// custom generator_material
			// custom value
			s_material actual_material;
			// custom value

			/* Particle model to emit from */

			c_typed_tag_reference<PARTICLEASSET_TAG> emitter_particle_asset;
			c_typed_tag_reference<PARTICLE_MODEL_TAG> emitter_particle_model;

			/* Particle model to render with */

			c_typed_tag_reference<PARTICLEASSET_TAG> renderer_particle_asset;
			c_typed_tag_reference<PARTICLE_MODEL_TAG> renderer_particle_model;

			/* Particle model as goal */

			c_typed_tag_reference<PARTICLEASSET_TAG> goal_particle_asset;
			c_typed_tag_reference<PARTICLE_MODEL_TAG> goal_particle_model;
			short shared_state_size;
			short instance_state_size;
			dword max_instance_count;
			real max_lifetime;
			dword max_vertex_count_per_instance;
			dword primitive_topology;
			char generated_pad975f[4]; // padding
			long long m_emitterpipelinestates;
			long long m_simulatorpipelinestate;
			long long m_rendererpipelinestates;
		};
		static_assert(sizeof(s_i343effectsgeneratordefinition) == 228, "struct s_i343effectsgeneratordefinition is invalid size");

		struct s_i343effectsgeneratorsystemdefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<GENERATOR_SYSTEM_TAG> parent;
			c_flags<e_i343effectsgeneratorsystemdefinitionflags, long, k_i343effectsgeneratorsystemdefinitionflags_count> generator_system_flags;
			real_bounds camera_distance_range_override;
			c_typed_tag_block<s_i343effectsgeneratordefinition> generators_block;
			char generated_pad1988[4]; // padding
		};
		static_assert(sizeof(s_i343effectsgeneratorsystemdefinition) == 60, "struct s_i343effectsgeneratorsystemdefinition is invalid size");

		struct s_i343effectseffectwindfunction
		{
			c_enum<e_i343effectswindfunctioninputs, char> input_variable;
			c_enum<e_i343effectswindfunctioninputs, char> range_variable;
			c_enum<e_i343effectsoutputmodifier, char> output_modifier;
			c_enum<e_i343effectswindfunctioninputs, char> output_modifier_input;
			// custom mapping
			s_functiondefinition mapping;
		};
		static_assert(sizeof(s_i343effectseffectwindfunction) == 24, "struct s_i343effectseffectwindfunction is invalid size");

		struct s_i343effectseffectwindmotor
		{
			s_anytag_struct_definition anytag;
			c_enum<e_i343windwindinfluencervolumetypeenum, long> type;
			real_vector3d direction;
			s_i343effectseffectwindfunction strength;
			s_i343effectseffectwindfunction scale_x_or_radius;
			s_i343effectseffectwindfunction scale_y;
			s_i343effectseffectwindfunction scale_z;
		};
		static_assert(sizeof(s_i343effectseffectwindmotor) == 128, "struct s_i343effectseffectwindmotor is invalid size");

		struct s_effectglobalforcedefinitiontag
		{
			s_anytag_struct_definition anytag;
			s_effectglobalforcedefinition force;
		};
		static_assert(sizeof(s_effectglobalforcedefinitiontag) == 56, "struct s_effectglobalforcedefinitiontag is invalid size");

		struct s_i343emblemlayer
		{
			string_id prefix;
			argb_color preview_color;
		};
		static_assert(sizeof(s_i343emblemlayer) == 20, "struct s_i343emblemlayer is invalid size");

		struct s_i343emblemglobals
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343emblemlayer> layers_block;
			char generated_pad3647[4]; // padding
		};
		static_assert(sizeof(s_i343emblemglobals) == 32, "struct s_i343emblemglobals is invalid size");

		struct s_i343emblemdefinitionsemblemshader
		{
			string_id name;
			c_typed_tag_reference<SHADER_TAG> shader;
		};
		static_assert(sizeof(s_i343emblemdefinitionsemblemshader) == 20, "struct s_i343emblemdefinitionsemblemshader is invalid size");

		struct s_i343emblemdefinitionsemblemsvg
		{
			string_id name;
			c_typed_tag_reference<SVG_TAG> svg;
			c_typed_tag_reference<ASSET_TAG> svg_geometry;
			c_typed_tag_reference<VECTORART_TAG> svgoutput;
		};
		static_assert(sizeof(s_i343emblemdefinitionsemblemsvg) == 52, "struct s_i343emblemdefinitionsemblemsvg is invalid size");

		struct s_i343emblemdefinitionsemblemcoatingswatch
		{
			c_typed_tag_reference<MATERIALSWATCH_TAG> swatch;
			string_id color;
			c_enum<e_materialroughnessoverride, char> roughness;
			c_enum<e_i343emblemdefinitionsemblemswatchvisibility, char> visibility;
			c_enum<e_i343emblemdefinitionsemblemswatchclipping, char> clipping;
			char generated_pad2e68[1]; // padding
			real_vector2d scale;
			real_vector2d offset;
		};
		static_assert(sizeof(s_i343emblemdefinitionsemblemcoatingswatch) == 40, "struct s_i343emblemdefinitionsemblemcoatingswatch is invalid size");

		struct s_i343emblemdefinitionsemblemcoating
		{
			string_id name;
			short shader;
			char generated_pad0e9c[2]; // padding
			rgb_color text_color;
			c_typed_tag_block<s_i343emblemdefinitionsemblemcoatingswatch> swatches_block;
		};
		static_assert(sizeof(s_i343emblemdefinitionsemblemcoating) == 32, "struct s_i343emblemdefinitionsemblemcoating is invalid size");

		struct s_i343emblemdefinitionsemblem
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343emblemdefinitionsemblemshader> shaders_block;
			c_typed_tag_block<s_i343emblemdefinitionsemblemsvg> emblems_block;
			c_typed_tag_block<s_i343emblemdefinitionsemblemcoating> coatings_block;
			char generated_paddebf[4]; // padding
		};
		static_assert(sizeof(s_i343emblemdefinitionsemblem) == 56, "struct s_i343emblemdefinitionsemblem is invalid size");

		struct s_interfaceemblemelementname
		{
			string_id id;
		};
		static_assert(sizeof(s_interfaceemblemelementname) == 4, "struct s_interfaceemblemelementname is invalid size");

		struct s_interfaceemblemelementgroup
		{
			string_id id;
			c_typed_tag_block<s_interfaceemblemelementname> elements_block;
		};
		static_assert(sizeof(s_interfaceemblemelementgroup) == 16, "struct s_interfaceemblemelementgroup is invalid size");

		struct s_interfaceemblemthemedefinition
		{
			string_id theme_id;

			/* Theme emblems */

			string_id key_emblem;
			string_id tile_emblem;
			string_id ui_nameplate_emblem;

			/* Theme coatings */

			c_typed_tag_block<s_interfaceemblemelementname> valid_coatings_block;
			c_typed_tag_block<s_interfaceemblemelementname> valid_coating_groups_block;
			string_id default_coating;
			string_id initial_coating;
		};
		static_assert(sizeof(s_interfaceemblemthemedefinition) == 48, "struct s_interfaceemblemthemedefinition is invalid size");

		struct s_interfaceemblemthemeglobals
		{
			s_anytag_struct_definition anytag;
			string_id global_default_emblem_coating;
			c_typed_tag_block<s_interfaceemblemelementgroup> coating_groups_block;

			/* Themes */

			c_typed_tag_block<s_interfaceemblemthemedefinition> emblem_themes_block;
			char generated_padf606[4]; // padding
		};
		static_assert(sizeof(s_interfaceemblemthemeglobals) == 48, "struct s_interfaceemblemthemeglobals is invalid size");

		struct s_emittertag
		{
			s_anytag_struct_definition anytag;
			s_c_particle_emitter_definition emitter;
			char generated_pad299c[4]; // padding
		};
		static_assert(sizeof(s_emittertag) == 1188, "struct s_emittertag is invalid size");

		struct s_explicitshader
		{
			s_tag_reference shader;
			char generated_padc559[4]; // padding
			char ptr_psos[8]; // padding
			char countpsos[4]; // padding
			char generated_padab78[4]; // padding
		};
		static_assert(sizeof(s_explicitshader) == 36, "struct s_explicitshader is invalid size");

		struct s_explicitshaders
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_explicitshader> explicit_shaders_block;
			char generated_padc45e[4]; // padding
		};
		static_assert(sizeof(s_explicitshaders) == 32, "struct s_explicitshaders is invalid size");

		struct s_explicitshadertable
		{
			s_anytag_struct_definition anytag;
			long long name_to_path_map;
		};
		static_assert(sizeof(s_explicitshadertable) == 24, "struct s_explicitshadertable is invalid size");

		struct s_i343graphicsforwardfastlight
		{
			rgb_color color;
			real min_roughness;
			real_vector3d direction_vector;
			real diffuse_intensity;
			real specular_intensity;
		};
		static_assert(sizeof(s_i343graphicsforwardfastlight) == 36, "struct s_i343graphicsforwardfastlight is invalid size");

		struct s_i343graphicsforwardfastlightingtag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343graphicsforwardfastlight> lights_block;
			c_typed_tag_reference<BITMAP_TAG> diffuse_cubemap;
			real alpha_value_for_parts_not_highlighted;
			dword diffuse_cubemap_mip_to_sample;
			real indirect_diffuse_intensity;
			real indirect_specular_intensity;
		};
		static_assert(sizeof(s_i343graphicsforwardfastlightingtag) == 60, "struct s_i343graphicsforwardfastlightingtag is invalid size");

		struct s_enginefanfarefanfaredefinition
		{
			s_anytag_struct_definition anytag;
			c_enum<e_fanfaremessagequeuetype, char> type;
			char generated_pad07bd[3]; // padding
			long priority;
			string_id string_identifier;
			short sprite_index;
			short display_time_in_seconds;
			c_typed_tag_reference<CUI_SCREEN_TAG> screen;
			c_typed_tag_reference<SOUND_RESPONSE_TAG> sound;
		};
		static_assert(sizeof(s_enginefanfarefanfaredefinition) == 64, "struct s_enginefanfarefanfaredefinition is invalid size");

		struct s_fixeddepthquadtreenode
		{
			real x0;
			real x1;
			real y0;
			real y1;
			real z0;
			real z1;
		};
		static_assert(sizeof(s_fixeddepthquadtreenode) == 24, "struct s_fixeddepthquadtreenode is invalid size");

		struct s_fixeddepthquadtreetri
		{
			real_point3d v0;
			real_point3d v1;
			real_point3d v2;
		};
		static_assert(sizeof(s_fixeddepthquadtreetri) == 36, "struct s_fixeddepthquadtreetri is invalid size");

		struct s_fixeddepthquadtreegeo
		{
			c_typed_tag_block<s_fixeddepthquadtreetri> raw_vertices_block;
		};
		static_assert(sizeof(s_fixeddepthquadtreegeo) == 12, "struct s_fixeddepthquadtreegeo is invalid size");

		struct s_fixeddepthquadtree
		{
			s_anytag_struct_definition anytag;
			long max_depth;
			c_typed_tag_block<s_fixeddepthquadtreenode> node_list_block;
			c_typed_tag_block<s_fixeddepthquadtreegeo> geo_block;
			char generated_pad38b2[4]; // padding
		};
		static_assert(sizeof(s_fixeddepthquadtree) == 48, "struct s_fixeddepthquadtree is invalid size");

		struct s_animframeevent
		{
			short frame;
			char generated_pad8ebc[2]; // padding
			string_id anim_event_type;
		};
		static_assert(sizeof(s_animframeevent) == 8, "struct s_animframeevent is invalid size");

		struct s_animfunction
		{
			string_id function_name;
			string_id comment;
			s_i343curveanimatedcurve1d function_curve;
		};
		static_assert(sizeof(s_animfunction) == 40, "struct s_animfunction is invalid size");

		struct s_animframeevents
		{
			string_id name;
			long guid;
			c_typed_tag_block<s_animframeevent> frame_events_block;
			c_typed_tag_block<s_animfunction> functions_block;
		};
		static_assert(sizeof(s_animframeevents) == 32, "struct s_animframeevents is invalid size");

		struct s_animationframeeventlist
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_animframeevents> animations_block;
			char generated_padfeff[4]; // padding
		};
		static_assert(sizeof(s_animationframeeventlist) == 32, "struct s_animationframeeventlist is invalid size");

		struct s_soundevententry
		{
			c_typed_tag_reference<SOUND_TAG> sound;
			c_flags<e_animationkeyeventflags, short, k_animationkeyeventflags_count> key_event_flags;
			char generated_padb649[2]; // padding
			s_tag_reference model_reference;
			string_id model_variant;
			c_typed_tag_reference<WEAPON_TAG> weapon_reference;
			string_id weapon_variant;
		};
		static_assert(sizeof(s_soundevententry) == 60, "struct s_soundevententry is invalid size");

		struct s_animationsounds
		{
			long unique_id;
			string_id name;
			c_typed_tag_block<s_soundevententry> sounds_block;
		};
		static_assert(sizeof(s_animationsounds) == 20, "struct s_animationsounds is invalid size");

		struct s_animationdialogues
		{
			long unique_id;
			string_id vocialization_name;
			c_enum<e_dialogueplayrestriction, char> dialogue_play_restrictions;
			char generated_pad2391[3]; // padding
		};
		static_assert(sizeof(s_animationdialogues) == 12, "struct s_animationdialogues is invalid size");

		struct s_soundevent
		{
			short frame;
			char generated_pad4191[2]; // padding
			string_id marker_name;
			long sound_id;
			short sound;
			char generated_pad27b0[2]; // padding
		};
		static_assert(sizeof(s_soundevent) == 16, "struct s_soundevent is invalid size");

		struct s_dialogevent
		{
			short frame;
			char generated_pade448[2]; // padding
			string_id marker_name;
			long dialogue_id;
			short dialogue;
			char generated_padfe29[2]; // padding
		};
		static_assert(sizeof(s_dialogevent) == 16, "struct s_dialogevent is invalid size");

		struct s_audioframeevents
		{
			string_id name;
			long guid;
			c_typed_tag_block<s_soundevent> sound_events_block;
			c_typed_tag_block<s_dialogevent> dialogue_events_block;
		};
		static_assert(sizeof(s_audioframeevents) == 32, "struct s_audioframeevents is invalid size");

		struct s_animationframeeventlistaudio
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<ANIMATIONLIBRARYAUDIO_TAG> library;
			c_typed_tag_block<s_animationsounds> sounds_block;
			c_typed_tag_block<s_animationdialogues> dialogues_block;
			c_typed_tag_block<s_audioframeevents> animations_block;
		};
		static_assert(sizeof(s_animationframeeventlistaudio) == 68, "struct s_animationframeeventlistaudio is invalid size");

		struct s_effectdefinition
		{
			c_typed_tag_reference<EFFECT_TAG> effect;
			c_flags<e_animationkeyeventflags, short, k_animationkeyeventflags_count> key_event_flags;
			char generated_padf5ee[2]; // padding
			s_tag_reference model_reference;
			string_id model_variant;
			c_typed_tag_reference<WEAPON_TAG> weapon_reference;
			string_id weapon_variant;
		};
		static_assert(sizeof(s_effectdefinition) == 60, "struct s_effectdefinition is invalid size");

		struct s_animationeffects
		{
			long unique_id;
			string_id name;
			c_typed_tag_block<s_effectdefinition> effects_block;
		};
		static_assert(sizeof(s_animationeffects) == 20, "struct s_animationeffects is invalid size");

		struct s_effectframeevent
		{
			short frame;
			char generated_pad6ca8[2]; // padding
			string_id marker_name;
			long effect_id;
			short effect;
			char generated_pad8689[2]; // padding
		};
		static_assert(sizeof(s_effectframeevent) == 16, "struct s_effectframeevent is invalid size");

		struct s_effectframeevents
		{
			string_id name;
			long guid;
			c_typed_tag_block<s_effectframeevent> effect_events_block;
		};
		static_assert(sizeof(s_effectframeevents) == 20, "struct s_effectframeevents is invalid size");

		struct s_animationframeeventlisteffects
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<ANIMATIONLIBRARYFX_TAG> library;
			c_typed_tag_block<s_animationeffects> effects_block;
			c_typed_tag_block<s_effectframeevents> animations_block;
			char generated_pad35c1[4]; // padding
		};
		static_assert(sizeof(s_animationframeeventlisteffects) == 60, "struct s_animationframeeventlisteffects is invalid size");

		struct s_animationframeeventlistaudio_v0
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<ANIMATIONLIBRARYAUDIO_TAG> library;
			c_typed_tag_block<s_animationsounds> sounds_block;
			c_typed_tag_block<s_animationdialogues> dialogues_block;
			c_typed_tag_block<s_audioframeevents> animations_block;
		};
		static_assert(sizeof(s_animationframeeventlistaudio_v0) == 68, "struct s_animationframeeventlistaudio_v0 is invalid size");

		struct s_animationframeeventlisteffects_v0
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<ANIMATIONLIBRARYFX_TAG> library;
			c_typed_tag_block<s_animationeffects> effects_block;
			c_typed_tag_block<s_effectframeevents> animations_block;
			char generated_pad10f8[4]; // padding
		};
		static_assert(sizeof(s_animationframeeventlisteffects_v0) == 60, "struct s_animationframeeventlisteffects_v0 is invalid size");

		struct s_soundeventreference
		{
			c_typed_tag_reference<SOUND_TAG> sound;
			c_flags<e_c_animation_key_event_flags, short, k_c_animation_key_event_flags_count> flags;
			char generated_padeb82[2]; // padding
			c_typed_tag_reference<MODEL_TAG> model;
			string_id model_variant;
			c_typed_tag_reference<WEAPON_TAG> weapon;
			string_id weapon_variant;
		};
		static_assert(sizeof(s_soundeventreference) == 60, "struct s_soundeventreference is invalid size");

		struct s_soundeventreferenceset
		{
			string_id name;
			c_typed_tag_block<s_soundeventreference> sounds_block;
		};
		static_assert(sizeof(s_soundeventreferenceset) == 16, "struct s_soundeventreferenceset is invalid size");

		struct s_animationgraphdialoguereference
		{
			string_id vocalization_name;
			c_enum<e_edialogueplayrestriction, char> play_restriction;
			char generated_padf213[3]; // padding
		};
		static_assert(sizeof(s_animationgraphdialoguereference) == 8, "struct s_animationgraphdialoguereference is invalid size");

		struct s_soundframeeventdescriptor
		{
			string_id linked_frame_event_id;
			short sound;
			short frame_offset;
			// custom value
			string_id marker_name;
		};
		static_assert(sizeof(s_soundframeeventdescriptor) == 12, "struct s_soundframeeventdescriptor is invalid size");

		struct s_dialogueframeeventdescriptor
		{
			string_id linked_frame_event_id;
			short dialogue_reference;
			short frame_offset;
		};
		static_assert(sizeof(s_dialogueframeeventdescriptor) == 8, "struct s_dialogueframeeventdescriptor is invalid size");

		struct s_audioframeeventcontainer
		{
			string_id animation_name;
			c_typed_tag_block<s_soundframeeventdescriptor> sound_events_block;
			c_typed_tag_block<s_dialogueframeeventdescriptor> dialogue_events_block;
		};
		static_assert(sizeof(s_audioframeeventcontainer) == 28, "struct s_audioframeeventcontainer is invalid size");

		struct s_c_animation_frame_event_list_audio
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_soundeventreferenceset> sound_references_block;
			c_typed_tag_block<s_animationgraphdialoguereference> dialogue_references_block;
			c_typed_tag_block<s_audioframeeventcontainer> frame_event_containers_block;
			char generated_pad99a3[4]; // padding
		};
		static_assert(sizeof(s_c_animation_frame_event_list_audio) == 56, "struct s_c_animation_frame_event_list_audio is invalid size");

		struct s_animframeeventdescriptor
		{
			string_id linked_frame_event_id;
			short frame_offset;
			char generated_pad359b[2]; // padding
			string_id marker_name;
		};
		static_assert(sizeof(s_animframeeventdescriptor) == 12, "struct s_animframeeventdescriptor is invalid size");

		struct s_animframeeventcontainer
		{
			string_id animation_name;
			c_typed_tag_block<s_animframeeventdescriptor> anim_events_block;
		};
		static_assert(sizeof(s_animframeeventcontainer) == 16, "struct s_animframeeventcontainer is invalid size");

		struct s_c_animation_frame_event_list_anim
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_animframeeventcontainer> frame_event_containers_block;
			char generated_pad33c2[4]; // padding
		};
		static_assert(sizeof(s_c_animation_frame_event_list_anim) == 32, "struct s_c_animation_frame_event_list_anim is invalid size");

		struct s_effecteventreference
		{
			c_typed_tag_reference<EFFECT_TAG> effect;
			c_flags<e_c_animation_key_event_flags, short, k_c_animation_key_event_flags_count> flags;
			char generated_pad9456[2]; // padding
			c_typed_tag_reference<MODEL_TAG> model;
			string_id model_variant;
			c_typed_tag_reference<WEAPON_TAG> weapon;
			string_id weapon_variant;
		};
		static_assert(sizeof(s_effecteventreference) == 60, "struct s_effecteventreference is invalid size");

		struct s_effecteventreferenceset
		{
			string_id name;
			c_typed_tag_block<s_effecteventreference> effects_block;
		};
		static_assert(sizeof(s_effecteventreferenceset) == 16, "struct s_effecteventreferenceset is invalid size");

		struct s_effectframeeventdescriptor
		{
			string_id linked_frame_event_id;
			short effect;
			short frame_offset;
			// custom value
			string_id marker_name;
		};
		static_assert(sizeof(s_effectframeeventdescriptor) == 12, "struct s_effectframeeventdescriptor is invalid size");

		struct s_effectframeeventcontainer
		{
			string_id animation_name;
			c_typed_tag_block<s_effectframeeventdescriptor> effect_events_block;
		};
		static_assert(sizeof(s_effectframeeventcontainer) == 16, "struct s_effectframeeventcontainer is invalid size");

		struct s_c_animation_frame_event_list_effect
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_effecteventreferenceset> effect_references_block;
			c_typed_tag_block<s_effectframeeventcontainer> frame_event_containers_block;
		};
		static_assert(sizeof(s_c_animation_frame_event_list_effect) == 40, "struct s_c_animation_frame_event_list_effect is invalid size");

		struct s_aiflocktag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<KIT_TAG> parent;

			/* Simple flocking */

			real_fraction forward_weight;
			real_fraction leveling_force_weight;
			real_fraction destination_weight;
			real_fraction movement_weight_threshold;
			real_fraction target_weight;
			real target_distance;
			real target_delay_time;
			real_fraction target_kill_chance;
			real_fraction ai_destroy_chance;

			/* Perlin noise parameters */

			real_fraction random_offset_weight;
			real_bounds random_offset_period;

			/* Complex Flocking */

			real neighborhood_radius;
			angle perception_angle;
			real_fraction avoidance_weight;
			real avoidance_radius;
			real_fraction alignment_weight;
			real_fraction position_weight;
			real_bounds position_radius;
			c_typed_tag_reference<CHEAP_PARTICLE_EMITTER_TAG> battle_projectile_effect;
			c_typed_tag_reference<EFFECT_TAG> battle_projectile_effect_expensive;
			real_bounds battle_projectile_effect_cooldown;
			real_point3d battle_effect_offset;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			real_bounds boid_scale_range;
			c_flags<e_perceptionsettingsflags, char, k_perceptionsettingsflags_count> perception_flags;
			char generated_pad41f9[3]; // padding
			real object_perception_radius;
			real vehicle_perception_radius;
			real danger_event_perception_radius;
			c_flags<e_spawnsettingsflags, char, k_spawnsettingsflags_count> spawn_flags;
			c_flags<e_enableflag, char, k_enableflag_count> generate_spawn_point_for_each_boid;
			char generated_padd75d[2]; // padding
			long number_of_spawn_points;
			real distance_of_importance;
			real despawn_distance;
			real spawn_distance;
			real minimum_respawn_delay;
			real_bounds time_before_dehydration_hide_is_forced;
			real distance_enough_for_dehydration_hide;
			c_enum<e_spawnpriority, char> spawn_priority;
			c_flags<e_enableflag, char, k_enableflag_count> disable_backward_flock_relevancy_reduce;
			char generated_padbd7c[2]; // padding
			real_bounds production_frequency_bounds;
			real high_lod_distance;
			c_typed_tag_reference<CREATURE_TAG> creature_asset;
			string_id creature_variant_name;
			long boid_count;
			c_enum<e_flockbehaviortype, char> initial_behavior;
			c_enum<e_flockbehaviortype, char> second_behavior;
			c_enum<e_flockreactionbehaviortype, char> reaction_behavior;
			c_enum<e_flockbehaviortype, char> reaction_navigation_behavior;
			c_enum<e_flockreactionbehaviortype, char> second_reaction_behavior;
			c_enum<e_flockbehaviortype, char> second_reaction_navigation_behavior;
			c_enum<e_flockreactionbehaviortype, char> despawn_reaction_behavior;
			c_enum<e_flockbehaviortype, char> despawn_reaction_navigation_behavior;
			real event_memory_time;
			real return_after_disrupt_time;
			c_flags<e_flockfleeflags, short, k_flockfleeflags_count> flee_flags;
			char generated_padfcfe[2]; // padding
			real danger_weight;
			real_fraction additional_throttle;
			real_bounds time_before_hide_or_fly_away;
			real max_hide_time;
			c_enum<e_volumecontainmentmode, char> volume_containment_mode_evasion;
			char generated_pad49b3[3]; // padding
			real torus_inner_radius;
			real torus_cross_section_radius;
			c_enum<e_circlingdirectiontype, char> circling_direction;
			char generated_padf423[3]; // padding
			real leveling_coefficient;
			real traveling_spawn_radius;

			/* Runtime-generated path settings */

			real distance_to_the_initial_destination;
			real distance_to_the_final_destination;
			real spawn_cylinder_radius;
			real spawn_cylinder_height;
			real_bounds wandering_time;
			real_bounds grazing_time;
			real change_of_direction_time;
			c_flags<e_wanderingbehaviorflags, char, k_wanderingbehaviorflags_count> flags;
			c_flags<e_enableflag, char, k_enableflag_count> wandering_to_same_source_point_is_allowed;
			char generated_pad094b[2]; // padding
			c_flags<e_flyonfixedheightflags, char, k_flyonfixedheightflags_count> fly_on_fixed_height_flags;
			char generated_padbdf6[3]; // padding
			real fixed_height_from_ground;
			real height_rechecking_distance;
			real maximum_height_difference;
			c_flags<e_enableflag, char, k_enableflag_count> override_facing;
			c_flags<e_enableflag, char, k_enableflag_count> use_flock_formations;
			c_flags<e_boidgroundalignmentflags, char, k_boidgroundalignmentflags_count> ground_alignment;
			char generated_pad6ca6[1]; // padding
			real_fraction default_throttle;
			real start_slowing_distance;
			real_fraction slowing_to_fraction;
			real desired_start_descending_height;
			real start_descending_distance;
			real_bounds descending_throttle_bounds;
			real stop_distance;
			real start_parking_height;
			real increased_noise_distance;
			real noise_increase_multiplier;
			real_bounds time_between_one_off_random_boid_sounds_default;
			real density_scaler_for_one_off_sounds_default;
			real_bounds time_between_one_off_random_boid_sounds_fleeing;
			real density_scaler_for_one_off_sounds_fleeing;
			c_typed_tag_reference<SOUND_TAG> single_shot_sound_for_killed_by_the_player;
			c_typed_tag_reference<SOUND_TAG> single_shot_sound_for_non_player_death;
			c_typed_tag_reference<SOUND_TAG> single_shot_sound_for_despawn;
			c_typed_tag_reference<SOUND_LOOPING_TAG> looping_sound_for_idle;
			c_typed_tag_reference<SOUND_TAG> single_shot_sound_for_idle_randomly_plays;
			c_typed_tag_reference<SOUND_LOOPING_TAG> looping_sound_for_moving;
			c_typed_tag_reference<SOUND_TAG> single_shot_sound_for_moving_randomly_plays;
			c_typed_tag_reference<SOUND_TAG> single_shot_sound_for_reacting_to_danger;
			c_typed_tag_reference<SOUND_TAG> single_shot_sound_for_shooting;
			c_typed_tag_reference<OBJECT_TAG> proxy_object_asset;
			c_typed_tag_block<s_i343objectsobjectnodegraphdefinition> proxy_object_node_graphs_block;
		};
		static_assert(sizeof(s_aiflocktag) == 640, "struct s_aiflocktag is invalid size");

		struct s_i343flinchflinchimpulsesettings
		{
			c_enum<e_i343flincheflinchdirectiontype, char> flinch_direction;
			c_enum<e_i343flincheflinchmapping, char> flinch_mapping;
			char generated_pad3673[2]; // padding
			angle_bounds magnitude_range;
			angle random_rotation;
			angle absolute_flinch_angle;
			real_vector2d normalized_screen_relative_absolute_flinch;
		};
		static_assert(sizeof(s_i343flinchflinchimpulsesettings) == 28, "struct s_i343flinchflinchimpulsesettings is invalid size");

		struct s_i343flinchflinchimpulseinternaldefinition
		{
			// custom gun_flinch
			s_i343flinchflinchimpulsesettings gun_flinch;
			// custom value
			// custom view_flinch
			s_i343flinchflinchimpulsesettings view_flinch;
			// custom value
		};
		static_assert(sizeof(s_i343flinchflinchimpulseinternaldefinition) == 56, "struct s_i343flinchflinchimpulseinternaldefinition is invalid size");

		struct s_i343flinchflinchimpulsedefinition
		{
			s_anytag_struct_definition anytag;
			s_i343flinchflinchimpulseinternaldefinition flinch_impulse;
		};
		static_assert(sizeof(s_i343flinchflinchimpulsedefinition) == 72, "struct s_i343flinchflinchimpulsedefinition is invalid size");

		struct s_i343proceduralmotionrecoilangulardefinition
		{
			angle deceleration_away_from_center;
			angle acceleration_to_center;
		};
		static_assert(sizeof(s_i343proceduralmotionrecoilangulardefinition) == 8, "struct s_i343proceduralmotionrecoilangulardefinition is invalid size");

		struct s_i343flinchflinchrecoilblock
		{
			s_i343proceduralmotionrecoilangulardefinition recoil_return;
		};
		static_assert(sizeof(s_i343flinchflinchrecoilblock) == 8, "struct s_i343flinchflinchrecoilblock is invalid size");

		struct s_i343proceduralmotionspringdamperangulardefinition
		{
			real spring_constant;
			real damping_ratio;
			real runtime_damping_constant;
		};
		static_assert(sizeof(s_i343proceduralmotionspringdamperangulardefinition) == 12, "struct s_i343proceduralmotionspringdamperangulardefinition is invalid size");

		struct s_i343flinchflinchspringdamperblock
		{
			s_i343proceduralmotionspringdamperangulardefinition spring_damper;
		};
		static_assert(sizeof(s_i343flinchflinchspringdamperblock) == 12, "struct s_i343flinchflinchspringdamperblock is invalid size");

		struct s_i343flinchflinchsystemsettings
		{
			angle_bounds yaw_bounds;
			angle_bounds pitch_bounds;
			c_typed_tag_block<s_i343flinchflinchrecoilblock> recoil_block;
			c_typed_tag_block<s_i343flinchflinchspringdamperblock> spring_damper_block;
		};
		static_assert(sizeof(s_i343flinchflinchsystemsettings) == 40, "struct s_i343flinchflinchsystemsettings is invalid size");

		struct s_i343flinchflinchsysteminternaldefinition
		{
			// custom gun_flinch
			s_i343flinchflinchsystemsettings gun_flinch;
			// custom value
			// custom view_flinch
			s_i343flinchflinchsystemsettings view_flinch;
			// custom value
		};
		static_assert(sizeof(s_i343flinchflinchsysteminternaldefinition) == 80, "struct s_i343flinchflinchsysteminternaldefinition is invalid size");

		struct s_i343flinchflinchsystemdefinition
		{
			s_anytag_struct_definition anytag;
			s_i343flinchflinchsysteminternaldefinition flinch_system;
		};
		static_assert(sizeof(s_i343flinchflinchsystemdefinition) == 96, "struct s_i343flinchflinchsystemdefinition is invalid size");

		struct s_loopingsounddefinition_blocksize64
		{
			c_typed_tag_reference<SOUND_LOOPING_TAG> looping_sound_reference;
			string_id name;
		};
		static_assert(sizeof(s_loopingsounddefinition_blocksize64) == 20, "struct s_loopingsounddefinition_blocksize64 is invalid size");

		struct s_loopingsoundcategory
		{
			string_id name;
			c_typed_tag_block<s_loopingsounddefinition_blocksize64> sounds_block;
		};
		static_assert(sizeof(s_loopingsoundcategory) == 16, "struct s_loopingsoundcategory is invalid size");

		struct s_forgeloopingsoundcategories
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_loopingsoundcategory> looping_sound_categories_block;
			char generated_pad47fa[4]; // padding
		};
		static_assert(sizeof(s_forgeloopingsoundcategories) == 32, "struct s_forgeloopingsoundcategories is invalid size");

		struct s_typeface
		{
			c_static_string<256> font_name;
			c_enum<e_fontweight, long> font_weight;
			c_flags<e__fontfaceflags, short, k__fontfaceflags_count> flags;
			char generated_pad6635[2]; // padding
		};
		static_assert(sizeof(s_typeface) == 264, "struct s_typeface is invalid size");

		struct s_languagetypeface
		{
			c_enum<e_e_language, long> language;
			s_typeface replacement_typeface;
		};
		static_assert(sizeof(s_languagetypeface) == 268, "struct s_languagetypeface is invalid size");

		struct s_loctypeface
		{
			string_id typeface_name;
			s_typeface default_typeface;
			c_typed_tag_block<s_languagetypeface> language_specific_typefaces_block;
		};
		static_assert(sizeof(s_loctypeface) == 280, "struct s_loctypeface is invalid size");

		struct s_typefacedefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_loctypeface> typefaces_block;
			char generated_padb4d2[4]; // padding
		};
		static_assert(sizeof(s_typefacedefinition) == 32, "struct s_typefacedefinition is invalid size");

		struct s_forgenamedtagref
		{
			string_id name;
			c_typed_tag_reference<ANYTAG_TAG> _tag;
		};
		static_assert(sizeof(s_forgenamedtagref) == 20, "struct s_forgenamedtagref is invalid size");

		struct s_forgenamedtaglist
		{
			string_id listid;
			c_typed_tag_block<s_forgenamedtagref> items_block;
		};
		static_assert(sizeof(s_forgenamedtaglist) == 16, "struct s_forgenamedtaglist is invalid size");

		struct s_forgenamedtaglists
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_forgenamedtaglist> lists_block;
			char generated_pad31c9[4]; // padding
		};
		static_assert(sizeof(s_forgenamedtaglists) == 32, "struct s_forgenamedtaglists is invalid size");

		struct s_wpffontsetreferencesdefinition
		{
			c_typed_tag_reference<WPF_FONT_TAG> font;
			c_flags<e_wpffontsetreferencesdefinitionalllanagugesenabled, long, k_wpffontsetreferencesdefinitionalllanagugesenabled_count> wpf_all_languages;
			c_flags<e_fontsetlanguagflags, long, k_fontsetlanguagflags_count> wpf_flags;
			c_flags<e_wpffontsetreferencesdefinitionalllanagugesenabled, long, k_wpffontsetreferencesdefinitionalllanagugesenabled_count> fasthud_all_languages;
			c_flags<e_fontsetlanguagflags, long, k_fontsetlanguagflags_count> fasthud_flags;
		};
		static_assert(sizeof(s_wpffontsetreferencesdefinition) == 32, "struct s_wpffontsetreferencesdefinition is invalid size");

		struct s_wpffontsetdefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_wpffontsetreferencesdefinition> font_references_block;
			char generated_padab5f[4]; // padding
		};
		static_assert(sizeof(s_wpffontsetdefinition) == 32, "struct s_wpffontsetdefinition is invalid size");

		struct s_foliageassettag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<ASSET_TAG> asset;
			string_id foliage_variant_default_name;
		};
		static_assert(sizeof(s_foliageassettag) == 36, "struct s_foliageassettag is invalid size");

		struct s_s_atmosphere_definition
		{
			s_anytag_struct_definition anytag;
			// custom depth_fog
			// custom master_depth_fog_start

			/* Start Bias */

			real distance_bias;
			// custom value
			// custom depth_sky_fog
			s_s_solo_fog_parameters sky_fog;
			// custom value
			// custom depth_ground_fog
			s_s_solo_fog_parameters ground_fog;
			// custom value
			// custom depth_ceiling_fog
			s_s_ceiling_fog_parameters ceiling_fog;
			// custom value
			// custom value
			// custom fog_light
			s_s_fog_light_parameters fog_light;
			// custom value

			/* @@@ CAUTION  */

			s_volumetexturefogglobals fog_globals;

			/* Volume Texture Fog Per-Cluster Parameters */

			c_flags<e_volumetexturefogflags, long, k_volumetexturefogflags_count> flags;
			real sheet_density;
			rgb_color color_tint;
			rgb_color color_tint_inner;
			real intensity;
			real full_intensity_height;
			real half_intensity_height;
			real reference_plane_height;
			// custom volumetric_fog
			c_flags<e_volumetricfogflags, long, k_volumetricfogflags_count> volfog_flags;
			rgb_color volfog_color_1;
			rgb_color volfog_color_2;
			real volfog_density;
			real volfog_indirect_light_intensity;
			real volfog_light_intensity;
			real volfog_ambient_intensity;
			real volfog_sun_intensity;
			real volfog_near_range;
			real volfog_far_range;
			real volfog_range_exponent;
			real volfog_reprojection_weight;
			real volfog_inscatter_scale;
			real volfog_terrain_density_low;
			real volfog_terrain_density_high;
			real volfog_maximum_terrain_fog_height;
			real volfog_terrain_fog_falloff_exponent;
			real volfog_noise_scale;
			real volfog_noise_wind_influence;
			real volfog_noise_input_min;
			real volfog_noise_input_max;
			real volfog_noise_output_min;
			real volfog_noise_output_max;
			real volfog_noise_terrain_follow_intensity;
			real volfog_natural_light_near_intensity;
			real volfog_natural_light_far_intensity;
			real volfog_natural_light_range_near;
			real volfog_natural_light_range_far;
			real volfog_local_light_near_intensity;
			real volfog_local_light_far_intensity;
			real volfog_local_light_range_near;
			real volfog_local_light_range_far;
			// custom value
			// custom crepuscular_rays
			s_crepuscularrayparams crepuscular_ray;
			// custom value
		};
		static_assert(sizeof(s_s_atmosphere_definition) == 512, "struct s_s_atmosphere_definition is invalid size");

		struct s_s_bool_property
		{
			c_static_string<256> name;
			byte value;
		};
		static_assert(sizeof(s_s_bool_property) == 257, "struct s_s_bool_property is invalid size");

		struct s_s_numeric_property
		{
			c_static_string<256> name;
			real value;
		};
		static_assert(sizeof(s_s_numeric_property) == 260, "struct s_s_numeric_property is invalid size");

		struct s_s_string_property
		{
			c_static_string<256> name;
			c_static_string<256> value;
		};
		static_assert(sizeof(s_s_string_property) == 512, "struct s_s_string_property is invalid size");

		struct s_s_tag_property
		{
			c_static_string<256> name;
			c_typed_tag_reference<ANYTAG_TAG> value;
			string_id load_variant;
		};
		static_assert(sizeof(s_s_tag_property) == 276, "struct s_s_tag_property is invalid size");

		struct s_s_color_property
		{
			c_static_string<256> name;
			argb_color value;
		};
		static_assert(sizeof(s_s_color_property) == 272, "struct s_s_color_property is invalid size");

		struct s_s_vector_property
		{
			c_static_string<256> name;
			real_vector3d value;
		};
		static_assert(sizeof(s_s_vector_property) == 268, "struct s_s_vector_property is invalid size");

		struct s_s_property_collection
		{
			c_typed_tag_block<s_s_bool_property> bool_properties_block;
			c_typed_tag_block<s_s_numeric_property> numeric_properties_block;
			c_typed_tag_block<s_s_string_property> string_properties_block;
			c_typed_tag_block<s_s_tag_property> tag_properties_block;
			c_typed_tag_block<s_s_color_property> color_properties_block;
			c_typed_tag_block<s_s_vector_property> vector_properties_block;
		};
		static_assert(sizeof(s_s_property_collection) == 72, "struct s_s_property_collection is invalid size");

		struct s_forgeengineforgekitobject
		{
			string_id name;
			c_typed_tag_reference<ANYTAG_TAG> object;
			string_id asset_variant_name;
			c_typed_tag_reference<RUNTIME_GEO_TAG> asset_geo;
			c_typed_tag_reference<STATIC_COLLISION_TAG> asset_collision_geo;
			c_typed_tag_reference<RTMP_TAG> material_palette;
			real_point3d position;
			real_euler_angles3d rotation;
			real_vector3d scale;
		};
		static_assert(sizeof(s_forgeengineforgekitobject) == 108, "struct s_forgeengineforgekitobject is invalid size");

		struct s_forgeengineforgekitgroup
		{
			string_id name;
			string_id parent_name;
			long group_index;
			long parent_group_index;
			c_typed_tag_reference<LUA_TAG> script_tag;
			s_s_property_collection scriptable_properties;
			c_typed_tag_block<s_forgeengineforgekitobject> objects_block;
		};
		static_assert(sizeof(s_forgeengineforgekitgroup) == 116, "struct s_forgeengineforgekitgroup is invalid size");

		struct s_forgeengineforgekitdefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<KIT_TAG> original_kit;
			c_typed_tag_block<s_forgeengineforgekitgroup> kit_groups_block;
			long child_object_count;
			c_typed_tag_reference<FORGEOBJECTSCRIPTPROPERTYMENUITEMDEFINITIONS_TAG> menu_item_definitions;
		};
		static_assert(sizeof(s_forgeengineforgekitdefinition) == 64, "struct s_forgeengineforgekitdefinition is invalid size");

		struct s_antialiasdata
		{
			real antialiasdata;
		};
		static_assert(sizeof(s_antialiasdata) == 4, "struct s_antialiasdata is invalid size");

		struct s_wpffontdefinition
		{
			s_anytag_struct_definition anytag;
			// custom import
			c_static_string<256> font_name;
			c_enum<e_efontrendermode, long> render_mode;

			/* Vector Font Antialiasing Tweakables */

			s_antialiasdata anti_alias_data[4];
			s_tag_resource font_file_resource;
			char generated_padbe8d[4]; // padding
		};
		static_assert(sizeof(s_wpffontdefinition) == 304, "struct s_wpffontdefinition is invalid size");

		struct s_forgeengineforgeobjectdefinitionvariant
		{
			string_id representation_name;
			string_id crate_variant;
			c_typed_tag_reference<OBJECT_TAG> object_definition_crate;
			c_typed_tag_reference<FORGEOBJECTSCRIPTPROPERTYMENUITEMDEFINITIONS_TAG> menu_item_definitions;
		};
		static_assert(sizeof(s_forgeengineforgeobjectdefinitionvariant) == 40, "struct s_forgeengineforgeobjectdefinitionvariant is invalid size");

		struct s_forgeengineforgeassetvariant
		{
			string_id variant_name;
			c_typed_tag_reference<RUNTIME_GEO_TAG> runtime_underlying_geo_static_io;
			c_typed_tag_reference<STATIC_COLLISION_TAG> runtime_underlying_collision_geo_static_io;
			c_typed_tag_reference<RTMP_TAG> runtime_underlying_material_palette_static_io;
		};
		static_assert(sizeof(s_forgeengineforgeassetvariant) == 52, "struct s_forgeengineforgeassetvariant is invalid size");

		struct s_forgeengineswatchgroupname
		{
			string_id swatch_group_name;
		};
		static_assert(sizeof(s_forgeengineswatchgroupname) == 4, "struct s_forgeengineswatchgroupname is invalid size");

		struct s_forgeenginematerialregionsettings
		{
			c_typed_tag_block<s_forgeengineswatchgroupname> swatch_groups_block;
			c_enum<e_forgeenginematerialparameterstate, char> force_region_always_visible;
			c_enum<e_forgeenginematerialparameterstate, char> is_swatch_editable;
			c_enum<e_forgeenginematerialparameterstate, char> is_color_editable;
			c_enum<e_forgeenginematerialparameterstate, char> is_roughness_editable;
			c_enum<e_forgeenginematerialparameterstate, char> is_metalness__editable;
			char generated_padc70f[3]; // padding
			string_id color_variant;
		};
		static_assert(sizeof(s_forgeenginematerialregionsettings) == 24, "struct s_forgeenginematerialregionsettings is invalid size");

		struct s_forgeengineforgeobjectconfigoptions
		{
			c_flags<e_forgeengineforgeobjectdatapropertyflags, short, k_forgeengineforgeobjectdatapropertyflags_count> property_flags;
			char generated_padffaf[2]; // padding
			s_tag_reference configuration;
			real_vector3d starting_yaw_pitch_roll;
			c_enum<e_forgeenginedefaultphysicsmode, short> default_physics_mode;
			c_enum<e_forgeenginecollisionmode, short> collision_mode;
			c_enum<e_forgeenginescalelimittype, short> scale_limit_type;
			char generated_padb2fa[2]; // padding
			real_vector3d starting_scale;
			real_vector3d minimum_scale;
			real_vector3d maximum_scale;
			// custom material_settings
			// custom region_1
			s_forgeenginematerialregionsettings settings_region_1;
			// custom value
			// custom region_2
			s_forgeenginematerialregionsettings settings_region_2;
			// custom value
			// custom region_3
			s_forgeenginematerialregionsettings settings_region_3;
			// custom value
			// custom overlay
			s_forgeenginematerialregionsettings settings_overlay;
			// custom value
			// custom value
		};
		static_assert(sizeof(s_forgeengineforgeobjectconfigoptions) == 172, "struct s_forgeengineforgeobjectconfigoptions is invalid size");

		struct s_forgeengineforgeobjectdata
		{
			s_anytag_struct_definition anytag;
			s_tag_reference static_io_representation;
			string_id asset_variant_to_be_used_with_the_static_io_representation;
			c_typed_tag_block<s_forgeengineforgeobjectdefinitionvariant> object_representations_block;
			c_typed_tag_block<s_forgeengineforgeassetvariant> runtime_variants_block;
			c_typed_tag_reference<FORGETELESCOPINGASSET_TAG> runtime_telescoping_asset;
			c_typed_tag_reference<FORGEKIT_TAG> forge_kit;
			string_id default_representation_asset_variant_or_object_representation_name;
			s_forgeengineforgeobjectconfigoptions configuration_options;
			char generated_pad750f[4]; // padding
		};
		static_assert(sizeof(s_forgeengineforgeobjectdata) == 272, "struct s_forgeengineforgeobjectdata is invalid size");

		struct s_forgeengineforgeobjectmetadata
		{
			string_id keyword;
		};
		static_assert(sizeof(s_forgeengineforgeobjectmetadata) == 4, "struct s_forgeengineforgeobjectmetadata is invalid size");

		struct s_forgeengineforgeobjectmanifestentry
		{
			c_typed_tag_reference<FORGEOBJECTDATA_TAG> forge_object;
			string_id name;
			string_id description;
			c_typed_tag_reference<BITMAP_TAG> thumbnail;
			c_typed_tag_block<s_forgeengineforgeobjectmetadata> object_metadata_block;
		};
		static_assert(sizeof(s_forgeengineforgeobjectmanifestentry) == 52, "struct s_forgeengineforgeobjectmanifestentry is invalid size");

		struct s_forgeengineforgeobjectcategoryentry
		{
			string_id title;
			string_id description;
			string_id category_id;
			string_id parent_category_id;
		};
		static_assert(sizeof(s_forgeengineforgeobjectcategoryentry) == 16, "struct s_forgeengineforgeobjectcategoryentry is invalid size");

		struct s_forgeenginematerialstyleshader
		{
			string_id name;
			c_typed_tag_reference<MATERIALPALETTE_TAG> palette;
			c_typed_tag_reference<COATINGMATERIALSET_TAG> coatingmaterialset;
		};
		static_assert(sizeof(s_forgeenginematerialstyleshader) == 36, "struct s_forgeenginematerialstyleshader is invalid size");

		struct s_forgeengineforgeobjectmanifest
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_forgeengineforgeobjectmanifestentry> forge_object_entries_block;
			c_typed_tag_block<s_forgeengineforgeobjectcategoryentry> category_entries_block;
			string_id recent_objects_category_id;
			string_id prefabs_category_id;
			c_typed_tag_block<s_forgeenginematerialstyleshader> styleshaders_block;
			char generated_pad0120[4]; // padding
		};
		static_assert(sizeof(s_forgeengineforgeobjectmanifest) == 64, "struct s_forgeengineforgeobjectmanifest is invalid size");

		struct s_s_material_effect_material
		{
			s_tag_reference tag_effect_or_sound;
			s_tag_reference secondary_tag_effect_or_sound;
			string_id material_name;
			short runtime_material_index;
			c_enum<e_e_sweetener_mode, char> sweetener_mode;
			char generated_pad2bf3[1]; // padding
			real max_visibility_distance;
			c_flags<e_i343effectsmaterialeffectflags, char, k_i343effectsmaterialeffectflags_count> material_flags;
			char generated_paddf3e[3]; // padding
		};
		static_assert(sizeof(s_s_material_effect_material) == 48, "struct s_s_material_effect_material is invalid size");

		struct s_s_material_effect
		{
			c_typed_tag_block<s_s_material_effect_material> sounds_block;
			c_typed_tag_block<s_s_material_effect_material> effects_block;
		};
		static_assert(sizeof(s_s_material_effect) == 24, "struct s_s_material_effect is invalid size");

		struct s_s_material_effects_definition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_s_material_effect> effects_block;
			char generated_pad3926[4]; // padding
		};
		static_assert(sizeof(s_s_material_effects_definition) == 32, "struct s_s_material_effects_definition is invalid size");

		struct s_forgeactionsoundsdefinition
		{
			s_anytag_struct_definition anytag;
			// custom $$$_general_$$$
			c_typed_tag_reference<SOUND_TAG> undo_sound;
			c_typed_tag_reference<SOUND_TAG> redo_sound;
			c_typed_tag_reference<SOUND_TAG> monitor_speed_change_sound;
			c_typed_tag_reference<SOUND_TAG> error_sound;
			c_typed_tag_reference<SOUND_TAG> menu_opened_sound;
			c_typed_tag_reference<SOUND_TAG> menu_closed_sound;
			// custom value
			// custom $$$_objects_$$$
			c_typed_tag_reference<SOUND_TAG> object_select_sound;
			c_typed_tag_reference<SOUND_TAG> object_deselect_sound;
			c_typed_tag_reference<SOUND_TAG> object_snap_sound;
			c_typed_tag_reference<SOUND_TAG> object_place_sound;
			c_typed_tag_reference<SOUND_TAG> object_place_error_sound;
			c_typed_tag_reference<SOUND_TAG> object_duplicate_sound;
			c_typed_tag_reference<SOUND_TAG> object_delete_sound;
			c_typed_tag_reference<SOUND_TAG> object_lock_focus_sound;
			c_typed_tag_reference<SOUND_TAG> object_hide_sound;
			c_typed_tag_reference<SOUND_TAG> object_show_sound;
			c_typed_tag_reference<SOUND_TAG> object_lock_sound;
			c_typed_tag_reference<SOUND_TAG> object_unlock_sound;
			c_typed_tag_reference<SOUND_TAG> object_group_sound;
			c_typed_tag_reference<SOUND_TAG> object_ungroup_sound;
			c_typed_tag_reference<SOUND_TAG> object_rotate_sound;
			c_typed_tag_reference<SOUND_TAG> object_scale_sound;
			c_typed_tag_reference<SOUND_TAG> save_prefab_sound;
			// custom value
			// custom $$$_nodegraph_$$$
			c_typed_tag_reference<SOUND_TAG> nodegraph_enter_editor_sound;
			c_typed_tag_reference<SOUND_TAG> nodegraph_exit_editor_sound;
			c_typed_tag_reference<SOUND_TAG> nodegraph_place_node_sound;
			c_typed_tag_reference<SOUND_TAG> nodegraph_select_node_sound;
			c_typed_tag_reference<SOUND_TAG> nodegraph_deselect_node_sound;
			c_typed_tag_reference<SOUND_TAG> nodegraph_connect_nodes_sound;
			c_typed_tag_reference<SOUND_TAG> nodegraph_disconnect_node_sound;
			c_typed_tag_reference<SOUND_TAG> nodegraph_delete_node_sound;
			c_typed_tag_reference<SOUND_TAG> nodegraph_duplicate_node_sound;
			// custom value
			// custom $$$_script_validation_$$$
			c_typed_tag_reference<SOUND_TAG> script_validation_success_sound;
			c_typed_tag_reference<SOUND_TAG> script_validation_error_sound;
			// custom value
		};
		static_assert(sizeof(s_forgeactionsoundsdefinition) == 560, "struct s_forgeactionsoundsdefinition is invalid size");

		struct s_s_named_rgb_color
		{
			string_id name;
			rgb_color color;
		};
		static_assert(sizeof(s_s_named_rgb_color) == 16, "struct s_s_named_rgb_color is invalid size");

		struct s_forgecolorreference
		{
			char default_value;
			char generated_pad6d1d[3]; // padding
			string_id name;
		};
		static_assert(sizeof(s_forgecolorreference) == 8, "struct s_forgecolorreference is invalid size");

		struct s_forgeenginemonitormovespeed
		{
			string_id name;
			real translation_speed;
			real rotation_speed;
			real scale_speed;
		};
		static_assert(sizeof(s_forgeenginemonitormovespeed) == 16, "struct s_forgeenginemonitormovespeed is invalid size");

		struct s_jumbotrondefinition
		{
			c_typed_tag_reference<NODE_GRAPH_STACK_TAG> jumbotron_ui_element;
			string_id name;
		};
		static_assert(sizeof(s_jumbotrondefinition) == 20, "struct s_jumbotrondefinition is invalid size");

		struct s_forgedwsconstants
		{
			real min_sun_intensity;
			real max_sun_intensity;
			real min_static_tint_intensity;
			real max_static_tint_intensity;
			real min_sky_tint_intensity;
			real max_sky_tint_intensity;
			real min_wind_speed;
			real max_wind_speed;
			real min_explicit_camera_exposure;
			real max_explicit_camera_exposure;
			real default_ranged_camera_exposure;
			real max_camera_exposure_range;
			real min_fog_distance;
			real max_fog_distance;
			real min_fog_thickness;
			real max_fog_thickness;
			real min_fog_color_intensity;
			real max_fog_color_intensity;
		};
		static_assert(sizeof(s_forgedwsconstants) == 72, "struct s_forgedwsconstants is invalid size");

		struct s_forgegobodefinition
		{
			c_typed_tag_reference<GOBO_SETTING_TAG> gobo_setting;
			string_id name;
		};
		static_assert(sizeof(s_forgegobodefinition) == 20, "struct s_forgegobodefinition is invalid size");

		struct s_scalarlightfunction
		{
			string_id input_variable;
			string_id range_variable;
			c_enum<e_lightoutputmodifier, short> output_modifier;
			char generated_padc7e0[2]; // padding
			string_id output_modifier_input;
			// custom mapping
			s_functiondefinition mapping;
		};
		static_assert(sizeof(s_scalarlightfunction) == 36, "struct s_scalarlightfunction is invalid size");

		struct s_forgelightintensityfunctiondefinition
		{
			s_scalarlightfunction intensity_function;
			string_id name;
		};
		static_assert(sizeof(s_forgelightintensityfunctiondefinition) == 40, "struct s_forgelightintensityfunctiondefinition is invalid size");

		struct s_forgeareascreeneffectdefinition
		{
			c_typed_tag_reference<AREA_SCREEN_EFFECT_TAG> area_screen_effect;
			string_id name;
		};
		static_assert(sizeof(s_forgeareascreeneffectdefinition) == 20, "struct s_forgeareascreeneffectdefinition is invalid size");

		struct s_forgeweathereffectdefinition
		{
			c_typed_tag_reference<EFFECT_TAG> weather_effect;
			string_id name;
		};
		static_assert(sizeof(s_forgeweathereffectdefinition) == 20, "struct s_forgeweathereffectdefinition is invalid size");

		struct s_forgebitmapdefinition
		{
			c_typed_tag_reference<BITMAP_TAG> bitmap;
			string_id name;
		};
		static_assert(sizeof(s_forgebitmapdefinition) == 20, "struct s_forgebitmapdefinition is invalid size");

		struct s_forgelensflaredefinition
		{
			c_typed_tag_reference<LENS_FLARE_TAG> lens_flare;
			string_id name;
		};
		static_assert(sizeof(s_forgelensflaredefinition) == 20, "struct s_forgelensflaredefinition is invalid size");

		struct s_forgelightconedefinition
		{
			c_typed_tag_reference<LIGHT_CONE_TAG> light_cone;
			string_id name;
		};
		static_assert(sizeof(s_forgelightconedefinition) == 20, "struct s_forgelightconedefinition is invalid size");

		struct s_scalesnapdefinition
		{
			string_id name;
			real scale_snap_amount_relative_to_default_size;
		};
		static_assert(sizeof(s_scalesnapdefinition) == 8, "struct s_scalesnapdefinition is invalid size");

		struct s_rotationsnapdefinition
		{
			string_id name;
			real rotation_snap_amount_degrees;
		};
		static_assert(sizeof(s_rotationsnapdefinition) == 8, "struct s_rotationsnapdefinition is invalid size");

		struct s_translationsnapdefinition
		{
			string_id name;
			real translation_snap_amount_world_units;
		};
		static_assert(sizeof(s_translationsnapdefinition) == 8, "struct s_translationsnapdefinition is invalid size");

		struct s_forgelabeldefinition
		{
			string_id name;
			string_id label_display_name;
			string_id label_display_description;
			c_enum<e_forgeenginelabelapplicationrule, char> application_rule;
			c_flags<e_forgeenginelabelsideeffectflags, char, k_forgeenginelabelsideeffectflags_count> side_effects_of_label;
			char generated_pad20ec[2]; // padding
		};
		static_assert(sizeof(s_forgelabeldefinition) == 16, "struct s_forgelabeldefinition is invalid size");

		struct s_forgeoutlinedefinition
		{
			c_typed_tag_reference<OUTLINETYPEDEFINITION_TAG> outline_type;
		};
		static_assert(sizeof(s_forgeoutlinedefinition) == 16, "struct s_forgeoutlinedefinition is invalid size");

		struct s_compositiondefinitionreference
		{
			c_typed_tag_reference<COMPOSITION_TAG> composition_reference;
		};
		static_assert(sizeof(s_compositiondefinitionreference) == 16, "struct s_compositiondefinitionreference is invalid size");

		struct s_gametypecinematicname
		{
			string_id name;
		};
		static_assert(sizeof(s_gametypecinematicname) == 4, "struct s_gametypecinematicname is invalid size");

		struct s_teaminfotocinematicanimation
		{
			byte player_index_in_team;
			c_enum<e_ecinematicteamsize, char> team_size;
			c_enum<e_ecinematicteamrelation, char> team_relation;
			c_enum<e_i343netprotocolbondenumhelper_i343netprotocolmapvariantcinematictype_enum, char> cinematic_type;
			c_typed_tag_reference<MODEL_ANIMATION_GRAPH_TAG> model_animation_graph;
			string_id animation_name;
		};
		static_assert(sizeof(s_teaminfotocinematicanimation) == 24, "struct s_teaminfotocinematicanimation is invalid size");

		struct s_forgenodegraphschemadefinition
		{
			s_tag_data graphschema;
		};
		static_assert(sizeof(s_forgenodegraphschemadefinition) == 20, "struct s_forgenodegraphschemadefinition is invalid size");

		struct s_loopingsounddefinition_blocksize32
		{
			c_typed_tag_reference<SOUND_LOOPING_TAG> looping_sound_reference;
			string_id name;
		};
		static_assert(sizeof(s_loopingsounddefinition_blocksize32) == 20, "struct s_loopingsounddefinition_blocksize32 is invalid size");

		struct s_reverbdefinition
		{
			c_typed_tag_reference<SOUND_ENVIRONMENT_TAG> reverb_environment_reference;
			string_id name;
		};
		static_assert(sizeof(s_reverbdefinition) == 20, "struct s_reverbdefinition is invalid size");

		struct s_mixstatedefinition
		{
			string_id mix_state_group;
			string_id mix_state_value;
			string_id name;
		};
		static_assert(sizeof(s_mixstatedefinition) == 12, "struct s_mixstatedefinition is invalid size");

		struct s_forgeambientsounds
		{
			// custom forge_ambient_sounds
			c_typed_tag_block<s_loopingsounddefinition_blocksize32> base_air_sounds_block;
			c_typed_tag_block<s_loopingsounddefinition_blocksize32> base_air_sweetener_sounds_block;
			c_typed_tag_block<s_reverbdefinition> reverb_environments_block;
			c_typed_tag_block<s_mixstatedefinition> mix_states_block;
			// custom value
		};
		static_assert(sizeof(s_forgeambientsounds) == 48, "struct s_forgeambientsounds is invalid size");

		struct s_forgeglobalsdefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_s_named_rgb_color> forge_colors_block;
			c_typed_tag_block<s_forgecolorreference> forge_color_references_block;

			/* Magnets */

			c_typed_tag_reference<EFFECT_SCENERY_TAG> magnet_effect_scenery;
			string_id parent_magnet_marker_name;
			string_id child_magnet_marker_name;
			real_fraction deprecated_delete_me_when_systems_team_says_its_okay_1;
			real deprecated_delete_me_when_systems_team_says_its_okay_2;
			real deprecated_delete_me_when_systems_team_says_its_okay_3;
			real deprecated_delete_me_when_systems_team_says_its_okay_4;
			real deprecated_delete_me_when_systems_team_says_its_okay_5;
			real deprecated_delete_me_when_systems_team_says_its_okay_6;
			real deprecated_delete_me_when_systems_team_says_its_okay_7;
			real_fraction deprecated_delete_me_when_systems_team_says_its_okay_8;

			/* Forge Camera Manipulation */

			real max_object_grab_range;
			real default_grab_distance_mult;
			real_bounds min_max_grab_distance_mult;
			real_bounds minimum_grab_distance_threshold;
			real_bounds maximum_grab_distance_threshold;
			real lock_on_time;
			real grab_cam_soft_ceiling_movement_speed;
			real grab_cam_inward_spring_constant;
			real grab_cam_outward_spring_constant;
			real camera_object_distance_threshold;
			c_typed_tag_block<s_forgeenginemonitormovespeed> monitor_speed_multipliers_block;
			string_id monitor_boost_name;
			real monitor_boost_translation_speed;
			real monitor_boost_rotation_speed;
			real monitor_boost_scale_speed;
			c_typed_tag_block<s_jumbotrondefinition> jumbotron_ui_element_block;
			s_forgedwsconstants forge_dws_constants;
			c_typed_tag_block<s_forgegobodefinition> forge_gobo_definitions_block;
			c_typed_tag_block<s_forgelightintensityfunctiondefinition> forge_light_intensity_function_definitions_block;
			c_typed_tag_block<s_forgeareascreeneffectdefinition> forge_area_screen_effect_definitions_block;
			c_typed_tag_block<s_forgeweathereffectdefinition> forge_weather_effect_definitions_block;
			c_typed_tag_block<s_forgebitmapdefinition> forge_patchy_fog_bitmaps_block;
			c_typed_tag_block<s_forgebitmapdefinition> forge_cloud_bitmaps_block;
			c_typed_tag_block<s_forgelensflaredefinition> forge_lens_flares_block;
			c_typed_tag_block<s_forgelightconedefinition> forge_light_cones_block;
			c_typed_tag_block<s_scalesnapdefinition> scale_snap_values_block;
			c_typed_tag_block<s_rotationsnapdefinition> rotation_snap_values_block;
			c_typed_tag_block<s_translationsnapdefinition> translation_snap_values_block;
			c_typed_tag_reference<SCENARIO_REQUIRED_RESOURCE_TAG> forge_required_resources;
			c_typed_tag_reference<MATERIAL_TAG> rotation_handle_shader;
			c_typed_tag_reference<MATERIAL_TAG> path_preview_shader;
			c_typed_tag_block<s_forgelabeldefinition> global_label_values_block;
			c_typed_tag_block<s_forgeoutlinedefinition> outline_type_definitions_block;
			string_id forge_intro_composition_name;
			c_typed_tag_block<s_compositiondefinitionreference> forge_intro_compositions_block;
			c_typed_tag_reference<COMPOSITION_TAG> forge_outro_composition_template;
			c_typed_tag_reference<COMPOSITION_TAG> forge_static_view_composition_template;
			c_typed_tag_block<s_gametypecinematicname> game_type_cinematic_names_block;
			c_typed_tag_block<s_teaminfotocinematicanimation> cinematic_player_animations_block;
			c_typed_tag_reference<MATERIAL_TAG> default_boundary_shader;
			char generated_padd2ca[4]; // padding
			long long m_rotationhandlepipelinestate;
			long long m_pathpreviewpipelinestate;
			long long m_defaultboundarypipelinestate;
			long long m_handlewithdepthteststate;
			c_typed_tag_reference<FORGEOBJECTMANIFEST_TAG> forge_object_manifest;
			c_typed_tag_reference<FORGENAMEDTAGLISTS_TAG> forge_named_tag_lists;
			c_typed_tag_block<s_forgenodegraphschemadefinition> forge_nodegraph_schema_block;
			c_typed_tag_reference<FORGEOBJECTDATA_TAG> forge_script_brain_tag_reference;
			c_typed_tag_reference<FORGE_SOUNDS_TAG> forge_sound_tag_reference;
			s_forgeambientsounds forge_ambient_sounds;
			c_typed_tag_reference<FORGE_LOOPING_SOUND_CATEGORIES_TAG> forge_looping_sound_categories;
			c_typed_tag_reference<FORGE_SOUND_RESPONSE_SOUNDS_TAG> forge_sound_response_sounds;
			char generated_pad1f7f[4]; // padding
		};
		static_assert(sizeof(s_forgeglobalsdefinition) == 748, "struct s_forgeglobalsdefinition is invalid size");

		struct s_s_formation_point
		{

			/* value */

			angle _angle;
			real offset;
		};
		static_assert(sizeof(s_s_formation_point) == 8, "struct s_s_formation_point is invalid size");

		struct s_s_formation_primitive
		{

			/* value */

			c_flags<e_formationprimitiveflags, short, k_formationprimitiveflags_count> flags;
			short priority;
			short capacity;
			char generated_pad9ea5[2]; // padding
			real dist_forwards;
			real dist_backwards;
			real rank_spacing;
			real file_spacing;
			c_typed_tag_block<s_s_formation_point> points_block;
		};
		static_assert(sizeof(s_s_formation_primitive) == 36, "struct s_s_formation_primitive is invalid size");

		struct s_s_formation_definition
		{
			s_anytag_struct_definition anytag;
			string_id name;
			c_typed_tag_block<s_s_formation_primitive> primitives_block;
		};
		static_assert(sizeof(s_s_formation_definition) == 32, "struct s_s_formation_definition is invalid size");

		struct s_forgeengineforgeobjectscriptpropertymenuitemstring
		{
			string_id _string;
			c_static_string<256> string_literal;
		};
		static_assert(sizeof(s_forgeengineforgeobjectscriptpropertymenuitemstring) == 260, "struct s_forgeengineforgeobjectscriptpropertymenuitemstring is invalid size");

		struct s_forgeengineforgeobjectscriptpropertymenuitemdefinition
		{
			string_id property;
			string_id title;
			string_id description;
			c_static_string<256> property_name_literal;
			c_enum<e_forgeengineforgeobjectscriptpropertyvaluetype, short> value_type;
			char generated_pad36ce[2]; // padding
			real float_min;
			real float_max;
			real float_step;
			string_id string_list;
			c_typed_tag_block<s_forgeengineforgeobjectscriptpropertymenuitemstring> strings_block;
			string_id callback_name;
			string_id submenu_id;
			string_id submenu_description;
			c_flags<e_forgeengineforgebooleanflag, char, k_forgeengineforgebooleanflag_count> hidden_in_forge;
			char generated_pad8383[3]; // padding
		};
		static_assert(sizeof(s_forgeengineforgeobjectscriptpropertymenuitemdefinition) == 316, "struct s_forgeengineforgeobjectscriptpropertymenuitemdefinition is invalid size");

		struct s_forgeengineforgeobjectscriptpropertymenuitemdefinitioncollection
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_forgeengineforgeobjectscriptpropertymenuitemdefinition> menu_item_definitions_block;
			char generated_pad82b6[4]; // padding
		};
		static_assert(sizeof(s_forgeengineforgeobjectscriptpropertymenuitemdefinitioncollection) == 32, "struct s_forgeengineforgeobjectscriptpropertymenuitemdefinitioncollection is invalid size");

		struct s_i343objectsforgepalettedefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<FORGEPALETTEDEFINITION_TAG> parent_palette;
			string_id name;
			string_id description;
			real placement_priority;
			c_flags<e_i343objectsforgepaletteflags, short, k_i343objectsforgepaletteflags_count> flags;
			char generated_paddd1c[6]; // padding
		};
		static_assert(sizeof(s_i343objectsforgepalettedefinition) == 52, "struct s_i343objectsforgepalettedefinition is invalid size");

		struct s_s_import_frame_event
		{
			string_id event_name;
			string_id animation_name;
			short frame;
			short frame_offset;
			c_enum<e_animationframeeventtype, short> type;
			char generated_pade518[2]; // padding
			long unique_id;
		};
		static_assert(sizeof(s_s_import_frame_event) == 20, "struct s_s_import_frame_event is invalid size");

		struct s_s_sound_event_extended_deprecated
		{
			short frame_event;
			short sound;
			short frame_offset;
			char generated_pad72c6[2]; // padding
			// custom value
			string_id marker_name;
		};
		static_assert(sizeof(s_s_sound_event_extended_deprecated) == 12, "struct s_s_sound_event_extended_deprecated is invalid size");

		struct s_s_effect_event_extended_deprecated
		{
			short frame_event;
			short effect;
			short frame_offset;
			char generated_pad3d06[2]; // padding
			// custom value
			string_id marker_name;
		};
		static_assert(sizeof(s_s_effect_event_extended_deprecated) == 12, "struct s_s_effect_event_extended_deprecated is invalid size");

		struct s_s_dialogue_event_extended_deprecated
		{
			short frame_event;
			short dialogue_reference;
			short frame_offset;
		};
		static_assert(sizeof(s_s_dialogue_event_extended_deprecated) == 6, "struct s_s_dialogue_event_extended_deprecated is invalid size");

		struct s_s_import_animation_event
		{
			string_id animation_name;
			long animation_frame_count;
			c_typed_tag_block<s_s_import_frame_event> animation_events_block;
			c_typed_tag_block<s_s_sound_event_extended_deprecated> sound_events_block;
			c_typed_tag_block<s_s_effect_event_extended_deprecated> effect_events_block;
			c_typed_tag_block<s_s_dialogue_event_extended_deprecated> dialogue_events_block;
		};
		static_assert(sizeof(s_s_import_animation_event) == 56, "struct s_s_import_animation_event is invalid size");

		struct s_c_animation_frame_event_list
		{
			s_anytag_struct_definition anytag;

			/* IMPORTANT TAG NOTES */

			c_typed_tag_block<s_soundeventreferenceset> sound_references_block;
			c_typed_tag_block<s_animationgraphdialoguereference> dialogue_references_block;
			c_typed_tag_block<s_effecteventreferenceset> effect_references_block;
			c_typed_tag_block<s_s_import_animation_event> frame_events_block;
			c_typed_tag_reference<FRAME_EVENT_LIST_AUDIO_TAG> audio_frame_events_tag;
			c_typed_tag_reference<FRAME_EVENT_LIST_EFFECT_TAG> effect_frame_events_tag;
		};
		static_assert(sizeof(s_c_animation_frame_event_list) == 96, "struct s_c_animation_frame_event_list is invalid size");

		struct s_engineforgesoundeventdefinition
		{
			string_id name;
			string_id sound_category;
			c_typed_tag_reference<SOUND_RESPONSE_TAG> sound_response;
		};
		static_assert(sizeof(s_engineforgesoundeventdefinition) == 24, "struct s_engineforgesoundeventdefinition is invalid size");

		struct s_engineforgesoundlistdefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_engineforgesoundeventdefinition> entries_block;
			char generated_padf045[4]; // padding
		};
		static_assert(sizeof(s_engineforgesoundlistdefinition) == 32, "struct s_engineforgesoundlistdefinition is invalid size");

		struct s_forgesoundresponsedefinition
		{
			string_id name;
			c_typed_tag_reference<SOUND_RESPONSE_TAG> sound_response_reference;
		};
		static_assert(sizeof(s_forgesoundresponsedefinition) == 20, "struct s_forgesoundresponsedefinition is invalid size");

		struct s_forgesoundresponsesounds
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_forgesoundresponsedefinition> sound_response_sounds_block;
			char generated_pad13f9[4]; // padding
		};
		static_assert(sizeof(s_forgesoundresponsesounds) == 32, "struct s_forgesoundresponsesounds is invalid size");

		struct s_forgeenginetelescopingpoint
		{
			real_vector3d point;
		};
		static_assert(sizeof(s_forgeenginetelescopingpoint) == 12, "struct s_forgeenginetelescopingpoint is invalid size");

		struct s_forgeenginetelescopingcorner
		{
			c_typed_tag_reference<ANYTAG_TAG> object;
			real_vector3d position;
			string_id variant;
			real_vector3d tip;
			c_typed_tag_block<s_forgeenginetelescopingpoint> magnets_block;
			real_vector3d positionatminscale;
			real_vector3d positionatmaxscale;
			c_typed_tag_reference<RUNTIME_GEO_TAG> runtime_underlying_geo_static_io;
			c_typed_tag_reference<STATIC_COLLISION_TAG> runtime_underlying_collision_geo_static_io;
			c_typed_tag_reference<RTMP_TAG> runtime_underlying_material_palette_static_io;
		};
		static_assert(sizeof(s_forgeenginetelescopingcorner) == 128, "struct s_forgeenginetelescopingcorner is invalid size");

		struct s_forgeenginetelescopingedge
		{
			c_typed_tag_reference<ANYTAG_TAG> object;
			real_vector3d position;
			string_id variant;
			real_vector3d creasetip1;
			real_vector3d creasetip2;
			c_typed_tag_block<s_forgeenginetelescopingpoint> endpoints_block;
			real_quaternion rotation;
			c_enum<e_forgeenginetelescopingobjectspaceedgealignment, char> objectspaceedgealignment;
			char generated_padf5c1[3]; // padding
			c_typed_tag_block<s_forgeenginetelescopingpoint> magnets_block;
			real_vector3d positionatminscale;
			real_vector3d positionatmaxscale;
			real scaleatminscale;
			real scaleatmaxscale;
			c_typed_tag_reference<RUNTIME_GEO_TAG> runtime_underlying_geo_static_io;
			c_typed_tag_reference<STATIC_COLLISION_TAG> runtime_underlying_collision_geo_static_io;
			c_typed_tag_reference<RTMP_TAG> runtime_underlying_material_palette_static_io;
		};
		static_assert(sizeof(s_forgeenginetelescopingedge) == 180, "struct s_forgeenginetelescopingedge is invalid size");

		struct s_forgeenginetelescopingface
		{
			c_typed_tag_reference<ANYTAG_TAG> object;
			real_vector3d position;
			string_id variant;
			c_typed_tag_block<s_forgeenginetelescopingpoint> faceendpoints_block;
			c_typed_tag_block<s_forgeenginetelescopingpoint> magnets_block;
			c_typed_tag_reference<RUNTIME_GEO_TAG> runtime_underlying_geo_static_io;
			c_typed_tag_reference<STATIC_COLLISION_TAG> runtime_underlying_collision_geo_static_io;
			c_typed_tag_reference<RTMP_TAG> runtime_underlying_material_palette_static_io;
			real_vector3d endpointsboundsmax;
			real_vector3d endpointsboundsmin;
			real_vector3d geoboundsmin;
			real_vector3d geoboundsmax;
			c_enum<e_forgeenginetelescopingmaintainfacewidth, char> facewidthtomaintain;
			char generated_padac75[3]; // padding
			real_vector3d positionatminscale;
			real_vector3d positionatmaxscale;
			real_vector3d scaleatminscale;
			real_vector3d scaleatmaxscale;
		};
		static_assert(sizeof(s_forgeenginetelescopingface) == 204, "struct s_forgeenginetelescopingface is invalid size");

		struct s_forgeenginetelescopingassettag
		{
			s_anytag_struct_definition anytag;
			c_enum<e_forgeenginetelescopingsolutiontype, char> telescopingsolutiontype;
			char generated_pad4682[3]; // padding
			c_typed_tag_block<s_forgeenginetelescopingcorner> corners_block;
			c_typed_tag_block<s_forgeenginetelescopingedge> edges_block;
			c_typed_tag_block<s_forgeenginetelescopingface> faces_block;
			c_enum<e_forgeenginetelescopingscaleconstraint, char> scaleconstraint;
			char generated_pad9337[3]; // padding
			real_vector3d starting_scale;
			real_vector3d minimum_scale;
			real_vector3d maximum_scale;
			c_typed_tag_reference<STATIC_COLLISION_TAG> runtime_underlying_collision_geo_static_io;
			c_typed_tag_reference<RTMP_TAG> runtime_underlying_material_palette_static_io;
		};
		static_assert(sizeof(s_forgeenginetelescopingassettag) == 128, "struct s_forgeenginetelescopingassettag is invalid size");

		struct s_interfacefasthudresourcehandledefinition
		{
			dword resource_type;
			long resource_index;
		};
		static_assert(sizeof(s_interfacefasthudresourcehandledefinition) == 8, "struct s_interfacefasthudresourcehandledefinition is invalid size");

		struct s_interfacefasthudresourceentrydefinition
		{
			string_id name;
			s_interfacefasthudresourcehandledefinition handle;
		};
		static_assert(sizeof(s_interfacefasthudresourceentrydefinition) == 12, "struct s_interfacefasthudresourceentrydefinition is invalid size");

		struct s_interfacefasthudbooleandefinition
		{
			c_flags<e_interfacefasthudbooleanflags, char, k_interfacefasthudbooleanflags_count> value;
		};
		static_assert(sizeof(s_interfacefasthudbooleandefinition) == 1, "struct s_interfacefasthudbooleandefinition is invalid size");

		struct s_interfacefasthudintegerdefinition
		{
			long value;
		};
		static_assert(sizeof(s_interfacefasthudintegerdefinition) == 4, "struct s_interfacefasthudintegerdefinition is invalid size");

		struct s_interfacefasthudfloatdefinition
		{
			real value;
		};
		static_assert(sizeof(s_interfacefasthudfloatdefinition) == 4, "struct s_interfacefasthudfloatdefinition is invalid size");

		struct s_interfacefasthudfasthudcoloractualdata
		{
			string_id name;
			argb_color value;
		};
		static_assert(sizeof(s_interfacefasthudfasthudcoloractualdata) == 20, "struct s_interfacefasthudfasthudcoloractualdata is invalid size");

		struct s_interfacefasthudfasthudcolor
		{
			s_interfacefasthudfasthudcoloractualdata value;
			argb_color value_old_;
		};
		static_assert(sizeof(s_interfacefasthudfasthudcolor) == 36, "struct s_interfacefasthudfasthudcolor is invalid size");

		struct s_interfacefasthudpoint2fdefinition
		{
			real_point2d value;
		};
		static_assert(sizeof(s_interfacefasthudpoint2fdefinition) == 8, "struct s_interfacefasthudpoint2fdefinition is invalid size");

		struct s_interfacefasthudstringiddefinition
		{
			string_id value;
		};
		static_assert(sizeof(s_interfacefasthudstringiddefinition) == 4, "struct s_interfacefasthudstringiddefinition is invalid size");

		struct s_interfacefasthudbitmapgroupreferencedefinition
		{
			c_typed_tag_reference<BITMAP_TAG> asset_reference;
			word sprite_index;
			char generated_padbdbe[2]; // padding
		};
		static_assert(sizeof(s_interfacefasthudbitmapgroupreferencedefinition) == 20, "struct s_interfacefasthudbitmapgroupreferencedefinition is invalid size");

		struct s_interfacefasthudanimationbasedefinition
		{
			string_id target;
			s_interfacefasthudresourcehandledefinition repeat_behavior;
		};
		static_assert(sizeof(s_interfacefasthudanimationbasedefinition) == 12, "struct s_interfacefasthudanimationbasedefinition is invalid size");

		struct s_interfacefasthudfloatanimationdefinition
		{
			s_interfacefasthudanimationbasedefinition animation_base;
			c_flags<e_interfacefasthudfloatanimationflags, char, k_interfacefasthudfloatanimationflags_count> flags;
			char generated_padf997[3]; // padding
			real from;
			real to;
			real duration;
		};
		static_assert(sizeof(s_interfacefasthudfloatanimationdefinition) == 28, "struct s_interfacefasthudfloatanimationdefinition is invalid size");

		struct s_interfacefasthudcoloranimationdefinition
		{
			s_interfacefasthudanimationbasedefinition animation_base;
			c_flags<e_interfacefasthudcoloranimationflags, char, k_interfacefasthudcoloranimationflags_count> flags;
			char generated_pada026[3]; // padding
			s_interfacefasthudfasthudcoloractualdata from;
			argb_color from_old_;
			s_interfacefasthudfasthudcoloractualdata to;
			argb_color to_old_;
			real duration;
		};
		static_assert(sizeof(s_interfacefasthudcoloranimationdefinition) == 92, "struct s_interfacefasthudcoloranimationdefinition is invalid size");

		struct s_interfacefasthudpoint2fanimationdefinition
		{
			s_interfacefasthudanimationbasedefinition animation_base;
			c_flags<e_interfacefasthudpoint2fanimationflags, char, k_interfacefasthudpoint2fanimationflags_count> flags;
			char generated_pad693f[3]; // padding
			real_point2d from;
			real_point2d to;
			real duration;
		};
		static_assert(sizeof(s_interfacefasthudpoint2fanimationdefinition) == 36, "struct s_interfacefasthudpoint2fanimationdefinition is invalid size");

		struct s_interfacefasthudintegeranimationdefinition
		{
			s_interfacefasthudanimationbasedefinition animation_base;
			c_flags<e_interfacefasthudintegeranimationflags, char, k_interfacefasthudintegeranimationflags_count> flags;
			char generated_pad388f[3]; // padding
			long from;
			long to;
			real duration;
		};
		static_assert(sizeof(s_interfacefasthudintegeranimationdefinition) == 28, "struct s_interfacefasthudintegeranimationdefinition is invalid size");

		struct s_interfacefasthudresourcehandle
		{
			s_interfacefasthudresourcehandledefinition handle;
		};
		static_assert(sizeof(s_interfacefasthudresourcehandle) == 8, "struct s_interfacefasthudresourcehandle is invalid size");

		struct s_interfacefasthudstoryboarddefinition
		{
			c_typed_tag_block<s_interfacefasthudresourcehandle> timelines_block;
		};
		static_assert(sizeof(s_interfacefasthudstoryboarddefinition) == 12, "struct s_interfacefasthudstoryboarddefinition is invalid size");

		struct s_interfacefasthudnumericdisplaydefinition
		{
			c_static_string<32> extra_characters_used_in_display_in_addition_to_0_to_9;
			c_typed_tag_reference<BITMAP_TAG> asset_reference;
			s_interfacefasthudfasthudcoloractualdata tint_color_of_the_numeric_display;
			argb_color tint_color_old_;
			real_point2d alignment_point_on_screen;
			c_enum<e_interfacefasthudnumericdisplaytextalignment, short> numeric_display_alignment_based_on_alignment_point_given;
			c_flags<e_interfacefasthudnumericdisplayflags, char, k_interfacefasthudnumericdisplayflags_count> flags;
			char generated_padc1d6[1]; // padding
		};
		static_assert(sizeof(s_interfacefasthudnumericdisplaydefinition) == 96, "struct s_interfacefasthudnumericdisplaydefinition is invalid size");

		struct s_interfacefasthudvisualstatedefinition
		{
			string_id name;
			s_interfacefasthudresourcehandledefinition storyboard;
		};
		static_assert(sizeof(s_interfacefasthudvisualstatedefinition) == 12, "struct s_interfacefasthudvisualstatedefinition is invalid size");

		struct s_interfacefasthudvisualstategroupdefinition
		{
			c_typed_tag_block<s_interfacefasthudresourcehandle> visual_states_block;
		};
		static_assert(sizeof(s_interfacefasthudvisualstategroupdefinition) == 12, "struct s_interfacefasthudvisualstategroupdefinition is invalid size");

		struct s_interfacefasthudfloatanimationusingkeyframesdefinition
		{
			s_interfacefasthudanimationbasedefinition animation_base;
			c_typed_tag_block<s_interfacefasthudresourcehandle> key_frames_block;
		};
		static_assert(sizeof(s_interfacefasthudfloatanimationusingkeyframesdefinition) == 24, "struct s_interfacefasthudfloatanimationusingkeyframesdefinition is invalid size");

		struct s_interfacefasthudfloatkeyframebasedefinition
		{
			real key_time;
			real key_value;
		};
		static_assert(sizeof(s_interfacefasthudfloatkeyframebasedefinition) == 8, "struct s_interfacefasthudfloatkeyframebasedefinition is invalid size");

		struct s_interfacefasthudlinearfloatkeyframedefinition
		{
			s_interfacefasthudfloatkeyframebasedefinition keyframebase;
		};
		static_assert(sizeof(s_interfacefasthudlinearfloatkeyframedefinition) == 8, "struct s_interfacefasthudlinearfloatkeyframedefinition is invalid size");

		struct s_interfacefasthuddiscretefloatkeyframedefinition
		{
			s_interfacefasthudfloatkeyframebasedefinition keyframebase;
		};
		static_assert(sizeof(s_interfacefasthuddiscretefloatkeyframedefinition) == 8, "struct s_interfacefasthuddiscretefloatkeyframedefinition is invalid size");

		struct s_interfacefasthudcoloranimationusingkeyframesdefinition
		{
			s_interfacefasthudanimationbasedefinition animation_base;
			c_typed_tag_block<s_interfacefasthudresourcehandle> key_frames_block;
		};
		static_assert(sizeof(s_interfacefasthudcoloranimationusingkeyframesdefinition) == 24, "struct s_interfacefasthudcoloranimationusingkeyframesdefinition is invalid size");

		struct s_interfacefasthudcolorkeyframebasedefinition
		{
			real key_time;
			s_interfacefasthudfasthudcoloractualdata key_value;
			argb_color key_value_old_;
		};
		static_assert(sizeof(s_interfacefasthudcolorkeyframebasedefinition) == 40, "struct s_interfacefasthudcolorkeyframebasedefinition is invalid size");

		struct s_interfacefasthudlinearcolorkeyframedefinition
		{
			s_interfacefasthudcolorkeyframebasedefinition keyframebase;
		};
		static_assert(sizeof(s_interfacefasthudlinearcolorkeyframedefinition) == 40, "struct s_interfacefasthudlinearcolorkeyframedefinition is invalid size");

		struct s_interfacefasthuddiscretecolorkeyframedefinition
		{
			s_interfacefasthudcolorkeyframebasedefinition keyframebase;
		};
		static_assert(sizeof(s_interfacefasthuddiscretecolorkeyframedefinition) == 40, "struct s_interfacefasthuddiscretecolorkeyframedefinition is invalid size");

		struct s_interfacefasthudbooleananimationusingkeyframesdefinition
		{
			s_interfacefasthudanimationbasedefinition animation_base;
			c_typed_tag_block<s_interfacefasthudresourcehandle> key_frames_block;
		};
		static_assert(sizeof(s_interfacefasthudbooleananimationusingkeyframesdefinition) == 24, "struct s_interfacefasthudbooleananimationusingkeyframesdefinition is invalid size");

		struct s_interfacefasthudbooleankeyframebasedefinition
		{
			real key_time;
			c_flags<e_interfacefasthudbooleanflags, char, k_interfacefasthudbooleanflags_count> key_value;
			char generated_pad2322[3]; // padding
		};
		static_assert(sizeof(s_interfacefasthudbooleankeyframebasedefinition) == 8, "struct s_interfacefasthudbooleankeyframebasedefinition is invalid size");

		struct s_interfacefasthuddiscretebooleankeyframedefinition
		{
			s_interfacefasthudbooleankeyframebasedefinition keyframebase;
		};
		static_assert(sizeof(s_interfacefasthuddiscretebooleankeyframedefinition) == 8, "struct s_interfacefasthuddiscretebooleankeyframedefinition is invalid size");

		struct s_interfacefasthudpoint2fanimationusingkeyframesdefinition
		{
			s_interfacefasthudanimationbasedefinition animation_base;
			c_typed_tag_block<s_interfacefasthudresourcehandle> key_frames_block;
		};
		static_assert(sizeof(s_interfacefasthudpoint2fanimationusingkeyframesdefinition) == 24, "struct s_interfacefasthudpoint2fanimationusingkeyframesdefinition is invalid size");

		struct s_interfacefasthudpoint2fkeyframebasedefinition
		{
			real key_time;
			real_point2d key_value;
		};
		static_assert(sizeof(s_interfacefasthudpoint2fkeyframebasedefinition) == 12, "struct s_interfacefasthudpoint2fkeyframebasedefinition is invalid size");

		struct s_interfacefasthudlinearpoint2fkeyframedefinition
		{
			s_interfacefasthudpoint2fkeyframebasedefinition keyframebase;
		};
		static_assert(sizeof(s_interfacefasthudlinearpoint2fkeyframedefinition) == 12, "struct s_interfacefasthudlinearpoint2fkeyframedefinition is invalid size");

		struct s_interfacefasthuddiscretepoint2fkeyframedefinition
		{
			s_interfacefasthudpoint2fkeyframebasedefinition keyframebase;
		};
		static_assert(sizeof(s_interfacefasthuddiscretepoint2fkeyframedefinition) == 12, "struct s_interfacefasthuddiscretepoint2fkeyframedefinition is invalid size");

		struct s_interfacefasthudintegeranimationusingkeyframesdefinition
		{
			s_interfacefasthudanimationbasedefinition animation_base;
			c_typed_tag_block<s_interfacefasthudresourcehandle> key_frames_block;
		};
		static_assert(sizeof(s_interfacefasthudintegeranimationusingkeyframesdefinition) == 24, "struct s_interfacefasthudintegeranimationusingkeyframesdefinition is invalid size");

		struct s_interfacefasthudintegerkeyframebasedefinition
		{
			real key_time;
			long key_value;
		};
		static_assert(sizeof(s_interfacefasthudintegerkeyframebasedefinition) == 8, "struct s_interfacefasthudintegerkeyframebasedefinition is invalid size");

		struct s_interfacefasthudlinearintegerkeyframedefinition
		{
			s_interfacefasthudintegerkeyframebasedefinition keyframebase;
		};
		static_assert(sizeof(s_interfacefasthudlinearintegerkeyframedefinition) == 8, "struct s_interfacefasthudlinearintegerkeyframedefinition is invalid size");

		struct s_interfacefasthuddiscreteintegerkeyframedefinition
		{
			s_interfacefasthudintegerkeyframebasedefinition keyframebase;
		};
		static_assert(sizeof(s_interfacefasthuddiscreteintegerkeyframedefinition) == 8, "struct s_interfacefasthuddiscreteintegerkeyframedefinition is invalid size");

		struct s_interfacefasthudrepeatbehaviordefinition
		{
			c_flags<e_interfacefasthudrepeatbehaviorflags, char, k_interfacefasthudrepeatbehaviorflags_count> flags;
			char generated_padc8d8[3]; // padding
			long count;
			real duration;
		};
		static_assert(sizeof(s_interfacefasthudrepeatbehaviordefinition) == 12, "struct s_interfacefasthudrepeatbehaviordefinition is invalid size");

		struct s_interfacefasthudsounddefinition
		{
			c_typed_tag_reference<SOUND_TAG> asset_reference;
		};
		static_assert(sizeof(s_interfacefasthudsounddefinition) == 16, "struct s_interfacefasthudsounddefinition is invalid size");

		struct s_interfacefasthudsoundloopdefinition
		{
			c_typed_tag_reference<SOUND_LOOPING_TAG> asset_reference;
		};
		static_assert(sizeof(s_interfacefasthudsoundloopdefinition) == 16, "struct s_interfacefasthudsoundloopdefinition is invalid size");

		struct s_interfacefasthudnavpointlayoutreferencedefinition
		{
			c_typed_tag_reference<NAVPOINTLAYOUTDEFINITION_TAG> tag_reference;
		};
		static_assert(sizeof(s_interfacefasthudnavpointlayoutreferencedefinition) == 16, "struct s_interfacefasthudnavpointlayoutreferencedefinition is invalid size");

		struct s_interfacefasthudnavpointanimationreferencedefinition
		{
			c_typed_tag_reference<NAVPOINTANIMATIONDEFINITION_TAG> tag_reference;
		};
		static_assert(sizeof(s_interfacefasthudnavpointanimationreferencedefinition) == 16, "struct s_interfacefasthudnavpointanimationreferencedefinition is invalid size");

		struct s_interfacefasthudstringtableentrydefinition
		{
			c_typed_tag_reference<MULTILINGUAL_UNICODE_STRING_LIST_TAG> data;
		};
		static_assert(sizeof(s_interfacefasthudstringtableentrydefinition) == 16, "struct s_interfacefasthudstringtableentrydefinition is invalid size");

		struct s_interfacefasthudstringtabledefinition
		{
			c_typed_tag_block<s_interfacefasthudstringtableentrydefinition> entires_block;
		};
		static_assert(sizeof(s_interfacefasthudstringtabledefinition) == 12, "struct s_interfacefasthudstringtabledefinition is invalid size");

		struct s_interfacefasthudsubcomponentdefinition
		{
			c_typed_tag_reference<COMPONENTDEFINITION_TAG> sub_component_reference;
		};
		static_assert(sizeof(s_interfacefasthudsubcomponentdefinition) == 16, "struct s_interfacefasthudsubcomponentdefinition is invalid size");

		struct s_interfacefasthudhudtwotonegradientdefinition
		{
			s_interfacefasthudfasthudcoloractualdata left_color;
			argb_color left_color_old_;
			s_interfacefasthudfasthudcoloractualdata right_color;
			argb_color right_color_old_;
			real edge_filter_amount;
			real current_meter_value;
			real min_meter_value;
			real max_meter_value;
			c_flags<e_interfacefasthudbooleanflags, char, k_interfacefasthudbooleanflags_count> additive_blend_toggle;
			char generated_pad6488[3]; // padding
		};
		static_assert(sizeof(s_interfacefasthudhudtwotonegradientdefinition) == 92, "struct s_interfacefasthudhudtwotonegradientdefinition is invalid size");

		struct s_interfacefasthudfontdefinition
		{
			c_static_string<256> font_family_name;
			s_interfacefasthudfasthudcoloractualdata tint_color;
			argb_color tint_color_old_;
			real font_size;
		};
		static_assert(sizeof(s_interfacefasthudfontdefinition) == 296, "struct s_interfacefasthudfontdefinition is invalid size");

		struct s_interfacefasthudhighcontrastadditivedefinition
		{
			real dynamic_threshold_min;
			real dynamic_threshold_max;
			real dynamic_threshold_clamp;
			c_flags<e_interfacefasthudbooleanflags, char, k_interfacefasthudbooleanflags_count> high_contrast_enable;
			char generated_pad7bd5[3]; // padding
		};
		static_assert(sizeof(s_interfacefasthudhighcontrastadditivedefinition) == 16, "struct s_interfacefasthudhighcontrastadditivedefinition is invalid size");

		struct s_interfacefasthudvertexwarpdefinition
		{
			real_point3d ellipsoid_scale;
			real_point3d ellipsoid_center;
			real_point3d output_offset;
			long tessellation_x;
			long tessellation_y;
			c_flags<e_interfacefasthudbooleanflags, char, k_interfacefasthudbooleanflags_count> warp_enabled;
			char generated_pad0073[3]; // padding
		};
		static_assert(sizeof(s_interfacefasthudvertexwarpdefinition) == 48, "struct s_interfacefasthudvertexwarpdefinition is invalid size");

		struct s_interfacefasthudcomponentresourcesdefinition
		{
			c_typed_tag_block<s_interfacefasthudresourceentrydefinition> entries_block;
			c_typed_tag_block<s_interfacefasthudbooleandefinition> booleans_block;
			c_typed_tag_block<s_interfacefasthudintegerdefinition> ints_block;
			c_typed_tag_block<s_interfacefasthudfloatdefinition> floats_block;
			c_typed_tag_block<s_interfacefasthudfasthudcolor> colors_block;
			c_typed_tag_block<s_interfacefasthudpoint2fdefinition> point2fs_block;
			c_typed_tag_block<s_interfacefasthudstringiddefinition> string_ids_block;
			c_typed_tag_block<s_interfacefasthudbitmapgroupreferencedefinition> bitmaps_block;
			c_typed_tag_block<s_interfacefasthudfloatanimationdefinition> floatanimations_block;
			c_typed_tag_block<s_interfacefasthudcoloranimationdefinition> coloranimations_block;
			c_typed_tag_block<s_interfacefasthudpoint2fanimationdefinition> point2fanimations_block;
			c_typed_tag_block<s_interfacefasthudintegeranimationdefinition> integeranimations_block;
			c_typed_tag_block<s_interfacefasthudstoryboarddefinition> storyboards_block;
			c_typed_tag_block<s_interfacefasthudnumericdisplaydefinition> numericdisplay_block;
			c_typed_tag_block<s_interfacefasthudvisualstatedefinition> visualstates_block;
			c_typed_tag_block<s_interfacefasthudvisualstategroupdefinition> visualstategroups_block;
			c_typed_tag_block<s_interfacefasthudfloatanimationusingkeyframesdefinition> floatanimationusingkeyframes_block;
			c_typed_tag_block<s_interfacefasthudlinearfloatkeyframedefinition> linearfloatkeyframes_block;
			c_typed_tag_block<s_interfacefasthuddiscretefloatkeyframedefinition> discretefloatkeyframes_block;
			c_typed_tag_block<s_interfacefasthudcoloranimationusingkeyframesdefinition> coloranimationusingkeyframes_block;
			c_typed_tag_block<s_interfacefasthudlinearcolorkeyframedefinition> linearcolorkeyframes_block;
			c_typed_tag_block<s_interfacefasthuddiscretecolorkeyframedefinition> discretecolorkeyframes_block;
			c_typed_tag_block<s_interfacefasthudbooleananimationusingkeyframesdefinition> booleananimationusingkeyframes_block;
			c_typed_tag_block<s_interfacefasthuddiscretebooleankeyframedefinition> discretebooleankeyframes_block;
			c_typed_tag_block<s_interfacefasthudpoint2fanimationusingkeyframesdefinition> point2fanimationusingkeyframes_block;
			c_typed_tag_block<s_interfacefasthudlinearpoint2fkeyframedefinition> linearpoint2fkeyframes_block;
			c_typed_tag_block<s_interfacefasthuddiscretepoint2fkeyframedefinition> discretepoint2fkeyframes_block;
			c_typed_tag_block<s_interfacefasthudintegeranimationusingkeyframesdefinition> integeranimationusingkeyframes_block;
			c_typed_tag_block<s_interfacefasthudlinearintegerkeyframedefinition> linearintegerkeyframes_block;
			c_typed_tag_block<s_interfacefasthuddiscreteintegerkeyframedefinition> discreteintegerkeyframes_block;
			c_typed_tag_block<s_interfacefasthudrepeatbehaviordefinition> repeatbehaviors_block;
			c_typed_tag_block<s_interfacefasthudsounddefinition> sound_block;
			c_typed_tag_block<s_interfacefasthudsoundloopdefinition> soundloop_block;
			c_typed_tag_block<s_interfacefasthudnavpointlayoutreferencedefinition> navpointlayouts_block;
			c_typed_tag_block<s_interfacefasthudnavpointanimationreferencedefinition> navpointanimations_block;
			c_typed_tag_block<s_interfacefasthudstringtabledefinition> stringtables_block;
			c_typed_tag_block<s_interfacefasthudsubcomponentdefinition> subcomponents_block;
			c_typed_tag_block<s_interfacefasthudhudtwotonegradientdefinition> hudtwotonegradient_block;
			c_typed_tag_block<s_interfacefasthudfontdefinition> font_block;
			c_typed_tag_block<s_interfacefasthudhighcontrastadditivedefinition> highcontrastadditive_block;
			c_typed_tag_block<s_interfacefasthudvertexwarpdefinition> vertexwarp_block;
		};
		static_assert(sizeof(s_interfacefasthudcomponentresourcesdefinition) == 492, "struct s_interfacefasthudcomponentresourcesdefinition is invalid size");

		struct s_interfacefasthudcomponentdefinition
		{
			s_anytag_struct_definition anytag;
			string_id name;
			c_static_string<32> _class;
			s_interfacefasthudcomponentresourcesdefinition resources;
		};
		static_assert(sizeof(s_interfacefasthudcomponentdefinition) == 544, "struct s_interfacefasthudcomponentdefinition is invalid size");

		struct s_interfacefasthudscreencomponentreference
		{
			c_typed_tag_reference<COMPONENTDEFINITION_TAG> reference;
		};
		static_assert(sizeof(s_interfacefasthudscreencomponentreference) == 16, "struct s_interfacefasthudscreencomponentreference is invalid size");

		struct s_interfacefasthudscreendefinition
		{
			s_anytag_struct_definition anytag;
			string_id name;
			string_id warp_params_name;
			string_id chromatic_aberration_params_name;
			string_id high_contrast_params_name;
			c_typed_tag_block<s_interfacefasthudscreencomponentreference> components_block;
			char generated_padbecb[4]; // padding
		};
		static_assert(sizeof(s_interfacefasthudscreendefinition) == 48, "struct s_interfacefasthudscreendefinition is invalid size");

		struct s_contenteffectplacement
		{
			c_typed_tag_reference<EFFECT_TAG> effect;
			real_point3d position;
			real_euler_angles3d facing;
			real scale;
		};
		static_assert(sizeof(s_contenteffectplacement) == 44, "struct s_contenteffectplacement is invalid size");

		struct s_effectkittag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_contenteffectplacement> effect_placements_block;
			// custom global_overrides
			rgb_color overridecolor;
			real globalscale;
			real globalemissionareascale;
			real globalemissionratescale;
			c_enum<e_effectloopstate, char> overrideloopstate;
			c_enum<e_effectplacementmode, char> placementmode;
			char generated_pad16d5[2]; // padding
			// custom value
			c_typed_tag_reference<EFFECT_TAG> generated_effect;
			char generated_padfcf4[4]; // padding
		};
		static_assert(sizeof(s_effectkittag) == 76, "struct s_effectkittag is invalid size");

		struct s_gameenginetextdefinition
		{
			c_typed_tag_reference<MULTILINGUAL_UNICODE_STRING_LIST_TAG> text_source;
			c_typed_tag_reference<STRINGLIST_TAG> new_text_source;
		};
		static_assert(sizeof(s_gameenginetextdefinition) == 32, "struct s_gameenginetextdefinition is invalid size");

		struct s_s_game_engine_globals_definition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_gameenginetextdefinition> game_engine_text_block;
			char generated_padba96[4]; // padding
		};
		static_assert(sizeof(s_s_game_engine_globals_definition) == 32, "struct s_s_game_engine_globals_definition is invalid size");

		struct s_basicpresetdefinition
		{
			c_static_string<32> preset;
			c_enum<e_reflectionpresetdefinitionpresets, char> reflections;
			c_enum<e_volumetricfogpresetdefinitionpresets, char> volumetric_fog;
			c_enum<e_shadowpresetdefinitionpresets, char> shadows;
			c_enum<e_skyqualitypresetdefinitionpresets, char> sky_quality;
			c_enum<e_temporalaapresetdefinitionpresets, char> temporal_aa;
			c_enum<e_aopresetdefinitionpresets, char> ambient_occlusion;
			c_enum<e_depthoffieldpresetdefinitionpresets, char> depth_of_field;
			c_enum<e_anisotropicfilteringpresetdefinitionpresets, char> anisotropic_filtering;
			c_enum<e_terrainpresetdefinitionpresets, char> terrain;
			c_enum<e_lightingpresetdefinitionpresets, char> lighting;
			c_enum<e_decoratorspresetdefinitionpresets, char> decorators;
			c_enum<e_assetcategorypresetdefinitionpresets, char> asset_category_preset;
			c_enum<e_dynamicwindpresetdefinitionpresets, char> dynamic_wind;
			c_enum<e_hlodpresetdefinitionpresets, char> hlod_preset;
			c_enum<e_animationqualitypresetdefinitionpresets, char> animation_quality;
			c_enum<e_flocksqualitypresetdefinitionpresets, char> flocks;
			c_enum<e_simulationqualitypresetdefinitionpresets, char> simulation_quality;
			c_enum<e_effectspresetdefinitionpresets, char> effects;
			c_enum<e_texturequalitypresetdefinitionpresets, char> texture_quality;
			c_enum<e_decalspresetdefinitionpresets, char> decals;
			c_enum<e_shaderqualitypresetdefinitionpresets, char> shader_quality;
		};
		static_assert(sizeof(s_basicpresetdefinition) == 53, "struct s_basicpresetdefinition is invalid size");

		struct s_reflectionpresetdefinitionsplitscreenpreset
		{
			c_enum<e_reflectionpresetdefinitionmodes, char> mode;
		};
		static_assert(sizeof(s_reflectionpresetdefinitionsplitscreenpreset) == 1, "struct s_reflectionpresetdefinitionsplitscreenpreset is invalid size");

		struct s_speccontrolvramsettings
		{
			long initial_vram_usage;
			long vram_per_1_million_pixels;
		};
		static_assert(sizeof(s_speccontrolvramsettings) == 8, "struct s_speccontrolvramsettings is invalid size");

		struct s_reflectionpresetdefinition
		{
			c_static_string<32> preset;
			c_enum<e_reflectionpresetdefinitionmodes, char> mode;
			// custom single_screen
			s_reflectionpresetdefinitionsplitscreenpreset single_screen_preset;
			// custom value
			// custom _2_player_splitscreen
			s_reflectionpresetdefinitionsplitscreenpreset _2_player_splitscreen_preset;
			// custom value
			// custom _3_player_splitscreen
			s_reflectionpresetdefinitionsplitscreenpreset _3_player_splitscreen_preset;
			// custom value
			// custom _4_player_splitscreen
			s_reflectionpresetdefinitionsplitscreenpreset _4_player_splitscreen_preset;
			char generated_padeff7[3]; // padding
			// custom value
			// custom vram
			s_speccontrolvramsettings vram;
			// custom value
		};
		static_assert(sizeof(s_reflectionpresetdefinition) == 48, "struct s_reflectionpresetdefinition is invalid size");

		struct s_volumetricfogpresetdefinitionsplitscreenpreset
		{
			long resolution;
			c_flags<e_volumetricfogpresetdefinitionvolumetricfogflags, char, k_volumetricfogpresetdefinitionvolumetricfogflags_count> volumetric_fog_flags;
			char generated_pad26b1[3]; // padding
		};
		static_assert(sizeof(s_volumetricfogpresetdefinitionsplitscreenpreset) == 8, "struct s_volumetricfogpresetdefinitionsplitscreenpreset is invalid size");

		struct s_volumetricfogpresetdefinition
		{
			c_static_string<32> preset;
			long resolution;
			c_flags<e_volumetricfogpresetdefinitionvolumetricfogflags, char, k_volumetricfogpresetdefinitionvolumetricfogflags_count> volumetric_fog_flags;
			char generated_pad0612[3]; // padding
			// custom single_screen
			s_volumetricfogpresetdefinitionsplitscreenpreset single_screen_preset;
			// custom value
			// custom _2_player_splitscreen
			s_volumetricfogpresetdefinitionsplitscreenpreset _2_player_splitscreen_preset;
			// custom value
			// custom _3_player_splitscreen
			s_volumetricfogpresetdefinitionsplitscreenpreset _3_player_splitscreen_preset;
			// custom value
			// custom _4_player_splitscreen
			s_volumetricfogpresetdefinitionsplitscreenpreset _4_player_splitscreen_preset;
			// custom value
			// custom vram
			s_speccontrolvramsettings vram;
			// custom value
		};
		static_assert(sizeof(s_volumetricfogpresetdefinition) == 80, "struct s_volumetricfogpresetdefinition is invalid size");

		struct s_shadowpresetdefinitionsplitscreenpreset
		{
			long dynamic_shadowmap_atlas_resolution;
			long dynamic_shadowmap_atlas_resolution_no_sun;
			long static_shadowmap_atlas_resolution;
			c_flags<e_shadowpresetdefinitionenabledeferredshadowmaskflag, char, k_shadowpresetdefinitionenabledeferredshadowmaskflag_count> deferred_shadow_mask;
			c_flags<e_shadowpresetdefinitionenablecontactshadowsflag, char, k_shadowpresetdefinitionenablecontactshadowsflag_count> contact_shadows;
			c_flags<e_shadowpresetdefinitionenablelocallightslowshadowsamplingflag, char, k_shadowpresetdefinitionenablelocallightslowshadowsamplingflag_count> local_lights_low_shadow_sampling;
			char generated_padf8ff[1]; // padding
			real local_lights_shadow_sampling_falloff;
		};
		static_assert(sizeof(s_shadowpresetdefinitionsplitscreenpreset) == 20, "struct s_shadowpresetdefinitionsplitscreenpreset is invalid size");

		struct s_shadowpresetdefinition
		{
			c_static_string<32> preset;
			long dynamic_shadowmap_atlas_resolution;
			long dynamic_shadowmap_atlas_resolution_no_sun;
			long static_shadowmap_atlas_resolution;
			c_flags<e_shadowpresetdefinitionenabledeferredshadowmaskflag, char, k_shadowpresetdefinitionenabledeferredshadowmaskflag_count> deferred_shadow_mask;
			c_flags<e_shadowpresetdefinitionenablecontactshadowsflag, char, k_shadowpresetdefinitionenablecontactshadowsflag_count> contact_shadows;
			c_flags<e_shadowpresetdefinitionenablelocallightslowshadowsamplingflag, char, k_shadowpresetdefinitionenablelocallightslowshadowsamplingflag_count> local_lights_low_shadow_sampling;
			char generated_pad91b0[1]; // padding
			real local_lights_shadow_sampling_falloff;
			// custom single_screen
			s_shadowpresetdefinitionsplitscreenpreset single_screen_preset;
			// custom value
			// custom _2_player_splitscreen
			s_shadowpresetdefinitionsplitscreenpreset _2_player_splitscreen_preset;
			// custom value
			// custom _3_player_splitscreen
			s_shadowpresetdefinitionsplitscreenpreset _3_player_splitscreen_preset;
			// custom value
			// custom _4_player_splitscreen
			s_shadowpresetdefinitionsplitscreenpreset _4_player_splitscreen_preset;
			// custom value
			// custom vram
			s_speccontrolvramsettings vram;
			// custom value
		};
		static_assert(sizeof(s_shadowpresetdefinition) == 140, "struct s_shadowpresetdefinition is invalid size");

		struct s_skyqualitypresetdefinitionsplitscreenpreset
		{
			c_flags<e_skyqualitypresetdefinitionenablevolumetriccloudsflag, char, k_skyqualitypresetdefinitionenablevolumetriccloudsflag_count> volumetric_clouds_enable_flag;
			char generated_pad31c9[3]; // padding
			long volumetric_clouds_rt_width_resolution;
			long volumetric_clouds_rt_height_resolution;
			long volumetric_clouds_depth_rt_resolution;
			long perlin_worley_noise_resolution;
			long worley_noise_resolution;
			long curl_noise_resolution;
			long volumetric_clouds_shape_ray_steps;
			long volumetric_clouds_lighting_ray_steps;
			real volumetric_clouds_beer_scale;
			real volumetric_clouds_cornette_scale;
			real volumetric_clouds_coverage_strength;
			long volumetric_clouds_perf_tier;
		};
		static_assert(sizeof(s_skyqualitypresetdefinitionsplitscreenpreset) == 52, "struct s_skyqualitypresetdefinitionsplitscreenpreset is invalid size");

		struct s_skyqualitypresetdefinition
		{
			c_static_string<32> preset;
			c_flags<e_skyqualitypresetdefinitionenablevolumetriccloudsflag, char, k_skyqualitypresetdefinitionenablevolumetriccloudsflag_count> volumetric_clouds_enable_flag;
			char generated_pad520a[3]; // padding
			long volumetric_clouds_rt_width_resolution;
			long volumetric_clouds_rt_height_resolution;
			long volumetric_clouds_depth_rt_resolution;
			long perlin_worley_noise_resolution;
			long worley_noise_resolution;
			long curl_noise_resolution;
			long volumetric_clouds_shape_ray_steps;
			long volumetric_clouds_lighting_ray_steps;
			real volumetric_clouds_beer_scale;
			real volumetric_clouds_cornette_scale;
			real volumetric_clouds_coverage_strength;
			long volumetric_clouds_perf_tier;
			// custom single_screen
			s_skyqualitypresetdefinitionsplitscreenpreset single_screen_preset;
			// custom value
			// custom _2_player_splitscreen
			s_skyqualitypresetdefinitionsplitscreenpreset _2_player_splitscreen_preset;
			// custom value
			// custom _3_player_splitscreen
			s_skyqualitypresetdefinitionsplitscreenpreset _3_player_splitscreen_preset;
			// custom value
			// custom _4_player_splitscreen
			s_skyqualitypresetdefinitionsplitscreenpreset _4_player_splitscreen_preset;
			// custom value
			// custom vram
			s_speccontrolvramsettings vram;
			// custom value
		};
		static_assert(sizeof(s_skyqualitypresetdefinition) == 300, "struct s_skyqualitypresetdefinition is invalid size");

		struct s_temporalaapresetdefinitionsplitscreenpreset
		{
			c_flags<e_temporalaapresetdefinitionenabletemporalaaflag, char, k_temporalaapresetdefinitionenabletemporalaaflag_count> enable_flag;
			char generated_pad7fc7[3]; // padding
			long quality;
		};
		static_assert(sizeof(s_temporalaapresetdefinitionsplitscreenpreset) == 8, "struct s_temporalaapresetdefinitionsplitscreenpreset is invalid size");

		struct s_temporalaapresetdefinition
		{
			c_static_string<32> preset;
			c_flags<e_temporalaapresetdefinitionenabletemporalaaflag, char, k_temporalaapresetdefinitionenabletemporalaaflag_count> enable_flag;
			char generated_pad3998[3]; // padding
			long quality;
			// custom single_screen
			s_temporalaapresetdefinitionsplitscreenpreset single_screen_preset;
			// custom value
			// custom _2_player_splitscreen
			s_temporalaapresetdefinitionsplitscreenpreset _2_player_splitscreen_preset;
			// custom value
			// custom _3_player_splitscreen
			s_temporalaapresetdefinitionsplitscreenpreset _3_player_splitscreen_preset;
			// custom value
			// custom _4_player_splitscreen
			s_temporalaapresetdefinitionsplitscreenpreset _4_player_splitscreen_preset;
			// custom value
			// custom vram
			s_speccontrolvramsettings vram;
			// custom value
		};
		static_assert(sizeof(s_temporalaapresetdefinition) == 80, "struct s_temporalaapresetdefinition is invalid size");

		struct s_aopresetdefinitionsplitscreenpreset
		{
			c_flags<e_aopresetdefinitionaoflags, char, k_aopresetdefinitionaoflags_count> flags;
			char generated_pad8c97[3]; // padding
			long quality;
		};
		static_assert(sizeof(s_aopresetdefinitionsplitscreenpreset) == 8, "struct s_aopresetdefinitionsplitscreenpreset is invalid size");

		struct s_aopresetdefinition
		{
			c_static_string<32> preset;
			c_flags<e_aopresetdefinitionaoflags, char, k_aopresetdefinitionaoflags_count> flags;
			char generated_paddfa8[3]; // padding
			long quality;
			// custom single_screen
			s_aopresetdefinitionsplitscreenpreset single_screen_preset;
			// custom value
			// custom _2_player_splitscreen
			s_aopresetdefinitionsplitscreenpreset _2_player_splitscreen_preset;
			// custom value
			// custom _3_player_splitscreen
			s_aopresetdefinitionsplitscreenpreset _3_player_splitscreen_preset;
			// custom value
			// custom _4_player_splitscreen
			s_aopresetdefinitionsplitscreenpreset _4_player_splitscreen_preset;
			// custom value
			// custom vram
			s_speccontrolvramsettings vram;
			// custom value
		};
		static_assert(sizeof(s_aopresetdefinition) == 80, "struct s_aopresetdefinition is invalid size");

		struct s_depthoffieldpresetdefinitionsplitscreenpreset
		{
			long ring_count;
			c_enum<e_depthoffieldpresetdefinitionblurtype, char> blur_type;
			char generated_pad9a0b[3]; // padding
		};
		static_assert(sizeof(s_depthoffieldpresetdefinitionsplitscreenpreset) == 8, "struct s_depthoffieldpresetdefinitionsplitscreenpreset is invalid size");

		struct s_depthoffieldpresetdefinition
		{
			c_static_string<32> preset;
			long ring_count;
			c_enum<e_depthoffieldpresetdefinitionblurtype, char> blur_type;
			char generated_pad9984[3]; // padding
			// custom single_screen
			s_depthoffieldpresetdefinitionsplitscreenpreset single_screen_preset;
			// custom value
			// custom _2_player_splitscreen
			s_depthoffieldpresetdefinitionsplitscreenpreset _2_player_splitscreen_preset;
			// custom value
			// custom _3_player_splitscreen
			s_depthoffieldpresetdefinitionsplitscreenpreset _3_player_splitscreen_preset;
			// custom value
			// custom _4_player_splitscreen
			s_depthoffieldpresetdefinitionsplitscreenpreset _4_player_splitscreen_preset;
			// custom value
			// custom vram
			s_speccontrolvramsettings vram;
			// custom value
		};
		static_assert(sizeof(s_depthoffieldpresetdefinition) == 80, "struct s_depthoffieldpresetdefinition is invalid size");

		struct s_anisotropicfilteringpresetdefinitionsplitscreenpreset
		{
			c_enum<e_anisotropicfilteringpresetdefinitionanisotropicfilteringlevel, char> level;
		};
		static_assert(sizeof(s_anisotropicfilteringpresetdefinitionsplitscreenpreset) == 1, "struct s_anisotropicfilteringpresetdefinitionsplitscreenpreset is invalid size");

		struct s_anisotropicfilteringpresetdefinition
		{
			c_static_string<32> preset;
			c_enum<e_anisotropicfilteringpresetdefinitionanisotropicfilteringlevel, char> level;
			// custom single_screen
			s_anisotropicfilteringpresetdefinitionsplitscreenpreset single_screen_preset;
			// custom value
			// custom _2_player_splitscreen
			s_anisotropicfilteringpresetdefinitionsplitscreenpreset _2_player_splitscreen_preset;
			// custom value
			// custom _3_player_splitscreen
			s_anisotropicfilteringpresetdefinitionsplitscreenpreset _3_player_splitscreen_preset;
			// custom value
			// custom _4_player_splitscreen
			s_anisotropicfilteringpresetdefinitionsplitscreenpreset _4_player_splitscreen_preset;
			char generated_padc853[3]; // padding
			// custom value
			// custom vram
			s_speccontrolvramsettings vram;
			// custom value
		};
		static_assert(sizeof(s_anisotropicfilteringpresetdefinition) == 48, "struct s_anisotropicfilteringpresetdefinition is invalid size");

		struct s_terrainpresetdefinitionsplitscreenpreset
		{
			real lod_radius_factor;
		};
		static_assert(sizeof(s_terrainpresetdefinitionsplitscreenpreset) == 4, "struct s_terrainpresetdefinitionsplitscreenpreset is invalid size");

		struct s_terrainpresetdefinition
		{
			c_static_string<32> preset;
			real lod_radius_factor;
			// custom single_screen
			s_terrainpresetdefinitionsplitscreenpreset single_screen_preset;
			// custom value
			// custom _2_player_splitscreen
			s_terrainpresetdefinitionsplitscreenpreset _2_player_splitscreen_preset;
			// custom value
			// custom _3_player_splitscreen
			s_terrainpresetdefinitionsplitscreenpreset _3_player_splitscreen_preset;
			// custom value
			// custom _4_player_splitscreen
			s_terrainpresetdefinitionsplitscreenpreset _4_player_splitscreen_preset;
			// custom value
			// custom vram
			s_speccontrolvramsettings vram;
			// custom value
		};
		static_assert(sizeof(s_terrainpresetdefinition) == 60, "struct s_terrainpresetdefinition is invalid size");

		struct s_lightingpresetdefinition
		{
			c_static_string<32> preset;
			// custom vram
			s_speccontrolvramsettings vram;
			// custom value
		};
		static_assert(sizeof(s_lightingpresetdefinition) == 40, "struct s_lightingpresetdefinition is invalid size");

		struct s_decoratorspresetdefinition
		{
			c_enum<e_interactionpresetdefinitionpresets, char> push_bending;
			c_static_string<32> preset;
			char generated_pad704e[3]; // padding
			// custom vram
			s_speccontrolvramsettings vram;
			// custom value
		};
		static_assert(sizeof(s_decoratorspresetdefinition) == 44, "struct s_decoratorspresetdefinition is invalid size");

		struct s_assetcategorypresetdefinition
		{
			c_static_string<32> preset;
			// custom vram
			s_speccontrolvramsettings vram;
			// custom value
		};
		static_assert(sizeof(s_assetcategorypresetdefinition) == 40, "struct s_assetcategorypresetdefinition is invalid size");

		struct s_dynamicwindpresetdefinitionsplitscreenpreset
		{
			c_flags<e_dynamicwindpresetdefinitiondynamicwindflags, char, k_dynamicwindpresetdefinitiondynamicwindflags_count> flags;
			char generated_pad48fe[3]; // padding
			real texel_size;
			long texture_resolution_x;
			long texture_resolution_y;
			long texture_resolution_z;
		};
		static_assert(sizeof(s_dynamicwindpresetdefinitionsplitscreenpreset) == 20, "struct s_dynamicwindpresetdefinitionsplitscreenpreset is invalid size");

		struct s_dynamicwindpresetdefinition
		{
			c_static_string<32> preset;
			// custom single_screen
			s_dynamicwindpresetdefinitionsplitscreenpreset single_screen_preset;
			// custom value
			// custom _2_player_splitscreen
			s_dynamicwindpresetdefinitionsplitscreenpreset _2_player_splitscreen_preset;
			// custom value
			// custom _3_player_splitscreen
			s_dynamicwindpresetdefinitionsplitscreenpreset _3_player_splitscreen_preset;
			// custom value
			// custom _4_player_splitscreen
			s_dynamicwindpresetdefinitionsplitscreenpreset _4_player_splitscreen_preset;
			// custom value
			// custom vram
			s_speccontrolvramsettings vram;
			// custom value
		};
		static_assert(sizeof(s_dynamicwindpresetdefinition) == 120, "struct s_dynamicwindpresetdefinition is invalid size");

		struct s_interactionpresetdefinitionsplitscreenpreset
		{
			long resolution;
			c_flags<e_interactionpresetdefinitioninteractionflags, char, k_interactionpresetdefinitioninteractionflags_count> flags;
			char generated_padb399[3]; // padding
		};
		static_assert(sizeof(s_interactionpresetdefinitionsplitscreenpreset) == 8, "struct s_interactionpresetdefinitionsplitscreenpreset is invalid size");

		struct s_interactionpresetdefinition
		{
			c_static_string<32> preset;
			// custom single_screen
			s_interactionpresetdefinitionsplitscreenpreset single_screen_preset;
			// custom value
			// custom _2_player_splitscreen
			s_interactionpresetdefinitionsplitscreenpreset _2_player_splitscreen_preset;
			// custom value
			// custom _3_player_splitscreen
			s_interactionpresetdefinitionsplitscreenpreset _3_player_splitscreen_preset;
			// custom value
			// custom _4_player_splitscreen
			s_interactionpresetdefinitionsplitscreenpreset _4_player_splitscreen_preset;
			// custom value
			// custom vram
			s_speccontrolvramsettings vram;
			// custom value
		};
		static_assert(sizeof(s_interactionpresetdefinition) == 72, "struct s_interactionpresetdefinition is invalid size");

		struct s_hlodpresetdefinition
		{
			c_static_string<32> preset;
			real hlod_switch_distance_multiplier;
			real distant_geo_streaming_distance_multiplier;
			// custom vram
			s_speccontrolvramsettings vram;
			// custom value
		};
		static_assert(sizeof(s_hlodpresetdefinition) == 48, "struct s_hlodpresetdefinition is invalid size");

		struct s_animationqualitypresetdefinition
		{
			c_static_string<32> preset;
			// custom vram
			s_speccontrolvramsettings vram;
			// custom value
		};
		static_assert(sizeof(s_animationqualitypresetdefinition) == 40, "struct s_animationqualitypresetdefinition is invalid size");

		struct s_visualdamagepresetdefinitionsplitscreenpreset
		{
			c_flags<e_visualdamagepresetdefinitionenablevisualdamageflag, char, k_visualdamagepresetdefinitionenablevisualdamageflag_count> enable_flag;
			char generated_pad9506[3]; // padding
			long mask_resolution;
		};
		static_assert(sizeof(s_visualdamagepresetdefinitionsplitscreenpreset) == 8, "struct s_visualdamagepresetdefinitionsplitscreenpreset is invalid size");

		struct s_visualdamagepresetdefinition
		{
			c_static_string<32> preset;
			c_flags<e_visualdamagepresetdefinitionenablevisualdamageflag, char, k_visualdamagepresetdefinitionenablevisualdamageflag_count> enable_flag;
			char generated_pada34f[3]; // padding
			long mask_resolution;
			// custom single_screen
			s_visualdamagepresetdefinitionsplitscreenpreset single_screen_preset;
			// custom value
			// custom _2_player_splitscreen
			s_visualdamagepresetdefinitionsplitscreenpreset _2_player_splitscreen_preset;
			// custom value
			// custom _3_player_splitscreen
			s_visualdamagepresetdefinitionsplitscreenpreset _3_player_splitscreen_preset;
			// custom value
			// custom _4_player_splitscreen
			s_visualdamagepresetdefinitionsplitscreenpreset _4_player_splitscreen_preset;
			// custom value
			// custom vram
			s_speccontrolvramsettings vram;
			// custom value
		};
		static_assert(sizeof(s_visualdamagepresetdefinition) == 80, "struct s_visualdamagepresetdefinition is invalid size");

		struct s_virtualtexturingpresetdefinitionsplitscreenpreset
		{
			long desired_page_count;
			long max_pages_per_frame;
			long low_priority_pages_per_frame;
			c_enum<e_virtualtexturingpresetdefinitioncompressionquality, char> compression_quality;
			c_flags<e_virtualtexturingpresetdefinitionvirtualtexturingoptionflags, char, k_virtualtexturingpresetdefinitionvirtualtexturingoptionflags_count> virtual_texturing_flags;
			char generated_pad5b4a[2]; // padding
		};
		static_assert(sizeof(s_virtualtexturingpresetdefinitionsplitscreenpreset) == 16, "struct s_virtualtexturingpresetdefinitionsplitscreenpreset is invalid size");

		struct s_virtualtexturingpresetdefinition
		{
			c_static_string<32> preset;
			// custom single_screen
			s_virtualtexturingpresetdefinitionsplitscreenpreset single_screen_preset;
			// custom value
			// custom _2_player_splitscreen
			s_virtualtexturingpresetdefinitionsplitscreenpreset _2_player_splitscreen_preset;
			// custom value
			// custom _3_player_splitscreen
			s_virtualtexturingpresetdefinitionsplitscreenpreset _3_player_splitscreen_preset;
			// custom value
			// custom _4_player_splitscreen
			s_virtualtexturingpresetdefinitionsplitscreenpreset _4_player_splitscreen_preset;
			// custom value
			// custom vram
			s_speccontrolvramsettings vram;
			// custom value
		};
		static_assert(sizeof(s_virtualtexturingpresetdefinition) == 104, "struct s_virtualtexturingpresetdefinition is invalid size");

		struct s_flocksqualitypresetdefinition
		{
			c_static_string<32> preset;
			// custom vram
			s_speccontrolvramsettings vram;
			// custom value
		};
		static_assert(sizeof(s_flocksqualitypresetdefinition) == 40, "struct s_flocksqualitypresetdefinition is invalid size");

		struct s_simulationqualitypresetdefinition
		{
			c_static_string<32> preset;
			// custom vram
			s_speccontrolvramsettings vram;
			// custom value
		};
		static_assert(sizeof(s_simulationqualitypresetdefinition) == 40, "struct s_simulationqualitypresetdefinition is invalid size");

		struct s_effectspresetdefinitioneffectstreamingrelevancysettings
		{
			real inner_radius;
			real outer_radius;
			real front_facing_radius;
			angle front_facing_fov;
			real environment_effect_distance_scale;
			real sandbox_effect_distance_scale;
			real critical_effect_distance_scale;
		};
		static_assert(sizeof(s_effectspresetdefinitioneffectstreamingrelevancysettings) == 28, "struct s_effectspresetdefinitioneffectstreamingrelevancysettings is invalid size");

		struct s_effectspresetdefinitionsplitscreenpreset
		{
			c_flags<e_effectspresetdefinitioneffectqualityoptionsflags, char, k_effectspresetdefinitioneffectqualityoptionsflags_count> effect_quality_options_flags;
			char generated_paded43[3]; // padding
			real dynamic_low_priority_culling_threshold;
			real low_priority_culling_distance;
			real dynamic_medium_priority_culling_threshold;
			real medium_priority_culling_distance;
			real distortion_throttling_threshold;
			real distortion_fade_threshold;
			real lod_distance_scaling;
			real lod_distance_dynamic_throttle_min;
			real lod_distance_dynamic_throttle_max;
			real cheap_light_falloff_throttle;
			real material_effects_distance_scalar;
			// custom effect_streaming_relevancy_settings
			s_effectspresetdefinitioneffectstreamingrelevancysettings effect_streaming_relevancy_settings;
			// custom value
		};
		static_assert(sizeof(s_effectspresetdefinitionsplitscreenpreset) == 76, "struct s_effectspresetdefinitionsplitscreenpreset is invalid size");

		struct s_effectspresetdefinition
		{
			c_static_string<32> preset;
			c_flags<e_effectspresetdefinitioneffectqualityoptionsflags, char, k_effectspresetdefinitioneffectqualityoptionsflags_count> effect_quality_options_flags;
			char generated_pad5cbc[3]; // padding
			real dynamic_low_priority_culling_threshold;
			real low_priority_culling_distance;
			real dynamic_medium_priority_culling_threshold;
			real medium_priority_culling_distance;
			real distortion_throttling_threshold;
			real distortion_fade_threshold;
			real lod_distance_scaling;
			real lod_distance_dynamic_throttle_min;
			real lod_distance_dynamic_throttle_max;
			real cheap_light_falloff_throttle;
			c_enum<e_visualdamagepresetdefinitionpresets, char> visual_damage_preset;
			char generated_pad769d[3]; // padding
			real material_effects_distance_scalar;
			c_enum<e_chromaticaberrationpresetdefinitionpresets, char> chromatic_aberration_preset;
			c_enum<e_uipresetdefinitionpresets, char> ui_preset;
			char generated_padc352[2]; // padding
			// custom effect_streaming_relevancy_settings
			s_effectspresetdefinitioneffectstreamingrelevancysettings effect_streaming_relevancy_settings;
			// custom value
			// custom single_screen
			s_effectspresetdefinitionsplitscreenpreset single_screen_preset;
			// custom value
			// custom _2_player_splitscreen
			s_effectspresetdefinitionsplitscreenpreset _2_player_splitscreen_preset;
			// custom value
			// custom _3_player_splitscreen
			s_effectspresetdefinitionsplitscreenpreset _3_player_splitscreen_preset;
			// custom value
			// custom _4_player_splitscreen
			s_effectspresetdefinitionsplitscreenpreset _4_player_splitscreen_preset;
			// custom value
			// custom vram
			s_speccontrolvramsettings vram;
			// custom value
		};
		static_assert(sizeof(s_effectspresetdefinition) == 428, "struct s_effectspresetdefinition is invalid size");

		struct s_emblemqualitypresetdefinitionsplitscreenpreset
		{
			dword resolution;
		};
		static_assert(sizeof(s_emblemqualitypresetdefinitionsplitscreenpreset) == 4, "struct s_emblemqualitypresetdefinitionsplitscreenpreset is invalid size");

		struct s_emblemqualitypresetdefinition
		{
			c_static_string<32> preset;
			dword resolution;
			// custom single_screen
			s_emblemqualitypresetdefinitionsplitscreenpreset single_screen_preset;
			// custom value
			// custom _2_player_splitscreen
			s_emblemqualitypresetdefinitionsplitscreenpreset _2_player_splitscreen_preset;
			// custom value
			// custom _3_player_splitscreen
			s_emblemqualitypresetdefinitionsplitscreenpreset _3_player_splitscreen_preset;
			// custom value
			// custom _4_player_splitscreen
			s_emblemqualitypresetdefinitionsplitscreenpreset _4_player_splitscreen_preset;
			// custom value
			// custom vram
			s_speccontrolvramsettings vram;
			// custom value
		};
		static_assert(sizeof(s_emblemqualitypresetdefinition) == 60, "struct s_emblemqualitypresetdefinition is invalid size");

		struct s_texturequalitypresetdefinitionsplitscreenpreset
		{
			long texture_array_bias;
		};
		static_assert(sizeof(s_texturequalitypresetdefinitionsplitscreenpreset) == 4, "struct s_texturequalitypresetdefinitionsplitscreenpreset is invalid size");

		struct s_texturequalitypresetdefinition
		{
			c_static_string<32> preset;
			real texture_prediction_resolution_limit;
			real texture_prediction_target_resolution;
			c_enum<e_emblemqualitypresetdefinitionpresets, char> emblem_quality_preset;
			c_enum<e_virtualtexturingpresetdefinitionpresets, char> virtual_texturing_preset;
			char generated_pad880c[2]; // padding
			// custom single_screen
			s_texturequalitypresetdefinitionsplitscreenpreset single_screen_preset;
			// custom value
			// custom _2_player_splitscreen
			s_texturequalitypresetdefinitionsplitscreenpreset _2_player_splitscreen_preset;
			// custom value
			// custom _3_player_splitscreen
			s_texturequalitypresetdefinitionsplitscreenpreset _3_player_splitscreen_preset;
			// custom value
			// custom _4_player_splitscreen
			s_texturequalitypresetdefinitionsplitscreenpreset _4_player_splitscreen_preset;
			// custom value
			// custom vram
			s_speccontrolvramsettings vram;
			// custom value
		};
		static_assert(sizeof(s_texturequalitypresetdefinition) == 68, "struct s_texturequalitypresetdefinition is invalid size");

		struct s_chromaticaberrationpresetdefinition
		{
			c_static_string<32> preset;
			long number_of_samples;
		};
		static_assert(sizeof(s_chromaticaberrationpresetdefinition) == 36, "struct s_chromaticaberrationpresetdefinition is invalid size");

		struct s_uipresetdefinitionsplitscreenpreset
		{
			c_flags<e_uipresetdefinitionenablebloomflag, char, k_uipresetdefinitionenablebloomflag_count> bloom;
		};
		static_assert(sizeof(s_uipresetdefinitionsplitscreenpreset) == 1, "struct s_uipresetdefinitionsplitscreenpreset is invalid size");

		struct s_uipresetdefinition
		{
			c_static_string<32> preset;
			c_flags<e_uipresetdefinitionenablebloomflag, char, k_uipresetdefinitionenablebloomflag_count> bloom;
			// custom single_screen
			s_uipresetdefinitionsplitscreenpreset single_screen_preset;
			// custom value
			// custom _2_player_splitscreen
			s_uipresetdefinitionsplitscreenpreset _2_player_splitscreen_preset;
			// custom value
			// custom _3_player_splitscreen
			s_uipresetdefinitionsplitscreenpreset _3_player_splitscreen_preset;
			// custom value
			// custom _4_player_splitscreen
			s_uipresetdefinitionsplitscreenpreset _4_player_splitscreen_preset;
			// custom value
		};
		static_assert(sizeof(s_uipresetdefinition) == 37, "struct s_uipresetdefinition is invalid size");

		struct s_decalspresetdefinitionsplitscreenpreset
		{
			long max_decal_count;
			real decal_lifetime_scale;
			long max_clustered_decals;
			c_enum<e_decalspresetdefinitionblendquality, char> blend_quality;
			char generated_pad2c5d[3]; // padding
		};
		static_assert(sizeof(s_decalspresetdefinitionsplitscreenpreset) == 16, "struct s_decalspresetdefinitionsplitscreenpreset is invalid size");

		struct s_decalspresetdefinition
		{
			c_static_string<32> preset;
			long max_decal_count;
			real decal_lifetime_scale;
			long max_clustered_decals;
			c_enum<e_decalspresetdefinitionblendquality, char> blend_quality;
			char generated_pada386[3]; // padding
			// custom single_screen
			s_decalspresetdefinitionsplitscreenpreset single_screen_preset;
			// custom value
			// custom _2_player_splitscreen
			s_decalspresetdefinitionsplitscreenpreset _2_player_splitscreen_preset;
			// custom value
			// custom _3_player_splitscreen
			s_decalspresetdefinitionsplitscreenpreset _3_player_splitscreen_preset;
			// custom value
			// custom _4_player_splitscreen
			s_decalspresetdefinitionsplitscreenpreset _4_player_splitscreen_preset;
			// custom value
			// custom vram
			s_speccontrolvramsettings vram;
			// custom value
		};
		static_assert(sizeof(s_decalspresetdefinition) == 120, "struct s_decalspresetdefinition is invalid size");

		struct s_shaderqualitypresetdefinition
		{
			c_static_string<32> preset;
		};
		static_assert(sizeof(s_shaderqualitypresetdefinition) == 32, "struct s_shaderqualitypresetdefinition is invalid size");

		struct s_presetdefinitionstag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_basicpresetdefinition> basic_presets_block;
			// custom preset_details
			c_typed_tag_block<s_reflectionpresetdefinition> reflection_presets_block;
			c_typed_tag_block<s_volumetricfogpresetdefinition> volumetric_fog_presets_block;
			c_typed_tag_block<s_shadowpresetdefinition> shadow_presets_block;
			c_typed_tag_block<s_skyqualitypresetdefinition> sky_quality_presets_block;
			c_typed_tag_block<s_temporalaapresetdefinition> temporal_aa_presets_block;
			c_typed_tag_block<s_aopresetdefinition> ao_presets_block;
			c_typed_tag_block<s_depthoffieldpresetdefinition> depth_of_field_presets_block;
			c_typed_tag_block<s_anisotropicfilteringpresetdefinition> anisotropic_filtering_presets_block;
			c_typed_tag_block<s_terrainpresetdefinition> terrain_presets_block;
			c_typed_tag_block<s_lightingpresetdefinition> lighting_presets_block;
			c_typed_tag_block<s_decoratorspresetdefinition> decorators_presets_block;
			c_typed_tag_block<s_assetcategorypresetdefinition> asset_category_presets_block;
			c_typed_tag_block<s_dynamicwindpresetdefinition> dynamic_wind_presets_block;
			c_typed_tag_block<s_interactionpresetdefinition> push_bending_presets_block;
			c_typed_tag_block<s_hlodpresetdefinition> hlod_presets_block;
			c_typed_tag_block<s_animationqualitypresetdefinition> animation_quality_presets_block;
			c_typed_tag_block<s_visualdamagepresetdefinition> visual_damage_presets_block;
			c_typed_tag_block<s_virtualtexturingpresetdefinition> virtual_texturing_presets_block;
			c_typed_tag_block<s_flocksqualitypresetdefinition> flocks_presets_block;
			c_typed_tag_block<s_simulationqualitypresetdefinition> simulation_quality_presets_block;
			c_typed_tag_block<s_effectspresetdefinition> effects_presets_block;
			c_typed_tag_block<s_emblemqualitypresetdefinition> emblem_quality_presets_block;
			c_typed_tag_block<s_texturequalitypresetdefinition> texture_quality_presets_block;
			c_typed_tag_block<s_chromaticaberrationpresetdefinition> chromatic_aberration_presets_block;
			c_typed_tag_block<s_uipresetdefinition> ui_presets_block;
			c_typed_tag_block<s_decalspresetdefinition> decal_presets_block;
			c_typed_tag_block<s_shaderqualitypresetdefinition> shader_quality_presets_block;
			// custom value
		};
		static_assert(sizeof(s_presetdefinitionstag) == 352, "struct s_presetdefinitionstag is invalid size");

		struct s_i343malleablepropertybaseshortstructdefinition
		{
			short base_value;
			short_bounds value_bounds;
		};
		static_assert(sizeof(s_i343malleablepropertybaseshortstructdefinition) == 6, "struct s_i343malleablepropertybaseshortstructdefinition is invalid size");

		struct s_gameglobalsgrenade
		{

			/* UI */

			string_id display_text_stringid;
			string_id description_text_stringid;
			string_id help_text_stringid;
			c_typed_tag_reference<SOUND_TAG> grenade_switching_sound;

			/* Initial Grenade Count */

			// custom initial_count
			s_i343malleablepropertybaseshortstructdefinition initial_count;
			char generated_pad5ef2[2]; // padding
			c_typed_tag_reference<EFFECT_TAG> throwing_effect;
			c_typed_tag_reference<EQUIPMENT_TAG> equipment;
			c_typed_tag_reference<PROJECTILE_TAG> projectile;
			c_typed_tag_reference<EQUIPMENT_TAG> equipment_pve;
			c_typed_tag_reference<PROJECTILE_TAG> projectile_pve;
			c_typed_tag_block<s_interfaceuiiteminfo> ui_display_info_block;
		};
		static_assert(sizeof(s_gameglobalsgrenade) == 128, "struct s_gameglobalsgrenade is invalid size");

		struct s_gameglobalsgrenadelist
		{
			s_anytag_struct_definition anytag;

			/* Maximum Grenade Count */

			// custom maximum_count
			s_i343malleablepropertybaseshortstructdefinition maximum_count;

			/* Slot Count */

			// custom slot_count
			s_i343malleablepropertybaseshortstructdefinition slot_count$2;
			c_typed_tag_block<s_gameglobalsgrenade> grenades_block;
		};
		static_assert(sizeof(s_gameglobalsgrenadelist) == 40, "struct s_gameglobalsgrenadelist is invalid size");

		struct s_personalscorehighlighteventtierdefinition
		{
			string_id name;
			string_id description;
		};
		static_assert(sizeof(s_personalscorehighlighteventtierdefinition) == 8, "struct s_personalscorehighlighteventtierdefinition is invalid size");

		struct s_personalscorehighlighteventdefinition
		{
			string_id name;
			short sequence_index;
			byte medal_weight;
			byte tier_index;
		};
		static_assert(sizeof(s_personalscorehighlighteventdefinition) == 8, "struct s_personalscorehighlighteventdefinition is invalid size");

		struct s_highlighteventsglobals
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_personalscorehighlighteventtierdefinition> tiers_block;
			c_typed_tag_block<s_personalscorehighlighteventdefinition> personal_score_highlight_events_block;
		};
		static_assert(sizeof(s_highlighteventsglobals) == 40, "struct s_highlighteventsglobals is invalid size");

		struct s_s_camera_obstruction_parameters
		{
			real_fraction cylinder_fraction;
			angle obstruction_test_angle;
			real obstruction_max_inward_accel;
			real obstruction_max_outward_accel;
			real obstruction_max_velocity;
			real obstruction_return_delay;
		};
		static_assert(sizeof(s_s_camera_obstruction_parameters) == 24, "struct s_s_camera_obstruction_parameters is invalid size");

		struct s_s_game_globals_camera
		{
			c_typed_tag_reference<CAMERA_TRACK_TAG> default_unit_camera_track;

			/* SANDBOX */

			s_scalarfunctionname pitch_to_vertical_offset;

			/* CAMERA UNIVERSALS */

			real field_of_view;
			real yaw_scale;
			real pitch_scale;
			real forward_scale;
			real side_scale;
			real up_scale;

			/* DEAD CAMERA */

			real minimum_distance_to_player;
			real transition_time;
			real falling_death_transition_time;
			real initial_distance;
			real final_distance;
			real dead_cam_z_offset;
			real dead_cam_maximum_elevation;
			real dead_cam_movement_delay;
			real time_to_auto_switch_to_orbiting;
			real ignore_stick_time;
			real ignore_button_time;
			real dead_camera_minimum_falling_velocity;

			/* FLYING CAMERA */

			real maximum_boost_speed;
			real time_to_maximum_boost;
			c_enum<e_transitionfunction, short> boost_function;
			char generated_pad632c[2]; // padding
			real zoomed_field_of_view;
			real zoomed_look_speed;
			real bounding_sphere_radius;
			real flying_cam_movement_delay;
			real zoom_transition_time;
			real vertical_movement_time_to_max_speed;
			c_enum<e_transitionfunction, short> vertical_movement_function;
			char generated_pad7d0d[2]; // padding

			/* ORBITING CAMERA */

			real minimum_distance;
			real maximum_distance;
			real initial_distance_on_focus;
			real orbit_cam_movement_delay;
			real orbit_cam_z_offset;
			real orbit_cam_minimum_elevation;
			real orbit_cam_maximum_elevation;
			real orbit_cam_use_targets_facing_direction_after_;
			real film_specific_tuning_orbit_cam_use_targets_facing_direction_after_;
			real orbit_cam_transition_to_targets_facing_direction_delay;

			/* FIRST PERSON CAMERA */

			angle first_person_vertical_field_of_view;

			/* SAVED FILMS */

			real max_playback_speed;
			real fade_out_time;
			real fade_in_time;

			/* IN GAME */

			real enter_vehicle_transition_time;
			real exit_vehicle_transition_time;

			/* CAMERA OBSTRUCTION */

			s_s_camera_obstruction_parameters obstruction;

			/* KILLPLAYBACK CAMERA */

			real initial_distance$2;
			real kill_playback_camera_use_targets_facing_direction_for_;
			real kill_playback_camera_z_offset;
			angle kill_playback_camera_initial_angle;

			/* PLAYER PROFILE DEFAULTS */

			real_bounds horizontal_fov_bounds;

			/* EDITOR PROFILE DEFAULTS */

			real_bounds editor_horizontal_fov_bounds;
		};
		static_assert(sizeof(s_s_game_globals_camera) == 268, "struct s_s_game_globals_camera is invalid size");

		struct s_s_camera_impulse_globals
		{
			// custom mapping_function
			s_functiondefinition mapping;
		};
		static_assert(sizeof(s_s_camera_impulse_globals) == 20, "struct s_s_camera_impulse_globals is invalid size");

		struct s_i343cameraglobals
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_s_game_globals_camera> camera_block;
			c_typed_tag_block<s_s_camera_impulse_globals> camera_impulse_block;
		};
		static_assert(sizeof(s_i343cameraglobals) == 40, "struct s_i343cameraglobals is invalid size");

		struct s_i343cheatpowerups
		{
			c_typed_tag_reference<EQUIPMENT_TAG> powerup;
		};
		static_assert(sizeof(s_i343cheatpowerups) == 16, "struct s_i343cheatpowerups is invalid size");

		struct s_i343cheatglobals
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343cheatpowerups> cheat_powerups_block;
			char generated_pad8f12[4]; // padding
		};
		static_assert(sizeof(s_i343cheatglobals) == 32, "struct s_i343cheatglobals is invalid size");

		struct s_composerstagecleanupreference
		{
			c_typed_tag_reference<ANYTAG_TAG> tag_reference;
		};
		static_assert(sizeof(s_composerstagecleanupreference) == 16, "struct s_composerstagecleanupreference is invalid size");

		struct s_composerglobalsdefinition
		{
			real cinematic_film_aperture;
			real cinematic_skip_ui_up_time;
			long max_frames_jumped_to_trigger_sound;
			// custom start_end_skip_scripts
			s_composerscript start_script;
			s_composerscript end_script;
			s_composerscript skip_script;
			// custom value
			// custom start_next_show_script
			s_composerscript start_next_show_script;
			// custom value
			// custom kill_previous_show_script
			s_composerscript kill_previous_show_script;
			// custom value
			c_typed_tag_block<s_composerstagecleanupreference> stage_cleanup_preserve_block;
			// custom streaming_ranges
			real stream_pinned_resources_radius;
			// custom value
		};
		static_assert(sizeof(s_composerglobalsdefinition) == 448, "struct s_composerglobalsdefinition is invalid size");

		struct s_i343composerglobals
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_composerglobalsdefinition> composer_globals_block;
			char generated_pada30b[4]; // padding
		};
		static_assert(sizeof(s_i343composerglobals) == 32, "struct s_i343composerglobals is invalid size");

		struct s_s_game_globals_input_abstraction
		{
			real axial_dead_zone;
			real radial_dead_zone;
		};
		static_assert(sizeof(s_s_game_globals_input_abstraction) == 8, "struct s_s_game_globals_input_abstraction is invalid size");

		struct s_s_controller_mapping_reference
		{
			c_typed_tag_reference<CONTROLLER_MAPPING_TAG> mapping;
			string_id default_binding_preset_name;
			string_id ui_string_id;
			string_id ui_description_string_id;
			c_typed_tag_reference<INPUTDEVICEBINDINGS_TAG> default_bindings;
		};
		static_assert(sizeof(s_s_controller_mapping_reference) == 44, "struct s_s_controller_mapping_reference is invalid size");

		struct s_i343playercontrolglobalsaxispairtype
		{
			string_id toggle_axis_id;
			string_id hold_axis_id;
			c_flags<e_i343playercontrolglobalsaxispairtypeflags, char, k_i343playercontrolglobalsaxispairtypeflags_count> flags;
			char generated_padecc4[3]; // padding
		};
		static_assert(sizeof(s_i343playercontrolglobalsaxispairtype) == 12, "struct s_i343playercontrolglobalsaxispairtype is invalid size");

		struct s_inputmappingfunctionblock
		{
			s_scalarfunctionname function;
		};
		static_assert(sizeof(s_inputmappingfunctionblock) == 20, "struct s_inputmappingfunctionblock is invalid size");

		struct s_s_gamepad_stick_settings
		{
			c_enum<e_e_gamepad_stick_remap_shape, char> input_shape;
			char generated_pad0710[3]; // padding
			real_fraction peg_threshold;
			real_point2d pegged_time;
			real_point2d pegged_scale;
			angle peg_max_angular_velocity;
			c_typed_tag_block<s_inputmappingfunctionblock> input_mapping_function_block;
		};
		static_assert(sizeof(s_s_gamepad_stick_settings) == 40, "struct s_s_gamepad_stick_settings is invalid size");

		struct s_s_game_globals_player_control
		{

			/* controller bindings */

			c_typed_tag_block<s_s_controller_mapping_reference> controller_button_mappings_block;
			string_id default_binding;
			c_typed_tag_reference<INPUTDEVICEBINDINGS_TAG> observer_controller_bindings;
			c_typed_tag_reference<INPUTDEVICEBINDINGS_TAG> tacmap_controller_bindings;

			/* mouse and keyboard bindings */

			c_typed_tag_reference<INPUTDEVICEBINDINGS_TAG> default_mouse_kb_bindings;
			c_typed_tag_reference<INPUTDEVICEBINDINGS_TAG> observer_mouse_kb_bindings;
			c_typed_tag_reference<INPUTDEVICEBINDINGS_TAG> tacmap_mouse_kb_bindings;

			/* Firing Axes */

			string_id primary_on_foot;
			string_id secondary_on_foot;
			string_id primary_in_vehicle;
			string_id secondary_in_vehicle;

			/* Axis Defaults */

			// custom sprint
			s_i343playercontrolglobalsaxispairtype sprint_info;
			// custom value
			// custom zoom
			s_i343playercontrolglobalsaxispairtype zoom_info;
			// custom value
			// custom crouch
			s_i343playercontrolglobalsaxispairtype crouch_info;
			// custom value

			/* inventory peek */

			real auto_close_inventory_peek_time;

			/* sticks */

			c_typed_tag_block<s_s_gamepad_stick_settings> move_stick_info_block;
			c_typed_tag_block<s_s_gamepad_stick_settings> look_stick_info_block;

			/* aim assist */

			real_fraction magnetism_friction;
			real_fraction magnetism_adhesion;
			real_fraction inconsequential_target_scale;
			real_fraction ads_magnetism_friction;
			real_fraction ads_magnetism_adhesion;
			real_fraction mouse_magnetism_scalar_whilst_firing;
			real_fraction mouse_magnetism_scalar_not_firing;
			real_fraction mouse_magnetism_decay;

			/* crosshair */

			real_point2d crosshair_location;
			real gravity_scale;
			angle minimum_angle_for_vehicle_flipping;
			real minimum_action_hold_time;
			real powerup_activation_max_hold_time;
			real switch_to_signature_weapon_hold_time;
			real pegged_zoom_suppression_threshold;
			// custom zoom_default_sensitivities
			// custom none
			real none;
			// custom value
			// custom _14x
			real _14x;
			// custom value
			// custom _25x
			real _25x;
			// custom value
			// custom _30x
			real _30x;
			// custom value
			// custom _50x
			real _50x;
			// custom value
			// custom _60x
			real _60x;
			// custom value
			// custom _100x
			real _100x;
			// custom value
			// custom value
			real active_look_input_type_detection_time;

			/* double/triple jump */

			real minimum_vertical_velocity;
			real cooldown_time;
			real_vector2d double_jump_velocity;
			real_vector2d triple_jump_velocity;

			/* tricks */

			real flick_peg_jump_max_time;
			real double_tap_interval_time;
			real jump_forward_horizontal_speed_0;
			real jump_forward_horizontal_speed_1;
			real jump_forward_horizontal_speed_2;
			real jump_forward_gravity_0;
			real jump_forward_gravity_1;
			real jump_forward_gravity_2;
			real jump_forward_height;
			real jump_lateral_horizontal_speed_0;
			real jump_lateral_horizontal_speed_1;
			real jump_lateral_horizontal_speed_2;
			real jump_lateral_gravity_0;
			real jump_lateral_gravity_1;
			real jump_lateral_gravity_2;
			real jump_lateral_height;
			real jump_reverse_horizontal_speed_0;
			real jump_reverse_horizontal_speed_1;
			real jump_reverse_horizontal_speed_2;
			real jump_reverse_gravity_0;
			real jump_reverse_gravity_1;
			real jump_reverse_gravity_2;
			real jump_reverse_height;
			real jump_stationary_horizontal_speed_0;
			real jump_stationary_horizontal_speed_1;
			real jump_stationary_horizontal_speed_2;
			real jump_stationary_gravity_0;
			real jump_stationary_gravity_1;
			real jump_stationary_gravity_2;
			real jump_stationary_height;
		};
		static_assert(sizeof(s_s_game_globals_player_control) == 416, "struct s_s_game_globals_player_control is invalid size");

		struct s_inputscopetagref
		{
			c_typed_tag_reference<INPUTSCOPE_TAG> scope;
		};
		static_assert(sizeof(s_inputscopetagref) == 16, "struct s_inputscopetagref is invalid size");

		struct s_i343controlglobals
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_s_game_globals_input_abstraction> controller_input_block;
			c_typed_tag_block<s_s_game_globals_player_control> player_control_block;
			c_typed_tag_block<s_inputscopetagref> input_abstraction_globals_block;
			char generated_pad0ea8[4]; // padding
		};
		static_assert(sizeof(s_i343controlglobals) == 56, "struct s_i343controlglobals is invalid size");

		struct s_multiplayer_color
		{
			rgb_color color;
		};
		static_assert(sizeof(s_multiplayer_color) == 12, "struct s_multiplayer_color is invalid size");

		struct s_i343emblemharmony
		{
			string_id harmony_name;
			rgb_color primary_color;
			rgb_color secondary_color;
			rgb_color tertiary_color;
		};
		static_assert(sizeof(s_i343emblemharmony) == 40, "struct s_i343emblemharmony is invalid size");

		struct s_i343emblemharmonygroup
		{
			string_id harmony_group_name;
			c_typed_tag_block<s_i343emblemharmony> harmonies_block;
		};
		static_assert(sizeof(s_i343emblemharmonygroup) == 16, "struct s_i343emblemharmonygroup is invalid size");

		struct s_s_multiplayer_visor_color
		{
			string_id name;
			rgb_color tertiary_color;
			rgb_color quaternary_color;
		};
		static_assert(sizeof(s_s_multiplayer_visor_color) == 28, "struct s_s_multiplayer_visor_color is invalid size");

		struct s_s_elite_specular_color
		{
			rgb_color tertiary_color;
			rgb_color quaternary_color;
		};
		static_assert(sizeof(s_s_elite_specular_color) == 24, "struct s_s_elite_specular_color is invalid size");

		struct s_i343colorglobals
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_multiplayer_color> profile_colors_block;
			c_typed_tag_block<s_i343emblemharmonygroup> emblem_colors_block;
			c_typed_tag_block<s_s_multiplayer_visor_color> visor_colors_block;
			s_s_elite_specular_color elite_specular_color;
			char generated_padc5d6[4]; // padding
		};
		static_assert(sizeof(s_i343colorglobals) == 80, "struct s_i343colorglobals is invalid size");

		struct s_s_armor_modifier_definition
		{
			string_id name;
			real damage_multiplier;
		};
		static_assert(sizeof(s_s_armor_modifier_definition) == 8, "struct s_s_armor_modifier_definition is invalid size");

		struct s_s_damage_group_definition
		{
			string_id name;
			c_typed_tag_block<s_s_armor_modifier_definition> armor_modifiers_block;
		};
		static_assert(sizeof(s_s_damage_group_definition) == 16, "struct s_s_damage_group_definition is invalid size");

		struct s_s_damage_globals_definition
		{
			c_typed_tag_block<s_s_damage_group_definition> damage_groups_block;
		};
		static_assert(sizeof(s_s_damage_globals_definition) == 12, "struct s_s_damage_globals_definition is invalid size");

		struct s_i343damagedamagetypedefinition
		{
			string_id damage_type_name;
		};
		static_assert(sizeof(s_i343damagedamagetypedefinition) == 4, "struct s_i343damagedamagetypedefinition is invalid size");

		struct s_s_damage_decay
		{
			real current_damage_decay_delay;
			real current_damage_decay_time;
			real current_damage_decay_rate;
			real recent_damage_decay_delay;
			real recent_damage_decay_time;
		};
		static_assert(sizeof(s_s_damage_decay) == 20, "struct s_s_damage_decay is invalid size");

		struct s_i343damageplayeradditivesounddealdamagedefinition
		{
			c_typed_tag_reference<SOUND_TAG> player_additive_sound_deal_damage_regular;
			c_typed_tag_reference<SOUND_TAG> player_additive_sound_deal_damage_aoe;
			c_typed_tag_reference<SOUND_TAG> player_additive_sound_deal_damage_friendly_fire;
			c_typed_tag_reference<SOUND_TAG> player_additive_sound_deal_damage_weak_spot;
			c_typed_tag_reference<SOUND_TAG> player_additive_sound_deal_damage_headshot;
			c_typed_tag_reference<SOUND_TAG> player_additive_sound_deal_damage_kill;
			c_typed_tag_reference<SOUND_TAG> player_additive_sound_deal_damage_headshot_kill;
		};
		static_assert(sizeof(s_i343damageplayeradditivesounddealdamagedefinition) == 112, "struct s_i343damageplayeradditivesounddealdamagedefinition is invalid size");

		struct s_s_game_globals_damage
		{

			/* Guardians Damage Source */

			s_i343damagedamagesourcedefinition guardiansdamagesource;

			/* Unknown Damage Type */

			s_i343damagedamagetypedefinition unknowndamagetype;

			/* Generic Collision Damage Source */

			s_i343damagedamagesourcedefinition genericcollisiondamagesource;

			/* Scripting Damage Source */

			s_i343damagedamagesourcedefinition scriptingdamagesource;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> instant_kill_damage;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> falling_damage;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> jumping_damage;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> soft_landing_damage;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> hard_landing_damage;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> hs_damage;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> hs_healing;

			/* Fire Damage Source */

			s_i343damagedamagesourcedefinition scriptingfiredamagesource;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> hs_fire_damage;

			/* Terminal Velocity Damage Source */

			s_i343damagedamagesourcedefinition terminalvelocitydamagesource;
			real terminal_velocity;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> terminal_velocity_damage;
			c_typed_tag_reference<DAMAGE_RESPONSE_DEFINITION_TAG> default_damage_response;
			c_typed_tag_reference<DAMAGE_RESPONSE_DEFINITION_TAG> friendly_fire_damage_response;
			real player_shield_spillover;
			// custom damage_decay
			s_s_damage_decay damage_decay_props;
			// custom value
			// custom ai_damage_decay
			s_s_damage_decay ai_damage_decay_props;
			// custom value
			// custom shield_impact_decay
			s_s_damage_decay shield_impact_decay_props;
			// custom value
			// custom ai_stun_damage_decay
			s_s_damage_decay ai_stun_damage_decay_props;
			// custom value
			// custom medium_ping_decay
			s_s_damage_decay medium_ping_decay_props;
			// custom value
			// custom hard_ping_decay
			s_s_damage_decay hard_ping_decay_props;
			// custom value
			// custom player_damage_additive_sounds
			c_typed_tag_reference<SOUND_TAG> deprecated_player_dealt_damage_additive_sound;
			c_typed_tag_reference<SOUND_TAG> deprecated_player_dealt_aoe_damage_additive_sound;
			c_typed_tag_reference<SOUND_TAG> deprecated_player_dealt_friendly_fire_additive_sound;
			s_i343damageplayeradditivesounddealdamagedefinition player_additive_sound_deal_damage;
			c_typed_tag_reference<SOUND_TAG> player_received_damage_additive_sound_default;
			c_typed_tag_reference<SOUND_TAG> player_received_damage_additive_sound_third_person;
			c_typed_tag_reference<SOUND_TAG> player_received_damage_additive_sound_in_vehicle;
			c_typed_tag_reference<SOUND_TAG> player_received_aoe_damage_additive_sound_default;
			c_typed_tag_reference<SOUND_TAG> player_received_aoe_damage_additive_sound_third_person;
			c_typed_tag_reference<SOUND_TAG> player_received_aoe_damage_additive_sound_in_vehicle;
			c_typed_tag_reference<SOUND_TAG> player_died_from_aoe_damage_sound;
			// custom value
		};
		static_assert(sizeof(s_s_game_globals_damage) == 600, "struct s_s_game_globals_damage is invalid size");

		struct s_i343damageglobals
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_s_damage_globals_definition> damage_table_block;
			c_typed_tag_block<s_s_game_globals_damage> damage_block;
		};
		static_assert(sizeof(s_i343damageglobals) == 40, "struct s_i343damageglobals is invalid size");

		struct s_colorlightfunction
		{
			string_id input_variable;
			string_id range_variable;
			c_enum<e_lightoutputmodifier, short> output_modifier;
			char generated_pad8f6d[2]; // padding
			string_id output_modifier_input;
			// custom mapping
			s_functiondefinition mapping;
		};
		static_assert(sizeof(s_colorlightfunction) == 36, "struct s_colorlightfunction is invalid size");

		struct s_s_cheap_light_definition
		{
			s_anytag_struct_definition anytag;

			/* Cheap Lights */

			c_enum<e_cheaplightfunctioninput, char> function_input;
			char version;
			c_flags<e_cheaplightflags, char, k_cheaplightflags_count> flags;

			/* COLOR */

			c_enum<e_i343effectscoloroverridemode, char> color_override_mode;
			s_colorlightfunction color$2;
			s_scalarlightfunction intensity;

			/* SIZE */

			s_scalarlightfunction far_attenuation;
			real falloff_begin_ratio;
			real near_fade_distance;
			real camera_distance_fade_start;
			real camera_distance_fade_end;
			real diffuse_scalar;
			real specular_scalar;
			real fog_intensity;
			real particle_intensity;
			real mininum_roughness;
			real intensity_balancing;
			real area_light_radius;
			c_typed_tag_reference<LIGHTGROUP_TAG> light_group;
			char generated_padb984[4]; // padding
		};
		static_assert(sizeof(s_s_cheap_light_definition) == 192, "struct s_s_cheap_light_definition is invalid size");

		struct s_s_game_globals_difficulty_information
		{

			/* health */

			real easy_enemy_damage;
			real normal_enemy_damage;
			real hard_enemy_damage;
			real imposs_enemy_damage;
			real easy_enemy_vitality;
			real normal_enemy_vitality;
			real hard_enemy_vitality;
			real imposs_enemy_vitality;
			real easy_enemy_shield;
			real normal_enemy_shield;
			real hard_enemy_shield;
			real imposs_enemy_shield;
			real easy_enemy_recharge;
			real normal_enemy_recharge;
			real hard_enemy_recharge;
			real imposs_enemy_recharge;
			real easy_friend_damage;
			real normal_friend_damage;
			real hard_friend_damage;
			real imposs_friend_damage;
			real easy_friend_vitality;
			real normal_friend_vitality;
			real hard_friend_vitality;
			real imposs_friend_vitality;
			real easy_friend_shield;
			real normal_friend_shield;
			real hard_friend_shield;
			real imposs_friend_shield;
			real easy_friend_recharge;
			real normal_friend_recharge;
			real hard_friend_recharge;
			real imposs_friend_recharge;
			char _game_difficulty_health_unused5[16]; // padding
			char _game_difficulty_health_unused6[16]; // padding

			/* ranged fire */

			real easy_rate_of_fire;
			real normal_rate_of_fire;
			real hard_rate_of_fire;
			real imposs_rate_of_fire;
			real easy_projectile_error;
			real normal_projectile_error;
			real hard_projectile_error;
			real imposs_projectile_error;
			real easy_burst_error;
			real normal_burst_error;
			real hard_burst_error;
			real imposs_burst_error;
			real easy_new_target_delay;
			real normal_new_target_delay;
			real hard_new_target_delay;
			real imposs_new_target_delay;
			real easy_burst_separation;
			real normal_burst_separation;
			real hard_burst_separation;
			real imposs_burst_separation;
			real easy_target_tracking;
			real normal_target_tracking;
			real hard_target_tracking;
			real imposs_target_tracking;
			real easy_target_leading;
			real normal_target_leading;
			real hard_target_leading;
			real imposs_target_leading;
			real easy_overcharge_chance;
			real normal_overcharge_chance;
			real hard_overcharge_chance;
			real imposs_overcharge_chance;
			real easy_special_fire_delay;
			real normal_special_fire_delay;
			real hard_special_fire_delay;
			real imposs_special_fire_delay;
			real easy_guidance_vs_player;
			real normal_guidance_vs_player;
			real hard_guidance_vs_player;
			real imposs_guidance_vs_player;
			real easy_melee_delay_base;
			real normal_melee_delay_base;
			real hard_melee_delay_base;
			real imposs_melee_delay_base;
			real easy_melee_delay_scale;
			real normal_melee_delay_scale;
			real hard_melee_delay_scale;
			real imposs_melee_delay_scale;
			char _game_difficulty_fire_unused6[16]; // padding

			/* grenades */

			real easy_grenade_chance_scale;
			real normal_grenade_chance_scale;
			real hard_grenade_chance_scale;
			real imposs_grenade_chance_scale;
			real easy_grenade_timer_scale;
			real normal_grenade_timer_scale;
			real hard_grenade_timer_scale;
			real imposs_grenade_timer_scale;
			real easy_grenade_detonation_timer_scale;
			real normal_grenade_detonation_timer_scale;
			real hard_grenade_detonation_timer_scale;
			real imposs_grenade_detonation_timer_scale;
			real easy_grenade_arming_timer_scale;
			real normal_grenade_arming_timer_scale;
			real hard_grenade_arming_timer_scale;
			real imposs_grenade_arming_timer_scale;
			real easy_grenade_velocity_scale;
			real normal_grenade_velocity_scale;
			real hard_grenade_velocity_scale;
			real imposs_grenade_velocity_scale;

			/* placement */

			real easy_major_upgrade_normal;
			real normal_major_upgrade_normal;
			real hard_major_upgrade_normal;
			real imposs_major_upgrade_normal;
			real easy_major_upgrade_few;
			real normal_major_upgrade_few;
			real hard_major_upgrade_few;
			real imposs_major_upgrade_few;
			real easy_major_upgrade_many;
			real normal_major_upgrade_many;
			real hard_major_upgrade_many;
			real imposs_major_upgrade_many;

			/* vehicles */

			real easy_player_vehicle_ram_chance;
			real normal_player_vehicle_ram_chance;
			real hard_player_vehicle_ram_chance;
			real imposs_player_vehicle_ram_chance;
			real easy_trick_dodge_chance_scale;
			real normal_trick_dodge_chance_scale;
			real hard_trick_dodge_chance_scale;
			real imposs_trick_dodge_chance_scale;
			real easy_vehicle_boarding_chance;
			real normal_vehicle_boarding_chance;
			real hard_vehicle_boarding_chance;
			real imposs_vehicle_boarding_chance;

			/* cover */

			real easy_hide_time;
			real normal_hide_time;
			real hard_hide_time;
			real imposs_hide_time;
			real easy_shield_fraction_hide;
			real normal_shield_fraction_hide;
			real hard_shield_fraction_hide;
			real imposs_shield_fraction_hide;
			real easy_cover_vitality_threshold;
			real normal_cover_vitality_threshold;
			real hard_cover_vitality_threshold;
			real imposs_cover_vitality_threshold;
			real easy_bunker_open_duration;
			real normal_bunker_open_duration;
			real hard_bunker_open_duration;
			real imposs_bunker_open_duration;
			real easy_bunker_closed_duration;
			real normal_bunker_closed_duration;
			real hard_bunker_closed_duration;
			real imposs_bunker_closed_duration;
			char _game_difficulty_vehicle_unused[16]; // padding

			/* global kung fu */

			real easy_max_attackers;
			real normal_max_attackers;
			real hard_max_attackers;
			real imposs_max_attackers;

			/* threat tokens */

			real easy_max_high_tokens;
			real normal_max_high_tokens;
			real hard_max_high_tokens;
			real imposs_max_high_tokens;
			real easy_max_low_tokens;
			real normal_max_low_tokens;
			real hard_max_low_tokens;
			real imposs_max_low_tokens;
			real easy_max_engagement_tokens;
			real normal_max_engagement_tokens;
			real hard_max_engagement_tokens;
			real imposs_max_engagement_tokens;

			/* grenade tokens */

			real easy_max_grenade_tokens;
			real normal_max_grenade_tokens;
			real hard_max_grenade_tokens;
			real imposs_max_grenade_tokens;
			real easy_grenade_token_cooldown;
			real normal_grenade_token_cooldown;
			real hard_grenade_token_cooldown;
			real imposs_grenade_token_cooldown;

			/* effectiveness tokens */

			real easy_max_effectiveness_tokens;
			real normal_max_effectiveness_tokens;
			real hard_max_effectiveness_tokens;
			real imposs_max_effectiveness_tokens;
			real easy_weapon_fidget_chance_per_second;
			real normal_weapon_fidget_chance_per_second;
			real hard_weapon_fidget_chance_per_second;
			real imposs_weapon_fidget_chance_per_second;
		};
		static_assert(sizeof(s_s_game_globals_difficulty_information) == 768, "struct s_s_game_globals_difficulty_information is invalid size");

		struct s_s_game_globals_coop_difficulty_information
		{

			/* vitality */

			real two_player_shield_recharge_delay;
			real four_player_shield_recharge_delay;
			real warzone_shield_recharge_delay;
			real two_player_shield_recharge_timer;
			real four_player_shield_recharge_timer;
			real warzone_shield_recharge_timer;

			/* movement */

			real two_player_grenade_dive_chance;
			real four_player_grenade_dive_chance;
			real warzone_grenade_dive_chance;

			/* evasion */

			real two_player_evasion_danger_threshold;
			real four_player_evasion_danger_threshold;
			real warzone_evasion_danger_threshold;
			real two_player_evasion_delay_timer;
			real four_player_evasion_delay_timer;
			real warzone_evasion_delay_timer;
			real two_player_evasion_chance;
			real four_player_evasion_chance;
			real warzone_evasion_chance;

			/* shooting */

			real two_player_burst_duration;
			real four_player_burst_duration;
			real warzone_burst_duration;
			real two_player_burst_separation;
			real four_player_burst_separation;
			real warzone_burst_separation;
			real two_player_damage_modifier;
			real four_player_damage_modifier;
			real warzone_damage_modifier;

			/* projectile */

			real two_player_projectile_speed;
			real four_player_projectile_speed;
			real warzone_projectile_speed;
			real two_player_grenade_throw_chance;
			real four_player_grenade_throw_chance;
			real warzone_grenade_throw_chance;

			/* other */

			real two_player_ai_upgrade_additional_chance;
			real four_player_ai_upgrade_additional_chance;
			real warzone_ai_upgrade_additional_chance;
		};
		static_assert(sizeof(s_s_game_globals_coop_difficulty_information) == 144, "struct s_s_game_globals_coop_difficulty_information is invalid size");

		struct s_i343difficultyglobals
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_s_game_globals_difficulty_information> difficulty_block;
			c_typed_tag_block<s_s_game_globals_coop_difficulty_information> co_op_difficulty_block;
		};
		static_assert(sizeof(s_i343difficultyglobals) == 40, "struct s_i343difficultyglobals is invalid size");

		struct s_garbagecollectionglobalvariables
		{

			/* Garbage Times */

			real dropped_item;
			real dropped_special_item;
			real dropped_item_in_multiplayer;
			real dead_unit;
			real dead_player;
			real dead_mp_player;
			real dead_mp_player_overloaded;
			long max_dead_body_count_;
		};
		static_assert(sizeof(s_garbagecollectionglobalvariables) == 32, "struct s_garbagecollectionglobalvariables is invalid size");

		struct s_i343garbagecollectionglobals
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_garbagecollectionglobalvariables> garbage_collection_block;
			char generated_pad2c4e[4]; // padding
		};
		static_assert(sizeof(s_i343garbagecollectionglobals) == 32, "struct s_i343garbagecollectionglobals is invalid size");

		struct s_hologramlightfunctions
		{
			string_id intensity;
			string_id forward;
			string_id right;
			string_id up;
		};
		static_assert(sizeof(s_hologramlightfunctions) == 16, "struct s_hologramlightfunctions is invalid size");

		struct s_hologramlightingglobals
		{
			// custom hologram_functions
			string_id intensity;
			// custom value
			// custom key_light_functions
			s_hologramlightfunctions key_light_functions;
			// custom value
			// custom fill_light_functions
			s_hologramlightfunctions fill_light_functions;
			// custom value
			// custom rim_light_functions
			s_hologramlightfunctions rim_light_functions;
			// custom value
		};
		static_assert(sizeof(s_hologramlightingglobals) == 52, "struct s_hologramlightingglobals is invalid size");

		struct s_s_active_camo_level_definition
		{
			real biped_speed_reference;
			real active_camo_ground_vertical_speed_scalar;
			real active_camo_airborne_vertical_speed_scalar;
			real vehicle_speed_reference;
			real_fraction camo_value_for_game_name;
			s_scalarfunctionname camo_value_to_distortion;
			s_scalarfunctionname camo_value_to_transparency;
			s_scalarfunctionname camo_distortion_texture_strength;
			real_vector2d camo_distortion_scale;
			real_vector2d camo_distortion_translate_speed;
			c_typed_tag_reference<BITMAP_TAG> camo_distortion_texture;
			real camo_depth_bias_max_distance;
			s_scalarfunctionname camo_depth_bias_function;
			s_scalarfunctionname speed_to_maximum_camo;
		};
		static_assert(sizeof(s_s_active_camo_level_definition) == 156, "struct s_s_active_camo_level_definition is invalid size");

		struct s_s_active_camo_globals
		{
			real biped_speed_reference;
			real active_camo_ground_vertical_speed_scalar;
			real active_camo_airborne_vertical_speed_scalar;
			real vehicle_speed_reference;
			real_fraction camo_value_for_game_name;
			s_scalarfunctionname camo_value_to_distortion;
			s_scalarfunctionname camo_value_to_transparency;
			s_scalarfunctionname camo_distortion_texture_strength;
			real_vector2d camo_distortion_scale;
			real_vector2d camo_distortion_translate_speed;
			c_typed_tag_reference<BITMAP_TAG> camo_distortion_texture;
			real camo_depth_bias_max_distance;
			s_scalarfunctionname camo_depth_bias_function;
			c_typed_tag_block<s_s_active_camo_level_definition> camo_levels_block;
		};
		static_assert(sizeof(s_s_active_camo_globals) == 148, "struct s_s_active_camo_globals is invalid size");

		struct s_s_game_globals_shield_boost
		{

			/* shield boosting */

			real shield_boost_decay;
			real shield_boost_recharge_time;
			real shield_boost_stun_time;
		};
		static_assert(sizeof(s_s_game_globals_shield_boost) == 12, "struct s_s_game_globals_shield_boost is invalid size");

		struct s_i343unitsunititemtossglobals
		{
			// custom random_toss_angles

			/* Possible Toss Directions */


			/* Radial Toss Direction */


			/* Toss Pitch Angle */

			angle_bounds pitch_angle;
			// custom value
			// custom random_toss_speed

			/* Speed */

			real_bounds speed$2;
			// custom value
		};
		static_assert(sizeof(s_i343unitsunititemtossglobals) == 16, "struct s_i343unitsunititemtossglobals is invalid size");

		struct s_i343gameplayobjectglobals
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_hologramlightingglobals> hologram_lighting_block;
			c_typed_tag_block<s_s_active_camo_globals> active_camo_block;
			c_typed_tag_block<s_s_game_globals_shield_boost> shield_boost_block;
			c_typed_tag_block<s_i343unitsunititemtossglobals> item_toss_block;
		};
		static_assert(sizeof(s_i343gameplayobjectglobals) == 64, "struct s_i343gameplayobjectglobals is invalid size");

		struct s_interfacecustomizationuicamerapositionoffset
		{
			c_enum<e_interfacecustomizationiteminspectionposition, short> camera_position_type;
			char generated_pad010d[2]; // padding
			real_vector3d camera_position;
			string_id composer_scene_name;
		};
		static_assert(sizeof(s_interfacecustomizationuicamerapositionoffset) == 20, "struct s_interfacecustomizationuicamerapositionoffset is invalid size");

		struct s_interfacecustomizationuirttregiondata
		{
			string_id ui_display_string;
			string_id ui_description_string;
			long cms_customization_item_type;
			string_id region_name;
			string_id marker_name;
			real marker_offset;
			real camera_offset;
			c_enum<e_interfacecustomizationanimationeasing, short> animation_easing;
			char generated_pad2a44[2]; // padding
			c_typed_tag_block<s_interfacecustomizationuicamerapositionoffset> camera_positions_block;
			real camera_fov;
			real camera_transition_time;
			real_euler_angles3d camera_orientation;
			real_euler_angles3d focused_object_orientation;
			c_flags<e_interfacecustomizationuidofflags, char, k_interfacecustomizationuidofflags_count> dof_flags;
			char generated_pad4425[3]; // padding
			real dof_focal_length;
			real dof_focal_distance;
			real dof_fstop;
			string_id idle_animation;
			string_id to_idle_animation;
			string_id from_idle_animation;
		};
		static_assert(sizeof(s_interfacecustomizationuirttregiondata) == 104, "struct s_interfacecustomizationuirttregiondata is invalid size");

		struct s_interfacecustomizationcamerapointname
		{
			c_static_string<32> camerapoint;
		};
		static_assert(sizeof(s_interfacecustomizationcamerapointname) == 32, "struct s_interfacecustomizationcamerapointname is invalid size");

		struct s_interfacecustomizationcamerapointlayoutblock
		{
			// custom single_camera_point_properties
			c_static_string<32> layout_one_first_postion;
			// custom value
			// custom two_camera_point_properties
			c_static_string<32> layout_two_first_position;
			c_static_string<32> layout_two_second_position;
			// custom value
			// custom three_camera_point_properties
			c_static_string<32> layout_three_first_position;
			c_static_string<32> layout_three_second_position;
			c_static_string<32> layout_three_third_position;
			// custom value
			// custom four_camera_point_properties
			c_static_string<32> layout_four_first_position_;
			c_static_string<32> layout_four_second_position;
			c_static_string<32> layout_four_third_position;
			c_static_string<32> layout_four_fourth_position;
			// custom value
		};
		static_assert(sizeof(s_interfacecustomizationcamerapointlayoutblock) == 320, "struct s_interfacecustomizationcamerapointlayoutblock is invalid size");

		struct s_interfacecustomizationuicomposercustomizationdata
		{
			string_id composer_scene_name;
			c_typed_tag_block<s_interfacecustomizationcamerapointname> camera_points_block;
			c_typed_tag_block<s_interfacecustomizationcamerapointlayoutblock> camera_point_layout_block;
			real camera_point_move_time;
			c_typed_tag_reference<COMPOSITION_TAG> composer_definition;
		};
		static_assert(sizeof(s_interfacecustomizationuicomposercustomizationdata) == 48, "struct s_interfacecustomizationuicomposercustomizationdata is invalid size");

		struct s_interfacecustomizationlandingscenecompositiondata
		{
			string_id composer_scene_name;
			c_enum<e_interfacecustomizationcoretype, short> core_type;
			char generated_pad18b7[2]; // padding
		};
		static_assert(sizeof(s_interfacecustomizationlandingscenecompositiondata) == 8, "struct s_interfacecustomizationlandingscenecompositiondata is invalid size");

		struct s_interfacecustomizationlandingscenedata
		{
			long composer_scene_time;
			long fodeout_star_time;
			long fodeout_end_time;
			c_typed_tag_block<s_interfacecustomizationlandingscenecompositiondata> composer_scenes_block;
		};
		static_assert(sizeof(s_interfacecustomizationlandingscenedata) == 24, "struct s_interfacecustomizationlandingscenedata is invalid size");

		struct s_interfacecustomizationcoretypeitem
		{
			c_enum<e_interfacecustomizationcoretype, short> core_type;
		};
		static_assert(sizeof(s_interfacecustomizationcoretypeitem) == 2, "struct s_interfacecustomizationcoretypeitem is invalid size");

		struct s_interfacecustomizationcomposerscenenames
		{
			string_id composer_scene_name;
		};
		static_assert(sizeof(s_interfacecustomizationcomposerscenenames) == 4, "struct s_interfacecustomizationcomposerscenenames is invalid size");

		struct s_s_game_globals_interface_tag_references
		{

			/* Mode-Specific Tags */

			c_typed_tag_reference<USER_INTERFACE_SHARED_GLOBALS_DEFINITION_TAG> shared_globals;
			c_typed_tag_reference<USER_INTERFACE_GLOBALS_DEFINITION_TAG> mainmenu_ui_globals;
			c_typed_tag_reference<USER_INTERFACE_GLOBALS_DEFINITION_TAG> singleplayer_ui_globals;
			c_typed_tag_reference<USER_INTERFACE_GLOBALS_DEFINITION_TAG> multiplayer_ui_globals;
			c_typed_tag_reference<DAMAGEREPORTINGDISPLAYGLOBALS_TAG> damage_reporting_display_globals;

			/* Customization Data */

			c_typed_tag_reference<UIPLATFORMANIMATIONS_TAG> platform_animations;
			c_typed_tag_reference<UILIGHTPRESETS_TAG> light_presets;
			c_typed_tag_reference<UICAMERAPRESETS_TAG> camera_presets;
			c_typed_tag_reference<UITRANSITIONSOUNDS_TAG> camera_transition_sounds;
			c_typed_tag_reference<UITRANSITIONSOUNDS_TAG> spartan_voice_sounds;
			string_id idling_marine_composition;
			string_id default_gray_emblem_coating;

			/* Customization Scene Data */

			c_typed_tag_reference<UIOBJECTCUSTOMIZATION_TAG> spartan_armor_customization;
			c_typed_tag_reference<UIOBJECTCUSTOMIZATION_TAG> weapons_customization;
			c_typed_tag_reference<UIOBJECTCUSTOMIZATION_TAG> vehicle_customization;
			c_typed_tag_reference<UIOBJECTCUSTOMIZATION_TAG> ai_customization;
			c_typed_tag_reference<UIOBJECTCUSTOMIZATION_TAG> fireteam_customization;
			c_typed_tag_reference<UIOBJECTCUSTOMIZATION_TAG> presentation_customization;
			c_typed_tag_reference<UIOBJECTCUSTOMIZATION_TAG> inspect_customization;
			c_typed_tag_reference<UIOBJECTCUSTOMIZATION_TAG> inspect_player_customization;
			c_typed_tag_reference<UIOBJECTCUSTOMIZATION_TAG> pgcr;
			c_typed_tag_block<s_interfacecustomizationuirttregiondata> rtt_camera_scenes_block;
			c_typed_tag_block<s_interfacecustomizationuicomposercustomizationdata> composer_scenes_block;
			c_typed_tag_block<s_interfacecustomizationlandingscenedata> landing_scene_data_block;
			c_typed_tag_block<s_interfacecustomizationcoretypeitem> coretype_order_block;
			c_typed_tag_block<s_interfacecustomizationcomposerscenenames> mythicfx_composer_names_block;
			c_typed_tag_reference<UIITEMINSPECT_TAG> inspect_data;
		};
		static_assert(sizeof(s_s_game_globals_interface_tag_references) == 388, "struct s_s_game_globals_interface_tag_references is invalid size");

		struct s_i343interfaceglobals
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_s_game_globals_interface_tag_references> interface_tags_block;
			char generated_padaaba[4]; // padding
		};
		static_assert(sizeof(s_i343interfaceglobals) == 32, "struct s_i343interfaceglobals is invalid size");

		struct s_i343locglobals
		{
			s_anytag_struct_definition anytag;
			c_enum<e_e_language, long> language;
			char generated_padcaff[4]; // padding
		};
		static_assert(sizeof(s_i343locglobals) == 24, "struct s_i343locglobals is invalid size");

		struct s_s_global_material_object_drag_properties
		{
			c_typed_tag_reference<WATER_PHYSICS_DRAG_PROPERTIES_TAG> drag_properties;
		};
		static_assert(sizeof(s_s_global_material_object_drag_properties) == 16, "struct s_s_global_material_object_drag_properties is invalid size");

		struct s_s_material_physics_properties
		{
			dword flags;
			real friction;
			real_fraction restitution;
			real density;

			/* Drag */

			c_typed_tag_reference<WATER_PHYSICS_DRAG_PROPERTIES_TAG> water_physics_drag_properties;
			c_typed_tag_block<s_s_global_material_object_drag_properties> drag_overrides_block;

			/* Floatation */

			real _default;
			real super_floater;
			real floater;
			real neutral;
			real sinker;
			real super_sinker;
			char none[4]; // padding
		};
		static_assert(sizeof(s_s_material_physics_properties) == 72, "struct s_s_material_physics_properties is invalid size");

		struct s_s_global_material_sweeteners_definition
		{
			c_typed_tag_reference<SOUND_TAG> sound_sweetener_small;
			c_typed_tag_reference<SOUND_TAG> sound_sweetener_medium;
			c_typed_tag_reference<SOUND_TAG> sound_sweetener_large;
			c_typed_tag_reference<SOUND_LOOPING_TAG> sound_sweetener_rolling;
			c_typed_tag_reference<SOUND_LOOPING_TAG> sound_sweetener_grinding;
			c_typed_tag_reference<SOUND_TAG> sound_sweetener_melee_small;
			c_typed_tag_reference<SOUND_TAG> sound_sweetener_melee;
			c_typed_tag_reference<SOUND_TAG> sound_sweetener_melee_large;
			c_typed_tag_reference<EFFECT_TAG> effect_sweetener_small;
			c_typed_tag_reference<EFFECT_TAG> effect_sweetener_medium;
			c_typed_tag_reference<EFFECT_TAG> effect_sweetener_large;
			c_typed_tag_reference<EFFECT_TAG> effect_sweetener_rolling;
			c_typed_tag_reference<EFFECT_TAG> effect_sweetener_grinding;
			c_typed_tag_reference<EFFECT_TAG> effect_sweetener_melee;
			c_typed_tag_reference<RENDER_WATER_RIPPLE_TAG> water_ripple_small;
			c_typed_tag_reference<RENDER_WATER_RIPPLE_TAG> water_ripple_medium;
			c_typed_tag_reference<RENDER_WATER_RIPPLE_TAG> water_ripple_large;

			/* sweetener inheritance flags */

			c_flags<e_c_global_material_sweetener_types_flags, long, k_c_global_material_sweetener_types_flags_count> sweetener_inheritance_flags$2;
		};
		static_assert(sizeof(s_s_global_material_sweeteners_definition) == 276, "struct s_s_global_material_sweeteners_definition is invalid size");

		struct s_s_global_material_underwater_proxy
		{

			/* when this material is encounted under a material of this type ... */

			string_id underwater_material;

			/* ... we report it as this material */

			string_id proxy_material;
			short underwater_material_type;
			short proxy_material_type;
		};
		static_assert(sizeof(s_s_global_material_underwater_proxy) == 12, "struct s_s_global_material_underwater_proxy is invalid size");

		struct s_s_global_material_definition
		{
			string_id name;
			string_id parent_name;
			string_id audio_material_name;
			string_id audio_fallback_material_name;
			short audio_fallback_material_index;
			short runtime_material_index;
			c_flags<e_globalmaterialbitflags, short, k_globalmaterialbitflags_count> flags;
			char generated_pad3ced[2]; // padding
			string_id general_armor;
			string_id specific_armor;
			short runtime_dry_base_material_index;
			char generated_pad230c[2]; // padding
			s_s_material_physics_properties physics_properties;
			s_s_global_material_sweeteners_definition sweeteners;
			c_typed_tag_reference<MATERIAL_EFFECTS_TAG> material_effects;
			c_typed_tag_block<s_s_global_material_underwater_proxy> underwater_proxies_block;
		};
		static_assert(sizeof(s_s_global_material_definition) == 412, "struct s_s_global_material_definition is invalid size");

		struct s_i343materialglobals
		{
			s_anytag_struct_definition anytag;

			/* global material types */

			string_id global_water_material;
			string_id global_air_material;
			string_id audio_material_switch_group;
			short global_water_material_type;
			short global_air_material_type;
			c_typed_tag_block<s_s_global_material_definition> runtime_materials_block;
			c_typed_tag_block<s_s_global_material_definition> materials_block;
		};
		static_assert(sizeof(s_i343materialglobals) == 56, "struct s_i343materialglobals is invalid size");

		struct s_i343playerfirstpersonhiddenbodyregion
		{
			string_id hidden_region;
			c_flags<e_i343playerbodyregionflags, char, k_i343playerbodyregionflags_count> flags;
			char generated_pad9af5[3]; // padding
		};
		static_assert(sizeof(s_i343playerfirstpersonhiddenbodyregion) == 8, "struct s_i343playerfirstpersonhiddenbodyregion is invalid size");

		struct s_i343playerrepresentation
		{
			string_id name;
			string_id first_person_interface_name;
			string_id customization_set;
			c_typed_tag_reference<CUSTOMIZATIONGLOBALSDEFINITION_TAG> customization;
			c_flags<e_i343playerrepresentationflags, char, k_i343playerrepresentationflags_count> flags;
			char generated_pad3e61[3]; // padding
			c_typed_tag_reference<UNIT_TAG> third_person_unit;
			string_id third_person_variant;
			c_typed_tag_reference<FRAMEDEFINITION_TAG> frame_override;
			long player_information;
			c_typed_tag_reference<CUI_SCREEN_TAG> hud_screen_reference;
			string_id hud_transition_event_name;
			s_tag_reference first_person_hands_model;
			c_typed_tag_reference<MODEL_TAG> generatedfirstpersonhandsmodel;
			string_id first_person_hands_variant;
			string_id first_person_body_variant;
			c_typed_tag_block<s_i343playerfirstpersonhiddenbodyregion> hidden_fpbody_regions_block;
			string_id override_default_style_id;
			c_typed_tag_reference<CHARACTER_TAG> bot_reference;
			c_typed_tag_reference<OUTLINETYPEDEFINITION_TAG> outline_to_use_for_enemy;
			c_typed_tag_reference<OUTLINETYPEDEFINITION_TAG> outline_to_use_for_enemy_near_reticle;
			c_typed_tag_reference<OUTLINETYPEDEFINITION_TAG> outline_to_use_for_enemy_flash_acquire;
			c_typed_tag_reference<OUTLINETYPEDEFINITION_TAG> outline_to_use_for_friendly;
			c_typed_tag_reference<OUTLINETYPEDEFINITION_TAG> outline_to_use_for_friendly_near_reticle;
			c_typed_tag_reference<OUTLINETYPEDEFINITION_TAG> outline_to_use_when_viewed_by_spectators;
			c_typed_tag_reference<OUTLINETYPEDEFINITION_TAG> outline_to_use_when_we_need_only_characters;
		};
		static_assert(sizeof(s_i343playerrepresentation) == 276, "struct s_i343playerrepresentation is invalid size");

		struct s_s_game_globals_player_information
		{
			string_id name;
			real walking_speed;
			real run_forward;
			real run_backward;
			real run_sideways;
			real run_acceleration;
			real sneak_forward;
			real sneak_backward;
			real sneak_sideways;
			real sneak_acceleration;
			real downed_forward;
			real downed_backward;
			real downed_sideways;
			real downed_acceleration;
			real airborne_acceleration;
			real_point3d grenade_origin;
			s_scalarfunctionname grenade_aiming;
			real_bounds first_person_idle_time;
			real_fraction first_person_skip_fraction;
			real tracking_detection_locked_decay_time;
			real tracking_detection_locking_decay_time;
		};
		static_assert(sizeof(s_s_game_globals_player_information) == 112, "struct s_s_game_globals_player_information is invalid size");

		struct s_i343playerflyinglooksensitivityarraydefinition
		{
			real angular_velocity;
		};
		static_assert(sizeof(s_i343playerflyinglooksensitivityarraydefinition) == 4, "struct s_i343playerflyinglooksensitivityarraydefinition is invalid size");

		struct s_i343playerflyingspeedarraydefinition
		{
			real speed;
		};
		static_assert(sizeof(s_i343playerflyingspeedarraydefinition) == 4, "struct s_i343playerflyingspeedarraydefinition is invalid size");

		struct s_i343playerflyingthrustarraydefinition
		{
			real thrust;
		};
		static_assert(sizeof(s_i343playerflyingthrustarraydefinition) == 4, "struct s_i343playerflyingthrustarraydefinition is invalid size");

		struct s_i343playercameraglobals
		{

			/* Default camera values */

			real look_velocity_base_pitch;
			real look_velocity_step_pitch;
			real look_velocity_base_yaw;
			real look_velocity_step_yaw;
			real mouse_input_velocity_scale;

			/* Flying camera pitch values */

			s_i343playerflyinglooksensitivityarraydefinition flying_camera_pitch_values$2[4];

			/* Flying camera yaw values */

			s_i343playerflyinglooksensitivityarraydefinition flying_camera_yaw_values$2[4];

			/* Flying camera speed values */

			s_i343playerflyingspeedarraydefinition flying_camera_speed_values$2[4];

			/* Flying camera thrust values */

			s_i343playerflyingthrustarraydefinition flying_camera_thrust_values$2[3];
		};
		static_assert(sizeof(s_i343playercameraglobals) == 80, "struct s_i343playercameraglobals is invalid size");

		struct s_i343firstpersonweaponglobals
		{

			/* Body Render Max FOV */

			real body_render_max_fov$2;
		};
		static_assert(sizeof(s_i343firstpersonweaponglobals) == 4, "struct s_i343firstpersonweaponglobals is invalid size");

		struct s_i343participantmalleablepropertiesdefinition
		{
			// custom motion_tracker_normal_range
			s_i343malleablepropertybasefloatstructdefinition motion_tracker_normal_range;
			// custom motion_tracker_extended_range
			s_i343malleablepropertybasefloatstructdefinition motion_tracker_extended_range;
			// custom motion_tracker_vehicle_range
			s_i343malleablepropertybasefloatstructdefinition motion_tracker_vehicle_range;
			// custom motion_tracker_threshold_speed_friendly
			s_i343malleablepropertybasefloatstructdefinition motion_tracker_threshold_speed_friendly;
			// custom motion_tracker_threshold_speed_enemy
			s_i343malleablepropertybasefloatstructdefinition motion_tracker_threshold_speed_enemy;
			// custom motion_tracker_visibility_scalar
			s_i343malleablepropertybasefloatstructdefinition motion_tracker_visibility_scalar;
		};
		static_assert(sizeof(s_i343participantmalleablepropertiesdefinition) == 72, "struct s_i343participantmalleablepropertiesdefinition is invalid size");

		struct s_i343playerinventorylimits
		{
			byte maximum_allowed_weapons_per_player;
		};
		static_assert(sizeof(s_i343playerinventorylimits) == 1, "struct s_i343playerinventorylimits is invalid size");

		struct s_i343playerinteractionpriorities
		{

			/* Interaction Priorities */

			byte none;
			byte weaponpickupdisabled;
			byte deviceinteractdenied;
			byte bannedvehicleentrance;
			byte pickupgrenade;
			byte pickupweapon;
			byte pickupability;
			byte pickupequipment;
			byte pickupdispenserweapon;
			byte touchdevice;
			byte evictfromvehicle;
			byte entervehicle;
			byte tradeweapon;
			byte boardvehicle;
			byte pickupmultiplayerobject;
			byte flipvehicle;
			byte lookingat;
		};
		static_assert(sizeof(s_i343playerinteractionpriorities) == 17, "struct s_i343playerinteractionpriorities is invalid size");

		struct s_i343playerglobals
		{
			s_anytag_struct_definition anytag;
			string_id default_representation;
			// custom player_representations

			/* Notes */

			c_typed_tag_block<s_i343playerrepresentation> player_representations_block;
			// custom value
			c_typed_tag_block<s_s_game_globals_player_information> player_information_block;
			c_typed_tag_block<s_i343playercameraglobals> player_camera_block;
			c_typed_tag_block<s_i343firstpersonweaponglobals> first_person_weapon_block;
			s_i343participantmalleablepropertiesdefinition participant_malleable_properties;
			s_i343playerinventorylimits inventory_limits;
			s_i343playerinteractionpriorities interaction_priorities;
			char generated_pad9d6c[2]; // padding
		};
		static_assert(sizeof(s_i343playerglobals) == 160, "struct s_i343playerglobals is invalid size");

		struct s_i343skillrankingtierdefinition
		{
			string_id display_name_;
			long beginning_points;
		};
		static_assert(sizeof(s_i343skillrankingtierdefinition) == 8, "struct s_i343skillrankingtierdefinition is invalid size");

		struct s_i343skillrankingdefinition
		{
			string_id display_name;
			long icon_index;
			c_typed_tag_block<s_i343skillrankingtierdefinition> tier_block;
		};
		static_assert(sizeof(s_i343skillrankingdefinition) == 20, "struct s_i343skillrankingdefinition is invalid size");

		struct s_i343skillrankingglobals
		{
			s_anytag_struct_definition anytag;
			long number_of_games_to_qualify_for_csr;
			c_typed_tag_block<s_i343skillrankingdefinition> skill_ranking_globals_block;
		};
		static_assert(sizeof(s_i343skillrankingglobals) == 32, "struct s_i343skillrankingglobals is invalid size");

		struct s_s_campaign_metagame_style_definition
		{
			string_id incident_name;
			real style_multiplier;
		};
		static_assert(sizeof(s_s_campaign_metagame_style_definition) == 8, "struct s_s_campaign_metagame_style_definition is invalid size");

		struct s_s_campaign_metagame_difficulty
		{
			real difficulty_multiplier;
		};
		static_assert(sizeof(s_s_campaign_metagame_difficulty) == 4, "struct s_s_campaign_metagame_difficulty is invalid size");

		struct s_s_campaign_metagame_skull_data
		{
			real difficulty_multiplier;
		};
		static_assert(sizeof(s_s_campaign_metagame_skull_data) == 4, "struct s_s_campaign_metagame_skull_data is invalid size");

		struct s_mythicskullbonus
		{
			c_enum<e_c_campaign_metagame_bucket_type, char> type;
			char generated_pad9f60[3]; // padding
			real shield_vitality_bonus;
		};
		static_assert(sizeof(s_mythicskullbonus) == 8, "struct s_mythicskullbonus is invalid size");

		struct s_s_campaign_metagame_globals
		{
			c_typed_tag_block<s_s_campaign_metagame_style_definition> styles_block;
			c_typed_tag_block<s_s_campaign_metagame_difficulty> difficulty_block;
			c_typed_tag_block<s_s_campaign_metagame_skull_data> skulls_block;
			long friendly_death_point_count;
			long player_death_point_count;
			long player_betrayal_point_count;
			real transient_score_time;
			real emp_kill_window;
			real cowbell_explosion_acceleration_multiplier;
			real boom_explosion_acceleration_multiplier;
			real famine_ammo_multiplier;
			real score_delta_display_seconds_max;
			real score_delta_display_seconds_incremental;
			real mythic_skull_body_vitality_scalar;
			real mythic_skull_shield_vitality_scalar;
			c_typed_tag_block<s_mythicskullbonus> mythic_skull_bonuses_block;
		};
		static_assert(sizeof(s_s_campaign_metagame_globals) == 96, "struct s_s_campaign_metagame_globals is invalid size");

		struct s_i343skullglobals
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_s_campaign_metagame_globals> campaign_metagame_globals_block;
			char generated_pad8e18[4]; // padding
		};
		static_assert(sizeof(s_i343skullglobals) == 32, "struct s_i343skullglobals is invalid size");

		struct s_s_game_globals_soft_ceiling
		{
			real biped_spring_constant;
			real biped_normal_damping;
			real biped_tangent_damping;
			real biped_min_tangent_damp_velocity;
			real vehicle_spring_constant;
			real vehicle_normal_damping;
			real vehicle_tangent_damping;
		};
		static_assert(sizeof(s_s_game_globals_soft_ceiling) == 28, "struct s_s_game_globals_soft_ceiling is invalid size");

		struct s_i343softceilingglobals
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_s_game_globals_soft_ceiling> soft_ceilings_block;
			char generated_pad71fe[4]; // padding
		};
		static_assert(sizeof(s_i343softceilingglobals) == 32, "struct s_i343softceilingglobals is invalid size");

		struct s_i343subtitlespeakercolors
		{
			string_id character_id;
			c_enum<e_i343subtitlespeakerdisposition, char> disposition;
			c_flags<e_i343subtitlecoloroverrideflag, char, k_i343subtitlecoloroverrideflag_count> allow_color_override;
			char generated_padc00e[2]; // padding
			rgb_color color;
		};
		static_assert(sizeof(s_i343subtitlespeakercolors) == 20, "struct s_i343subtitlespeakercolors is invalid size");

		struct s_i343subtitleglobals
		{
			s_anytag_struct_definition anytag;
			real_bounds subtitle_rect_width;
			real_bounds subtitle_rect_height;
			rgb_color default_subtitle_color;
			rgb_color default_subtitle_shadow_color;
			argb_color default_subtitle_background_color;
			real_bounds default_subtitle_background_border_x;
			real_bounds default_subtitle_background_border_y;
			real_bounds small_subtitle_background_border_x;
			real_bounds small_subtitle_background_border_y;
			real_bounds large_subtitle_background_border_x;
			real_bounds large_subtitle_background_border_y;
			real_bounds small_4k_subtitle_background_border_x;
			real_bounds small_4k_subtitle_background_border_y;
			real_bounds medium_4k_subtitle_background_border_x;
			real_bounds medium_4k_subtitle_background_border_y;
			real_bounds large_4k_subtitle_background_border_x;
			real_bounds large_4k_subtitle_background_border_y;
			real minimum_subtitle_display_threshold_in_seconds;
			real subtitle_threshold_to_reset_character_moniker_in_seconds;
			c_typed_tag_reference<STRINGLIST_TAG> unicode_tag_reference_to_subtitles_character_ids_list;
			rgb_color default_subtitle_speaker_color;
			c_typed_tag_block<s_i343subtitlespeakercolors> subtitle_speaker_colors_block;
			char generated_padf9a9[4]; // padding
		};
		static_assert(sizeof(s_i343subtitleglobals) == 220, "struct s_i343subtitleglobals is invalid size");

		struct s_gamemedaldifficultydefinition
		{
			string_id name;
			string_id description;
			short sprite_index;
			char generated_pad3403[2]; // padding
		};
		static_assert(sizeof(s_gamemedaldifficultydefinition) == 12, "struct s_gamemedaldifficultydefinition is invalid size");

		struct s_gamemedaltypedefinition
		{
			string_id name;
			string_id description;
			long sprite_index;
		};
		static_assert(sizeof(s_gamemedaltypedefinition) == 12, "struct s_gamemedaltypedefinition is invalid size");

		struct s_s_game_medal_definition
		{
			string_id name;
			string_id description;
			short sprite_index;
			byte sorting_weight;
			byte difficulty_index;
			byte type_index;
			char generated_pad7cd0[3]; // padding
			long personal_score;
		};
		static_assert(sizeof(s_s_game_medal_definition) == 20, "struct s_s_game_medal_definition is invalid size");

		struct s_personalscoreeventdefinition
		{
			string_id name;
			string_id description;
			long default_score_value;
			byte weight;
			c_enum<e_personalscoreeventtype, char> event_type;
			c_flags<e_enablesuppresseventspam, char, k_enablesuppresseventspam_count> suppress_event_spam;
			char generated_pad6307[1]; // padding
		};
		static_assert(sizeof(s_personalscoreeventdefinition) == 16, "struct s_personalscoreeventdefinition is invalid size");

		struct s_s_game_medal_globals
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_gamemedaldifficultydefinition> difficulty_definitions_block;
			c_typed_tag_block<s_gamemedaltypedefinition> type_definitions_block;
			c_typed_tag_block<s_s_game_medal_definition> medals_block;
			c_typed_tag_block<s_personalscoreeventdefinition> personal_score_event_definitions_block;
		};
		static_assert(sizeof(s_s_game_medal_globals) == 64, "struct s_s_game_medal_globals is invalid size");

		struct s_i343malleablepropertygenericmodifierdefinitionfloat
		{
			string_id property;
			c_enum<e_i343malleablepropertyscopeenum, char> scope;
			char generated_pad531a[3]; // padding
			real duration;
			real modifier;
		};
		static_assert(sizeof(s_i343malleablepropertygenericmodifierdefinitionfloat) == 16, "struct s_i343malleablepropertygenericmodifierdefinitionfloat is invalid size");

		struct s_i343malleablepropertygenericmodifierdefinitionfloatparam
		{
			s_i343malleablepropertygenericmodifierdefinitionfloat modifier_float;
		};
		static_assert(sizeof(s_i343malleablepropertygenericmodifierdefinitionfloatparam) == 16, "struct s_i343malleablepropertygenericmodifierdefinitionfloatparam is invalid size");

		struct s_i343malleablepropertygenericmodifierdefinitionint
		{
			string_id property;
			c_enum<e_i343malleablepropertyscopeenum, char> scope;
			char generated_pad531a[3]; // padding
			real duration;
			long modifier;
		};
		static_assert(sizeof(s_i343malleablepropertygenericmodifierdefinitionint) == 16, "struct s_i343malleablepropertygenericmodifierdefinitionint is invalid size");

		struct s_i343malleablepropertygenericmodifierdefinitionintparam
		{
			s_i343malleablepropertygenericmodifierdefinitionint modifier_int;
		};
		static_assert(sizeof(s_i343malleablepropertygenericmodifierdefinitionintparam) == 16, "struct s_i343malleablepropertygenericmodifierdefinitionintparam is invalid size");

		struct s_i343malleablepropertygenericmodifierdefinitionbool
		{
			string_id property;
			c_enum<e_i343malleablepropertyscopeenum, char> scope;
			char generated_pad531a[3]; // padding
			real duration;
			c_enum<e_i343malleablepropertygenericmodifierdefinitionboolboolenum, char> modifier;
			char generated_pad900e[3]; // padding
		};
		static_assert(sizeof(s_i343malleablepropertygenericmodifierdefinitionbool) == 16, "struct s_i343malleablepropertygenericmodifierdefinitionbool is invalid size");

		struct s_i343malleablepropertygenericmodifierdefinitionboolparam
		{
			s_i343malleablepropertygenericmodifierdefinitionbool modifier_bool;
		};
		static_assert(sizeof(s_i343malleablepropertygenericmodifierdefinitionboolparam) == 16, "struct s_i343malleablepropertygenericmodifierdefinitionboolparam is invalid size");

		struct s_i343malleablepropertygenericmodifierdefinitionblock
		{
			c_typed_tag_block<s_i343malleablepropertygenericmodifierdefinitionfloatparam> modifiers_float_block;
			c_typed_tag_block<s_i343malleablepropertygenericmodifierdefinitionintparam> modifiers_int_block;
			c_typed_tag_block<s_i343malleablepropertygenericmodifierdefinitionboolparam> modifiers_bool_block;
		};
		static_assert(sizeof(s_i343malleablepropertygenericmodifierdefinitionblock) == 36, "struct s_i343malleablepropertygenericmodifierdefinitionblock is invalid size");

		struct s_i343malleablepropertygenericmodifierdefinitiontag
		{
			s_anytag_struct_definition anytag;
			s_i343malleablepropertygenericmodifierdefinitionblock modifiers;
			char generated_pad3c2c[4]; // padding
		};
		static_assert(sizeof(s_i343malleablepropertygenericmodifierdefinitiontag) == 56, "struct s_i343malleablepropertygenericmodifierdefinitiontag is invalid size");

		struct s_s_game_performance_throttle_filter
		{
			long minimum_player_count;
		};
		static_assert(sizeof(s_s_game_performance_throttle_filter) == 4, "struct s_s_game_performance_throttle_filter is invalid size");

		struct s_s_game_performance_throttle_profile
		{
			long maximum_havok_proxy_count;
			long maximum_impact_count;
			long vehicle_suspension_update_frequency;
			long actor_lod_ai_actors_to_update_fully_each_frame;
			long actor_lod_number_of_frames_to_tick_loded_ai;
			long actor_lod_number_of_concurrent_lod_actors_to_tick;
		};
		static_assert(sizeof(s_s_game_performance_throttle_profile) == 24, "struct s_s_game_performance_throttle_profile is invalid size");

		struct s_s_game_performance_throttle_entry
		{
			s_s_game_performance_throttle_filter filter;
			s_s_game_performance_throttle_profile profile;
		};
		static_assert(sizeof(s_s_game_performance_throttle_entry) == 28, "struct s_s_game_performance_throttle_entry is invalid size");

		struct s_s_game_performance_throttle_definitions
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_s_game_performance_throttle_entry> entries_block;
			char generated_pad2b25[4]; // padding
		};
		static_assert(sizeof(s_s_game_performance_throttle_definitions) == 32, "struct s_s_game_performance_throttle_definitions is invalid size");

		struct s_s_grounded_friction_definition
		{
			s_anytag_struct_definition anytag;

			/* GROUNDED FRICTION */

			s_scalarfunctionname friction_over_time;
			real friction_over_time_domain_min;
			real friction_over_time_domain_max;
			real maximum_slope_for_friction;
			real minimum_asymmetry_ratio_for_axis_lock;
		};
		static_assert(sizeof(s_s_grounded_friction_definition) == 52, "struct s_s_grounded_friction_definition is invalid size");

		struct s_jointweight
		{
			short joint_index;
			char generated_pad85cc[2]; // padding
			real joint_weight;
		};
		static_assert(sizeof(s_jointweight) == 8, "struct s_jointweight is invalid size");

		struct s_geometryvertexblendshapetarget
		{
			string_id name;
			real_vector3d delta;
			dword procedural_deformation_index;
		};
		static_assert(sizeof(s_geometryvertexblendshapetarget) == 20, "struct s_geometryvertexblendshapetarget is invalid size");

		struct s_geometryvertex
		{
			real_vector3d position;
			real_vector3d normal;
			real_vector3d binormal;
			real_vector3d tangent;
			real_vector3d tangent_uv2;
			real_vector3d tangent_uv3;
			real_vector2d texcoord_set_1;
			real_vector2d texcoord_set_2;
			real_vector2d texcoord_set_3;
			real_vector2d lighting_texcoord_set;
			argb_color color;
			real dual_quaternion_weight;
			c_typed_tag_block<s_jointweight> joint_weights_block;
			c_typed_tag_block<s_geometryvertexblendshapetarget> blendshape_targets_block;
		};
		static_assert(sizeof(s_geometryvertex) == 148, "struct s_geometryvertex is invalid size");

		struct s_geometryindex
		{
			long triangle_index;
		};
		static_assert(sizeof(s_geometryindex) == 4, "struct s_geometryindex is invalid size");

		struct s_geometrymeshpart
		{
			c_typed_tag_block<s_geometryvertex> vertices_block;
			c_typed_tag_block<s_geometryindex> indices_block;
			dword material_block_index;
			c_static_string<256> originating_shape_name;
			c_static_string<256> originating_shape_uuid;
			dword properties_checksum;
			real_point3d position_bounds_lower;
			real_point3d position_bounds_upper;
			real_point2d texcoord_bounds_lower;
			real_point2d texcoord_bounds_upper;
			real_point2d texcoord2_bounds_lower;
			real_point2d texcoord2_bounds_upper;
			real_point2d texcoord3_bounds_lower;
			real_point2d texcoord3_bounds_upper;
			real_point2d lighting_texcoord_bounds_lower;
			real_point2d lighting_texcoord_bounds_upper;
		};
		static_assert(sizeof(s_geometrymeshpart) == 632, "struct s_geometrymeshpart is invalid size");

		struct s_geometrymesh
		{
			string_id visual_region_name;
			string_id property_region_name;
			c_typed_tag_block<s_geometrymeshpart> mesh_parts_block;
			c_flags<e_meshlodflagsdefinition, short, k_meshlodflagsdefinition_count> lod_flags;
			c_flags<e_meshusageflagsdefinition, short, k_meshusageflagsdefinition_count> usage_flags;
			c_flags<e_supportedfeaturesflagsdefinition, short, k_supportedfeaturesflagsdefinition_count> supported_features;
			char generated_pade039[2]; // padding
			c_flags<e_importinfoflagsdefinition, long, k_importinfoflagsdefinition_count> import_info;
			c_static_string<256> originating_source_file;
			long long properties_checksum;
			real_point3d position_bounds_lower;
			real_point3d position_bounds_upper;
		};
		static_assert(sizeof(s_geometrymesh) == 320, "struct s_geometrymesh is invalid size");

		struct s_geometrymaterial
		{
			c_typed_tag_reference<MATERIAL_TAG> material_reference;
		};
		static_assert(sizeof(s_geometrymaterial) == 16, "struct s_geometrymaterial is invalid size");

		struct s_skeletonjoint
		{
			string_id name;
			short parent_node;
			short first_child_node;
			short next_sibling_node;
			char generated_pad95e7[2]; // padding
			real_point3d default_translation;
			real_quaternion default_rotation;
			c_flags<e_skeletonjointjointdefinitionflags, long, k_skeletonjointjointdefinitionflags_count> importer_flags;
		};
		static_assert(sizeof(s_skeletonjoint) == 44, "struct s_skeletonjoint is invalid size");

		struct s_proceduraldeformationparameter
		{
			c_enum<e_proceduraldeformationparametermode, char> parameter_mode;
			char generated_pade7c0[3]; // padding
			string_id name;
			real constant_value;
		};
		static_assert(sizeof(s_proceduraldeformationparameter) == 12, "struct s_proceduraldeformationparameter is invalid size");

		struct s_proceduraldeformationblock
		{
			string_id name;
			string_id mode;
			c_typed_tag_block<s_proceduraldeformationparameter> control_parameters_block;
		};
		static_assert(sizeof(s_proceduraldeformationblock) == 20, "struct s_proceduraldeformationblock is invalid size");

		struct s_modelmarkerblock
		{
			string_id visual_region_name;
			string_id name;
			string_id parent;
			real_point3d position;
			real_euler_angles3d rotation;
			real_vector3d scale;
			real_vector3d direction;
		};
		static_assert(sizeof(s_modelmarkerblock) == 60, "struct s_modelmarkerblock is invalid size");

		struct s_markergroupblock
		{
			string_id group;
			c_typed_tag_block<s_modelmarkerblock> markers_block;
		};
		static_assert(sizeof(s_markergroupblock) == 16, "struct s_markergroupblock is invalid size");

		struct s_hintmarkerblock
		{
			string_id visual_region_name;
			string_id name;
			string_id parent;
			real_point3d position;
			real_euler_angles3d rotation;
			real_vector3d scale;
			real length;
		};
		static_assert(sizeof(s_hintmarkerblock) == 52, "struct s_hintmarkerblock is invalid size");

		struct s_hintmarkergroupblock
		{
			c_enum<e_hintmarkertype, long> hint_type;
			c_typed_tag_block<s_hintmarkerblock> hint_markers_block;
		};
		static_assert(sizeof(s_hintmarkergroupblock) == 16, "struct s_hintmarkergroupblock is invalid size");

		struct s_targetmarkerblock
		{
			string_id visual_region_name;
			string_id name;
			string_id parent;
			real_point3d position;
			real radius;
		};
		static_assert(sizeof(s_targetmarkerblock) == 28, "struct s_targetmarkerblock is invalid size");

		struct s_targetmarkergroupblock
		{
			string_id group;
			c_typed_tag_block<s_targetmarkerblock> target_markers_block;
		};
		static_assert(sizeof(s_targetmarkergroupblock) == 16, "struct s_targetmarkergroupblock is invalid size");

		struct s_geometrytransitions
		{
			real transition_distance;
		};
		static_assert(sizeof(s_geometrytransitions) == 4, "struct s_geometrytransitions is invalid size");

		struct s_physicsconstraint
		{
			string_id name;
			string_id physics_settings;
			real_point3d position;
			real_quaternion orientation;
			string_id parent_shape;
			string_id child_shape;
		};
		static_assert(sizeof(s_physicsconstraint) == 44, "struct s_physicsconstraint is invalid size");

		struct s_physicsprimitive
		{
			string_id name;
			string_id physics_settings;
			string_id visual_region_name;
			string_id property_region_name;
			c_enum<e_physicsprimitivetype, char> primitive_type;
			char generated_pade68c[1]; // padding
			short joint_index;
			real_point3d position;
			real_quaternion orientation;
			real radius;
			real length;
			real width;
			real height;
		};
		static_assert(sizeof(s_physicsprimitive) == 64, "struct s_physicsprimitive is invalid size");

		struct s_physicsmesh
		{
			string_id name;
			string_id physics_settings;
		};
		static_assert(sizeof(s_physicsmesh) == 8, "struct s_physicsmesh is invalid size");

		struct s_physicsblock
		{
			c_typed_tag_block<s_physicsconstraint> constraints_block;
			c_typed_tag_block<s_physicsprimitive> primitives_block;
			c_typed_tag_block<s_physicsmesh> meshes_block;
		};
		static_assert(sizeof(s_physicsblock) == 36, "struct s_physicsblock is invalid size");

		struct s_geometrytag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_geometrymesh> geometry_block;
			c_typed_tag_block<s_geometrymaterial> materials_block;
			long long joints_checksum;
			c_typed_tag_block<s_skeletonjoint> joints_block;
			c_typed_tag_block<s_proceduraldeformationblock> procedural_deformations_block;
			// custom markers
			c_typed_tag_block<s_markergroupblock> marker_groups_block;
			c_typed_tag_block<s_hintmarkergroupblock> hint_marker_groups_block;
			c_typed_tag_block<s_targetmarkergroupblock> target_marker_groups_block;
			// custom value
			c_typed_tag_block<s_geometrytransitions> import_transition_distances_block;
			c_typed_tag_block<s_physicsblock> physics_block;
			s_contentvalidationblockdata validation;
			char generated_pad6734[4]; // padding
		};
		static_assert(sizeof(s_geometrytag) == 152, "struct s_geometrytag is invalid size");

		struct s_i343graphicshairprofile
		{
			string_id name;
			rgb_color r_color;
			rgb_color tt_color;
			rgb_color trt_color;
			real_vector3d tangent;
			real shift;
			rgb_color scatter_color;
			real scatter_amount;
			real direct_scatter_amount;
			real indirect_scatter_amount;
			rgb_color ao_color;
			real ao_color_amount;
			real diffuse_pow_exponent;
			c_flags<e_i343graphicshairflags, long, k_i343graphicshairflags_count> flags;
		};
		static_assert(sizeof(s_i343graphicshairprofile) == 104, "struct s_i343graphicshairprofile is invalid size");

		struct s_i343graphicshairprofiletag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343graphicshairprofile> hair_profiles_block;
			char generated_pad129f[4]; // padding
			long long shaderaddressablebuffer;
		};
		static_assert(sizeof(s_i343graphicshairprofiletag) == 40, "struct s_i343graphicshairprofiletag is invalid size");

		struct s_hlodindex
		{
			long index;
		};
		static_assert(sizeof(s_hlodindex) == 4, "struct s_hlodindex is invalid size");

		struct s_hlodvisibilitygroup
		{
			dword visibility_index;
			long disabling_bsp;
			c_typed_tag_block<s_hlodindex> io_guids_block;
			c_typed_tag_block<s_wordindex> io_bsps_block;
			c_typed_tag_block<s_wordindex> streaming_bsps_block;
		};
		static_assert(sizeof(s_hlodvisibilitygroup) == 44, "struct s_hlodvisibilitygroup is invalid size");

		struct s_hlodnode
		{
			string_id name;
			real switch_distance;
			real_vector3d position;
			c_typed_tag_reference<RUNTIME_GEO_TAG> geo;
			c_typed_tag_reference<RTMP_TAG> materials;
			dword asset_guid;
			real_bounds volumebounds_x;
			real_bounds volumebounds_y;
			real_bounds volumebounds_z;
			s_hlodvisibilitygroup active_group;
			s_hlodvisibilitygroup inactive_group;
			c_typed_tag_block<s_hlodvisibilitygroup> inactive_streaming_groups_block;
			c_typed_tag_block<s_hlodindex> child_hlods_block;
		};
		static_assert(sizeof(s_hlodnode) == 192, "struct s_hlodnode is invalid size");

		struct s_hlodplacement
		{
			long bsp_index;
			long placement_index;
			c_enum<e_staticgeotype, long> geometry_type;
			dword visibility_index;
			dword hlod_index;
		};
		static_assert(sizeof(s_hlodplacement) == 20, "struct s_hlodplacement is invalid size");

		struct s_hlodbspdata
		{
			c_typed_tag_reference<SCENARIO_STRUCTURE_BSP_TAG> bsp;
			c_typed_tag_block<s_hlodplacement> placements_block;
			c_typed_tag_block<s_hlodindex> hlods_block;
			c_flags<e_hlodbspflags, short, k_hlodbspflags_count> flags;
			char generated_padd48c[2]; // padding
			real streaming_distance;
			long level_bsp_index;
		};
		static_assert(sizeof(s_hlodbspdata) == 52, "struct s_hlodbspdata is invalid size");

		struct s_hlodsystem
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<LEVEL_TAG> level;
			c_typed_tag_block<s_hlodnode> hlods_block;
			c_typed_tag_block<s_hlodbspdata> bsps_block;
			c_typed_tag_block<s_hlodindex> root_nodes_block;
			dword visibility_group_count;
			char generated_pad3058[4]; // padding
		};
		static_assert(sizeof(s_hlodsystem) == 76, "struct s_hlodsystem is invalid size");

		struct s_hlodobject
		{
			long guid;
			c_typed_tag_reference<LAYER_TAG> parent_layer_ref;
			c_enum<e_hlodincludeingeoenum, char> included_in_geo;
			char generated_pad944a[3]; // padding
		};
		static_assert(sizeof(s_hlodobject) == 24, "struct s_hlodobject is invalid size");

		struct s_hlodbsp
		{
			c_typed_tag_reference<SCENARIO_STRUCTURE_BSP_TAG> bsp;
			long iocount;
		};
		static_assert(sizeof(s_hlodbsp) == 20, "struct s_hlodbsp is invalid size");

		struct s_hlodsimplygoncustomspherecamerapath
		{
			dword quality;
			real semisphere_center_pitch_angle;
			real semisphere_center_yaw_angle;
			real sphere_coverage;
		};
		static_assert(sizeof(s_hlodsimplygoncustomspherecamerapath) == 16, "struct s_hlodsimplygoncustomspherecamerapath is invalid size");

		struct s_hlodmetadata
		{
			s_anytag_struct_definition anytag;
			string_id name;
			long guid;
			real_vector3d position;
			real_vector3d volumemin;
			real_vector3d volumemax;
			c_typed_tag_block<s_hlodobject> child_static_geo_block;
			c_typed_tag_block<s_hlodobject> child_hlod_volumes_block;
			c_enum<e_etargetlod, short> maximum_lod;
			char generated_pad77b4[2]; // padding
			c_typed_tag_block<s_hlodbsp> bsps_block;
			real switchdistance;
			c_typed_tag_reference<HLODSETTINGS_TAG> hlodsettings;
			c_typed_tag_reference<ASSET_TAG> asset;
			string_id asset_category;
			c_enum<e_hlodvisibilityenum, short> use_visibility;
			char generated_pad9195[2]; // padding
			s_hlodsimplygoncustomspherecamerapath visibility_camera_sphere_settings;
		};
		static_assert(sizeof(s_hlodmetadata) == 160, "struct s_hlodmetadata is invalid size");

		struct s_hlodmaterialcutoffmeshparts
		{
			s_tag_reference cut_off_mesh_parts_by_this_material;
		};
		static_assert(sizeof(s_hlodmaterialcutoffmeshparts) == 16, "struct s_hlodmaterialcutoffmeshparts is invalid size");

		struct s_hlodmaterialcutofflist
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_hlodmaterialcutoffmeshparts> hlod_materials_to_cut_off_mesh_parts_block;
			c_typed_tag_block<s_hlodmaterialcutoffmeshparts> hlod_materials_to_put_the_geo_directly_into_the_hlod_bypassing_simplygon_block;
		};
		static_assert(sizeof(s_hlodmaterialcutofflist) == 40, "struct s_hlodmaterialcutofflist is invalid size");

		struct s_lodtransitiondistanceblock
		{
			real lodtransitiondistance;
		};
		static_assert(sizeof(s_lodtransitiondistanceblock) == 4, "struct s_lodtransitiondistanceblock is invalid size");

		struct s_runtimeregionindex
		{
			char runtime_region_index;
		};
		static_assert(sizeof(s_runtimeregionindex) == 1, "struct s_runtimeregionindex is invalid size");

		struct s_s_model_variant_state
		{
			string_id permutation_name;
			char runtime_permutation_index;
			c_flags<e_modelstatepropertyflags, char, k_modelstatepropertyflags_count> property_flags;
			c_enum<e_modelstates, short> state;
			real_fraction initial_probability;
		};
		static_assert(sizeof(s_s_model_variant_state) == 12, "struct s_s_model_variant_state is invalid size");

		struct s_modelstatepermutationindex
		{
			char runtime_permutation_index;
		};
		static_assert(sizeof(s_modelstatepermutationindex) == 1, "struct s_modelstatepermutationindex is invalid size");

		struct s_s_model_variant_permutation
		{
			string_id permutation_name;
			dword runtime_permutation_index;
			c_flags<e_variantpermutationflags, char, k_variantpermutationflags_count> flags;
			char generated_padd60a[3]; // padding
			real probability;
			c_typed_tag_block<s_s_model_variant_state> states_block;
			s_modelstatepermutationindex runtime_state_permutation_indices[5];
			char generated_pad22bf[3]; // padding
		};
		static_assert(sizeof(s_s_model_variant_permutation) == 36, "struct s_s_model_variant_permutation is invalid size");

		struct s_s_model_variant_region
		{
			string_id region_name;
			char runtime_region_index;
			byte runtime_flags;
			short parent_variant;
			c_typed_tag_block<s_s_model_variant_permutation> permutations_block;
			c_enum<e_modelregionsorting, short> sort_order;
			char generated_pade9d0[2]; // padding
		};
		static_assert(sizeof(s_s_model_variant_region) == 24, "struct s_s_model_variant_region is invalid size");

		struct s_i343modelmodelvariantobject
		{
			// custom value
			string_id parent_marker;
			// custom value
			string_id child_marker;
			string_id child_variant_name;
			c_typed_tag_reference<OBJECT_TAG> child_object;
			c_typed_tag_reference<OBJECT_CONFIGURATION_TAG> child_configuration;
			short damage_section;
			c_flags<e_i343modelmodelvariantobjectflags, char, k_i343modelmodelvariantobjectflags_count> flags;
			char generated_padd065[1]; // padding
		};
		static_assert(sizeof(s_i343modelmodelvariantobject) == 48, "struct s_i343modelmodelvariantobject is invalid size");

		struct s_modelvariantmutednodeblock
		{
			string_id node_name;
		};
		static_assert(sizeof(s_modelvariantmutednodeblock) == 4, "struct s_modelvariantmutednodeblock is invalid size");

		struct s_s_model_variant
		{
			string_id name;
			string_id style;
			c_flags<e_modelvariantflags, long, k_modelvariantflags_count> model_variant_flags;
			c_enum<e_modelvariantenablehitdamageeffectsoundsoverride, short> damage_effect_sounds___enable_model_hit_override;
			s_runtimeregionindex runtime_variant_region_indices[32];
			char generated_pad364f[2]; // padding
			c_typed_tag_block<s_s_model_variant_region> regions_block;
			c_typed_tag_block<s_i343modelmodelvariantobject> objects_block;
			// custom object_node_graph_overrides
			c_typed_tag_block<s_i343objectsobjectnodegraphdefinition> object_node_graphs_block;
			// custom value
			c_typed_tag_block<s_modelvariantmutednodeblock> muted_nodes_block;
			s_nodeflagstoragearray muted_flag[32];
			c_typed_tag_reference<STRUCTURE_LIGHTS_TAG> structure_lighting_info;
			c_typed_tag_reference<BSP_LIGHTING_VOLUMES_TAG> lighting_volumes;
			c_typed_tag_reference<SCENARIO_LIGHTING_VOLUMES_TAG> scenario_lighting_volumes;
			c_typed_tag_reference<STRUCTURE_LIGHTMAP_TAG> object_lightmap;
			c_typed_tag_block<s_cubemapvolume> object_cubemap_set_block;
		};
		static_assert(sizeof(s_s_model_variant) == 300, "struct s_s_model_variant is invalid size");

		struct s_regionnameblock
		{
			string_id name;
		};
		static_assert(sizeof(s_regionnameblock) == 4, "struct s_regionnameblock is invalid size");

		struct s_s_model_material
		{
			string_id material_name;
			short damage_section;
			short runtime_collision_material_index;
			short runtime_damager_material_index;
			char generated_pad5ad1[2]; // padding
			string_id global_material_name;
			short runtime_global_material_index;
			char generated_pad40f0[2]; // padding
		};
		static_assert(sizeof(s_s_model_material) == 20, "struct s_s_model_material is invalid size");

		struct s_damagebodyparameters
		{
			real maximum_vitality;
			real minimum_stun_damage;
			real stun_time;
			real recharge_time;
			real_fraction recharge_fraction;
		};
		static_assert(sizeof(s_damagebodyparameters) == 20, "struct s_damagebodyparameters is invalid size");

		struct s_damageshieldparameters
		{
			real maximum_shield_vitality;
			string_id global_shield_material_name;
			real minimum_stun_damage;
			real stun_time;
			real recharge_time;
			real shield_overcharge_fraction;
			real shield_overcharge_time;
			real shield_damaged_threshold;
			c_typed_tag_reference<EFFECT_TAG> shield_damaged_effect;
			c_typed_tag_reference<EFFECT_TAG> shield_depleted_effect;
			c_typed_tag_reference<EFFECT_TAG> shield_recharging_effect;
		};
		static_assert(sizeof(s_damageshieldparameters) == 80, "struct s_damageshieldparameters is invalid size");

		struct s_instantaneousresponsedamageeffect
		{
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> transition_damage_effect;
		};
		static_assert(sizeof(s_instantaneousresponsedamageeffect) == 16, "struct s_instantaneousresponsedamageeffect is invalid size");

		struct s_instantaneousresponsedamageeffectmarker
		{
			string_id damage_effect_marker_name;
		};
		static_assert(sizeof(s_instantaneousresponsedamageeffectmarker) == 4, "struct s_instantaneousresponsedamageeffectmarker is invalid size");

		struct s_s_instantaneous_damage_response
		{
			c_enum<e_damageresponsetype, short> response_type;

			/* Constraint damage type */

			c_enum<e_damageresponseconstraintdamagetype, short> constraint_damage_type$2;

			/* Constraint destruction */

			string_id constraint_group_name;

			/* Damage response flags */

			c_flags<e_c_damage_response_flag_schema_part1, long, k_c_damage_response_flag_schema_part1_count> flags;
			c_flags<e_c_damage_response_flag_schema_part2, long, k_c_damage_response_flag_schema_part2_count> flags2;
			real_fraction damage_threshold;
			c_flags<e_damageresponsebodythresholdflag, long, k_damageresponsebodythresholdflag_count> body_threshold_flags;
			real body_damage_threshold;
			c_typed_tag_reference<EFFECT_TAG> transition_effect_generic;
			c_typed_tag_reference<EFFECT_TAG> transition_effect_specific;
			s_instantaneousresponsedamageeffect damage_effect;
			string_id region;
			c_enum<e_modelstates, short> new_state;
			short runtime_region_index;
			string_id region_secondary;
			c_enum<e_modelstates, short> new_state_secondary;
			short runtime_region_index_secondary;
			c_enum<e_damageresponsecustomresponsebehavior, short> custom_response_behavior;
			char generated_pad870e[2]; // padding
			string_id custom_response_label;
			string_id effect_marker_name;
			s_instantaneousresponsedamageeffectmarker damage_effect_marker;

			/* Response delay */

			real response_delay$2;
			c_typed_tag_reference<EFFECT_TAG> delay_effect;
			string_id delay_effect_marker_name;
			real response_delay_premature_damage_threshold;

			/* seat ejaculation */

			string_id ejecting_seat_label;

			/* skip fraction */

			real_fraction skip_fraction$2;

			/* destroyed child object marker name */

			string_id destroyed_child_object_marker_name$2;

			/* total damage threshold */

			real_fraction total_damage_threshold$2;
		};
		static_assert(sizeof(s_s_instantaneous_damage_response) == 152, "struct s_s_instantaneous_damage_response is invalid size");

		struct s_s_model_damage_section
		{
			string_id name;

			/* damage section flags */

			c_flags<e_c_old_damage_section_flags, long, k_c_old_damage_section_flags_count> flags;
			real_fraction vitality_percentage;
			c_typed_tag_block<s_s_instantaneous_damage_response> instant_responses_block;
			real stun_time;
			real recharge_time;
			real runtime_recharge_velocity;
			string_id resurrection_restored_region_name;
			short runtime_resurrection_restored_region_index;
			char generated_padab79[2]; // padding
		};
		static_assert(sizeof(s_s_model_damage_section) == 44, "struct s_s_model_damage_section is invalid size");

		struct s_s_damage_node
		{
			short runtime_damage_part;
		};
		static_assert(sizeof(s_s_damage_node) == 2, "struct s_s_damage_node is invalid size");

		struct s_s_damage_seat_region_setting
		{

			/* region-state-specific-damage */

			string_id damage_region_name;
			short runtime_damage_region_index;
			char generated_padf8cd[2]; // padding
			real direct_damage_scale_minor;
			real max_transfer_scale_minor;
			real min_transfer_scale_minor;
			real direct_damage_scale_medium;
			real max_transfer_scale_medium;
			real min_transfer_scale_medium;
			real direct_damage_scale_major;
			real max_transfer_scale_major;
			real min_transfer_scale_major;
		};
		static_assert(sizeof(s_s_damage_seat_region_setting) == 44, "struct s_s_damage_seat_region_setting is invalid size");

		struct s_s_damage_seat_info
		{
			string_id seat_label;
			real_fraction direct_damage_scale;
			real damage_transfer_fall_off_radius;
			real maximum_transfer_damage_scale;
			real minimum_transfer_damage_scale;
			c_typed_tag_block<s_s_damage_seat_region_setting> region_specific_damage_block;
		};
		static_assert(sizeof(s_s_damage_seat_info) == 32, "struct s_s_damage_seat_info is invalid size");

		struct s_s_damage_constraint_info
		{
			string_id physics_model_constraint_name;
			string_id damage_constraint_name;
			string_id damage_constraint_group_name;
			real group_probability_scale;
			short runtime_constraint_type;
			short runtime_constraint_index;
		};
		static_assert(sizeof(s_s_damage_constraint_info) == 20, "struct s_s_damage_constraint_info is invalid size");

		struct s_s_model_damage_info
		{
			c_flags<e_c_damage_info_flags, long, k_c_damage_info_flags_count> flags;
			string_id global_indirect_material_name;
			short indirect_damage_section;
			char generated_pad0d7e[2]; // padding

			/* body */

			s_damagebodyparameters body$2;

			/* shield */

			s_damageshieldparameters shield$2;
			c_typed_tag_block<s_s_model_damage_section> damage_sections_block;
			c_typed_tag_block<s_s_damage_node> nodes_block;
			short runtime_shield_material_type;
			short runtime_indirect_material_type;
			real runtime_shield_recharge_velocity;
			real runtime_overcharge_velocity;
			real runtime_health_recharge_velocity;
			c_typed_tag_block<s_s_damage_seat_info> damage_seats_block;
			c_typed_tag_block<s_s_damage_constraint_info> damage_constraints_block;
		};
		static_assert(sizeof(s_s_model_damage_info) == 176, "struct s_s_model_damage_info is invalid size");

		struct s_s_damage_section_recharge_speed_multiplier_curve
		{
			// custom mapping
			s_functiondefinition mapping;
		};
		static_assert(sizeof(s_s_damage_section_recharge_speed_multiplier_curve) == 20, "struct s_s_damage_section_recharge_speed_multiplier_curve is invalid size");

		struct s_damagesectionsegmentedrechargefractionblock
		{
			real_fraction vitality_percentage;
		};
		static_assert(sizeof(s_damagesectionsegmentedrechargefractionblock) == 4, "struct s_damagesectionsegmentedrechargefractionblock is invalid size");

		struct s_variantspecificationblock
		{
			string_id name;
		};
		static_assert(sizeof(s_variantspecificationblock) == 4, "struct s_variantspecificationblock is invalid size");

		struct s_s_region_transition
		{
			string_id region;
			c_enum<e_modelstates, short> new_state;
			short runtime_region_index;
		};
		static_assert(sizeof(s_s_region_transition) == 8, "struct s_s_region_transition is invalid size");

		struct s_s_damage_transfer
		{
			c_flags<e_damagetransferflags, long, k_damagetransferflags_count> flags;
			real transfer_amount;
			c_enum<e_damagetransferfunction, short> transfer_function;
			char generated_pad53f9[2]; // padding
			real ai_stun_transfer_amount;
			c_enum<e_damagetransferfunction, short> ai_stun_transfer_function;
			short damage_section;
			string_id seat_label;
		};
		static_assert(sizeof(s_s_damage_transfer) == 24, "struct s_s_damage_transfer is invalid size");

		struct s_seatejectionblock
		{
			string_id seat_label;
		};
		static_assert(sizeof(s_seatejectionblock) == 4, "struct s_seatejectionblock is invalid size");

		struct s_s_new_instantaneous_damage_response
		{
			c_flags<e_newdamageresponseflagsschemapart1, long, k_newdamageresponseflagsschemapart1_count> flags;
			c_flags<e_newdamageresponseflagsschemapart2, long, k_newdamageresponseflagsschemapart2_count> flags2;
			string_id label;
			c_typed_tag_block<s_variantspecificationblock> included_variants_block;
			c_typed_tag_block<s_variantspecificationblock> excluded_variants_block;
			real_fraction damage_threshold;
			real_fraction min_damage_threshold;
			string_id forced_hard_ping_anim_;
			c_typed_tag_reference<EFFECT_TAG> transition_effect_generic;
			string_id generic_effect_marker;
			c_typed_tag_reference<EFFECT_TAG> transition_effect_specific;
			string_id specific_effect_marker;
			s_instantaneousresponsedamageeffect damage_effect;
			s_instantaneousresponsedamageeffectmarker damage_effect_marker;
			c_typed_tag_reference<EFFECT_TAG> looping_effect;
			// custom contextual_effects

			/* Contextual Transition Effects */

			string_id ray_cast_marker;
			real ray_cast_length;
			c_typed_tag_reference<MATERIAL_EFFECTS_TAG> combined_material_effects;
			c_typed_tag_reference<VISUALMATERIALEFFECTSDEFINITION_TAG> visual_material_effects;
			c_typed_tag_reference<SOUNDMATERIALEFFECTSDEFINITION_TAG> sound_material_effects;
			c_typed_tag_reference<EFFECT_TAG> fallback_effect;
			string_id fallback_effect_marker;
			// custom value
			c_typed_tag_block<s_s_region_transition> region_transitions_block;
			c_typed_tag_block<s_s_damage_transfer> response_damage_transfers_block;
			c_enum<e_damageresponsecustomresponsebehavior, short> custom_response_behavior;
			char generated_padec95[2]; // padding
			string_id custom_response_label;
			real response_delay;
			c_typed_tag_reference<EFFECT_TAG> delay_effect;
			string_id delay_effect_marker_name;
			c_typed_tag_block<s_seatejectionblock> seat_eject_block;
			real_fraction skip_fraction;
			string_id destroyed_child_object_marker_name;
			real_fraction total_damage_threshold;
			string_id constraint_or_group_name;
			c_enum<e_damageresponseconstraintdamagetype, short> constraint_damage_type;
			char generated_padd2b4[2]; // padding
			c_enum<e_edamageresponseaidialogeeventtype, long> ai_dialog_event;
		};
		static_assert(sizeof(s_s_new_instantaneous_damage_response) == 292, "struct s_s_new_instantaneous_damage_response is invalid size");

		struct s_s_damage_section_rendering_parameters
		{
			c_typed_tag_reference<GENERATOR_SYSTEM_TAG> _3rd_person_impact_parameters_generator;
			c_typed_tag_reference<GENERATOR_SYSTEM_TAG> _1st_person_impact_parameters_generator;
		};
		static_assert(sizeof(s_s_damage_section_rendering_parameters) == 32, "struct s_s_damage_section_rendering_parameters is invalid size");

		struct s_s_new_model_damage_section
		{
			string_id name;
			c_enum<e_damagepart, char> damage_part;
			char generated_padaef0[3]; // padding
			c_flags<e_c_new_damage_section_flags, long, k_c_new_damage_section_flags_count> flags;
			long runtime_flags;
			// custom value
			real_fraction vitality_percentage;
			// custom value
			// custom maximum_vitality_percentage
			s_i343malleablepropertybasefloatstructdefinition maximum_vitality_percentage;
			string_id shield_material_name;

			/* stun */

			// custom value
			real stun_time;
			// custom value
			// custom stun_duration
			s_i343malleablepropertybasefloatstructdefinition stun_duration;
			real minimum_stun_damage;

			/* recharge */

			real recharge_time;
			// custom recharge_speed_base_scalar
			s_i343malleablepropertybasefloatstructdefinition recharge_speed_base_scalar;
			c_typed_tag_block<s_s_damage_section_recharge_speed_multiplier_curve> recharge_speed_curve_block;
			c_typed_tag_block<s_damagesectionsegmentedrechargefractionblock> recharge_fractions_block;
			c_typed_tag_reference<EFFECT_TAG> recharging_effect;
			real pre_recharge_effect_warn_time;
			c_typed_tag_reference<EFFECT_TAG> pre_recharge_effect;
			string_id pre_recharge_effect_marker;
			c_typed_tag_reference<EFFECT_TAG> pre_recharge_abort_effect;
			string_id pre_recharge_abort_effect_marker;

			/* overcharge */

			real overcharge_time;
			real overcharge_fraction;

			/* decay */

			real pre_decay_time;
			real decay_time;

			/* resurrection */

			string_id resurrection_restored_region_name;
			real anti_spam_timer_duration;
			c_typed_tag_block<s_s_new_instantaneous_damage_response> instant_responses_block;
			c_typed_tag_block<s_s_damage_transfer> section_damage_transfers_block;
			c_typed_tag_block<s_s_damage_section_rendering_parameters> rendering_block;
			real runtime_recharge_velocity;
			real runtime_overcharge_velocity;
			short runtime_resurrection_restored_region_index;
			short runtime_global_shield_material_type;
		};
		static_assert(sizeof(s_s_new_model_damage_section) == 228, "struct s_s_new_model_damage_section is invalid size");

		struct s_i343damageovershieldinformation
		{
			// custom overshield
			real decay_rate_;
			real stun_time_scalar;
			c_typed_tag_reference<GENERICMODIFIERDEFINITIONTAG_TAG> generic_modifiers;
			// custom value
		};
		static_assert(sizeof(s_i343damageovershieldinformation) == 24, "struct s_i343damageovershieldinformation is invalid size");

		struct s_i343damagedamageablecomponentpropertiesdefinition
		{
			// custom max_overshield_scalar
			s_i343malleablepropertybasefloatstructdefinition max_overshield_scalar;
			real body_vitality;
			// custom direct_damage_resistance
			s_i343malleablepropertybasefloatstructdefinition direct_damage_resistance;
			// custom grenade_damage_resistance
			s_i343malleablepropertybasefloatstructdefinition grenade_damage_resistance;
			// custom aoe_damage_resistance
			s_i343malleablepropertybasefloatstructdefinition aoe_damage_resistance;
			s_i343damageovershieldinformation overshield_information;
		};
		static_assert(sizeof(s_i343damagedamageablecomponentpropertiesdefinition) == 76, "struct s_i343damagedamageablecomponentpropertiesdefinition is invalid size");

		struct s_s_new_model_damage_info
		{

			/* Damage Info */

			c_flags<e_c_new_damage_info_flags, long, k_c_new_damage_info_flags_count> flags;
			string_id indirect_material_name;
			short indirect_damage_section;
			short shielded_state_damage_section;
			c_typed_tag_reference<EFFECT_TAG> restoration_effect;
			c_typed_tag_block<s_s_new_model_damage_section> damage_sections_block;
			c_typed_tag_block<s_s_damage_constraint_info> damage_constraints_block;
			c_typed_tag_block<s_s_damage_node> nodes_block;
			short runtime_indirect_material_type;
			char generated_pad9f05[2]; // padding

			/* Malleable Properties */

			s_i343damagedamageablecomponentpropertiesdefinition properties;
		};
		static_assert(sizeof(s_s_new_model_damage_info) == 144, "struct s_s_new_model_damage_info is invalid size");

		struct s_i343modelmodeltargetlockondata
		{

			/* lock-on fields */

			real lock_on_distance;
			string_id tracking_type;
		};
		static_assert(sizeof(s_i343modelmodeltargetlockondata) == 8, "struct s_i343modelmodeltargetlockondata is invalid size");

		struct s_i343modelmodeltarget
		{
			c_flags<e_i343modelmodeltargetflags, char, k_i343modelmodeltargetflags_count> flags;
			c_enum<e_i343modelmodeltargettype, char> type;
			c_enum<e_i343modelmodeltargetcategory, char> category;
			char generated_padb298[1]; // padding
			// custom value
			string_id marker_name;
			real size;
			angle cone_angle;
			short damage_section;
			short variant;
			real_fraction aim_assist_magnetism_scale;
			real_fraction ai_selection_priority_scale;
			real aoe_exclusion_radius;
			s_i343modelmodeltargetlockondata lock_on_data;
		};
		static_assert(sizeof(s_i343modelmodeltarget) == 40, "struct s_i343modelmodeltarget is invalid size");

		struct s_s_model_permutation
		{
			string_id name;
			c_flags<e_permutationflags, char, k_permutationflags_count> flags;
			char collision_permutation_index;
			char physics_permutation_index;
			char generated_padf2b8[1]; // padding
		};
		static_assert(sizeof(s_s_model_permutation) == 8, "struct s_s_model_permutation is invalid size");

		struct s_s_model_region
		{
			string_id name;
			char collision_region_index;
			char physics_region_index;
			char generated_pad1fd6[2]; // padding
			c_typed_tag_block<s_s_model_permutation> permutations_block;
		};
		static_assert(sizeof(s_s_model_region) == 20, "struct s_s_model_region is invalid size");

		struct s_s_model_node
		{
			string_id name;
			short parent_node;
			short first_child_node;
			short next_sibling_node;
			char generated_pad1c9e[2]; // padding
			real_point3d default_translation;
			real_quaternion default_rotation;
			real default_inverse_scale;
			real_vector3d default_inverse_forward;
			real_vector3d default_inverse_left;
			real_vector3d default_inverse_up;
			real_point3d default_inverse_position;
		};
		static_assert(sizeof(s_s_model_node) == 92, "struct s_s_model_node is invalid size");

		struct s_modelvariantoverridedef
		{
			string_id base_variant;
			string_id override_a;
			string_id override_b;
			string_id override_c;
		};
		static_assert(sizeof(s_modelvariantoverridedef) == 16, "struct s_modelvariantoverridedef is invalid size");

		struct s_teammatechatterdialogueblockdefinition
		{
			c_typed_tag_reference<DIALOGUE_TAG> teammate_chatter_dialogue;
		};
		static_assert(sizeof(s_teammatechatterdialogueblockdefinition) == 16, "struct s_teammatechatterdialogueblockdefinition is invalid size");

		struct s_specialdialogueblockdefinition
		{
			string_id identifier;
			c_typed_tag_reference<DIALOGUE_TAG> special_dialogue;
		};
		static_assert(sizeof(s_specialdialogueblockdefinition) == 20, "struct s_specialdialogueblockdefinition is invalid size");

		struct s_s_model_definition
		{
			s_anytag_struct_definition anytag;

			/* MODEL */

			// custom value
			c_typed_tag_reference<RENDER_MODEL_TAG> render_model;
			c_typed_tag_reference<COLLISION_MODEL_TAG> collision_model;
			c_typed_tag_reference<MODEL_ANIMATION_GRAPH_TAG> animation;
			c_typed_tag_reference<PHYSICS_MODEL_TAG> physics_model;
			long runtime_render_checksum;
			long runtime_collision_checksum;

			/* Optional Static Lightmap */

			c_flags<e_pvsflags, long, k_pvsflags_count> lightmap_flags;

			/* PVS */

			real pvs_bounding_box_extension_factor_;
			real_vector3d pvs_block_size_;
			long pvs_sampling_subdivision_per_axis_;
			real pvs_visibility_threshold_;
			string_id asset_category_name;
			long asset_category_index;

			/* level of detail */

			c_typed_tag_block<s_lodtransitiondistanceblock> lod_levels_block;
			real fade_out_after_distance;
			real disappear_distance;
			real begin_fade_distance;
			real animation_lod_distance;
			real shadow_fade_distance;
			real instance_disappear_distance;
			real midrange_detail_disappear_distance;
			real close_detail_disappear_distance;
			real tessellation_max_draw_distance;
			c_flags<e_lodresourcedistanceflags, long, k_lodresourcedistanceflags_count> resource_distance_override_flags;
			real medium_priority_distance;
			real low_priority_distance;
			c_typed_tag_block<s_s_model_variant> variants_block;
			c_typed_tag_block<s_regionnameblock> region_sort_block;
			c_typed_tag_block<s_s_model_material> model_materials_block;
			c_typed_tag_block<s_s_model_damage_info> new_damage_info_block;
			s_s_new_model_damage_info damage_info;
			c_typed_tag_block<s_i343modelmodeltarget> targets_old_block;
			c_typed_tag_block<s_i343modelmodeltarget> model_targets_block;
			c_typed_tag_block<s_s_model_region> runtime_regions_block;
			c_typed_tag_block<s_s_model_node> runtime_nodes_block;
			long runtime_node_list_checksum;
			c_typed_tag_block<s_s_model_node> prepopulated_runtime_nodes_block;

			/* more stuff */

			c_typed_tag_block<s_modelvariantoverridedef> variant_overrides_block;
			c_typed_tag_reference<DIALOGUE_TAG> default_dialogue;
			c_typed_tag_reference<DIALOGUE_TAG> default_dialogue_female;
			c_typed_tag_block<s_teammatechatterdialogueblockdefinition> teammate_chatter_dialogue_male_block;
			c_typed_tag_block<s_teammatechatterdialogueblockdefinition> teammate_chatter_dialogue_female_block;
			c_typed_tag_block<s_specialdialogueblockdefinition> special_dialogues_block;
			c_flags<e_modeldefinitionflags, long, k_modeldefinitionflags_count> flags;
			long runtime_flags;
			s_nodeflagstoragearray render_only_node_flags[32];
			s_nodeflagstoragearray render_only_section_flags[32];
			real_fraction sky_parallax_percent;
			real shadow_depth_compare_bias;
			real shadow_slope_scale_bias;
			real shadow_depth_compare_bias_dynamic_lights;
			real shadow_slope_scale_bias_dynamic_lights;
			real runtime_bounding_radius;
			real_point3d runtime_bounding_offset;
			char generated_pad57cd[4]; // padding
			long long reload_hash;
		};
		static_assert(sizeof(s_s_model_definition) == 832, "struct s_s_model_definition is invalid size");

		struct s_hlodsettingspreset
		{
			string_id name;
			c_typed_tag_reference<HLODSETTINGS_TAG> hlodsettings;
		};
		static_assert(sizeof(s_hlodsettingspreset) == 20, "struct s_hlodsettingspreset is invalid size");

		struct s_hlodsettingspresetlist
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_hlodsettingspreset> settings_presets_block;
			char generated_pad5f89[4]; // padding
		};
		static_assert(sizeof(s_hlodsettingspresetlist) == 32, "struct s_hlodsettingspresetlist is invalid size");

		struct s_hlodsimplygonrepairsettings
		{
			real tjuncdist;
			real welddist;
			dword progressivepasses;
		};
		static_assert(sizeof(s_hlodsimplygonrepairsettings) == 12, "struct s_hlodsimplygonrepairsettings is invalid size");

		struct s_hlodsimplygonnormalsettings
		{
			real hardedgeangleinradians;
		};
		static_assert(sizeof(s_hlodsimplygonnormalsettings) == 4, "struct s_hlodsimplygonnormalsettings is invalid size");

		struct s_hlodsimplygonmappingimagesettings
		{
			real parameterizermaxstretch;
			real parameterizerlargechartsimportance;
			dword gutterspace;
			dword texcoordlevel;
			c_enum<e_ehlodsimplygontexcoordgeneratortype, short> texcoordgeneratortype;
			char generated_pad85f3[2]; // padding
			dword multisamplinglevel;
			long texturesize;
			c_enum<e_ehlodsimplygonchartaggregatormode, short> chartaggregationmode;
			c_enum<e_ehlodchartaggregatororiginalchartproportionschannel, short> chartaggregatororiginalchartproportionschannel;
		};
		static_assert(sizeof(s_hlodsimplygonmappingimagesettings) == 32, "struct s_hlodsimplygonmappingimagesettings is invalid size");

		struct s_hlodsimplygonweldingsettings
		{
			c_flags<e_hlodsimplygonweld, long, k_hlodsimplygonweld_count> usewelding;
			real welddistance;
		};
		static_assert(sizeof(s_hlodsimplygonweldingsettings) == 8, "struct s_hlodsimplygonweldingsettings is invalid size");

		struct s_hlodsimplygonreductionsettings
		{
			s_hlodsimplygonrepairsettings repairsettings;
			c_flags<e_hlodsimplygonrepairstates, long, k_hlodsimplygonrepairstates_count> repairstates;
			s_hlodsimplygonnormalsettings normalsettings;
			c_flags<e_hlodsimplygonnormalstates, long, k_hlodsimplygonnormalstates_count> normalstates;
			s_hlodsimplygonmappingimagesettings mappingimagesettings;
			c_flags<e_hlodsimplygonmappingimagestates, long, k_hlodsimplygonmappingimagestates_count> mappingimagestates;
			c_enum<e_ehlodsimplygonreductiondeviationtype, short> deviationmode;
			char generated_pad4c1d[2]; // padding
			real maxdeviation;
			long reductiononscreensize;
			real derive_from_distance_scale;
			c_flags<e_hlodsimplygonreductionstates, char, k_hlodsimplygonreductionstates_count> reductionstates;
			char generated_pad323c[3]; // padding
			c_flags<e_hlodsimplygoneweldingsettingssource, long, k_hlodsimplygoneweldingsettingssource_count> weldingsettingssource;
			s_hlodsimplygonweldingsettings weldingsettings;
		};
		static_assert(sizeof(s_hlodsimplygonreductionsettings) == 92, "struct s_hlodsimplygonreductionsettings is invalid size");

		struct s_hlodsimplygonremeshingsettings
		{
			long remeshingonscreensize;
			real derive_from_distance_scale;
			dword maxtrianglesize;
			dword mergedistance;
			real mergeboldness;
			real hardedgeangleinradians;
			c_flags<e_hlodsimplygonremeshingstates, char, k_hlodsimplygonremeshingstates_count> remeshingstates;
			char generated_pad1da2[3]; // padding
			s_hlodsimplygonmappingimagesettings mappingimagesettings;
			c_flags<e_hlodsimplygonmappingimagestates, long, k_hlodsimplygonmappingimagestates_count> mappingimagestates;
		};
		static_assert(sizeof(s_hlodsimplygonremeshingsettings) == 64, "struct s_hlodsimplygonremeshingsettings is invalid size");

		struct s_hlodsimplygonaggregationsettings
		{
			s_hlodsimplygonmappingimagesettings mappingimagesettings;
			c_flags<e_hlodsimplygonmappingimagestates, long, k_hlodsimplygonmappingimagestates_count> mappingimagestates;
			c_flags<e_hlodsimplygonaggregationstates, char, k_hlodsimplygonaggregationstates_count> aggregationstates;
			char generated_pad1668[3]; // padding
			s_hlodsimplygonweldingsettings weldingsettings;
		};
		static_assert(sizeof(s_hlodsimplygonaggregationsettings) == 48, "struct s_hlodsimplygonaggregationsettings is invalid size");

		struct s_hlodvisibilitysettings
		{
			c_enum<e_hlodsimplygoncomputevisibilitymode, short> computevisibilitymode;
			char generated_pad69b8[2]; // padding
			real fillnonvisibleareathreshold;
			real visibilityweightspower;
			c_flags<e_hlodsimplygonvisibilitystates, long, k_hlodsimplygonvisibilitystates_count> visibilitystates;
		};
		static_assert(sizeof(s_hlodvisibilitysettings) == 16, "struct s_hlodvisibilitysettings is invalid size");

		struct s_hlodsimplygonglobalsettings
		{
			c_flags<e_hlodsimplygonglobalstates, char, k_hlodsimplygonglobalstates_count> states;
			char generated_pad2b9f[1]; // padding
			c_enum<e_validateprocessingdebuglevel, short> validateprocessingdebuglevel;
		};
		static_assert(sizeof(s_hlodsimplygonglobalsettings) == 4, "struct s_hlodsimplygonglobalsettings is invalid size");

		struct s_hlodsettings
		{
			s_anytag_struct_definition anytag;
			c_enum<e_ehlodgenerationpassstagecomplex, short> hlodgenerationpass;
			char generated_pad529c[2]; // padding
			long bakingtextureresolution;
			real baking_texture_screen_space_multiplier;
			dword bakingtexturedilation;
			real minimum_bounding_sphere_radius_to_include_in_hlod;
			// custom reduction_settings
			s_hlodsimplygonreductionsettings reduction;
			// custom value
			// custom remeshing_settings
			s_hlodsimplygonremeshingsettings remeshing;
			// custom value
			// custom aggregation_settings
			s_hlodsimplygonaggregationsettings aggregation;
			// custom value
			// custom visibility_settings
			s_hlodvisibilitysettings visibility;
			// custom value
			// custom global_settings
			s_hlodsimplygonglobalsettings simplygonglobalsettings;
			// custom value
			c_typed_tag_block<s_hlodmaterialcutoffmeshparts> hlod_materials_to_cut_off_mesh_parts_block;
			c_typed_tag_block<s_hlodmaterialcutoffmeshparts> hlod_materials_to_put_the_geo_directly_into_the_hlod_bypassing_simplygon_block;
			c_typed_tag_reference<HLODCUTOFFMATERIALLIST_TAG> reference_to_a_list_of_hlod_materials_to_cut_off_mesh_parts;
		};
		static_assert(sizeof(s_hlodsettings) == 300, "struct s_hlodsettings is invalid size");

		struct s_hologramlight
		{
			// custom hologram_light
			// custom direction
			real direction;
			// custom front_back
			real front_back;
			// custom intensity
			real intensity;
			real intensity_input;
			real forward_input;
			real right_input;
			real up_input;
		};
		static_assert(sizeof(s_hologramlight) == 28, "struct s_hologramlight is invalid size");

		struct s_hologramlighting
		{
			// custom hologram
			// custom intensity
			real intensity;
			real intensity_input;
			c_enum<e_hologramtransparencymode, char> transparency_mode;
			char generated_pad2b63[3]; // padding
			// custom value
			// custom key_light
			s_hologramlight key_light;
			// custom value
			// custom fill_light
			s_hologramlight fill_light;
			// custom value
			// custom rim_light
			s_hologramlight rim_light;
			// custom value
		};
		static_assert(sizeof(s_hologramlighting) == 96, "struct s_hologramlighting is invalid size");

		struct s_hologramlightingtag
		{
			s_anytag_struct_definition anytag;
			s_hologramlighting hologram_lighting;
		};
		static_assert(sizeof(s_hologramlightingtag) == 112, "struct s_hologramlightingtag is invalid size");

		struct s_objectscriptdefinition
		{
			c_static_string<256> classname;
			c_static_string<256> parentname;
		};
		static_assert(sizeof(s_objectscriptdefinition) == 512, "struct s_objectscriptdefinition is invalid size");

		struct s_hsreferencesblockwithvariant
		{
			c_typed_tag_reference<ANYTAG_TAG> reference;
			string_id load_variant;
			long long name_hash;
		};
		static_assert(sizeof(s_hsreferencesblockwithvariant) == 28, "struct s_hsreferencesblockwithvariant is invalid size");

		struct s_hsweakreferencesblockwithvariant
		{
			s_tag_reference reference;
			string_id load_variant;
			long long name_hash;
		};
		static_assert(sizeof(s_hsweakreferencesblockwithvariant) == 28, "struct s_hsweakreferencesblockwithvariant is invalid size");

		struct s_hsremotefunctionblock
		{
			s_tag_data function_name;
		};
		static_assert(sizeof(s_hsremotefunctionblock) == 20, "struct s_hsremotefunctionblock is invalid size");

		struct s_hstructfieldstringblock
		{
			c_static_string<256> name;
		};
		static_assert(sizeof(s_hstructfieldstringblock) == 256, "struct s_hstructfieldstringblock is invalid size");

		struct s_hstructfieldallowedextensionblock
		{
			c_static_string<32> name;
		};
		static_assert(sizeof(s_hstructfieldallowedextensionblock) == 32, "struct s_hstructfieldallowedextensionblock is invalid size");

		struct s_hstructfieldblock
		{
			c_static_string<256> name;
			c_enum<e_e_hstruct_type, long> type;
			c_static_string<256> _typename;
			c_static_string<256> prettyname;
			c_static_string<256> tooltip;
			c_static_string<256> group;
			c_enum<e_e_hstruct_field_source_type, long> sourcetype;
			c_typed_tag_block<s_hstructfieldstringblock> userdefinedstrings_block;
			c_typed_tag_block<s_hstructfieldallowedextensionblock> allowedextensions_block;
			real min;
			real max;
			real step;
			c_static_string<256> forgetaglistid;
		};
		static_assert(sizeof(s_hstructfieldblock) == 1580, "struct s_hstructfieldblock is invalid size");

		struct s_hstructblock
		{
			c_static_string<256> name;
			c_typed_tag_block<s_hstructfieldblock> fields_block;
		};
		static_assert(sizeof(s_hstructblock) == 268, "struct s_hstructblock is invalid size");

		struct s_hssourceruntimeerrormessage
		{
			c_static_string<256> error_message;
		};
		static_assert(sizeof(s_hssourceruntimeerrormessage) == 256, "struct s_hssourceruntimeerrormessage is invalid size");

		struct s_hssourcefiletag
		{
			s_anytag_struct_definition anytag;
			long long hash;
			s_tag_resource sourceresource;
			c_flags<e_hssourcedirectiveflags, char, k_hssourcedirectiveflags_count> sourcedirectiveflags;
			s_objectscriptdefinition objectscriptdefinition;
			char generated_pade272[3]; // padding
			s_tag_data serverbytecode;
			s_tag_data clientbytecode;
			c_typed_tag_block<s_hsreferencesblockwithvariant> references_with_variant_block;
			c_typed_tag_block<s_hsweakreferencesblockwithvariant> weak_references_with_variant_block;
			c_typed_tag_block<s_hsremotefunctionblock> server_remotes_block;
			c_typed_tag_block<s_hsremotefunctionblock> client_remotes_block;
			c_typed_tag_block<s_hstructblock> hstructs_block;
			s_tag_resource symbolresource;
			c_typed_tag_block<s_hssourceruntimeerrormessage> postprocess_error_messages_block;
			char generated_pad2f27[4]; // padding
		};
		static_assert(sizeof(s_hssourcefiletag) == 672, "struct s_hssourcefiletag is invalid size");

		struct s_s_hs_source_reference
		{
			c_typed_tag_reference<LUA_TAG> reference;
		};
		static_assert(sizeof(s_s_hs_source_reference) == 16, "struct s_s_hs_source_reference is invalid size");

		struct s_i343haloscriptscriptdata
		{
			c_typed_tag_block<s_s_hs_source_reference> source_file_references_block;
			c_typed_tag_block<s_s_hs_source_reference> external_source_references_block;
		};
		static_assert(sizeof(s_i343haloscriptscriptdata) == 24, "struct s_i343haloscriptscriptdata is invalid size");

		struct s_hsscriptcontainer
		{
			s_anytag_struct_definition anytag;
			s_i343haloscriptscriptdata script_data;
		};
		static_assert(sizeof(s_hsscriptcontainer) == 40, "struct s_hsscriptcontainer is invalid size");

		struct s_i343highlightservicehighlightserviceglobalsdefinition_type
		{
			c_typed_tag_reference<OUTLINETYPEDEFINITION_TAG> editor_depth_type;
		};
		static_assert(sizeof(s_i343highlightservicehighlightserviceglobalsdefinition_type) == 16, "struct s_i343highlightservicehighlightserviceglobalsdefinition_type is invalid size");

		struct s_i343highlightservicehighlightserviceglobalsdefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343highlightservicehighlightserviceglobalsdefinition_type> editor_depth_block;
			char generated_pad3812[4]; // padding
		};
		static_assert(sizeof(s_i343highlightservicehighlightserviceglobalsdefinition) == 32, "struct s_i343highlightservicehighlightserviceglobalsdefinition is invalid size");

		struct s_ingamemapmaterialvariation
		{
			string_id name;
			c_typed_tag_reference<MATERIAL_TAG> material;
		};
		static_assert(sizeof(s_ingamemapmaterialvariation) == 20, "struct s_ingamemapmaterialvariation is invalid size");

		struct s_ingamemapmaterialvariationstag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<MATERIAL_TAG> defaultmaterial;
			c_typed_tag_block<s_ingamemapmaterialvariation> variations_block;
		};
		static_assert(sizeof(s_ingamemapmaterialvariationstag) == 44, "struct s_ingamemapmaterialvariationstag is invalid size");

		struct s_impostortag
		{
			s_anytag_struct_definition anytag;
			real camera_distance;
			c_enum<e_eimpostorcamerapointscount, short> number_of_camera_points;
			c_flags<e_impostortexturechannels, short, k_impostortexturechannels_count> texture_channels_rendered;
			c_enum<e_eimpostorgridshape, short> grid_shape;
			c_enum<e_eimpostortexturesize, short> texture_size;
			c_enum<e_elodflags, short> maximum_lod_index;
			char generated_padac96[2]; // padding
		};
		static_assert(sizeof(s_impostortag) == 32, "struct s_impostortag is invalid size");

		struct s_inputbundleref
		{
			c_typed_tag_reference<INPUTBUNDLE_TAG> bundle;
		};
		static_assert(sizeof(s_inputbundleref) == 16, "struct s_inputbundleref is invalid size");

		struct s_inputbundlesetref
		{
			c_typed_tag_reference<INPUTBUNDLESET_TAG> bundleset;
		};
		static_assert(sizeof(s_inputbundlesetref) == 16, "struct s_inputbundlesetref is invalid size");

		struct s_inputbundleset
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_inputbundleref> bundles_block;
			c_typed_tag_block<s_inputbundlesetref> children_block;
			c_typed_tag_block<s_inputbundleref> flatbundles_block;
			char generated_pade53e[4]; // padding
		};
		static_assert(sizeof(s_inputbundleset) == 56, "struct s_inputbundleset is invalid size");

		struct s_inputaxis
		{
			string_id name;
			real default_value;
			c_enum<e_inputaxisbehavior, char> behavior;
			char generated_pada3ff[3]; // padding
		};
		static_assert(sizeof(s_inputaxis) == 12, "struct s_inputaxis is invalid size");

		struct s_inputdevicebinding
		{
			c_enum<e_inputdeviceelement, short> device;
			char output;
			char generated_padc197[1]; // padding
		};
		static_assert(sizeof(s_inputdevicebinding) == 4, "struct s_inputdevicebinding is invalid size");

		struct s_inputaxisref
		{
			c_typed_tag_reference<INPUTBUNDLE_TAG> bundle;
			string_id axis;
			byte axisindex;
			char generated_pad6600[3]; // padding
		};
		static_assert(sizeof(s_inputaxisref) == 24, "struct s_inputaxisref is invalid size");

		struct s_inputaxisconnection
		{
			s_inputaxisref external;
			char internal;
			c_flags<e_inputaxisconnectionflags, char, k_inputaxisconnectionflags_count> flags;
			char generated_pad3cef[2]; // padding
		};
		static_assert(sizeof(s_inputaxisconnection) == 28, "struct s_inputaxisconnection is invalid size");

		struct s_inputaxismap
		{
			char input0;
			char input1;
			char output;
			c_enum<e_inputaxismapop, char> operation;
			real minimum;
			real maximum;
		};
		static_assert(sizeof(s_inputaxismap) == 12, "struct s_inputaxismap is invalid size");

		struct s_inputaxisindex
		{
			byte axisindex;
		};
		static_assert(sizeof(s_inputaxisindex) == 1, "struct s_inputaxisindex is invalid size");

		struct s_inputbundle
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_inputaxis> axes_block;
			c_typed_tag_block<s_inputdevicebinding> bindings_block;
			c_typed_tag_block<s_inputaxisconnection> connections_block;
			c_typed_tag_block<s_inputaxismap> maps_block;
			c_typed_tag_block<s_inputaxisindex> constants_block;
			char generated_pad8744[4]; // padding
		};
		static_assert(sizeof(s_inputbundle) == 80, "struct s_inputbundle is invalid size");

		struct s_inputdevicebindingentry
		{
			c_enum<e_inputdeviceelement, short> device;
			char generated_padf483[2]; // padding
			string_id axis;
			c_flags<e_inputdevicebindingentryflags, char, k_inputdevicebindingentryflags_count> flags;
			char generated_pada7ce[3]; // padding
		};
		static_assert(sizeof(s_inputdevicebindingentry) == 12, "struct s_inputdevicebindingentry is invalid size");

		struct s_inputdevicebindings
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_inputdevicebindingentry> bindings_block;
			char generated_padd63c[4]; // padding
		};
		static_assert(sizeof(s_inputdevicebindings) == 32, "struct s_inputdevicebindings is invalid size");

		struct s_inputmode
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<INPUTBUNDLESET_TAG> include;
			c_typed_tag_reference<INPUTBUNDLESET_TAG> exclude;
			real priority;
			char generated_padfd69[4]; // padding
		};
		static_assert(sizeof(s_inputmode) == 56, "struct s_inputmode is invalid size");

		struct s_inputaxisendpointsource
		{
			string_id name;
			s_inputaxisref axis;
		};
		static_assert(sizeof(s_inputaxisendpointsource) == 28, "struct s_inputaxisendpointsource is invalid size");

		struct s_inputbundleendpointsource
		{
			string_id name;
			c_typed_tag_reference<INPUTBUNDLE_TAG> bundle;
		};
		static_assert(sizeof(s_inputbundleendpointsource) == 20, "struct s_inputbundleendpointsource is invalid size");

		struct s_inputmodeendpointsource
		{
			string_id name;
			c_typed_tag_reference<INPUTMODE_TAG> mode;
		};
		static_assert(sizeof(s_inputmodeendpointsource) == 20, "struct s_inputmodeendpointsource is invalid size");

		struct s_inputscopetag
		{
			s_anytag_struct_definition anytag;
			string_id name;
			c_typed_tag_block<s_inputaxisendpointsource> axisendpoints_block;
			c_typed_tag_block<s_inputbundleendpointsource> bundleendpoints_block;
			c_typed_tag_block<s_inputmodeendpointsource> modeendpoints_block;
		};
		static_assert(sizeof(s_inputscopetag) == 56, "struct s_inputscopetag is invalid size");

		struct s_interactiondefinition
		{
			s_anytag_struct_definition anytag;
			real_bounds duration_bounds;
			real radius;
			s_scalarfunctionname interaction_strength_over_time;
			s_scalarfunctionname interaction_falloff_function;
			char generated_pad3513[4]; // padding
		};
		static_assert(sizeof(s_interactiondefinition) == 72, "struct s_interactiondefinition is invalid size");

		struct s_inheritedanimationnodemap
		{
			short local_node;
		};
		static_assert(sizeof(s_inheritedanimationnodemap) == 2, "struct s_inheritedanimationnodemap is invalid size");

		struct s_inheritedanimationnodemapflag
		{
			dword local_node_flags;
		};
		static_assert(sizeof(s_inheritedanimationnodemapflag) == 4, "struct s_inheritedanimationnodemapflag is invalid size");

		struct s_inheritedanimationdata
		{
			string_id name;
		};
		static_assert(sizeof(s_inheritedanimationdata) == 4, "struct s_inheritedanimationdata is invalid size");

		struct s_animationgraphparentdata
		{
			c_typed_tag_reference<MODEL_ANIMATION_GRAPH_TAG> parent_graph;
			c_flags<e_animationgraphinheritanceflags, long, k_animationgraphinheritanceflags_count> inheritance_flags;
			c_typed_tag_block<s_inheritedanimationnodemap> node_map_block;
			c_typed_tag_block<s_inheritedanimationnodemapflag> node_map_flags_block;
			real uniform_translation_scale;
			long alias_index;
			long base_index;
			c_typed_tag_block<s_inheritedanimationdata> temp_anim_list_block;
		};
		static_assert(sizeof(s_animationgraphparentdata) == 68, "struct s_animationgraphparentdata is invalid size");

		struct s_animationgraphinheritancesettings
		{
			c_typed_tag_block<s_animationgraphparentdata> inherited_graph_block;
		};
		static_assert(sizeof(s_animationgraphinheritancesettings) == 12, "struct s_animationgraphinheritancesettings is invalid size");

		struct s_animationgrapheventreferences
		{
			c_typed_tag_reference<FRAME_EVENT_LIST_TAG> events_file;
			c_typed_tag_block<s_soundeventreferenceset> sound_references_block;
			c_typed_tag_block<s_animationgraphdialoguereference> dialogue_references_block;
			c_typed_tag_block<s_effecteventreferenceset> effect_references_block;
		};
		static_assert(sizeof(s_animationgrapheventreferences) == 52, "struct s_animationgrapheventreferences is invalid size");

		struct s_animationgraphpcareference
		{
			c_typed_tag_reference<PCA_ANIMATION_TAG> pca_animation;
		};
		static_assert(sizeof(s_animationgraphpcareference) == 16, "struct s_animationgraphpcareference is invalid size");

		struct s_animationgraphexternalreferences
		{
			// custom links

			/* inheritance */

			s_animationgraphinheritancesettings inheritance$2;

			/* events */

			s_animationgrapheventreferences events$2;

			/* pca animation */

			s_animationgraphpcareference pca;
			// custom value
		};
		static_assert(sizeof(s_animationgraphexternalreferences) == 80, "struct s_animationgraphexternalreferences is invalid size");

		struct s_animationgraphsettings
		{
			// custom settings
			c_flags<e_animationgraphmiscflagstype, short, k_animationgraphmiscflagstype_count> graph_flags;
			c_flags<e_animationgraphprivateflagstype, short, k_animationgraphprivateflagstype_count> private_flags;

			/* Compression */

			c_enum<e_c_animation_compression_force_setting, short> force_compression_setting;
			short animation_codec_pack;
			// custom value
		};
		static_assert(sizeof(s_animationgraphsettings) == 8, "struct s_animationgraphsettings is invalid size");

		struct s_i343animationfirstpersonoverlaychannelsliderweightfunctionmap
		{

			/* FIRST PERSON OVERLAY CHANNEL WEIGHT SCALING */

			string_id overlay_animation_name;
			// custom value
			string_id channel_weight_scale_source;
		};
		static_assert(sizeof(s_i343animationfirstpersonoverlaychannelsliderweightfunctionmap) == 8, "struct s_i343animationfirstpersonoverlaychannelsliderweightfunctionmap is invalid size");

		struct s_animationresourceindex
		{
			short resource_group;
			short resource_member_index;
		};
		static_assert(sizeof(s_animationresourceindex) == 4, "struct s_animationresourceindex is invalid size");

		struct s_c_model_animation
		{
			string_id name;
			// custom play_on_player
			short frame_count;
			word node_count;
			c_enum<e_c_animation_type, char> animation_type;
			c_enum<e_c_animation_frame_info_type, char> frame_info_type;
			c_enum<e_c_animation_frame_info_type, char> desired_frame_info_type;
			c_enum<e_c_animation_compression_setting, char> desired_compression;
			c_enum<e_c_animation_compression_setting, char> current_compression;
			char generated_padafd6[1]; // padding
			short parent_animation;
			short next_animation;
			short composite;
			real weight;
			short loop_frame_index;
			c_flags<e_c_animation_user_flags, short, k_c_animation_user_flags_count> user_flags;
			long replacement_interpolator;
			real override_blend_in_time;
			string_id replacement_blend_in_weight_function;
			real override_blend_out_time;
			string_id replacement_blend_out_weight_function;
			string_id pca_group_name;
			c_typed_tag_block<s_i343animationfirstpersonoverlaychannelsliderweightfunctionmap> first_person_overlay_channel_slider_weight_function_map_block;
			c_flags<e_c_animation_internal_flags, short, k_c_animation_internal_flags_count> internal_flags;
			word compressor_version;
			real_vector3d heading;
			real heading_angle;
			real average_translation_magnitude;
			real average_pivot_yaw;
			real original_object_space_yaw;
			real maxelevationoffset;
			long uid;
			dword node_list_checksum;
			s_animationresourceindex resource_index;
		};
		static_assert(sizeof(s_c_model_animation) == 112, "struct s_c_model_animation is invalid size");

		struct s_pcagroupsettings
		{
			string_id group_name;
			long desired_mesh_count;

			/* PCA Component Importance */

			real_vector3d position_importance_scale;
			real_vector2d normal_importance_scale;
			real_vector2d tension_importance_scale;
		};
		static_assert(sizeof(s_pcagroupsettings) == 36, "struct s_pcagroupsettings is invalid size");

		struct s_animationgraphpcadata
		{

			/* PCA Groups */

			c_typed_tag_block<s_pcagroupsettings> pca_groups_block;
			long pca_animation_count;
			long pca_checksum;
		};
		static_assert(sizeof(s_animationgraphpcadata) == 20, "struct s_animationgraphpcadata is invalid size");

		struct s_compositedeadzone
		{
			real_bounds bounds;
			real rate;
			real center;
			real radius;
			real amount;
			real delay;
		};
		static_assert(sizeof(s_compositedeadzone) == 28, "struct s_compositedeadzone is invalid size");

		struct s_compositeaxis
		{
			string_id name;
			string_id animation_source;
			// custom value
			string_id input_function;
			real_bounds animation_bounds;
			real_bounds input_bounds;
			real_bounds clamp_bounds;
			real blend_limit;
			c_typed_tag_block<s_compositedeadzone> dead_zones_block;
			byte divisions;
			byte priority;
			byte update;
			byte functionindex;
			c_flags<e_c_composite_axis_flags, long, k_c_composite_axis_flags_count> flags;
		};
		static_assert(sizeof(s_compositeaxis) == 60, "struct s_compositeaxis is invalid size");

		struct s_compositeentryvalue
		{
			real value;
		};
		static_assert(sizeof(s_compositeentryvalue) == 4, "struct s_compositeentryvalue is invalid size");

		struct s_compositeentry
		{
			string_id source;
			c_typed_tag_block<s_compositeentryvalue> values_block;
			long overridden;
			short animindex;
			byte slideaxis;
			char generated_padd329[1]; // padding
		};
		static_assert(sizeof(s_compositeentry) == 24, "struct s_compositeentry is invalid size");

		struct s_synckey
		{
			c_enum<e_animationframeeventtype, short> key;
		};
		static_assert(sizeof(s_synckey) == 2, "struct s_synckey is invalid size");

		struct s_compositephaseset
		{
			string_id name;
			string_id timing_source;
			c_typed_tag_block<s_synckey> sync_points_block;
			s_tag_data sync_frames;
			s_tag_data facets;
			s_tag_data neighbors;
			s_tag_data containment;
			s_tag_data example_grid;
			real_bounds normalized_bounds;
			byte offset;
			char generated_pad597a[1]; // padding
			short timinganimindex;
		};
		static_assert(sizeof(s_compositephaseset) == 132, "struct s_compositephaseset is invalid size");

		struct s_animationordefaultstringidblocktype
		{
			string_id name;
		};
		static_assert(sizeof(s_animationordefaultstringidblocktype) == 4, "struct s_animationordefaultstringidblocktype is invalid size");

		struct s_compositetag
		{
			string_id name;
			c_typed_tag_block<s_compositeaxis> axes_block;
			c_typed_tag_block<s_compositeentry> anims_block;
			c_typed_tag_block<s_compositephaseset> sets_block;
			c_typed_tag_block<s_animationordefaultstringidblocktype> strings_block;
			string_id timing_source;
			short timinganimindex;
			short medianthrottlemag;
		};
		static_assert(sizeof(s_compositetag) == 60, "struct s_compositetag is invalid size");

		struct s_animationtokenentry
		{
			string_id name;
		};
		static_assert(sizeof(s_animationtokenentry) == 4, "struct s_animationtokenentry is invalid size");

		struct s_overlaytokenentry
		{
			string_id name;
		};
		static_assert(sizeof(s_overlaytokenentry) == 4, "struct s_overlaytokenentry is invalid size");

		struct s_poseblendtokenentry
		{
			string_id name;
		};
		static_assert(sizeof(s_poseblendtokenentry) == 4, "struct s_poseblendtokenentry is invalid size");

		struct s_s_animation_function
		{
			string_id name;
			s_scalarfunctionname function;
		};
		static_assert(sizeof(s_s_animation_function) == 24, "struct s_s_animation_function is invalid size");

		struct s_c_animation_id
		{
			short parent_graph;
			short animation;
		};
		static_assert(sizeof(s_c_animation_id) == 4, "struct s_c_animation_id is invalid size");

		struct s_animationblendscreendefinition
		{
			string_id name;
			c_flags<e_c_animation_blend_screen_flags, long, k_c_animation_blend_screen_flags_count> flags;
			real weight;
			real_fraction interpolation_rate;
			c_enum<e_c_animation_blend_screen_variable_source, short> yaw_source;
			c_enum<e_c_animation_blend_screen_variable_source, short> pitch_source;
			// custom value
			string_id yaw_source_object_function;
			// custom value
			string_id pitch_source_object_function;
			c_enum<e_c_animation_blend_screen_weight_source, short> weight_source;
			c_enum<e_c_animation_blend_screen_weight_source, short> secondary_weight_source;
			// custom value
			string_id weight_source_object_function;
			// custom value
			string_id secondary_weight_object_function;
			short weight_function;
			s_c_animation_id animation;
			char generated_pade4f6[2]; // padding
			long animation_token;
		};
		static_assert(sizeof(s_animationblendscreendefinition) == 52, "struct s_animationblendscreendefinition is invalid size");

		struct s_s_new_animation_function_overlay
		{
			string_id name;
			c_flags<e_c_animation_function_overlay_flags, long, k_c_animation_function_overlay_flags_count> flags;
			// custom value
			string_id frame_ratio_object_function;
			// custom value
			string_id playback_speed_object_function;
			// custom value
			string_id blend_weight_object_function;
			// custom value
			string_id unlock_function;
			real_bounds unlock_range;
			s_c_animation_id animation;
			long animation_token;
			short start_lod_taper;
			short end_lod_taper;
		};
		static_assert(sizeof(s_s_new_animation_function_overlay) == 44, "struct s_s_new_animation_function_overlay is invalid size");

		struct s_s_blend_screen_item
		{
			short blend_screen;
			c_flags<e_c_overlay_group_item_definition_flags, short, k_c_overlay_group_item_definition_flags_count> flags;
			short node_mask;
		};
		static_assert(sizeof(s_s_blend_screen_item) == 6, "struct s_s_blend_screen_item is invalid size");

		struct s_s_function_overlay_item
		{
			short function_overlay;
			c_flags<e_c_overlay_group_item_definition_flags, short, k_c_overlay_group_item_definition_flags_count> flags;
		};
		static_assert(sizeof(s_s_function_overlay_item) == 4, "struct s_s_function_overlay_item is invalid size");

		struct s_s_overlay_group
		{
			string_id name;
			c_typed_tag_block<s_s_blend_screen_item> blend_screens_block;
			c_typed_tag_block<s_s_function_overlay_item> function_overlays_block;
		};
		static_assert(sizeof(s_s_overlay_group) == 28, "struct s_s_overlay_group is invalid size");

		struct s_animationinterpolator
		{
			string_id name;
			long bone_mask;
			s_scalarfunctionname function;
		};
		static_assert(sizeof(s_animationinterpolator) == 28, "struct s_animationinterpolator is invalid size");

		struct s_animationinterpolationentry
		{
			long interpolator;
		};
		static_assert(sizeof(s_animationinterpolationentry) == 4, "struct s_animationinterpolationentry is invalid size");

		struct s_animationinterpolationset
		{
			string_id name;
			real seconds;
			c_typed_tag_block<s_animationinterpolationentry> interpolators_block;
			s_scalarfunctionname default_curve;
		};
		static_assert(sizeof(s_animationinterpolationset) == 40, "struct s_animationinterpolationset is invalid size");

		struct s_s_mode_or_stance_alias
		{
			string_id mode_or_stance;
			string_id alias;
		};
		static_assert(sizeof(s_s_mode_or_stance_alias) == 8, "struct s_s_mode_or_stance_alias is invalid size");

		struct s_s_model_animation_variant
		{
			string_id variant_name;
			c_typed_tag_block<s_s_mode_or_stance_alias> mode_or_stance_aliases_block;
		};
		static_assert(sizeof(s_s_model_animation_variant) == 16, "struct s_s_model_animation_variant is invalid size");

		struct s_s_function_driven_variant
		{
			// custom value
			string_id function_name;
			c_typed_tag_block<s_s_mode_or_stance_alias> mode_or_stance_aliases_block;
		};
		static_assert(sizeof(s_s_function_driven_variant) == 16, "struct s_s_function_driven_variant is invalid size");

		struct s_s_animation_entry
		{
			string_id label;
			short overlay_group;
			short ik_set;
			s_c_animation_id animation;
		};
		static_assert(sizeof(s_s_animation_entry) == 12, "struct s_s_animation_entry is invalid size");

		struct s_damageregionparam
		{
			s_c_animation_id animation;
		};
		static_assert(sizeof(s_damageregionparam) == 4, "struct s_damageregionparam is invalid size");

		struct s_s_animation_damage_direction
		{
			c_typed_tag_block<s_damageregionparam> regions_block;
		};
		static_assert(sizeof(s_s_animation_damage_direction) == 12, "struct s_s_animation_damage_direction is invalid size");

		struct s_s_animation_damage_actions
		{
			string_id label;
			c_typed_tag_block<s_s_animation_damage_direction> directions_block;
		};
		static_assert(sizeof(s_s_animation_damage_actions) == 16, "struct s_s_animation_damage_actions is invalid size");

		struct s_animationtransitionsettings
		{
			long transition_lerp;
			s_c_animation_id transition_anim;
			// custom value
			string_id anim_timing_function;
			long anim_lerp_in;
			long anim_lerp_out;
		};
		static_assert(sizeof(s_animationtransitionsettings) == 20, "struct s_animationtransitionsettings is invalid size");

		struct s_s_animation_transition_destination
		{
			string_id mode_name;
			string_id state_name;
			s_animationtransitionsettings transition_settings;
		};
		static_assert(sizeof(s_s_animation_transition_destination) == 28, "struct s_s_animation_transition_destination is invalid size");

		struct s_s_animation_transition_source
		{
			string_id state_name;
			c_typed_tag_block<s_s_animation_transition_destination> destinations_block;
		};
		static_assert(sizeof(s_s_animation_transition_source) == 16, "struct s_s_animation_transition_source is invalid size");

		struct s_animationvelocityboundary
		{
			real values;
		};
		static_assert(sizeof(s_animationvelocityboundary) == 4, "struct s_animationvelocityboundary is invalid size");

		struct s_s_animation_velocity_boundaries
		{
			s_animationvelocityboundary velocity_boundary_entries[8];
		};
		static_assert(sizeof(s_s_animation_velocity_boundaries) == 32, "struct s_s_animation_velocity_boundaries is invalid size");

		struct s_c_animation_set
		{
			string_id label;
			short overlay_group;
			short ik_set;
			c_typed_tag_block<s_s_animation_entry> actions_block;
			c_typed_tag_block<s_s_animation_entry> overlay_animations_block;
			c_typed_tag_block<s_s_animation_damage_actions> death_and_damage_block;
			c_typed_tag_block<s_s_animation_transition_source> transitions_block;
			c_typed_tag_block<s_s_animation_velocity_boundaries> velocity_boundaries_block;
		};
		static_assert(sizeof(s_c_animation_set) == 68, "struct s_c_animation_set is invalid size");

		struct s_c_weapon_type
		{
			string_id label;
			short overlay_group;
			short ik_set;
			c_typed_tag_block<s_c_animation_set> sets_block;
		};
		static_assert(sizeof(s_c_weapon_type) == 20, "struct s_c_weapon_type is invalid size");

		struct s_s_animation_ik_point_v1
		{
			// custom value
			string_id marker;
			// custom value
			string_id attach_to_marker;
			// custom value
			string_id weight_source_object_function;
			// custom value
			string_id priority_source_object_function;
		};
		static_assert(sizeof(s_s_animation_ik_point_v1) == 16, "struct s_s_animation_ik_point_v1 is invalid size");

		struct s_s_ranged_animation_entry
		{
			short overlay_group;
			short ik_set;
			s_c_animation_id animation;
			real animation_parameter;
			real animation_parameter_b;
		};
		static_assert(sizeof(s_s_ranged_animation_entry) == 16, "struct s_s_ranged_animation_entry is invalid size");

		struct s_triangulationpoint
		{
			real_vector2d point;
		};
		static_assert(sizeof(s_triangulationpoint) == 8, "struct s_triangulationpoint is invalid size");

		struct s_s_blend_screen_delaunay_triangle
		{
			byte vertex1;
			byte vertex2;
			byte vertex3;
			byte link12;
			byte link23;
			byte link31;
			char padding[2]; // padding
		};
		static_assert(sizeof(s_s_blend_screen_delaunay_triangle) == 8, "struct s_s_blend_screen_delaunay_triangle is invalid size");

		struct s_s_triangulation_tag_struct
		{
			c_typed_tag_block<s_triangulationpoint> points_block;
			c_typed_tag_block<s_s_blend_screen_delaunay_triangle> triangles_block;
		};
		static_assert(sizeof(s_s_triangulation_tag_struct) == 24, "struct s_s_triangulation_tag_struct is invalid size");

		struct s_s_animation_ranged_action
		{
			string_id label;
			c_typed_tag_block<s_s_ranged_animation_entry> animations_block;
			c_typed_tag_block<s_s_triangulation_tag_struct> triangulation_data_block;
			c_enum<e_c_animation_ranged_action_variable_source, short> horizontal_source;
			c_enum<e_c_animation_ranged_action_variable_source, short> vertical_source;
			c_enum<e_animationframeeventtype, short> start_key;
			c_enum<e_animationframeeventtype, short> end_key;
		};
		static_assert(sizeof(s_s_animation_ranged_action) == 36, "struct s_s_animation_ranged_action is invalid size");

		struct s_s_animation_sync_action_same_type_participant
		{
			c_flags<e_c_animation_sync_action_flags, long, k_c_animation_sync_action_flags_count> flags;
			s_c_animation_id animation;
			real_point3d start_offset;
			real_vector3d start_facing;
			real_point3d end_offset;
			real time_until_hurt;
			real_point3d apex_offset;
		};
		static_assert(sizeof(s_s_animation_sync_action_same_type_participant) == 60, "struct s_s_animation_sync_action_same_type_participant is invalid size");

		struct s_s_animation_sync_action_other_type_participant
		{
			c_flags<e_c_animation_sync_action_other_type_flags, long, k_c_animation_sync_action_other_type_flags_count> flags;
			s_tag_reference object_type;
		};
		static_assert(sizeof(s_s_animation_sync_action_other_type_participant) == 20, "struct s_s_animation_sync_action_other_type_participant is invalid size");

		struct s_s_animation_sync_action
		{
			string_id name;
			c_enum<e_eanimationsyncactionstyle, long> sync_action_type;
			c_typed_tag_block<s_s_animation_sync_action_same_type_participant> same_type_participants_block;
			c_typed_tag_block<s_s_animation_sync_action_other_type_participant> other_participants_block;
		};
		static_assert(sizeof(s_s_animation_sync_action) == 32, "struct s_s_animation_sync_action is invalid size");

		struct s_s_animation_sync_action_group
		{
			string_id name;
			c_typed_tag_block<s_s_animation_sync_action> sync_actions_block;
		};
		static_assert(sizeof(s_s_animation_sync_action_group) == 16, "struct s_s_animation_sync_action_group is invalid size");

		struct s_c_weapon_class
		{
			string_id label;
			short overlay_group;
			short ik_set;
			c_typed_tag_block<s_c_weapon_type> weapon_type_block;
			c_typed_tag_block<s_s_animation_ik_point_v1> weapon_ik_block;
			c_typed_tag_block<s_s_animation_ranged_action> ranged_actions_block;
			c_typed_tag_block<s_s_animation_sync_action_group> sync_actions_groups_block;
		};
		static_assert(sizeof(s_c_weapon_class) == 56, "struct s_c_weapon_class is invalid size");

		struct s_c_animation_mode
		{
			string_id label;
			short overlay_group;
			short ik_set;
			c_flags<e_animationgraphnodeflags, long, k_animationgraphnodeflags_count> flags;
			c_typed_tag_block<s_c_weapon_class> weapon_class_block;
			c_typed_tag_block<s_s_animation_ik_point_v1> mode_ik_block;
		};
		static_assert(sizeof(s_c_animation_mode) == 36, "struct s_c_animation_mode is invalid size");

		struct s_c_vehicle_suspension
		{
			string_id label;
			s_c_animation_id animation;
			string_id function_name;
			// custom value
			string_id marker_name;
			// custom value
			string_id contact_marker_name;
			real mass_point_offset;
			real full_extension_ground_depth;
			real full_compression_ground_depth;

			/* Destroyed Suspension */

			string_id region_name;
			real destroyed_mass_point_offset;
			real destroyed_full_extension_ground_depth;
			real destroyed_full_compression_ground_depth;
		};
		static_assert(sizeof(s_c_vehicle_suspension) == 48, "struct s_c_vehicle_suspension is invalid size");

		struct s_s_function_overlay
		{
			string_id label;
			s_c_animation_id animation;
			c_enum<e_c_function_overlay_animation_mode, short> function_controls;
			char generated_padb2fd[2]; // padding
			string_id function;
		};
		static_assert(sizeof(s_s_function_overlay) == 16, "struct s_s_function_overlay is invalid size");

		struct s_animationgraphcontents
		{
			// custom links_and_settings
			s_animationgraphexternalreferences links;
			s_animationgraphsettings settings;
			// custom value
			// custom skeleton_and_ik

			/* Warning */

			// custom local_data
			c_typed_tag_reference<ANIMATION_SKELETON_TAG> skeleton_link;
			s_animationgraphskeleton skeleton;
			s_animationgraphik ik;
			// custom value
			// custom value
			// custom animation_pool
			c_typed_tag_block<s_c_model_animation> animations_block;
			s_animationgraphpcadata pca_data;
			c_typed_tag_block<s_compositetag> composites_block;
			c_typed_tag_block<s_animationtokenentry> action_tokens_block;
			c_typed_tag_block<s_overlaytokenentry> overlay_tokens_block;
			c_typed_tag_block<s_poseblendtokenentry> poseblend_tokens_block;
			// custom value
			// custom blending_and_overlays
			c_typed_tag_block<s_s_animation_function> functions_block;
			c_typed_tag_block<s_animationblendscreendefinition> blend_screens_block;
			c_typed_tag_block<s_s_new_animation_function_overlay> function_overlays_block;
			c_typed_tag_block<s_s_overlay_group> overlay_groups_block;
			// custom value
			// custom interpolators
			c_typed_tag_block<s_animationinterpolator> interpolators_block;
			c_typed_tag_block<s_animationinterpolationset> interpolation_sets_block;
			// custom value
			// custom animation_lookup_tables
			c_typed_tag_block<s_s_model_animation_variant> model_animation_variants_block;
			c_typed_tag_block<s_s_function_driven_variant> object_function_variants_block;
			c_typed_tag_block<s_c_animation_mode> modes_block;
			// custom value
			// custom special_case_animations
			c_typed_tag_block<s_c_vehicle_suspension> vehicle_suspension_block;
			c_typed_tag_block<s_s_function_overlay> constant_overlays_block;
			// custom value
		};
		static_assert(sizeof(s_animationgraphcontents) == 452, "struct s_animationgraphcontents is invalid size");

		struct s_s_weapon_class_listing
		{
			string_id weapon_name;
			string_id weapon_class;
		};
		static_assert(sizeof(s_s_weapon_class_listing) == 8, "struct s_s_weapon_class_listing is invalid size");

		struct s_s_model_animation_runtime_data
		{
			c_typed_tag_block<s_s_weapon_class_listing> weapon_list_block;
			s_nodeflagstoragearray left_arm_bit_vector[32];
			s_nodeflagstoragearray right_arm_bit_vector[32];
		};
		static_assert(sizeof(s_s_model_animation_runtime_data) == 268, "struct s_s_model_animation_runtime_data is invalid size");

		struct s_s_additional_node_data
		{
			string_id node_name;
			real_quaternion default_rotation;
			real_point3d default_translation;
			real default_scale;
			real_point3d min_bounds;
			real_point3d max_bounds;
		};
		static_assert(sizeof(s_s_additional_node_data) == 60, "struct s_s_additional_node_data is invalid size");

		struct s_c_model_animation_tag_refrence_counted_resource
		{
			long reference_count;
			s_tag_resource tag_resource;
		};
		static_assert(sizeof(s_c_model_animation_tag_refrence_counted_resource) == 12, "struct s_c_model_animation_tag_refrence_counted_resource is invalid size");

		struct s_c_quantized_quaternion_8byte_revised
		{
			short i;
			short j;
			short k;
			short w;
		};
		static_assert(sizeof(s_c_quantized_quaternion_8byte_revised) == 8, "struct s_c_quantized_quaternion_8byte_revised is invalid size");

		struct s_sharedstaticdatacodectranslation
		{
			real x;
			real y;
			real z;
		};
		static_assert(sizeof(s_sharedstaticdatacodectranslation) == 12, "struct s_sharedstaticdatacodectranslation is invalid size");

		struct s_sharedstaticdatacodecscale
		{
			real scale;
		};
		static_assert(sizeof(s_sharedstaticdatacodecscale) == 4, "struct s_sharedstaticdatacodecscale is invalid size");

		struct s_s_shared_static_data_codec_graph_data
		{

			/* Shared Static Codec */

			c_typed_tag_block<s_c_quantized_quaternion_8byte_revised> rotations_block;
			c_typed_tag_block<s_sharedstaticdatacodectranslation> translations_block;
			c_typed_tag_block<s_sharedstaticdatacodecscale> scale_block;
		};
		static_assert(sizeof(s_s_shared_static_data_codec_graph_data) == 36, "struct s_s_shared_static_data_codec_graph_data is invalid size");

		struct s_s_animation_codec_data
		{

			/* CODEC-SPECIFIC DATA */

			s_s_shared_static_data_codec_graph_data shared_static_codec;
		};
		static_assert(sizeof(s_s_animation_codec_data) == 36, "struct s_s_animation_codec_data is invalid size");

		struct s_c_model_animation_graph
		{
			s_anytag_struct_definition anytag;
			s_animationgraphcontents content;
			// custom runtime_data
			s_s_model_animation_runtime_data run_time_data;
			c_typed_tag_block<s_s_additional_node_data> additional_node_data_block;
			c_typed_tag_block<s_c_model_animation_tag_refrence_counted_resource> tag_resource_groups_block;
			s_s_animation_codec_data codec_data;
			// custom value
		};
		static_assert(sizeof(s_c_model_animation_graph) == 796, "struct s_c_model_animation_graph is invalid size");

		struct s_damageouterconeangle
		{
			angle dmg_outer_cone_angle;
		};
		static_assert(sizeof(s_damageouterconeangle) == 4, "struct s_damageouterconeangle is invalid size");

		struct s_i343damagevampirismparameters
		{
			c_flags<e_i343damagevampirismflags, char, k_i343damagevampirismflags_count> flags;
			char generated_pad26a2[3]; // padding
			real percent_transferred;
			real max_overshield;
			c_typed_tag_reference<GENERICMODIFIERDEFINITIONTAG_TAG> overshield_malleable_properties;
		};
		static_assert(sizeof(s_i343damagevampirismparameters) == 28, "struct s_i343damagevampirismparameters is invalid size");

		struct s_customdamageresponselabelparam
		{
			string_id custom_label;
		};
		static_assert(sizeof(s_customdamageresponselabelparam) == 4, "struct s_customdamageresponselabelparam is invalid size");

		struct s_s_damage_effect_sound
		{
			c_typed_tag_reference<SOUND_TAG> sound;
			c_flags<e_damageeffectsoundtypes, short, k_damageeffectsoundtypes_count> damage_types;
			c_flags<e_objecttypes, short, k_objecttypes_count> object_types;
		};
		static_assert(sizeof(s_s_damage_effect_sound) == 20, "struct s_s_damage_effect_sound is invalid size");

		struct s_s_damage_effect_definition
		{
			s_anytag_struct_definition anytag;
			real_bounds radius;
			real_fraction cutoff_scale;
			c_flags<e_damageeffectdefinitionflags, long, k_damageeffectdefinitionflags_count> effect_flags;

			/* damage */


			/* Damage Type */

			s_i343damagedamagetypedefinition damagetype;
			c_enum<e_damagesideeffects, short> side_effect;
			c_enum<e_damagecategories, short> category;
			c_enum<e_damagedeathvocalizations, long> death_vocalization;
			c_flags<e_damagedefinitionflags, long, k_damagedefinitionflags_count> flags;
			c_flags<e_damagedefinitionsecondaryflags, long, k_damagedefinitionsecondaryflags_count> secondary_flags;

			/* NOTE */

			c_typed_tag_reference<GENERICMODIFIERDEFINITIONTAG_TAG> modifiers;
			real headshot_damage_multiplier;
			real headshot_shielded_damage_multiplier;
			real aoe_core_radius;
			real aoe_force_offset_z;
			real damage_lower_bound;
			real_bounds damage_upper_bound;
			s_scalarfunctionname damage_falloff_function;
			angle dmg_inner_cone_angle;
			s_damageouterconeangle blah;
			real active_camouflage_damage;
			real_bounds active_camouflage_damage_range;
			real_fraction movement_stun;
			real_fraction maximum_movement_stun;
			real_fraction turn_stun;
			real_fraction maximum_turn_stun;
			real stun_time;
			long damage_stun;
			real instantaneous_acceleration;
			real alt_instantaneous_acceleration;
			real prop_instantaneous_acceleration;
			real acceleration_cap;

			/* AI Stun Parameters */

			real ai_stun_time;
			real ai_stun_magnitude;

			/* Impalement parameters */

			real impale_initial_velocity;
			real impale_drag_acceleration;
			real impale_gravity_acceleration;
			real impale_minimum_velocity;
			angle impale_maximum_angle;
			real impale_effect_duration;
			real_fraction soft_ping_pain_screen_scale;
			string_id general_damage;
			string_id specific_damage;

			/* vampirism */

			s_i343damagevampirismparameters vampirism$2;
			c_typed_tag_block<s_customdamageresponselabelparam> custom_response_labels_block;
			real ai_stun_radius;
			real_bounds ai_stun_bounds;
			c_enum<e_i343aisoundvolume, short> ainoisevolume;
			char generated_pad97e3[2]; // padding
			real shake_radius;
			real emp_radius;
			real emp_duration_scalar;
			real aoe_spike_radius;
			real aoe_spike_damage_bump;
			real shield_render_effects_scale;
			real equipment_hack_time;

			/* damage response */

			c_typed_tag_reference<DAMAGE_RESPONSE_DEFINITION_TAG> damage_response$2;
			c_typed_tag_block<s_s_damage_effect_sound> damage_sounds_block;
			real damage_dealt_sfx_cooldown_time;
			real damage_received_sfx_cooldown_time;
			// custom player_damage_additive_sounds
			c_typed_tag_reference<SOUND_TAG> deprecated_player_dealt_damage_additive_sound;
			c_typed_tag_reference<SOUND_TAG> deprecated_player_dealt_aoe_damage_additive_sound;
			c_typed_tag_reference<SOUND_TAG> deprecated_player_dealt_friendly_fire_additive_sound;
			s_i343damageplayeradditivesounddealdamagedefinition player_additive_sound_deal_damage;
			c_typed_tag_reference<SOUND_TAG> player_received_damage_additive_sound_default;
			c_typed_tag_reference<SOUND_TAG> player_received_damage_additive_sound_third_person;
			c_typed_tag_reference<SOUND_TAG> player_received_damage_additive_sound_in_vehicle;
			c_typed_tag_reference<SOUND_TAG> player_received_aoe_damage_additive_sound_default;
			c_typed_tag_reference<SOUND_TAG> player_received_aoe_damage_additive_sound_third_person;
			c_typed_tag_reference<SOUND_TAG> player_received_aoe_damage_additive_sound_in_vehicle;
			// custom value
			c_typed_tag_reference<DAMAGE_EFFECT_SOUNDS_TAG> damage_effect_sounds;
			real visual_damage_radius;
			real visual_damage_intensity;
		};
		static_assert(sizeof(s_s_damage_effect_definition) == 620, "struct s_s_damage_effect_definition is invalid size");

		struct s_kitcollectionentry
		{
			c_typed_tag_reference<KIT_TAG> kit;
		};
		static_assert(sizeof(s_kitcollectionentry) == 16, "struct s_kitcollectionentry is invalid size");

		struct s_kitcollectiontag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_kitcollectionentry> kits_block;
			char generated_pad5f56[4]; // padding
		};
		static_assert(sizeof(s_kitcollectiontag) == 32, "struct s_kitcollectiontag is invalid size");

		struct s_i343equipmentknockbackresponseoverride
		{
			c_typed_tag_reference<OBJECT_TAG> for_object;
			real impulse_scalar;
		};
		static_assert(sizeof(s_i343equipmentknockbackresponseoverride) == 20, "struct s_i343equipmentknockbackresponseoverride is invalid size");

		struct s_i343equipmentknockbackresponseoverrideset
		{
			s_anytag_struct_definition anytag;

			/* knockback response overrides */

			c_typed_tag_block<s_i343equipmentknockbackresponseoverride> overrides_block;
			char generated_pad9a3d[4]; // padding
		};
		static_assert(sizeof(s_i343equipmentknockbackresponseoverrideset) == 32, "struct s_i343equipmentknockbackresponseoverrideset is invalid size");

		struct s_animsetref
		{
			c_typed_tag_reference<ANIMSET_TAG> anim_set_reference;
		};
		static_assert(sizeof(s_animsetref) == 16, "struct s_animsetref is invalid size");

		struct s_legacyanimsetanimationentry
		{
			string_id name;
			short animset_index_in_legacyanimset_tag;
			short animset_parent_depth;
			short animsetentry_index;
			short composite_index;
			short anim_pool_subgraph_index;
			short anim_pool_animation_index;
		};
		static_assert(sizeof(s_legacyanimsetanimationentry) == 16, "struct s_legacyanimsetanimationentry is invalid size");

		struct s_jointnameblock
		{
			string_id joint_name;
		};
		static_assert(sizeof(s_jointnameblock) == 4, "struct s_jointnameblock is invalid size");

		struct s_animationjointflags
		{
			string_id legacy_animation_name;
			c_typed_tag_block<s_jointnameblock> fik_joint_names_block;
			c_typed_tag_block<s_jointnameblock> object_space_correction_joint_name_block;
			c_typed_tag_block<s_jointnameblock> replacement_offset_correction_joint_name_block;
		};
		static_assert(sizeof(s_animationjointflags) == 40, "struct s_animationjointflags is invalid size");

		struct s_legacyanimsetrenameentry
		{
			string_id alias;
			string_id source;
			c_flags<e_renameandcopyentryflags, char, k_renameandcopyentryflags_count> flags;
			char generated_pade78a[3]; // padding
		};
		static_assert(sizeof(s_legacyanimsetrenameentry) == 12, "struct s_legacyanimsetrenameentry is invalid size");

		struct s_legacyanimsetcopyentry
		{
			string_id destination;
			string_id source;
			c_flags<e_renameandcopyentryflags, char, k_renameandcopyentryflags_count> flags;
			char generated_pad20b9[3]; // padding
		};
		static_assert(sizeof(s_legacyanimsetcopyentry) == 12, "struct s_legacyanimsetcopyentry is invalid size");

		struct s_legacyanimsetfunction
		{
			string_id name;
			s_scalarfunctionname function;
		};
		static_assert(sizeof(s_legacyanimsetfunction) == 24, "struct s_legacyanimsetfunction is invalid size");

		struct s_legacyanimsetblendscreen
		{
			string_id name;
			c_flags<e_c_animation_blend_screen_flags, long, k_c_animation_blend_screen_flags_count> flags;
			real weight;
			real interpolation_rate;
			c_enum<e_c_animation_blend_screen_variable_source, short> yaw_source;
			c_enum<e_c_animation_blend_screen_variable_source, short> pitch_source;
			string_id yaw_source_function;
			string_id pitch_source_function;
			c_enum<e_c_animation_blend_screen_weight_source, short> weight_source;
			c_enum<e_c_animation_blend_screen_weight_source, short> secondary_weight_source;
			string_id weight_source_object_function;
			string_id secondary_weight_object_function;
			short weight_function;
			char generated_padffad[2]; // padding
			string_id animation;
		};
		static_assert(sizeof(s_legacyanimsetblendscreen) == 48, "struct s_legacyanimsetblendscreen is invalid size");

		struct s_legacyanimsetfunctionoverlay
		{
			string_id name;
			c_flags<e_c_animation_function_overlay_flags, long, k_c_animation_function_overlay_flags_count> flags;
			string_id frame_ratio_function;
			string_id playback_speed_function;
			string_id blend_weight_function;
			string_id unlock_function;
			real_bounds unlock_range;
			string_id animation;
			short start_lod_taper;
			short end_lod_taper;
		};
		static_assert(sizeof(s_legacyanimsetfunctionoverlay) == 40, "struct s_legacyanimsetfunctionoverlay is invalid size");

		struct s_blendscreenreference
		{
			short blend_screen;
			c_flags<e_blendscreenreferenceblockflags, short, k_blendscreenreferenceblockflags_count> flags;
			string_id node_mask;
		};
		static_assert(sizeof(s_blendscreenreference) == 8, "struct s_blendscreenreference is invalid size");

		struct s_functionoverlayreference
		{
			short function_overlay;
			c_flags<e_functionoverlayreferenceblockflags, short, k_functionoverlayreferenceblockflags_count> flags;
		};
		static_assert(sizeof(s_functionoverlayreference) == 4, "struct s_functionoverlayreference is invalid size");

		struct s_legacyanimsetoverlaygroup
		{
			string_id name;
			c_typed_tag_block<s_blendscreenreference> blend_screens_block;
			c_typed_tag_block<s_functionoverlayreference> function_overlays_block;
		};
		static_assert(sizeof(s_legacyanimsetoverlaygroup) == 28, "struct s_legacyanimsetoverlaygroup is invalid size");

		struct s_legacyanimsetinterpolator
		{
			string_id name;
			string_id joint_mask;
			s_scalarfunctionname function;
		};
		static_assert(sizeof(s_legacyanimsetinterpolator) == 28, "struct s_legacyanimsetinterpolator is invalid size");

		struct s_interpolatorlistentry
		{
			short interpolator;
		};
		static_assert(sizeof(s_interpolatorlistentry) == 2, "struct s_interpolatorlistentry is invalid size");

		struct s_legacyanimsetinterpolationset
		{
			string_id name;
			real seconds;
			c_typed_tag_block<s_interpolatorlistentry> interpolators_block;
			s_scalarfunctionname function;
		};
		static_assert(sizeof(s_legacyanimsetinterpolationset) == 40, "struct s_legacyanimsetinterpolationset is invalid size");

		struct s_legacyanimsetmodeorstancealias
		{
			string_id mode_or_stance;
			string_id alias;
		};
		static_assert(sizeof(s_legacyanimsetmodeorstancealias) == 8, "struct s_legacyanimsetmodeorstancealias is invalid size");

		struct s_legacyanimsetmodelanimationvariant
		{
			string_id name;
			c_typed_tag_block<s_legacyanimsetmodeorstancealias> mode_or_stance_aliases_block;
		};
		static_assert(sizeof(s_legacyanimsetmodelanimationvariant) == 16, "struct s_legacyanimsetmodelanimationvariant is invalid size");

		struct s_legacyanimsetobjectfunctionvariant
		{
			string_id name;
			c_typed_tag_block<s_legacyanimsetmodeorstancealias> mode_or_stance_aliases_block;
		};
		static_assert(sizeof(s_legacyanimsetobjectfunctionvariant) == 16, "struct s_legacyanimsetobjectfunctionvariant is invalid size");

		struct s_modetreeanimentry
		{
			string_id name;
			short overlay_group;
			char generated_padede6[2]; // padding
			string_id ik_set;
			short animation;
			char generated_pad3a9b[2]; // padding
			string_id animation_name;
		};
		static_assert(sizeof(s_modetreeanimentry) == 20, "struct s_modetreeanimentry is invalid size");

		struct s_damageregion
		{
			short animation;
			char generated_padfe89[2]; // padding
			string_id animation_name;
		};
		static_assert(sizeof(s_damageregion) == 8, "struct s_damageregion is invalid size");

		struct s_damagedirection
		{
			c_typed_tag_block<s_damageregion> regions_block;
		};
		static_assert(sizeof(s_damagedirection) == 12, "struct s_damagedirection is invalid size");

		struct s_modetreedeathanddamage
		{
			string_id name;
			c_typed_tag_block<s_damagedirection> directions_block;
		};
		static_assert(sizeof(s_modetreedeathanddamage) == 16, "struct s_modetreedeathanddamage is invalid size");

		struct s_transitiondestination
		{
			string_id mode_name;
			string_id state_name;
			short transition_lerp;
			short animation;
			string_id animation_name;
			string_id timing_function;
			short lerp_in_function;
			short lerp_out_function;
		};
		static_assert(sizeof(s_transitiondestination) == 24, "struct s_transitiondestination is invalid size");

		struct s_modetreetransition
		{
			string_id state_name;
			c_typed_tag_block<s_transitiondestination> destinations_block;
			c_flags<e_modetreetransitionflags, char, k_modetreetransitionflags_count> flags;
			char generated_pad9776[3]; // padding
		};
		static_assert(sizeof(s_modetreetransition) == 20, "struct s_modetreetransition is invalid size");

		struct s_modetreeset
		{
			string_id set_name;
			short overlay_group;
			char generated_pad4fdb[2]; // padding
			string_id ik_set;
			c_typed_tag_block<s_modetreeanimentry> actions_block;
			c_typed_tag_block<s_modetreeanimentry> overlays_block;
			c_typed_tag_block<s_modetreedeathanddamage> death_and_damage_block;
			c_typed_tag_block<s_modetreetransition> transitions_block;
		};
		static_assert(sizeof(s_modetreeset) == 60, "struct s_modetreeset is invalid size");

		struct s_modetreeweapontype
		{
			string_id weapon_type_name;
			short overlay_group;
			char generated_pad095f[2]; // padding
			string_id ik_set;
			c_typed_tag_block<s_modetreeset> sets_block;
		};
		static_assert(sizeof(s_modetreeweapontype) == 24, "struct s_modetreeweapontype is invalid size");

		struct s_modetreeik
		{
			string_id marker;
			string_id attach_to_marker;
			string_id weight_source_object_function;
			string_id priority_source_object_function;
		};
		static_assert(sizeof(s_modetreeik) == 16, "struct s_modetreeik is invalid size");

		struct s_syncactionsametypeparticipant
		{
			c_flags<e_animationsyncactionflags, short, k_animationsyncactionflags_count> flags;
			char generated_pad84f0[2]; // padding
			string_id animation;
			real_vector3d start_offset;
			real_vector3d start_facing;
			real_vector3d end_offset;
			real time_until_hurt;
			real_vector3d apex_offset;
		};
		static_assert(sizeof(s_syncactionsametypeparticipant) == 60, "struct s_syncactionsametypeparticipant is invalid size");

		struct s_syncactionotherparticipant
		{
			c_flags<e_animationsyncactionothertypeflags, short, k_animationsyncactionothertypeflags_count> flags;
			char generated_padc2f4[2]; // padding
			s_tag_reference object_type;
		};
		static_assert(sizeof(s_syncactionotherparticipant) == 20, "struct s_syncactionotherparticipant is invalid size");

		struct s_syncaction
		{
			string_id name;
			c_enum<e_animationsyncactionstyletype, short> sync_action_type;
			char generated_pad9781[2]; // padding
			c_typed_tag_block<s_syncactionsametypeparticipant> same_type_participants_block;
			c_typed_tag_block<s_syncactionotherparticipant> other_participant_block;
		};
		static_assert(sizeof(s_syncaction) == 32, "struct s_syncaction is invalid size");

		struct s_syncactionsgroup
		{
			string_id name;
			c_typed_tag_block<s_syncaction> sync_actions_block;
		};
		static_assert(sizeof(s_syncactionsgroup) == 16, "struct s_syncactionsgroup is invalid size");

		struct s_modetreeweaponclass
		{
			string_id weapon_class_name;
			short overlay_group;
			char generated_padf75f[2]; // padding
			string_id ik_set;
			c_typed_tag_block<s_modetreeweapontype> weapon_types_block;
			c_typed_tag_block<s_modetreeik> weapon_ik_block;
			c_typed_tag_block<s_syncactionsgroup> sync_actions_groups_block;
		};
		static_assert(sizeof(s_modetreeweaponclass) == 48, "struct s_modetreeweaponclass is invalid size");

		struct s_modetreemode
		{
			string_id anim_mode_name;
			short overlay_group;
			char generated_padb8e6[2]; // padding
			string_id ik_set;
			c_flags<e_animationgraphnodeflags, long, k_animationgraphnodeflags_count> flags;
			c_typed_tag_block<s_modetreeweaponclass> weapon_classes_block;
			c_typed_tag_block<s_modetreeik> mode_ik_block;
		};
		static_assert(sizeof(s_modetreemode) == 40, "struct s_modetreemode is invalid size");

		struct s_legacyanimsetvehiclesuspension
		{
			string_id label;
			string_id animation;
			string_id function_name;
			string_id marker_name;
			string_id contact_marker_name;
			real mass_point_offset;
			real extension_distance;
			real compression_distance;
			string_id region_name;
			real destroyed_mass_point_offset;
			real destroyed_extension_distance;
			real destroyed_compression_distance;
		};
		static_assert(sizeof(s_legacyanimsetvehiclesuspension) == 48, "struct s_legacyanimsetvehiclesuspension is invalid size");

		struct s_legacyanimsetconstantoverlay
		{
			string_id label;
			string_id animation;
			c_enum<e_c_function_overlay_animation_mode, short> function_controls;
			char generated_pade41c[2]; // padding
			string_id function;
		};
		static_assert(sizeof(s_legacyanimsetconstantoverlay) == 16, "struct s_legacyanimsetconstantoverlay is invalid size");

		struct s_legacyanimsettag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_animsetref> anim_sets_block;
			c_typed_tag_block<s_legacyanimsetanimationentry> animations_block;
			short maximum_inheritance_depth;
			char generated_pada9d8[2]; // padding
			c_typed_tag_block<s_animationjointflags> per_animation_joint_flags_block;
			c_typed_tag_block<s_legacyanimsetrenameentry> renames_block;
			c_typed_tag_block<s_legacyanimsetcopyentry> copies_block;
			// custom blending_and_overlays
			c_typed_tag_block<s_legacyanimsetfunction> functions_block;
			c_typed_tag_block<s_legacyanimsetblendscreen> blend_screens_block;
			c_typed_tag_block<s_legacyanimsetfunctionoverlay> function_overlays_block;
			c_typed_tag_block<s_legacyanimsetoverlaygroup> overlay_groups_block;
			// custom blending_and_overlays
			// custom interpolators
			c_typed_tag_block<s_legacyanimsetinterpolator> interpolators_block;
			c_typed_tag_block<s_legacyanimsetinterpolationset> interpolation_sets_block;
			// custom interpolators
			// custom animation_lookup_table
			c_typed_tag_block<s_legacyanimsetmodelanimationvariant> model_animation_variants_block;
			c_typed_tag_block<s_legacyanimsetobjectfunctionvariant> object_function_variants_block;
			c_typed_tag_block<s_modetreemode> modes_block;
			// custom animation_lookup_table
			// custom special_case_animations
			c_typed_tag_block<s_legacyanimsetvehiclesuspension> vehicle_suspensions_block;
			c_typed_tag_block<s_legacyanimsetconstantoverlay> constant_overlays_block;
			// custom special_case_animations
			char generated_padc3b9[4]; // padding
		};
		static_assert(sizeof(s_legacyanimsettag) == 216, "struct s_legacyanimsettag is invalid size");

		struct s_colorfunctionnamed
		{
			// custom function
			s_functiondefinition function;
		};
		static_assert(sizeof(s_colorfunctionnamed) == 20, "struct s_colorfunctionnamed is invalid size");

		struct s_lensflarereflection
		{
			// custom value
			string_id name;
			c_flags<e_lensflarereflectionflags, long, k_lensflarereflectionflags_count> flags;
			c_typed_tag_reference<BITMAP_TAG> bitmap_override;
			s_scalarfunctionname bitmap_frame_index;
			s_scalarfunctionname bitmap_animation_rate;
			angle falloff_angle;
			angle cutoff_angle;
			angle separate_x_falloff_angle;
			angle separate_x_cutoff_angle;
			angle separate_y_falloff_angle;
			angle separate_y_cutoff_angle;
			real near_fade_begin_distance;
			real near_fade_end_distance;
			real far_fade_begin_distance;
			real far_fade_end_distance;
			real rotation_offset;
			real axis_offset;
			real x_offset;
			real y_offset;
			real_bounds offset_bounds;
			s_scalarfunctionname radius_curve;
			s_scalarfunctionname scale_curve_x;
			s_scalarfunctionname scale_curve_y;
			s_scalarfunctionname brightness_curve;

			/* TINT COLOR */

			c_enum<e_i343effectscoloroverridemode, char> color_curve_override_mode;
			char generated_padebc7[3]; // padding
			s_colorfunctionnamed color_curve;
			real_fraction modulation_factor;
			real tint_power;
			// custom value
		};
		static_assert(sizeof(s_lensflarereflection) == 240, "struct s_lensflarereflection is invalid size");

		struct s_lensflarescalaranimation
		{
			s_scalarfunctionname function;
		};
		static_assert(sizeof(s_lensflarescalaranimation) == 20, "struct s_lensflarescalaranimation is invalid size");

		struct s_s_editing_function
		{
			string_id input_variable;
			string_id range_variable;
			c_enum<e_s_editing_functionlensflareoutputmod, short> output_modifier;
			char generated_padcaf7[2]; // padding
			string_id output_modifier_input;
			// custom lens_flare_color_editor
			s_functiondefinition lens_flare_color_mapping;
		};
		static_assert(sizeof(s_s_editing_function) == 36, "struct s_s_editing_function is invalid size");

		struct s_lensflarecoloranimation
		{
			s_s_editing_function color_animation;
		};
		static_assert(sizeof(s_lensflarecoloranimation) == 36, "struct s_lensflarecoloranimation is invalid size");

		struct s_s_lens_flare_definition
		{
			s_anytag_struct_definition anytag;

			/* LENS FLARE */

			angle falloff_angle;
			angle cutoff_angle;
			angle separate_x_falloff_angle;
			angle separate_x_cutoff_angle;
			angle separate_y_falloff_angle;
			angle separate_y_cutoff_angle;
			real exposure_amount;

			/* OCCLUSION */

			long occlusion_reflection_index;
			real occlusion_offset_distance;
			c_enum<e_lensflareocclusionoffset, short> occlusion_offset_direction;
			char generated_pad1f11[2]; // padding
			real occlusion_inner_radius_scale;
			real occlusion_min_pixels;
			real occlusion_max_pixels;
			real near_fade_begin_distance;
			real near_fade_end_distance;
			real far_fade_begin_distance;
			real far_fade_end_distance;
			c_typed_tag_reference<BITMAP_TAG> bitmap;
			c_flags<e_lensflareflags, short, k_lensflareflags_count> flags;
			short runtime_flags;
			c_enum<e_lensflarerotationfunction, short> rotation_function;
			char generated_pad0530[2]; // padding
			angle rotation_function_scale;

			/* EFFECT PARAMETERS */

			c_enum<e_reversetransitionfunction, short> falloff_function;
			char generated_padb87b[2]; // padding
			c_typed_tag_block<s_lensflarereflection> reflections_block;

			/* ANIMATION */

			c_flags<e_lensflareanimationflags, short, k_lensflareanimationflags_count> animation_flags;
			char generated_pad38f2[2]; // padding
			c_typed_tag_block<s_lensflarescalaranimation> time_brightness_block;
			c_typed_tag_block<s_lensflarescalaranimation> age_brightness_block;
			c_enum<e_i343effectscoloroverridemode, char> time_color_override_mode;
			char generated_padec3d[3]; // padding
			c_typed_tag_block<s_lensflarecoloranimation> time_color_block;
			c_enum<e_i343effectscoloroverridemode, char> age_color_override_mode;
			char generated_padd25c[3]; // padding
			c_typed_tag_block<s_lensflarecoloranimation> age_color_block;
			c_typed_tag_block<s_lensflarescalaranimation> time_rotation_block;
			c_typed_tag_block<s_lensflarescalaranimation> age_rotation_block;
		};
		static_assert(sizeof(s_s_lens_flare_definition) == 212, "struct s_s_lens_flare_definition is invalid size");

		struct s_s_static_loadout_tag_definition
		{
			string_id loadout_name;
			string_id initial_primary_weapon;
			string_id initial_primary_weapon_variant_name;
			string_id initial_secondary_weapon;
			string_id initial_secondary_weapon_variant_name;
			string_id initial_equipment;
		};
		static_assert(sizeof(s_s_static_loadout_tag_definition) == 24, "struct s_s_static_loadout_tag_definition is invalid size");

		struct s_s_loadout_globals_tag_definition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_s_static_loadout_tag_definition> default_custom_loadouts_block;
			char generated_pad2bd8[4]; // padding
		};
		static_assert(sizeof(s_s_loadout_globals_tag_definition) == 32, "struct s_s_loadout_globals_tag_definition is invalid size");

		struct s_animationlibraryaudio
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_animationsounds> sounds_block;
			c_typed_tag_block<s_animationdialogues> dialogues_block;
		};
		static_assert(sizeof(s_animationlibraryaudio) == 40, "struct s_animationlibraryaudio is invalid size");

		struct s_animationlibraryeffects
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_animationeffects> effects_block;
			char generated_pad7c9f[4]; // padding
		};
		static_assert(sizeof(s_animationlibraryeffects) == 32, "struct s_animationlibraryeffects is invalid size");

		struct s_lightconedefinition
		{
			s_anytag_struct_definition anytag;
			c_flags<e_lightconedefinitionlightconeflags, char, k_lightconedefinitionlightconeflags_count> flags;
			char generated_pad258a[3]; // padding
			// custom material
			// custom value
			s_material actual_material;
			// custom value
			real angle_fade_range;
			real angle_fade_cutoff;
			long long m_pipelinestates;
		};
		static_assert(sizeof(s_lightconedefinition) == 108, "struct s_lightconedefinition is invalid size");

		struct s_lightdefinition
		{

			/* Dynamic/Static Shared Light Parameters */

			string_id halolightnode;
			c_enum<e_e_light_type, long> type;
			rgb_color color;
			real source_energy;
			real baked_indirect_intensity_scalar;
			real dimmer;
			real far_attenuation;
			real near_begin;
			c_enum<e_lightpropertiesoverridesource, char> properties_override_source;
			char generated_pade39f[3]; // padding
			real override_source_intensity_multiplier;
			s_scalarlightfunction intensity_function;
			c_typed_tag_reference<LIGHTGROUP_TAG> light_group;
			s_scalarlightfunction dimmer_function;
			real near_attenuation;
			s_scalarlightfunction outer_attenuation_function;
			real far_begin;
			real base_position_modifier_for_fading;
			real camera_near_distance_fade_end;
			real camera_near_distance_fade_start;
			real camera_distance_fade_start;
			real camera_distance_fade_end;
			real fog_intensity;
			real particle_intensity;
			real minimum_roughness;

			/* Area Lights Parameters */

			real planar_light_width;
			real planar_light_height;
			real area_light_radius;
			real area_light_length;

			/* Shared Spot Parameters */

			real inner_cone_angle;
			real outer_cone_angle;
			s_scalarlightfunction outer_cone_angle_function;
			c_enum<e_e_light_projection_type, long> cone_projection_shape;

			/* Dynamic Only Parameters */

			c_enum<e_lightboolean, char> static_shadows;
			c_enum<e_lightboolean, char> dynamic_shadows;
			short static_shadow_resolution;
			short dynamic_shadow_resolution;
			short minimum_static_shadow_resolution;
			short minimum_dynamic_shadow_resolution;
			c_enum<e_lightboolean, char> enable_static_shadow_caching;
			c_enum<e_lightboolean, char> enable_dynamic_objects_shadow_caching;
			c_enum<e_lightboolean, char> composer_shadows;
			char generated_pad96ea[3]; // padding
			real shadow_resolution_distance_scaler;
			real camera_distance_static_shadow___gobo_fade_start;
			real camera_distance_static_shadow___gobo_fade_end;
			real camera_distance_do_shadow_fade_start;
			real camera_distance_do_shadow_fade_end;
			real inner_do_shadow_cone_angle_;
			real outer_do_shadow_cone_angle_;
			real do_shadow_far_attenuation_start_;
			real do_shadow_far_attenuation_end_;
			real static_object_shadow_lod_scaler;
			real dynamic_object_shadow_lod_scaler;
			real shadow_near_clip_plane;
			real shadow_far_clip_plane;
			c_enum<e_lightboolean, char> enable_light_obb;
			char generated_pad4a35[3]; // padding
			real_vector3d obb_center_offset;
			real_vector3d obb_scale_factor;
			real_vector3d obb_orientation_adjust;
			real shadow_bias_offset;
			real shadow_filter_width;
			real minimum_shadow_filter_width;
			c_enum<e_lightboolean, char> enable_pcss;
			char generated_pad6328[3]; // padding
			real pcss_light_size;
			real pcss_min_filter_size;
			real pcss_max_filter_size;
			c_enum<e_lightboolean, char> force_forward_lighting;
			c_enum<e_lightboolean, char> ignore_dynamic_objects;
			c_enum<e_lightboolean, char> cinema_objects_only;
			c_enum<e_lightboolean, char> cinema_only;
			c_enum<e_lightboolean, char> cinema_exclude;
			c_flags<e_lightdefinitionlightattenuationflags, char, k_lightdefinitionlightattenuationflags_count> attenuation_flags;
			c_enum<e_lightboolean, char> specular_contribution;
			c_enum<e_lightboolean, char> diffuse_contribution;
			short minimum_gobo_resolution;
			char generated_pad1673[2]; // padding

			/* Dynamic Gobo */

			c_typed_tag_reference<GOBO_SETTING_TAG> gobos;
			rgb_color target_color;
			real destroy_light_after;

			/* Color Change */

			s_colorlightfunction interpolation_function;

			/* Bungie Parameters */

			c_flags<e_lightdefinitionflags, long, k_lightdefinitionflags_count> flags;
			c_typed_tag_reference<LENS_FLARE_TAG> lens_flare;
			c_typed_tag_reference<ATTACHED_LIGHT_CONE_TAG> light_cone;
			long light_shadow_priority;
			char needs_update_state;
			char needs_update_bounding_sphere;
			char generated_padc9be[2]; // padding
			long tick_of_last_state_update;
			long tick_of_last_bounding_sphere_update;
		};
		static_assert(sizeof(s_lightdefinition) == 544, "struct s_lightdefinition is invalid size");

		struct s_dynamiclight
		{
			s_anytag_struct_definition anytag;
			s_lightdefinition midnight_light_parameters;
			char generated_pad8a13[4]; // padding
		};
		static_assert(sizeof(s_dynamiclight) == 564, "struct s_dynamiclight is invalid size");

		struct s_s_basic_spec_control_setting_bool
		{
			c_flags<e_s_basic_spec_control_setting_boolspeccontrolboolflags, short, k_s_basic_spec_control_setting_boolspeccontrolboolflags_count> flags;
		};
		static_assert(sizeof(s_s_basic_spec_control_setting_bool) == 2, "struct s_s_basic_spec_control_setting_bool is invalid size");

		struct s_lightgrouptag
		{
			s_anytag_struct_definition anytag;

			/* Fadeoff distance multiplier */

			s_s_throttle_spec_control_setting_float fadeoff_distance_multiplier$2;

			/* Near Fadeoff distance multiplier */

			s_s_throttle_spec_control_setting_float near_fadeoff_distance_multiplier$2;

			/* Static Object Shadow Fade */

			s_s_throttle_spec_control_setting_float static_object_shadow_fade$2;

			/* Dynamic Object Shadow Fade */

			s_s_throttle_spec_control_setting_float dynamic_object_shadow_fade$2;

			/* Cast Shadows */

			s_s_basic_spec_control_setting_bool cast_shadows$2;

			/* Dynamic Object Shadow Casting */

			s_s_basic_spec_control_setting_bool dynamic_object_shadow_casting$2;
			char generated_pad133b[4]; // padding
		};
		static_assert(sizeof(s_lightgrouptag) == 232, "struct s_lightgrouptag is invalid size");

		struct s_s_decorator_placement
		{
			real_point3d position;
			byte type_index;
			byte motion_scale;
			byte ground_tint;
			c_flags<e_s_decorator_placementdecoratorplacementflags, char, k_s_decorator_placementdecoratorplacementflags_count> flags;
			real_quaternion rotation;
			real scale;
			real_point3d tint_color;
			real_point3d original_point;
			real_point3d original_normal;
			long extra;
			word placement_surface_albedo;
			word placement_surface_normal;
		};
		static_assert(sizeof(s_s_decorator_placement) == 80, "struct s_s_decorator_placement is invalid size");

		struct s_s_decorator_scenario_set_placements
		{
			c_typed_tag_reference<DECORATOR_ASSET_TAG> decorator_asset;
			c_typed_tag_block<s_s_decorator_placement> decorator_placements_block;
			c_typed_tag_reference<SCENARIO_STRUCTURE_BSP_TAG> owning_layer_default_bsp;
		};
		static_assert(sizeof(s_s_decorator_scenario_set_placements) == 44, "struct s_s_decorator_scenario_set_placements is invalid size");

		struct s_s_scenario_new_decorator_definition
		{
			c_typed_tag_block<s_s_decorator_scenario_set_placements> sets_block;
		};
		static_assert(sizeof(s_s_scenario_new_decorator_definition) == 12, "struct s_s_scenario_new_decorator_definition is invalid size");

		struct s_editor_comment_definition
		{
			real_point3d position;
			c_enum<e_e_editor_comment_type, long> type;
			c_static_string<32> name;
			c_static_string<256> comment;
		};
		static_assert(sizeof(s_editor_comment_definition) == 304, "struct s_editor_comment_definition is invalid size");

		struct s_scenarioeditorannotation
		{
			string_id name;
			real_point3d position;
			c_static_string<256> info;
			s_tag_data additionalinfo;
			c_static_string<32> optionalannotationid;
			c_enum<e_editorannotationfiltergroups, short> filtergroup;
			char generated_padc55c[2]; // padding
			c_typed_tag_block<s_editormetadata> editormetadata_block;
		};
		static_assert(sizeof(s_scenarioeditorannotation) == 340, "struct s_scenarioeditorannotation is invalid size");

		struct s_scenario_object_name
		{
			string_id name;
			short object_type;
			short scenario_datum_index;
			long runtimeobjectindex;
		};
		static_assert(sizeof(s_scenario_object_name) == 12, "struct s_scenario_object_name is invalid size");

		struct s_scenariobspreference
		{
			c_typed_tag_reference<SCENARIO_STRUCTURE_BSP_TAG> structure_bsp;
		};
		static_assert(sizeof(s_scenariobspreference) == 16, "struct s_scenariobspreference is invalid size");

		struct s_compressedbspreferenceflags
		{
			c_typed_tag_block<s_scenariobspreference> references_block;
			s_tag_data flags;
			long bsp_index;
		};
		static_assert(sizeof(s_compressedbspreferenceflags) == 36, "struct s_compressedbspreferenceflags is invalid size");

		struct s_c_object_identifier
		{
			long unique_id;
			short origin_bsp_index;
			c_enum<e_scenarioobjecttypeenum, char> type;
			c_enum<e_e_object_source, char> source;
		};
		static_assert(sizeof(s_c_object_identifier) == 8, "struct s_c_object_identifier is invalid size");

		struct s_s_scenario_object_parent
		{
			long parent_object;
			string_id parent_name;
			string_id parent_marker;
			// custom value
			string_id connection_marker;
		};
		static_assert(sizeof(s_s_scenario_object_parent) == 16, "struct s_s_scenario_object_parent is invalid size");

		struct s_i343physicsmancannonballisticarcdata
		{
			real_point3d man_cannon_end_point;
			real man_cannon_apex_height;
			long man_cannon_phantom_index;
		};
		static_assert(sizeof(s_i343physicsmancannonballisticarcdata) == 20, "struct s_i343physicsmancannonballisticarcdata is invalid size");

		struct s_i343spartantrackingobjectdefinition
		{

			/* Map these settings to a ping type */

			c_flags<e_i343spartantrackingobjectdefinitionflags, char, k_i343spartantrackingobjectdefinitionflags_count> flags;
			c_enum<e_i343spartantrackingepingtype, char> ping_type;
			c_enum<e_i343spartantrackingteamvisibility, char> team_visibility;
			// custom misc
			c_enum<e_i343spartantrackingepriority, char> priority;
			// custom value
			string_id ping_group;
			// custom nav_point
			string_id nav_point_screen;
			string_id nav_point_label;
			real nav_point_vertical_offset;
			// custom value

			/* Range Override */

			real range;
			// custom effects
			c_typed_tag_reference<EFFECT_TAG> ping_hit_instigator_effect;
			c_typed_tag_reference<EFFECT_TAG> ping_hit_effect;
			c_typed_tag_reference<OUTLINETYPEDEFINITION_TAG> outline_override;
			// custom value
		};
		static_assert(sizeof(s_i343spartantrackingobjectdefinition) == 72, "struct s_i343spartantrackingobjectdefinition is invalid size");

		struct s_i343objectsassociation
		{
			c_flags<e_i343objectsassociationflags, short, k_i343objectsassociationflags_count> association_types;
			char generated_padee80[2]; // padding
			long target_index;
			string_id target_object_name;
			string_id target_marker_name;
			// custom value
			string_id source_marker_name;
		};
		static_assert(sizeof(s_i343objectsassociation) == 20, "struct s_i343objectsassociation is invalid size");

		struct s_s_scenario_object_datum
		{
			// custom value
			c_flags<e_c_scenario_object_placement_flags, long, k_c_scenario_object_placement_flags_count> placement_flags;
			real_point3d position;
			real_euler_angles3d rotation;
			real scale;
			real gravity_override;
			c_flags<e_c_scenario_object_gravity_flags, char, k_c_scenario_object_gravity_flags_count> gravity_flags;
			c_enum<e_c_object_bsp_placement_policy, char> bsp_policy;
			c_flags<e_scenarioobjectscriptflags, char, k_scenarioobjectscriptflags_count> script_flags;
			char generated_pad1c32[1]; // padding
			s_s_property_collection scriptable_properties;
			s_compressedbspreferenceflags bsp_flags;
			c_flags<e_transformflags, short, k_transformflags_count> transform_flags;
			c_enum<e_navmeshcuttingoverride, char> nav_mesh_cutting;
			c_flags<e_c_scenario_object_navmesh_flags, char, k_c_scenario_object_navmesh_flags_count> nav_mesh_flags;
			long editor_folder;
			s_c_object_identifier object_id;
			char runtimeobjecthandle[4]; // padding
			string_id module_id;
			s_s_scenario_object_parent parent_id;
			string_id in_game_maps_material_id;
			real directional_acceleration_mult_;
			c_typed_tag_reference<CUSTOM_OBJECT_LIGHTING_TAG> custom_object_lighting_reference;
			c_typed_tag_block<s_i343physicsmancannonballisticarcdata> man_cannon_ballistic_arc_data_block;
			c_typed_tag_block<s_i343spartantrackingobjectdefinition> spartan_tracking_block;
			c_flags<e_c_scenario_object_layer_flags, char, k_c_scenario_object_layer_flags_count> layer_flags;
			char generated_pad68e7[3]; // padding
			c_typed_tag_block<s_i343objectsassociation> associates_block;
		};
		static_assert(sizeof(s_s_scenario_object_datum) == 252, "struct s_s_scenario_object_datum is invalid size");

		struct s_s_scenario_object_permutation
		{
			string_id variant_name;
			c_flags<e_c_object_change_color_flags, char, k_c_object_change_color_flags_count> active_change_colors;
			char generated_paddcc3[3]; // padding
			string_id style_id;
			pixel32 primary_color;
			pixel32 secondary_color;
			pixel32 tertiary_color;
			pixel32 quaternary_color;
		};
		static_assert(sizeof(s_s_scenario_object_permutation) == 28, "struct s_s_scenario_object_permutation is invalid size");

		struct s_s_scenario_scenery_datum
		{
			// custom value
			c_enum<e_objectpathfindingpolicy, short> pathfinding_policy;
			short havok_mopp_index;
			short ai_spawning_squad;
		};
		static_assert(sizeof(s_s_scenario_scenery_datum) == 6, "struct s_s_scenario_scenery_datum is invalid size");

		struct s_splinenode
		{
			real_point3d position;
			real_euler_angles3d rotation;
			real scale;
		};
		static_assert(sizeof(s_splinenode) == 28, "struct s_splinenode is invalid size");

		struct s_spawnpointmultiplayerproperties
		{
			c_flags<e_spawnpointflags, char, k_spawnpointflags_count> spawn_point_flags;
		};
		static_assert(sizeof(s_spawnpointmultiplayerproperties) == 1, "struct s_spawnpointmultiplayerproperties is invalid size");

		struct s_warzoneobjectivedefinitionmembership
		{
			short warzone_objective_definition;
			c_static_string<32> warzone_objective_label;
		};
		static_assert(sizeof(s_warzoneobjectivedefinitionmembership) == 34, "struct s_warzoneobjectivedefinitionmembership is invalid size");

		struct s_terminalredeemableobjectdefinition
		{
			c_typed_tag_reference<OBJECT_TAG> redeemable_object;
			long level_requirement;
		};
		static_assert(sizeof(s_terminalredeemableobjectdefinition) == 20, "struct s_terminalredeemableobjectdefinition is invalid size");

		struct s_s_scenario_multiplayer_object_properties
		{

			/* Multiplayer Data */

			string_id megalo_label;
			string_id megalo_label_2;
			string_id megalo_label_3;
			string_id megalo_label_4;
			c_enum<e_i343netprotocolbondenumhelper_i343netprotocolmapvariantplacementmode_enum, char> game_engine_symmetric_placement;
			c_enum<e_i343netprotocolgameoptionsmultiplayerteamdesignatorenum, char> owner_team;
			c_enum<e_i343netprotocolgameoptionsmultiplayersquadenum_fabersafe, char> owner_squad;
			char generated_pad2291[1]; // padding
			c_flags<e_c_multiplayer_object_placement_spawn_flags, short, k_c_multiplayer_object_placement_spawn_flags_count> spawn_flags;
			c_enum<e_i343netprotocolbondenumhelper_i343netprotocolphonetic_enum, char> teleporter_channel;
			c_flags<e_c_teleporter_passability, char, k_c_teleporter_passability_count> teleporter_passability;
			c_enum<e_i343netprotocolbondenumhelper_i343netprotocolphonetic_enum, char> trait_zone_channel;
			char generated_pad08b0[3]; // padding
			real trait_zone_seconds_to_apply;
			real phantomvelocitymultiplier;
			real phantomaccelerationmultiplier;
			real boundary_width_or_radius;
			real boundary_box_length;
			real boundary_positive_height;
			real boundary_negative_height;
			c_enum<e_i343netprotocolbondenumhelper_i343netprotocolboundarytype_enum, char> boundary_shape;
			char boundary_pad[1]; // padding
			char boundary_pad2[2]; // padding
			short initial_spawn_delay;
			short spawn_time;
			short abandonment_time;
			char generated_padbbfb[2]; // padding
			string_id location_name;
			c_typed_tag_block<s_splinenode> spline_block;
			c_typed_tag_block<s_spawnpointmultiplayerproperties> spawnpointproperties_block;
			real respawn_weight;
			s_warzoneobjectivedefinitionmembership warzone_objective_definition_membership;
			byte spawn_order;
			c_flags<e_multiplayerobjectpropertyflags, char, k_multiplayerobjectpropertyflags_count> multiplayer_property_flags;
			c_typed_tag_reference<OBJECT_TAG> weaponpad_object_to_spawn;
			c_typed_tag_reference<OBJECT_CONFIGURATION_TAG> weaponpad_object_to_spawn_configuration;
			real weaponpad_respawn_time;
			c_typed_tag_block<s_terminalredeemableobjectdefinition> terminal_redeemable_objects_block;
			c_flags<e_multiplayerpropertiesmapzoneflags, char, k_multiplayerpropertiesmapzoneflags_count> mapzones;
			c_flags<e_multiplayerpropertiesmapzoneconfigurationflags, char, k_multiplayerpropertiesmapzoneconfigurationflags_count> mapzoneconfigurations;
			char generated_pad3c72[2]; // padding
		};
		static_assert(sizeof(s_s_scenario_multiplayer_object_properties) == 188, "struct s_s_scenario_multiplayer_object_properties is invalid size");

		struct s_s_scenario_scenery
		{
			long name;
			string_id object_name;
			c_typed_tag_reference<SCENERY_TAG> asset;
			s_s_scenario_object_datum object_data;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			s_s_scenario_object_permutation permutation_data;
			s_s_scenario_scenery_datum scenery_data;
			char generated_pad2908[2]; // padding
			c_typed_tag_block<s_s_scenario_multiplayer_object_properties> multiplayer_data_block;
		};
		static_assert(sizeof(s_s_scenario_scenery) == 336, "struct s_s_scenario_scenery is invalid size");

		struct s_s_scenario_unit_datum
		{
			real body_vitality;
			c_flags<e_scenariounitflags, long, k_scenariounitflags_count> flags;
		};
		static_assert(sizeof(s_s_scenario_unit_datum) == 8, "struct s_s_scenario_unit_datum is invalid size");

		struct s_s_scenario_biped
		{
			long name;
			string_id object_name;
			c_typed_tag_reference<BIPED_TAG> asset;
			s_s_scenario_object_datum object_data;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			s_s_scenario_object_permutation permutation_data;
			s_s_scenario_unit_datum unit_data;
			c_typed_tag_block<s_s_scenario_multiplayer_object_properties> multiplayer_data_block;
		};
		static_assert(sizeof(s_s_scenario_biped) == 336, "struct s_s_scenario_biped is invalid size");

		struct s_s_scenario_vehicle_datum
		{
			c_enum<e_objectpathfindingpolicy, short> pathfinding_policy;
			char generated_pad3f53[2]; // padding
			c_typed_tag_reference<VEHICLECONFIGURATION_TAG> configuration;
		};
		static_assert(sizeof(s_s_scenario_vehicle_datum) == 20, "struct s_s_scenario_vehicle_datum is invalid size");

		struct s_s_scenario_vehicle
		{
			long name;
			string_id object_name;
			c_typed_tag_reference<VEHICLE_TAG> asset;
			s_s_scenario_object_datum object_data;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			s_s_scenario_object_permutation permutation_data;
			s_s_scenario_unit_datum unit_data;
			c_typed_tag_block<s_s_scenario_multiplayer_object_properties> multiplayer_data_block;
			s_s_scenario_vehicle_datum vehicle_data;
		};
		static_assert(sizeof(s_s_scenario_vehicle) == 356, "struct s_s_scenario_vehicle is invalid size");

		struct s_s_scenario_equipment_datum
		{
			c_flags<e_scenarioequipmentflags, long, k_scenarioequipmentflags_count> equipment_flags;
		};
		static_assert(sizeof(s_s_scenario_equipment_datum) == 4, "struct s_s_scenario_equipment_datum is invalid size");

		struct s_s_scenario_equipment
		{
			long name;
			string_id object_name;
			c_typed_tag_reference<EQUIPMENT_TAG> asset;
			s_s_scenario_object_datum object_data;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			s_s_scenario_equipment_datum equipment_data;
			c_typed_tag_block<s_s_scenario_multiplayer_object_properties> multiplayer_data_block;
		};
		static_assert(sizeof(s_s_scenario_equipment) == 304, "struct s_s_scenario_equipment is invalid size");

		struct s_s_scenario_weapon_datum
		{
			short rounds_left;
			short rounds_loaded;
			c_enum<e_weaponaccelerateoverride, short> does_accelerate_moves_due_to_explosions;
			char generated_pad5bcf[2]; // padding
			c_typed_tag_reference<WEAPON_CONFIGURATION_TAG> configuration;
		};
		static_assert(sizeof(s_s_scenario_weapon_datum) == 24, "struct s_s_scenario_weapon_datum is invalid size");

		struct s_s_scenario_weapon
		{
			long name;
			string_id object_name;
			c_typed_tag_reference<WEAPON_TAG> asset;
			s_s_scenario_object_datum object_data;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			s_s_scenario_object_permutation permutation_data;
			s_s_scenario_weapon_datum weapon_data;
			c_typed_tag_block<s_s_scenario_multiplayer_object_properties> multiplayer_data_block;
		};
		static_assert(sizeof(s_s_scenario_weapon) == 352, "struct s_s_scenario_weapon is invalid size");

		struct s_scenario_device_group
		{
			c_static_string<32> name;
			real initial_value;
			c_flags<e_scenariodevicegroupflags, long, k_scenariodevicegroupflags_count> flags;
			string_id module_id;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			long editor_folder;
		};
		static_assert(sizeof(s_scenario_device_group) == 60, "struct s_scenario_device_group is invalid size");

		struct s_s_scenario_device_datum
		{
			short power_group;
			short position_group;
			real_fraction initial_animation_position;
			c_flags<e_scenariodeviceflags, long, k_scenariodeviceflags_count> flags;
		};
		static_assert(sizeof(s_s_scenario_device_datum) == 12, "struct s_s_scenario_device_datum is invalid size");

		struct s_s_scenario_machine_datum
		{
			c_flags<e_devicemachineflags, long, k_devicemachineflags_count> flags;
			c_enum<e_objectpathfindingpolicy, short> pathfinding_policy;
			char generated_padce30[2]; // padding
		};
		static_assert(sizeof(s_s_scenario_machine_datum) == 8, "struct s_s_scenario_machine_datum is invalid size");

		struct s_s_scenario_machine
		{
			long name;
			string_id object_name;
			c_typed_tag_reference<DEVICE_MACHINE_TAG> asset;
			s_s_scenario_object_datum object_data;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			s_s_scenario_object_permutation permutation_data;
			s_s_scenario_device_datum device_data;
			s_s_scenario_machine_datum machine_data;
			c_typed_tag_block<s_s_scenario_multiplayer_object_properties> multiplayer_data_block;
		};
		static_assert(sizeof(s_s_scenario_machine) == 348, "struct s_s_scenario_machine is invalid size");

		struct s_s_scenario_terminal_datum
		{
			long pah_pah;
		};
		static_assert(sizeof(s_s_scenario_terminal_datum) == 4, "struct s_s_scenario_terminal_datum is invalid size");

		struct s_s_scenario_terminal
		{
			long name;
			string_id object_name;
			c_typed_tag_reference<DEVICE_TERMINAL_TAG> asset;
			s_s_scenario_object_datum object_data;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			s_s_scenario_object_permutation permutation_data;
			s_s_scenario_device_datum device_data;
			s_s_scenario_terminal_datum terminal_data;
		};
		static_assert(sizeof(s_s_scenario_terminal) == 332, "struct s_s_scenario_terminal is invalid size");

		struct s_s_scenario_control_datum
		{
			c_flags<e_scenariocontrolflags, long, k_scenariocontrolflags_count> flags;
			short dont_touch_this;
			short health_station_charges;
			c_enum<e_scenariocontrolcharactertypes, short> allowed_players;
			char generated_padace0[2]; // padding
		};
		static_assert(sizeof(s_s_scenario_control_datum) == 12, "struct s_s_scenario_control_datum is invalid size");

		struct s_s_scenario_control
		{
			long name;
			string_id object_name;
			c_typed_tag_reference<DEVICE_CONTROL_TAG> asset;
			s_s_scenario_object_datum object_data;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			s_s_scenario_object_permutation permutation_data;
			s_s_scenario_device_datum device_data;
			s_s_scenario_control_datum control_data;
			c_typed_tag_block<s_s_scenario_multiplayer_object_properties> multiplayer_data_block;
		};
		static_assert(sizeof(s_s_scenario_control) == 352, "struct s_s_scenario_control is invalid size");

		struct s_scenariodispenserdatum
		{
			c_flags<e_scenariodispenserflags, char, k_scenariodispenserflags_count> flags;
		};
		static_assert(sizeof(s_scenariodispenserdatum) == 1, "struct s_scenariodispenserdatum is invalid size");

		struct s_scenariodispenser
		{
			long name;
			string_id object_name;
			c_typed_tag_reference<DEVICE_DISPENSER_TAG> asset;
			s_s_scenario_object_datum object_data;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			s_s_scenario_object_permutation permutation_data;
			s_s_scenario_device_datum device_data;
			s_scenariodispenserdatum dispenser_data;
			char generated_padf40b[3]; // padding
			c_typed_tag_block<s_s_scenario_multiplayer_object_properties> multiplayer_data_block;
		};
		static_assert(sizeof(s_scenariodispenser) == 344, "struct s_scenariodispenser is invalid size");

		struct s_s_scenario_giant_datum
		{
			c_enum<e_objectpathfindingpolicy, short> pathfinding_policy;
		};
		static_assert(sizeof(s_s_scenario_giant_datum) == 2, "struct s_s_scenario_giant_datum is invalid size");

		struct s_s_scenario_giant
		{
			long name;
			string_id object_name;
			c_typed_tag_reference<GIANT_TAG> asset;
			s_s_scenario_object_datum object_data;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			s_s_scenario_object_permutation permutation_data;
			s_s_scenario_unit_datum unit_data;
			s_s_scenario_giant_datum giant_data;
			char generated_padea38[2]; // padding
		};
		static_assert(sizeof(s_s_scenario_giant) == 328, "struct s_s_scenario_giant is invalid size");

		struct s_scenarioeffectscenerydatum
		{
			real effect_size_scale;
		};
		static_assert(sizeof(s_scenarioeffectscenerydatum) == 4, "struct s_scenarioeffectscenerydatum is invalid size");

		struct s_s_scenario_effect_scenery
		{
			long name;
			string_id object_name;
			c_typed_tag_reference<EFFECT_SCENERY_TAG> asset;
			s_s_scenario_object_datum object_data;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			s_scenarioeffectscenerydatum effect_scenery_data;
			c_typed_tag_block<s_s_scenario_multiplayer_object_properties> multiplayer_data_block;
		};
		static_assert(sizeof(s_s_scenario_effect_scenery) == 304, "struct s_s_scenario_effect_scenery is invalid size");

		struct s_s_scenario_crate_datum
		{
			c_enum<e_objectpathfindingpolicy, short> pathfinding_policy;
		};
		static_assert(sizeof(s_s_scenario_crate_datum) == 2, "struct s_s_scenario_crate_datum is invalid size");

		struct s_s_scenario_crate
		{
			long name;
			string_id object_name;
			c_typed_tag_reference<CRATE_TAG> asset;
			s_s_scenario_object_datum object_data;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			s_s_scenario_object_permutation permutation_data;
			s_s_scenario_crate_datum crate_data;
			char generated_pad36b2[2]; // padding
			c_typed_tag_block<s_s_scenario_multiplayer_object_properties> multiplayer_data_block;
		};
		static_assert(sizeof(s_s_scenario_crate) == 332, "struct s_s_scenario_crate is invalid size");

		struct s_s_scenario_creature
		{
			long name;
			string_id object_name;
			c_typed_tag_reference<CREATURE_TAG> asset;
			s_s_scenario_object_datum object_data;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
		};
		static_assert(sizeof(s_s_scenario_creature) == 288, "struct s_s_scenario_creature is invalid size");

		struct s_bspmapruntimerefcounter
		{
			short bsp_ref_count;
			short layer_ref_count;
		};
		static_assert(sizeof(s_bspmapruntimerefcounter) == 4, "struct s_bspmapruntimerefcounter is invalid size");

		struct s_i343objectsnodegraphplacement
		{
			string_id name;
			c_typed_tag_reference<XOBJECTNODEGRAPH_TAG> object_node_graph;
			real_point3d position;
			c_flags<e_i343objectsnodegraphplacementnodegraphplacementflags, long, k_i343objectsnodegraphplacementnodegraphplacementflags_count> flags;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			s_bspmapruntimerefcounter bspmapruntimerefcounter;
		};
		static_assert(sizeof(s_i343objectsnodegraphplacement) == 52, "struct s_i343objectsnodegraphplacement is invalid size");

		struct s_i343curveroaddecalmetadata
		{
			c_typed_tag_block<s_i343curveroaddecalbitmapreference> road_decal_textures_block;
			real_vector2d road_decal_scale;
			real_vector2d road_decal_offset;
			real road_decal_tile_repeat_count;
			real road_decal_height_strength;
			real road_decal_mask_strength;
			real road_decal_height_contrast;
			real road_decal_mask_contrast;
			real road_decal_edge_fade;
			long road_decal_random_seed;
		};
		static_assert(sizeof(s_i343curveroaddecalmetadata) == 56, "struct s_i343curveroaddecalmetadata is invalid size");

		struct s_i343curvesplineroadmetadata
		{
			real width;
			real opacity;
			real falloffleft;
			real falloffright;
			real bank;
			short subdivision_count;
			char generated_pad6df6[2]; // padding
			c_typed_tag_block<s_i343curveroaddecalmetadata> road_decal_metadata_block;
			c_typed_tag_reference<TERRAIN_SYSTEM_TAG> terrain_system;
		};
		static_assert(sizeof(s_i343curvesplineroadmetadata) == 52, "struct s_i343curvesplineroadmetadata is invalid size");

		struct s_i343curvesplineflightpathmetadata
		{
			real_fraction preference;
			byte lines_per_spline_segment;
			char generated_padfb3b[3]; // padding
		};
		static_assert(sizeof(s_i343curvesplineflightpathmetadata) == 8, "struct s_i343curvesplineflightpathmetadata is invalid size");

		struct s_i343curvesplineplacementmetadata
		{
			c_typed_tag_block<s_i343curvesplineroadmetadata> spline_road_metadata_block;
			c_typed_tag_block<s_i343curvesplineflightpathmetadata> spline_flight_path_metadata_block;
		};
		static_assert(sizeof(s_i343curvesplineplacementmetadata) == 24, "struct s_i343curvesplineplacementmetadata is invalid size");

		struct s_i343curvesplineplacement
		{
			string_id name;
			s_i343curvecurve3ddefinition curve;
			c_typed_tag_block<s_i343curvesplineplacementmetadata> splinemetadata_block;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			long guid;
		};
		static_assert(sizeof(s_i343curvesplineplacement) == 44, "struct s_i343curvesplineplacement is invalid size");

		struct s_warzoneobjectivedefinitiontriggervolume
		{
			c_static_string<32> label;
			short trigger_volume;
		};
		static_assert(sizeof(s_warzoneobjectivedefinitiontriggervolume) == 34, "struct s_warzoneobjectivedefinitiontriggervolume is invalid size");

		struct s_warzoneobjectivedefinition
		{
			string_id name;
			c_static_string<32> label;
			c_static_string<32> user_facing_name;
			c_enum<e_i343netprotocolgameoptionsmultiplayerteamdesignatorenum, char> initial_team;
			char generated_pad6d54[3]; // padding
			c_typed_tag_block<s_warzoneobjectivedefinitiontriggervolume> trigger_volumes_block;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
		};
		static_assert(sizeof(s_warzoneobjectivedefinition) == 96, "struct s_warzoneobjectivedefinition is invalid size");

		struct s_scenarioeffectplacement
		{
			string_id name;
			long guid;
			string_id lighting_variant;
			real_point3d position;
			real_euler_angles3d facing;
			c_flags<e_scenarioeffectplacementscenarioeffectplacementflags, char, k_scenarioeffectplacementscenarioeffectplacementflags_count> flags;
			c_enum<e_c_object_bsp_placement_policy, char> bsp_policy;
			char generated_pad675e[2]; // padding
			s_compressedbspreferenceflags manual_bsp_flags;
			c_typed_tag_reference<LENS_FLARE_TAG> lens_flare_reference;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
		};
		static_assert(sizeof(s_scenarioeffectplacement) == 104, "struct s_scenarioeffectplacement is invalid size");

		struct s_scenarioattachedlightcone
		{
			string_id name;
			long guid;
			string_id lighting_variant;
			real_point3d position;
			real_euler_angles3d facing;
			char padding[2]; // padding
			c_enum<e_c_object_bsp_placement_policy, char> bsp_policy;
			char generated_pad836b[1]; // padding
			s_compressedbspreferenceflags manual_bsp_flags;
			c_typed_tag_reference<LIGHT_CONE_TAG> light_cone_reference;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			argb_color color;
			real intensity;
			real length;
			real width;
			real camera_near_fade_start;
			real camera_near_fade_end;
			real camera_far_fade_start;
			real camera_far_fade_end;
			c_flags<e_scenarioattachedlightconescenarioattachedlightconeflags, char, k_scenarioattachedlightconescenarioattachedlightconeflags_count> flags;
			char generated_pad36b6[3]; // padding
			long editor_folder;
			string_id moduleid;
		};
		static_assert(sizeof(s_scenarioattachedlightcone) == 160, "struct s_scenarioattachedlightcone is invalid size");

		struct s_placementshapeoverride
		{
			real radius;
		};
		static_assert(sizeof(s_placementshapeoverride) == 4, "struct s_placementshapeoverride is invalid size");

		struct s_soundplacementsplinecontrolpoint
		{
			real_vector3d position;
		};
		static_assert(sizeof(s_soundplacementsplinecontrolpoint) == 12, "struct s_soundplacementsplinecontrolpoint is invalid size");

		struct s_soundplacement
		{
			string_id name;
			long guid;
			real_vector3d position;
			real_euler_angles3d facing;
			c_flags<e_soundplacementlayerflags, char, k_soundplacementlayerflags_count> placement_flags;
			c_flags<e_soundplacementruntimeflags, char, k_soundplacementruntimeflags_count> flags;
			char generated_paddbf0[2]; // padding
			long editor_folder;
			c_typed_tag_reference<SOUND_LOOPING_TAG> looping_sound;
			c_typed_tag_block<s_placementshapeoverride> shape_override_block;
			c_typed_tag_block<s_soundplacementsplinecontrolpoint> spline_block;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			string_id moduleid;
			string_id movement_rtpc_name;
			real movement_detection_radius;
			real movement_distance_scaling_factor;
			s_bspmapruntimerefcounter bspmapruntimerefcounter;
		};
		static_assert(sizeof(s_soundplacement) == 112, "struct s_soundplacement is invalid size");

		struct s_taggraphtaggraphfloatparam
		{
			string_id name;
			real value;
		};
		static_assert(sizeof(s_taggraphtaggraphfloatparam) == 8, "struct s_taggraphtaggraphfloatparam is invalid size");

		struct s_effectplacement
		{
			string_id name;
			long guid;
			string_id lighting_variant;
			real_point3d position;
			real_euler_angles3d facing;
			real scale;
			c_flags<e_effectplacementflags, short, k_effectplacementflags_count> flags;
			c_enum<e_c_object_bsp_placement_policy, char> bsp_policy;
			char generated_pad81e4[1]; // padding
			long editor_folder;
			real scale_a_override_value;
			real scale_b_override_value;
			s_tag_reference effect;
			c_typed_tag_reference<EFFECT_TAG> tag_graph_output;
			string_id output_node_name;
			c_typed_tag_block<s_taggraphtaggraphfloatparam> float_params_block;
			long handle;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			string_id moduleid;
			s_bspmapruntimerefcounter bspmapruntimerefcounter;
		};
		static_assert(sizeof(s_effectplacement) == 128, "struct s_effectplacement is invalid size");

		struct s_globalforceplacement
		{
			long force_index;
			string_id name;
			long guid;
			real_point3d position;
			real_euler_angles3d facing;
			real scale;
			c_typed_tag_reference<EFFECT_GLOBAL_FORCE_TAG> global_force;
			long editor_folder;
			string_id moduleid;
		};
		static_assert(sizeof(s_globalforceplacement) == 64, "struct s_globalforceplacement is invalid size");

		struct s_hlodvolume
		{
			long guid;
			string_id name;
			c_typed_tag_reference<SCENARIO_STRUCTURE_BSP_TAG> owner_bsp;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			s_genericvolume volume;
			real switchdistance;
			c_enum<e_etargetlod, short> maximum_lod;
			char generated_pad98b9[2]; // padding
			string_id asset_category;
			s_namedhlodsettings hlod_settings;
			c_flags<e_hlodvolumeflags, char, k_hlodvolumeflags_count> flags;
			char generated_pad7ed8[1]; // padding
			// custom visibility_settings
			c_enum<e_hlodvisibilityenum, short> use_visibility;
			s_hlodsimplygoncustomspherecamerapath visibility_camera_sphere_settings;
			// custom value
			c_enum<e_hlodvolumepolicy, char> volume_inclusion_policy;
			char generated_pad3223[3]; // padding
			c_typed_tag_reference<ASSET_TAG> hlod_asset_override;
			c_typed_tag_reference<ASSET_TAG> hlod_asset;
			c_typed_tag_reference<HLOD_METADATA_TAG> hlod_metadata_chore_generated_and_always_up_to_date;
			c_typed_tag_reference<HLOD_METADATA_TAG> hlod_metadata_baked_with_hlod_asset;
			long volumecolorindex;
		};
		static_assert(sizeof(s_hlodvolume) == 232, "struct s_hlodvolume is invalid size");

		struct s_windgustingfunction
		{
			// custom mapping
			s_functiondefinition mapping;
		};
		static_assert(sizeof(s_windgustingfunction) == 20, "struct s_windgustingfunction is invalid size");

		struct s_i343windwindinfluencervolume
		{
			string_id name;
			c_enum<e_i343windwindinfluencervolumetypeenum, long> type;
			real_vector2d direction;
			real strength;
			real radius;
			c_flags<e_windinfluencervolumemode, long, k_windinfluencervolumemode_count> mode;
			c_flags<e_i343windwindinfluencervolumeflags, long, k_i343windwindinfluencervolumeflags_count> flags;
			s_windgustingfunction direction_function;
			s_windgustingfunction strength_function;
			real direction_function_period;
			real strength_function_period;
			real wind_impulse_average_frequency;
			real wind_impulse_average_duration;
			real wind_impulse_strength;
			real last_sleep_pause;
			real last_random_activity_timestamp;
			long wind_impulse_state;
			c_enum<e_i343windnoisegustingfunctiontypeenum, long> noise_distribution;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			long editor_folder;
			string_id module_id;
			long datum_index;
			s_genericvolume volume;
			long bsp_index;
		};
		static_assert(sizeof(s_i343windwindinfluencervolume) == 208, "struct s_i343windwindinfluencervolume is invalid size");

		struct s_i343physicsphysicsvolume
		{
			string_id name;
			c_enum<e_i343physicsphysicsvolumetypeenumclass, long> type;
			// custom volume_settings
			s_genericvolume volume;
			// custom value
			string_id collision_layer;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			c_typed_tag_reference<SCENARIO_STRUCTURE_BSP_TAG> owner_bsp;
			c_typed_tag_reference<STATIC_COLLISION_TAG> generated_collision_volume;
		};
		static_assert(sizeof(s_i343physicsphysicsvolume) == 128, "struct s_i343physicsphysicsvolume is invalid size");

		struct s_pruningvolume
		{
			string_id name;
			s_genericvolume volume;
			c_flags<e_pruningvolumetypesflags, short, k_pruningvolumetypesflags_count> flags;
			char generated_padcbcb[2]; // padding
			c_typed_tag_block<s_editormetadata> editormetadata_block;
		};
		static_assert(sizeof(s_pruningvolume) == 92, "struct s_pruningvolume is invalid size");

		struct s_pathingcostmodifierfilter
		{
			c_enum<e_navigationtype, short> navigation_type;
			c_enum<e_characterfiltertype, short> character_filter_type;
			c_enum<e_objectaisize, short> ai_size;
		};
		static_assert(sizeof(s_pathingcostmodifierfilter) == 6, "struct s_pathingcostmodifierfilter is invalid size");

		struct s_i343aiaimarkupvolume
		{
			string_id name;
			s_genericvolume volume;
			angle fortification_direction;
			c_enum<e_i343aiaimarkupvolumefortintensity, char> fortification_intensity;
			char generated_pad932e[3]; // padding
			string_id fortification_direction_name;
			c_flags<e_i343aifortificationusedirectionvectors, short, k_i343aifortificationusedirectionvectors_count> should_use_direction_vector;
			char generated_paddfe3[2]; // padding
			c_typed_tag_block<s_i343aiaimarkupfilter> fortification_filters_block;
			c_typed_tag_block<s_i343aiaimarkupfilter> high_ground_filters_block;
			c_typed_tag_block<s_i343aiaimarkupfilter> fleehide_filters_block;
			c_typed_tag_block<s_i343aiaimarkupfilter> low_priority_filters_block;
			c_typed_tag_block<s_pathingcostmodifierfilter> pathing_cost_modifier_filters_block;
			c_typed_tag_block<s_i343aiaimarkupfilter> wander_priority_filters_block;
			c_enum<e_i343aiaimarkupprecombattype, char> volume_precombat_type;
			char generated_padf760[3]; // padding
			real precombat_wait_time;
			short max_characters;
			char generated_pad1141[2]; // padding
			c_typed_tag_block<s_editormetadata> editor_metadata_block;
			c_flags<e_i343aiaimarkupflavors, short, k_i343aiaimarkupflavors_count> volume_flavors;
			char generated_pad12df[2]; // padding
			long editor_folder;
			string_id moduleid;
			long guid;
			c_flags<e_i343aiaimarkupvolumeflags, short, k_i343aiaimarkupvolumeflags_count> flags;
			char generated_padc62a[2]; // padding
		};
		static_assert(sizeof(s_i343aiaimarkupvolume) == 208, "struct s_i343aiaimarkupvolume is invalid size");

		struct s_i343aibotexploreneighbor
		{
			s_levelobjectreference neighbor_ref;
		};
		static_assert(sizeof(s_i343aibotexploreneighbor) == 16, "struct s_i343aibotexploreneighbor is invalid size");

		struct s_i343aiobjectivetarget
		{
			s_levelobjectreference target;
		};
		static_assert(sizeof(s_i343aiobjectivetarget) == 16, "struct s_i343aiobjectivetarget is invalid size");

		struct s_i343aiaimarkuppoint
		{
			string_id name;
			real_point3d position;
			real_euler_angles3d orientation;
			c_typed_tag_block<s_editormetadata> editor_metadata_block;
			c_enum<e_i343aiaimarkuppointtype, char> point_type;
			c_enum<e_i343aiaimarkupprecombattype, char> point_precombat_type;
			char generated_pad277f[2]; // padding
			real max_attract_radius;
			real cooldown;
			short max_characters;
			c_enum<e_patrolmode, short> patrol_mode;
			short patrol_point_set;
			char generated_paddaca[2]; // padding
			real lookout_wait_time;
			c_typed_tag_block<s_i343aibotexploreneighbor> neighbors_block;
			c_enum<e_i343aiaimarkupplayerobjectivetype, char> objective_type;
			char generated_pad8e15[3]; // padding
			c_typed_tag_block<s_i343aiobjectivetarget> targets_block;
			c_typed_tag_block<s_i343aiaimarkupfilter> unit_type_filters_block;
			long editor_folder;
			string_id moduleid;
			long guid;
			c_flags<e_i343aiaimarkuppointflags, char, k_i343aiaimarkuppointflags_count> flags;
			char generated_pada708[3]; // padding
			string_id custom_animation_name;
		};
		static_assert(sizeof(s_i343aiaimarkuppoint) == 124, "struct s_i343aiaimarkuppoint is invalid size");

		struct s_i343botsexploreneighbor
		{
			s_levelobjectreference neighbor_ref;
		};
		static_assert(sizeof(s_i343botsexploreneighbor) == 16, "struct s_i343botsexploreneighbor is invalid size");

		struct s_i343botsbotmarkuppoint
		{
			string_id name;
			real_point3d position;
			real_euler_angles3d orientation;
			c_enum<e_i343botsbotmarkuppointtype, char> point_type;
			char generated_pad5318[3]; // padding
			c_typed_tag_block<s_i343botsexploreneighbor> explore_neighbors_block;
			c_static_string<32> megalo_label;
			c_static_string<32> megalo_label_2;
			c_static_string<32> megalo_label_3;
			c_static_string<32> megalo_label_4;
			c_enum<e_i343netprotocolgameoptionsmultiplayerteamdesignatorenum, char> owner_team;
			char generated_pad6cf9[3]; // padding
			c_typed_tag_block<s_editormetadata> editor_metadata_block;
			string_id moduleid;
			long editor_folder;
			long guid;
			c_flags<e_i343botsbotmarkuppointflags, char, k_i343botsbotmarkuppointflags_count> flags;
			char generated_padb9ae[3]; // padding
		};
		static_assert(sizeof(s_i343botsbotmarkuppoint) == 204, "struct s_i343botsbotmarkuppoint is invalid size");

		struct s_i343aichildencounterelement
		{
			s_levelobjectreference ref;
		};
		static_assert(sizeof(s_i343aichildencounterelement) == 16, "struct s_i343aichildencounterelement is invalid size");

		struct s_i343aiencounterzonecondition
		{
			c_enum<e_i343aidecoratortype, char> decorator_type;
			char generated_pada19b[1]; // padding
			c_flags<e_i343aidecoratorflags, short, k_i343aidecoratorflags_count> flags;
			long max_limit;
			c_enum<e_i343aiboolcomparison, char> assignment_limit_compare_condition;
			char generated_paddcdf[3]; // padding
			long max_bodies;
			c_enum<e_i343aiboolcomparison, char> combat_filter_compare_condition;
			char generated_pad7f6b[1]; // padding
			c_enum<e_actorcombatstatus, short> combat_status;
			string_id keyword;
			long min_living_count;
			c_flags<e_i343aivehicletypefilterflags, short, k_i343aivehicletypefilterflags_count> vehicle_compare_condition;
			char generated_pad54e6[2]; // padding
			s_levelobjectreference player_trigger_volume_reference;
			string_id label;
			c_enum<e_i343aibehaviortreerelevance, char> min_relevance;
			char generated_pad0831[3]; // padding
		};
		static_assert(sizeof(s_i343aiencounterzonecondition) == 56, "struct s_i343aiencounterzonecondition is invalid size");

		struct s_i343aiencounterzone
		{
			string_id name;
			s_genericvolume volume;
			c_enum<e_i343aibehaviortreerelevance, char> base_relevance;
			char generated_padcbd2[3]; // padding
			long editor_folder;
			string_id module_id;
			c_typed_tag_block<s_editormetadata> editor_metadata_block;
			long guid;
			c_flags<e_i343aiencounterzoneflags, short, k_i343aiencounterzoneflags_count> encounter_zone_flags;
			char generated_pad1887[2]; // padding
			c_typed_tag_block<s_i343aichildencounterelement> children_encounter_elements_block;
			c_typed_tag_block<s_i343aiencounterzonecondition> conditions_block;
			c_enum<e_i343aifollowtype, char> follow_type;
			char generated_pad653c[3]; // padding
			real follow_range_radius;
		};
		static_assert(sizeof(s_i343aiencounterzone) == 140, "struct s_i343aiencounterzone is invalid size");

		struct s_i343aichildguid
		{
			long guid;
		};
		static_assert(sizeof(s_i343aichildguid) == 4, "struct s_i343aichildguid is invalid size");

		struct s_i343aicompositechild
		{
			s_levelobjectreference ref;
		};
		static_assert(sizeof(s_i343aicompositechild) == 16, "struct s_i343aicompositechild is invalid size");

		struct s_i343aiencountertreenode
		{
			string_id name;
			real_point3d position;
			real_euler_angles3d orientation;
			c_enum<e_i343ainodetype, char> node_type;
			c_enum<e_i343aicompositetype, char> composite_type;
			c_flags<e_i343aicompositeflags, short, k_i343aicompositeflags_count> composite_flags;
			c_enum<e_i343aidecoratortype, char> decorator_type;
			char generated_padbf04[3]; // padding
			long max_limit;
			c_enum<e_i343aiboolcomparison, char> assignment_limit_compare_condition;
			char generated_paddcdf[3]; // padding
			long max_bodies;
			c_enum<e_i343aiboolcomparison, char> combat_filter_compare_condition;
			char generated_pad7f6b[1]; // padding
			c_enum<e_actorcombatstatus, short> combat_status;
			string_id keyword;
			long min_living_count;
			c_flags<e_i343aivehicletypefilterflags, short, k_i343aivehicletypefilterflags_count> vehicle_compare_condition;
			char generated_padd8e5[2]; // padding
			s_levelobjectreference player_trigger_volume_reference;
			string_id label;
			c_enum<e_i343aibehaviortreerelevance, char> min_relevance;
			char generated_pad259a[3]; // padding
			long editor_folder;
			string_id moduleid;
			c_typed_tag_block<s_editormetadata> editor_metadata_block;
			c_typed_tag_block<s_i343aichildguid> composite_child_guids_deprecated_block;
			long decorator_child_guid_deprecated;
			long root_child_guid_deprecated;
			s_levelobjectreference root_child;
			c_typed_tag_block<s_i343aicompositechild> composite_children_block;
			s_levelobjectreference decorator_child;
			long guid;
			c_flags<e_i343aiencountertreenodeflags, short, k_i343aiencountertreenodeflags_count> flags;
			char generated_pada523[2]; // padding
		};
		static_assert(sizeof(s_i343aiencountertreenode) == 180, "struct s_i343aiencountertreenode is invalid size");

		struct s_i343aiencounterbehaviortreeinputreference
		{
			string_id label;
			s_levelobjectreference ref;
		};
		static_assert(sizeof(s_i343aiencounterbehaviortreeinputreference) == 20, "struct s_i343aiencounterbehaviortreeinputreference is invalid size");

		struct s_i343aiencounterbehaviortree
		{
			string_id name;
			real_point3d position;
			real_euler_angles3d orientation;
			long editor_folder;
			string_id moduleid;
			c_typed_tag_block<s_editormetadata> editor_metadata_block;
			c_typed_tag_reference<EXPORTEDENCOUNTERBEHAVIORTREEDEFINITION_TAG> graph_tag;
			c_typed_tag_block<s_i343aiencounterbehaviortreeinputreference> input_references_block;
			c_typed_tag_block<s_i343aiencounterzonecondition> conditions_block;
			long guid;
			c_flags<e_i343aiencounterbehaviortreeflags, short, k_i343aiencounterbehaviortreeflags_count> flags;
			char generated_pad491e[2]; // padding
		};
		static_assert(sizeof(s_i343aiencounterbehaviortree) == 96, "struct s_i343aiencounterbehaviortree is invalid size");

		struct s_i343aiplacedorder
		{
			string_id name;
			s_genericvolume volume;
			c_typed_tag_block<s_editormetadata> editor_metadata_block;
		};
		static_assert(sizeof(s_i343aiplacedorder) == 88, "struct s_i343aiplacedorder is invalid size");

		struct s_i343aisquadfallbackcombattetherpoint
		{
			s_levelobjectreference ref;
			long abandon_previous_tether_point_body_count_condition_invalid_if_less_than_1;
			c_enum<e_i343aisquadcombattethertype, char> squad_combat_tether_type;
			char generated_padcce6[3]; // padding
			real squad_combat_tether_distance;
			real squad_abandon_tether_distance;
			real squad_re_tether_distance;
		};
		static_assert(sizeof(s_i343aisquadfallbackcombattetherpoint) == 36, "struct s_i343aisquadfallbackcombattetherpoint is invalid size");

		struct s_i343aiprecombatlink
		{
			s_levelobjectreference precombatref;
		};
		static_assert(sizeof(s_i343aiprecombatlink) == 16, "struct s_i343aiprecombatlink is invalid size");

		struct s_i343aiairdropflighttransitiondata
		{
			c_enum<e_i343aiairdropflighttransitiontype, char> transition_type;
			char generated_pad94e3[3]; // padding
			real transition_time;
		};
		static_assert(sizeof(s_i343aiairdropflighttransitiondata) == 8, "struct s_i343aiairdropflighttransitiondata is invalid size");

		struct s_i343aiairdropflightpathspline
		{
			s_levelobjectreference spline_ref;
		};
		static_assert(sizeof(s_i343aiairdropflightpathspline) == 16, "struct s_i343aiairdropflightpathspline is invalid size");

		struct s_i343aiairdropsquadspawnerflightpathsettings
		{
			c_enum<e_i343aiairdropflighttraveltype, char> travel_type;
			char generated_pad6c86[3]; // padding
			s_i343aiairdropflighttransitiondata transition;
			c_enum<e_i343aiairdropsquadspawnerflightpathsplinetype, char> flight_path_spline_type;
			c_flags<e_i343aiairdropusespawnerdirectionasspawnerdirectionflags, char, k_i343aiairdropusespawnerdirectionasspawnerdirectionflags_count> use_spawner_direction_as_destination_direction;
			char generated_padb93b[2]; // padding
			c_typed_tag_reference<KIT_TAG> flight_path_kit;
			c_typed_tag_block<s_i343aiairdropflightpathspline> flight_path_splines_block;
		};
		static_assert(sizeof(s_i343aiairdropsquadspawnerflightpathsettings) == 44, "struct s_i343aiairdropsquadspawnerflightpathsettings is invalid size");

		struct s_i343aiairdropsquadspawnerairdropsettings
		{
			c_typed_tag_reference<VEHICLE_TAG> air_drop_vehicle;
			c_typed_tag_reference<VEHICLECONFIGURATION_TAG> drop_ship_vehicle_configuration;
			c_typed_tag_reference<CHARACTER_TAG> air_drop_pilot_character;
			c_enum<e_i343aiairdroppassengerseatpreference, char> passenger_seat_preference;
			char generated_pade94c[3]; // padding
			real passenger_drop_height;
			real vehicle_drop_height;
			real attack_after_operations_duration;
			c_flags<e_i343aiairdropsquadspawneroptionsflags, char, k_i343aiairdropsquadspawneroptionsflags_count> flags;
			char generated_pad032d[3]; // padding
			s_i343aiairdropsquadspawnerflightpathsettings air_drop_fly_in_settings;
			s_i343aiairdropsquadspawnerflightpathsettings air_drop_fly_out_settings;
		};
		static_assert(sizeof(s_i343aiairdropsquadspawnerairdropsettings) == 156, "struct s_i343aiairdropsquadspawnerairdropsettings is invalid size");

		struct s_i343aisquadkeyword
		{
			string_id keyword;
		};
		static_assert(sizeof(s_i343aisquadkeyword) == 4, "struct s_i343aisquadkeyword is invalid size");

		struct s_i343aisquadspawner
		{
			string_id name;
			real_point3d position;
			real_euler_angles3d orientation;
			s_tag_reference squad_specification;
			c_enum<e_i343aisquadcombattethertype, char> squad_combat_tether_type;
			char generated_padcce6[3]; // padding
			real squad_combat_tether_distance;
			real squad_abandon_tether_distance;
			real squad_re_tether_distance;
			c_typed_tag_block<s_i343aisquadfallbackcombattetherpoint> fallback_combat_tether_ai_markup_points_block;
			c_typed_tag_block<s_i343aiprecombatlink> precombat_links_block;
			c_typed_tag_block<s_editormetadata> editor_metadata_block;
			long encounter_zone_instance_deprecated;
			s_levelobjectreference parent_encounter_zone_instance_deprecated;
			c_enum<e_i343aispawnmethod, char> spawn_method;
			c_enum<e_i343aiusespawnerorientation, char> spawn_orientation;
			c_enum<e_i343aiisinitallyplaced, char> is_initially_placed;
			char generated_pad9621[1]; // padding
			real spawn_radius;
			real precombat_activity_radius;
			c_typed_tag_reference<DEVICE_TAG> drop_pod_device_machine;
			real_bounds drop_pod_spawn_delay;
			c_typed_tag_reference<VEHICLE_TAG> air_drop_vehicle;
			c_typed_tag_reference<CHARACTER_TAG> air_drop_pilot_character;
			s_i343aiairdropsquadspawnerairdropsettings air_drop_settings;
			string_id placement_script;
			c_enum<e_i343aiinitialcombatstate, char> initial_combat_state;
			char generated_pad7c40[3]; // padding
			c_typed_tag_block<s_i343aisquadkeyword> squad_keywords_block;
			long editor_folder;
			string_id module_id;
			long guid;
			c_flags<e_i343aisquadspawnerflags, short, k_i343aisquadspawnerflags_count> flags;
			char generated_pad2f8b[2]; // padding
		};
		static_assert(sizeof(s_i343aisquadspawner) == 376, "struct s_i343aisquadspawner is invalid size");

		struct s_i343aireinforcementsquad
		{
			s_tag_reference squad_specification;
		};
		static_assert(sizeof(s_i343aireinforcementsquad) == 16, "struct s_i343aireinforcementsquad is invalid size");

		struct s_i343aispawnpoint
		{
			s_levelobjectreference ref;
		};
		static_assert(sizeof(s_i343aispawnpoint) == 16, "struct s_i343aispawnpoint is invalid size");

		struct s_i343aireinforcementpoint
		{
			c_flags<e_i343aireinforcementpointflags, short, k_i343aireinforcementpointflags_count> reinforcement_point_flags;
			char generated_pad545c[2]; // padding
			string_id name;
			real_point3d position;
			real_euler_angles3d orientation;
			c_enum<e_i343aireinforcementactivationcondition, char> reinforcement_activation_condition;
			c_enum<e_i343aireinforcementstyle, char> reinforcement_point_type;
			c_enum<e_i343aireinforcementsquaditerationstyle, char> reinforcement_squad_iteration_style;
			char generated_pad6e3d[1]; // padding
			c_typed_tag_block<s_i343aireinforcementsquad> reinforcement_squads_block;
			c_enum<e_i343aireinforcementspawnpointselectionstyle, char> reinforcement_spawn_point_selection_style;
			char generated_padbaf2[3]; // padding
			c_typed_tag_block<s_i343aispawnpoint> spawn_points_block;
			c_typed_tag_block<s_editormetadata> editor_metadata_block;
			long editor_folder;
			string_id moduleid;
			long guid;
		};
		static_assert(sizeof(s_i343aireinforcementpoint) == 88, "struct s_i343aireinforcementpoint is invalid size");

		struct s_i343activatableregionactivatableregion
		{
			string_id name;
			real_vector3d position;
			c_typed_tag_block<s_editormetadata> editor_metadata_block;
			c_enum<e_i343activatableregionactivatableregiontype, char> region_type;
			char generated_pad1d75[3]; // padding
			real radius;
			c_enum<e_i343activatableregionregionstate, char> active;
			char generated_pad0394[3]; // padding
			long editor_folder;
			string_id module_id;
		};
		static_assert(sizeof(s_i343activatableregionactivatableregion) == 48, "struct s_i343activatableregionactivatableregion is invalid size");

		struct s_s_trigger_volume_triangle
		{
			real_plane3d plane_0;
			real_plane3d plane_1;
			real_plane3d plane_2;
			real_plane3d plane_3;
			real_plane3d plane_4;
			real_point2d vertex_0;
			real_point2d vertex_1;
			real_point2d vertex_2;
			char pad[8]; // padding
		};
		static_assert(sizeof(s_s_trigger_volume_triangle) == 112, "struct s_s_trigger_volume_triangle is invalid size");

		struct s_i343activationvolume
		{
			string_id name;
			s_genericvolume volume;
			c_flags<e_i343activationvolumeflags, char, k_i343activationvolumeflags_count> flags;
			c_enum<e_i343eactivationvolumeactivatortype, char> activator_type;
			char generated_padc56b[2]; // padding
			real exit_delay;
			real vicinity_trigger_distance;
			c_typed_tag_block<s_s_trigger_volume_triangle> runtime_triangles_block;
			c_typed_tag_block<s_editormetadata> editor_metadata_block;
			long editor_folder;
			string_id module_id;
		};
		static_assert(sizeof(s_i343activationvolume) == 120, "struct s_i343activationvolume is invalid size");

		struct s_i343narrativecontrolparameter
		{
			string_id parameter;
		};
		static_assert(sizeof(s_i343narrativecontrolparameter) == 4, "struct s_i343narrativecontrolparameter is invalid size");

		struct s_i343narrativecageattachment
		{
			string_id name;
			s_levelobjectreference object_reference;
			c_enum<e_i343narrativecageplacementtype, char> placement_type;
			char generated_pad643c[3]; // padding
			c_typed_tag_reference<CAGEDEFINITION_TAG> cage_definition;
			string_id cage_center_point;
		};
		static_assert(sizeof(s_i343narrativecageattachment) == 44, "struct s_i343narrativecageattachment is invalid size");

		struct s_i343narrativepersistencecheckdef
		{
			string_id persistence_key;
			c_enum<e_i343narrativepersistencecomparetype, char> compare_type;
			char generated_pad6e63[3]; // padding
			long value;
			c_flags<e_i343narrativepersistencecheckflags, char, k_i343narrativepersistencecheckflags_count> flags;
			char generated_pad21ae[3]; // padding
		};
		static_assert(sizeof(s_i343narrativepersistencecheckdef) == 16, "struct s_i343narrativepersistencecheckdef is invalid size");

		struct s_i343narrativebeatactivation
		{
			c_flags<e_i343narrativebeatactivationflags, char, k_i343narrativebeatactivationflags_count> flags;
			char generated_padd35f[3]; // padding
			long on_control_parameter_set;
			string_id on_trigger_volume_enter_deprecated;
			s_levelobjectreference on_trigger_volume_enter;
			string_id on_trigger_volume_exit_deprecated;
			s_levelobjectreference on_trigger_volume_exit;
			long on_beat_activate;
			long on_beat_deactivate;
			long is_beat_inactive;
			long is_beat_active;
			long persistence_check;
			long move_to_finished;
			long hud_off_finished;
		};
		static_assert(sizeof(s_i343narrativebeatactivation) == 76, "struct s_i343narrativebeatactivation is invalid size");

		struct s_i343narrativebeatdeactivation
		{
			c_flags<e_i343narrativebeatdeactivationflags, char, k_i343narrativebeatdeactivationflags_count> flags;
			char generated_pada24a[3]; // padding
			long on_control_parameter_set;
			string_id on_trigger_volume_enter_deprecated;
			s_levelobjectreference on_trigger_volume_enter;
			string_id on_trigger_volume_exit_deprecated;
			s_levelobjectreference on_trigger_volume_exit;
			long on_beat_activate;
			long on_beat_deactivate;
			long is_beat_inactive;
			long is_beat_active;
			real time_in_beat;
			long persistence_check;
			long move_to_finished;
			long hud_off_finished;
		};
		static_assert(sizeof(s_i343narrativebeatdeactivation) == 80, "struct s_i343narrativebeatdeactivation is invalid size");

		struct s_i343narrativecagepointproperties
		{
			long cage_attachment;
			string_id cage_point;
		};
		static_assert(sizeof(s_i343narrativecagepointproperties) == 8, "struct s_i343narrativecagepointproperties is invalid size");

		struct s_i343narrativecagepointpropertieswithweight
		{
			s_levelobjectreference object_reference;
			real weight;
			// custom advanced
			long cage_attachment;
			string_id cage_point;
			// custom value
		};
		static_assert(sizeof(s_i343narrativecagepointpropertieswithweight) == 28, "struct s_i343narrativecagepointpropertieswithweight is invalid size");

		struct s_i343narrativecagegazeproperties
		{
			real distance;
			angle outer_angle;
			angle inner_angle;
			angle velocity;
			real_vector2d source_slide_range_min;
			real_vector2d source_slide_range_max;
			real_vector2d target_slide_range;
			byte slide_dampen_percentage;
			char generated_pada647[3]; // padding
			real slide_dampen_time;
			// custom input_velocity_curve
			s_i343curvecurvereference input_velocity_curve;
			// custom value
			// custom velocity_curve
			s_i343curvecurvereference velocity_curve;
			// custom value
			c_typed_tag_block<s_i343narrativecagepointpropertieswithweight> gazes_block;
		};
		static_assert(sizeof(s_i343narrativecagegazeproperties) == 108, "struct s_i343narrativecagegazeproperties is invalid size");

		struct s_i343narrativecagecompositionreference
		{
			s_levelobjectreference composition_placement;
			long composition_beat;
			long composition_index;
			string_id composition_camera_track_name;
			string_id composition_puppet_track_name;
		};
		static_assert(sizeof(s_i343narrativecagecompositionreference) == 32, "struct s_i343narrativecagecompositionreference is invalid size");

		struct s_i343narrativecagecameratransformproperties
		{
			c_flags<e_i343narrativecagetransformflags, char, k_i343narrativecagetransformflags_count> flags;
			char generated_pad6f7b[3]; // padding
			s_i343narrativecagedampingproperties damping;
			s_i343narrativecagepointproperties position_point;
			s_i343narrativecagegazeproperties gaze;
			s_i343narrativecageshakeproperties shake;
			// custom advanced___position
			s_i343narrativecagecompositionreference composition_reference;
			// custom value
		};
		static_assert(sizeof(s_i343narrativecagecameratransformproperties) == 312, "struct s_i343narrativecagecameratransformproperties is invalid size");

		struct s_i343narrativecagecameraproximityproperties
		{
			c_flags<e_i343narrativecageblendproximityflags, char, k_i343narrativecageblendproximityflags_count> flags;
			char generated_pad82ac[3]; // padding
			real desired_focal_length;
			real desired_focus_distance;
			real desired_f_stop;
			long desired_bokeh_side_count;
			c_typed_tag_reference<CURVEDEFINITION_TAG> proximity_curve;
			string_id transform_curve_name;
			string_id focal_length_curve_name;
			string_id focus_distance_curve_name;
			string_id f_stop_curve_name;
			string_id bokeh_side_count_curve_name;
			string_id gaze_outer_angle_curve_name;
			string_id gaze_inner_angle_curve_name;
			real outer_distance;
			real inner_distance;
			real catch_up_time;
			// custom source
			long source_cage_attachment;
			string_id source_cage_point;
			// custom value
			// custom destination
			s_levelobjectreference destination_object_reference;
			long destination_cage_attachment;
			string_id destination_cage_point;
			// custom value
		};
		static_assert(sizeof(s_i343narrativecagecameraproximityproperties) == 108, "struct s_i343narrativecagecameraproximityproperties is invalid size");

		struct s_i343narrativebeatnewcameraproperties
		{
			c_flags<e_i343narrativecagebeatflags, char, k_i343narrativecagebeatflags_count> flags;
			char generated_padf0b3[3]; // padding
			s_i343narrativecagecameratransformproperties camera_transform;
			// custom blend
			real starting_focal_length;
			real starting_focus_distance;
			real starting_f_stop;
			long starting_bokeh_side_count;
			real blend_in_time;
			real blend_out_time;
			s_i343curvecurvereference transform_blend_curve;
			s_i343curvecurvereference properties_blend_curve;
			// custom value
			// custom from_gameplay_transition
			s_i343cagesystemcagetransitioncurve from_gameplay_transition;
			// custom value
			// custom to_gameplay_transition
			s_i343cagesystemcagetransitioncurve to_gameplay_transition;
			// custom value
			// custom proximity
			s_i343narrativecagecameraproximityproperties proximity;
			// custom value
			// custom proximity_advanced
			c_typed_tag_block<s_i343narrativecagecameratransformproperties> proximity_advanced_camera_block;
			// custom value
			// custom player_controlled_zoom
			c_typed_tag_block<s_i343narrativecagecamerazoomsettings> zoom_settings_block;
			// custom value
		};
		static_assert(sizeof(s_i343narrativebeatnewcameraproperties) == 624, "struct s_i343narrativebeatnewcameraproperties is invalid size");

		struct s_i343narrativecagecameraproperties
		{
			c_flags<e_i343narrativecageflags, short, k_i343narrativecageflags_count> flags;
			char generated_pad8e75[2]; // padding
			real blend_time;
			byte position_dampen_percentage;
			char generated_pad7494[3]; // padding
			real position_dampen_time;
			byte rotation_dampen_percentage;
			char generated_pad27df[3]; // padding
			real rotation_dampen_time;
			s_i343curvecurvereference transform_blend_curve;
			s_i343narrativecagepointproperties position_point;
			s_i343narrativecagegazeproperties gaze;
			s_i343curvecurvereference properties_blend_curve;
			real focal_length;
			real focus_distance;
			real f_stop;
		};
		static_assert(sizeof(s_i343narrativecagecameraproperties) == 200, "struct s_i343narrativecagecameraproperties is invalid size");

		struct s_i343narrativecageblendproximity
		{
			s_i343narrativecagepointproperties source;
			s_i343narrativecagepointproperties destination;
			s_i343narrativecagecameraproperties camera_properties_at_destination;
			c_flags<e_i343narrativecageblendproximityflags, char, k_i343narrativecageblendproximityflags_count> flags;
			char generated_pad2e4f[3]; // padding
			real outer_edge;
			real inner_edge;
		};
		static_assert(sizeof(s_i343narrativecageblendproximity) == 228, "struct s_i343narrativecageblendproximity is invalid size");

		struct s_i343narrativebeatcameraproperties
		{
			s_i343narrativecagecameraproperties blend_in_properties;
			c_typed_tag_block<s_i343narrativecageblendproximity> blend_in_proximity_block;
			s_i343narrativecagecameraproperties blend_out_properties;
			s_i343narrativecagecameraproperties blend_from_properties;
		};
		static_assert(sizeof(s_i343narrativebeatcameraproperties) == 612, "struct s_i343narrativebeatcameraproperties is invalid size");

		struct s_i343narrativebeatcompositionproperties
		{
			s_levelobjectreference placed_composition;
			c_typed_tag_reference<COMPOSITION_TAG> composition;
			s_i343narrativecagepointproperties anchor_point;
			c_flags<e_i343narrativebeatcompositionpropertiesflags, char, k_i343narrativebeatcompositionpropertiesflags_count> flags;
			char generated_pad62be[3]; // padding
			real cage_blend_in_time;
			real cage_blend_out_time;
		};
		static_assert(sizeof(s_i343narrativebeatcompositionproperties) == 52, "struct s_i343narrativebeatcompositionproperties is invalid size");

		struct s_i343narrativenarrativesequenceassociatedobject
		{
			s_levelobjectreference associated_object;
		};
		static_assert(sizeof(s_i343narrativenarrativesequenceassociatedobject) == 16, "struct s_i343narrativenarrativesequenceassociatedobject is invalid size");

		struct s_i343narrativebeatnarrativesequence
		{
			c_static_string<256> sequence_name;
			c_typed_tag_block<s_i343narrativenarrativesequenceassociatedobject> associated_objects_block;
		};
		static_assert(sizeof(s_i343narrativebeatnarrativesequence) == 268, "struct s_i343narrativebeatnarrativesequence is invalid size");

		struct s_i343narrativebeataicontrolproperties
		{
			c_flags<e_i343narrativebeataicontrolflags, char, k_i343narrativebeataicontrolflags_count> flags;
		};
		static_assert(sizeof(s_i343narrativebeataicontrolproperties) == 1, "struct s_i343narrativebeataicontrolproperties is invalid size");

		struct s_i343narrativemalleablepropertydatablockdef
		{
			c_typed_tag_reference<CURVEDMALLEABLEPROPERTYTAG_TAG> data;
		};
		static_assert(sizeof(s_i343narrativemalleablepropertydatablockdef) == 16, "struct s_i343narrativemalleablepropertydatablockdef is invalid size");

		struct s_i343narrativeactivationcurvedefandnamesdef
		{
			c_typed_tag_reference<CURVEDEFINITION_TAG> curve_definition;
			string_id activate_curve_name;
			string_id deactivate_curve_name;
		};
		static_assert(sizeof(s_i343narrativeactivationcurvedefandnamesdef) == 24, "struct s_i343narrativeactivationcurvedefandnamesdef is invalid size");

		struct s_i343narrativenewplayercontrolmovetocomponent
		{
			c_flags<e_i343narrativemovetoflags, char, k_i343narrativemovetoflags_count> flags;
			char generated_pad94cc[3]; // padding
			s_levelobjectreference destination;
			real close_enough_distance;
			angle close_enough_angle;
			real time;
			real linear_velocity;
			angle angular_velocity;
			long composition_beat;
			long composition_index;
			string_id composition_track_name;
			c_typed_tag_block<s_i343narrativeactivationcurvedefandnamesdef> activation_curves_block;
		};
		static_assert(sizeof(s_i343narrativenewplayercontrolmovetocomponent) == 64, "struct s_i343narrativenewplayercontrolmovetocomponent is invalid size");

		struct s_i343narrativebeatnewplayercontrolproperties
		{
			c_typed_tag_block<s_i343narrativemalleablepropertydatablockdef> malleable_properties_block;
			c_typed_tag_block<s_i343narrativeactivationcurvedefandnamesdef> weapon_disable_block;
			c_typed_tag_block<s_i343narrativeactivationcurvedefandnamesdef> grenade_disable_block;
			// custom animation
			string_id animation_mode;
			c_typed_tag_block<s_i343narrativeactivationcurvedefandnamesdef> animation_mode_curves_block;
			// custom value
			// custom weapon_state
			c_enum<e_i343narrativeebeatplayercontrolweaponstate, char> weapon_state;
			char generated_pad1840[3]; // padding
			real weapon_state_activate_transition_time;
			real weapon_state_deactivate_transition_time;
			c_typed_tag_block<s_i343narrativeactivationcurvedefandnamesdef> weapon_state_curves_block;
			// custom value
			c_typed_tag_block<s_i343narrativenewplayercontrolmovetocomponent> move_to_component_block;
		};
		static_assert(sizeof(s_i343narrativebeatnewplayercontrolproperties) == 88, "struct s_i343narrativebeatnewplayercontrolproperties is invalid size");

		struct s_i343narrativeplayercontrolmovetocomponent
		{
			c_flags<e_i343narrativemovetoflags, char, k_i343narrativemovetoflags_count> flags;
			char generated_pad94cc[3]; // padding
			s_levelobjectreference destination;
			real close_enough_distance;
			angle close_enough_angle;
			real time;
			real linear_velocity;
			angle angular_velocity;
			long composition_beat;
			long composition_index;
			string_id composition_track_name;
		};
		static_assert(sizeof(s_i343narrativeplayercontrolmovetocomponent) == 52, "struct s_i343narrativeplayercontrolmovetocomponent is invalid size");

		struct s_i343narrativebeatplayercontrolproperties
		{
			c_flags<e_i343narrativebeatplayercontrolflags, long, k_i343narrativebeatplayercontrolflags_count> flags;
			string_id animation_mode;
			// custom weapon_state
			c_enum<e_i343narrativeebeatplayercontrolweaponstate, char> weapon_state;
			char generated_pad5e1a[3]; // padding
			real activate_transition_time;
			real deactivate_transition_time;
			// custom value
			byte movement_speed;
			char generated_padaacf[3]; // padding
			real movement_speed_blend_time;
			byte sprint_speed;
			char generated_padf784[3]; // padding
			c_typed_tag_block<s_i343narrativeplayercontrolmovetocomponent> move_to_component_block;
		};
		static_assert(sizeof(s_i343narrativebeatplayercontrolproperties) == 44, "struct s_i343narrativebeatplayercontrolproperties is invalid size");

		struct s_i343narrativebeatplayerhudproperties
		{
			c_flags<e_i343narrativebeatplayerhudflags, long, k_i343narrativebeatplayerhudflags_count> flags;
			string_id broadcast_activation_event_name;
			real broadcast_activation_event_delay;
			string_id broadcast_deactivation_event_name;
			real broadcast_deactivation_event_delay;
		};
		static_assert(sizeof(s_i343narrativebeatplayerhudproperties) == 20, "struct s_i343narrativebeatplayerhudproperties is invalid size");

		struct s_i343narrativebeatpersistencechange
		{
			c_enum<e_i343narrativebeatpersistencechangetype, char> change_type;
			char generated_padcc02[3]; // padding
			string_id persistence_key;
			long change_value;
		};
		static_assert(sizeof(s_i343narrativebeatpersistencechange) == 12, "struct s_i343narrativebeatpersistencechange is invalid size");

		struct s_i343narrativebeatpersistencechanges
		{
			c_typed_tag_block<s_i343narrativebeatpersistencechange> at_activation_block;
			c_typed_tag_block<s_i343narrativebeatpersistencechange> at_deactivation_block;
		};
		static_assert(sizeof(s_i343narrativebeatpersistencechanges) == 24, "struct s_i343narrativebeatpersistencechanges is invalid size");

		struct s_i343narrativecagelighttransformproperties
		{
			c_flags<e_i343narrativelightflags, char, k_i343narrativelightflags_count> flags;
			char generated_pad5e44[3]; // padding
			s_i343narrativecagedampingproperties damping;
			s_i343narrativecagepointproperties position_point;
			s_i343narrativecagegazeproperties gaze;
		};
		static_assert(sizeof(s_i343narrativecagelighttransformproperties) == 136, "struct s_i343narrativecagelighttransformproperties is invalid size");

		struct s_i343narrativecagelighttransition
		{
			c_typed_tag_reference<CURVEDEFINITION_TAG> animation_curve;
			string_id transform_curve_name;
			string_id dimmer_curve_name;
			string_id intensity_curve_name;
			string_id color_curve_name;
			string_id near_attenuation_curve_name;
			string_id far_attenuation_curve_name;
			string_id inner_cone_angle_curve_name;
			string_id outer_cone_angle_curve_name;
			real animation_time;
		};
		static_assert(sizeof(s_i343narrativecagelighttransition) == 52, "struct s_i343narrativecagelighttransition is invalid size");

		struct s_i343narrativecagelightproximityproperties
		{
			c_flags<e_i343narrativecageblendproximityflags, char, k_i343narrativecageblendproximityflags_count> flags;
			char generated_padedff[3]; // padding
			c_typed_tag_reference<CURVEDEFINITION_TAG> proximity_curve;
			string_id transform_curve_name;
			string_id dimmer_curve_name;
			string_id intensity_curve_name;
			string_id color_curve_name;
			string_id near_attenuation_curve_name;
			string_id far_attenuation_curve_name;
			string_id inner_cone_angle_curve_name;
			string_id outer_cone_angle_curve_name;
			real outer_distance;
			real inner_distance;
			real catch_up_time;
			// custom source
			long source_cage_attachment;
			string_id source_cage_point;
			// custom value
			// custom destination
			s_levelobjectreference destination_object_reference;
			long destination_cage_attachment;
			string_id destination_cage_point;
			// custom value
		};
		static_assert(sizeof(s_i343narrativecagelightproximityproperties) == 96, "struct s_i343narrativecagelightproximityproperties is invalid size");

		struct s_i343narrativebeatlightproperties
		{
			c_typed_tag_reference<LIGHT_TAG> light_tag;
			s_i343narrativecagelighttransformproperties light_transform;
			s_i343narrativecagelighttransition activate_transition;
			s_i343narrativecagelightproximityproperties proximity;
			c_typed_tag_block<s_i343narrativecagelighttransformproperties> proximity_advanced_lighting_block;
		};
		static_assert(sizeof(s_i343narrativebeatlightproperties) == 312, "struct s_i343narrativebeatlightproperties is invalid size");

		struct s_i343narrativebeatcontrolparameterproperties
		{
			long set_on_activate;
			long unset_on_activate;
			long set_on_deactivate;
			long unset_on_deactivate;
		};
		static_assert(sizeof(s_i343narrativebeatcontrolparameterproperties) == 16, "struct s_i343narrativebeatcontrolparameterproperties is invalid size");

		struct s_i343narrativebeattransitionproperties
		{
			c_flags<e_i343narrativetransitionbeatflags, long, k_i343narrativetransitionbeatflags_count> flags;
			s_levelobjectreference destination;
			real_vector2d close_enough_distance_range;
			real_vector2d close_enough_angle_range;
			real time;
			real_vector2d linear_velocity_range;
			real_vector2d angular_velocity_range;
			real lower_weapon_time;
			real raise_weapon_time;
			real hide_player_time;
			real lower_weapon_delay_override;
			real raise_weapon_delay_override;
			real hud_off_delay_override;
			real hud_on_delay_override;
			real move_to_delay_override;
			string_id composition_puppet_track_name;
			string_id composition_camera_track_name;
			c_enum<e_i343curvecurvebuiltin, char> move_to_slide_curve;
			c_enum<e_i343curvecurvebuiltin, char> gaze_blend_curve;
			char generated_pad0e2d[2]; // padding
		};
		static_assert(sizeof(s_i343narrativebeattransitionproperties) == 100, "struct s_i343narrativebeattransitionproperties is invalid size");

		struct s_i343narrativebeat
		{
			string_id name;
			// custom activation
			s_i343narrativebeatactivation activation;
			c_typed_tag_block<s_i343narrativebeatactivation> additional_activations_block;
			// custom value
			// custom deactivation
			s_i343narrativebeatdeactivation deactivation;
			c_typed_tag_block<s_i343narrativebeatdeactivation> additional_deactivations_block;
			// custom value
			c_flags<e_i343narrativebeatflags, char, k_i343narrativebeatflags_count> flags;
			char generated_pad0447[3]; // padding
			c_typed_tag_block<s_i343narrativebeatnewcameraproperties> new_camera_properties_block;
			c_typed_tag_block<s_i343narrativebeatcameraproperties> camera_properties_block;
			c_typed_tag_block<s_i343narrativebeatcompositionproperties> composition_properties_block;
			c_typed_tag_block<s_i343narrativebeatnarrativesequence> narrative_sequences_block;
			c_typed_tag_block<s_i343narrativebeataicontrolproperties> ai_control_block;
			c_typed_tag_block<s_i343narrativebeatnewplayercontrolproperties> new_player_control_block;
			c_typed_tag_block<s_i343narrativebeatplayercontrolproperties> player_control_block;
			c_typed_tag_block<s_i343narrativebeatplayerhudproperties> player_hud_properties_block;
			c_typed_tag_block<s_i343narrativebeatpersistencechanges> persistence_block;
			c_typed_tag_block<s_i343narrativebeatlightproperties> light_properties_block;
			c_typed_tag_block<s_i343narrativebeatcontrolparameterproperties> control_parameter_properties_block;
			c_typed_tag_block<s_i343narrativebeattransitionproperties> transition_properties_block;
		};
		static_assert(sizeof(s_i343narrativebeat) == 332, "struct s_i343narrativebeat is invalid size");

		struct s_i343narrativemoment
		{
			string_id name;
			s_genericvolume volume;
			c_flags<e_i343narrativemomentflags, char, k_i343narrativemomentflags_count> flags;
			char generated_pad9bbf[3]; // padding
			s_levelobjectreference blink_location;
			c_typed_tag_block<s_i343narrativecontrolparameter> control_parameters_block;
			c_typed_tag_block<s_i343narrativecageattachment> cage_attachments_block;
			c_typed_tag_block<s_i343narrativepersistencecheckdef> persistence_checks_block;
			c_typed_tag_block<s_i343narrativebeat> beats_block;
			c_typed_tag_block<s_s_trigger_volume_triangle> runtime_triangles_block;
			c_typed_tag_block<s_editormetadata> editor_metadata_block;
			long editor_folder;
			string_id module_id;
			long guid;
		};
		static_assert(sizeof(s_i343narrativemoment) == 180, "struct s_i343narrativemoment is invalid size");

		struct s_i343exampleentity
		{
			string_id name;
			real_vector3d position;
			long editor_folder;
			string_id moduleid;
		};
		static_assert(sizeof(s_i343exampleentity) == 24, "struct s_i343exampleentity is invalid size");

		struct s_s_scenario_soft_ceiling
		{
			c_flags<e_scenariosoftceilingflags, short, k_scenariosoftceilingflags_count> flags;
			c_flags<e_scenariosoftceilingruntimeflags, short, k_scenariosoftceilingruntimeflags_count> runtime_flags;
			string_id name;
			c_enum<e_e_soft_ceiling_type, short> type;
			char generated_paddf27[2]; // padding
		};
		static_assert(sizeof(s_s_scenario_soft_ceiling) == 12, "struct s_s_scenario_soft_ceiling is invalid size");

		struct s_scenario_starting_profile
		{
			c_static_string<32> name;
			real_fraction starting_health_damage;
			real_fraction starting_shield_damage;
			c_typed_tag_reference<WEAPON_TAG> primary_weapon;
			short primaryrounds_loaded;
			short primaryrounds_total;
			c_typed_tag_reference<WEAPON_CONFIGURATION_TAG> primary_weapon_configuration;
			string_id primary_weapon_variant_name;
			c_typed_tag_reference<WEAPON_TAG> secondary_weapon;
			short secondaryrounds_loaded;
			short secondaryrounds_total;
			c_typed_tag_reference<WEAPON_CONFIGURATION_TAG> secondary_weapon_configuration;
			string_id secondary_weapon_variant_name;
			char starting_fragmentation_grenade_count;
			char starting_plasma_grenade_count;
			char starting_lightning_grenade_count;
			char starting_gravity_grenade_count;
			char starting_spike_grenade_count;
			char starting_pulse_grenade_count;
			char starting_grenade_type_7_count;
			char starting_grenade_type_8_count;
			c_typed_tag_reference<EQUIPMENT_TAG> starting_equipment;
			string_id starting_tactical_package;
			string_id starting_support_upgrade;
			short editor_folder;
			char generated_padc11b[2]; // padding
			c_typed_tag_block<s_editormetadata> editormetadata_block;
		};
		static_assert(sizeof(s_scenario_starting_profile) == 168, "struct s_scenario_starting_profile is invalid size");

		struct s_scenario_player_starting_location
		{
			real_point3d position;
			long _navmeshuidoffaceref;
			long _packedkeyoffaceref;
			angle facing;
			angle pitch;
			string_id name;
			long editor_folder;
			string_id module_id;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
		};
		static_assert(sizeof(s_scenario_player_starting_location) == 52, "struct s_scenario_player_starting_location is invalid size");

		struct s_ambientactionpointinstance
		{
			string_id ambient_action_point_name;
			real_vector3d position;
			real_euler_angles2d yaw_pitch;
			c_typed_tag_reference<AMBIENTACTIONPOINTDEFINITIONTAG_TAG> asset;
			real max_distance_override;
			string_id debug_squad_override_only_used_for_debugging_compositions;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
		};
		static_assert(sizeof(s_ambientactionpointinstance) == 60, "struct s_ambientactionpointinstance is invalid size");

		struct s_s_real_sector_point
		{
			real_point3d position;
		};
		static_assert(sizeof(s_s_real_sector_point) == 12, "struct s_s_real_sector_point is invalid size");

		struct s_scenario_trigger_volume
		{
			string_id name;
			string_id object;
			long object_name;
			short runtime_node_index;
			char generated_padb464[2]; // padding
			string_id node_name;
			c_enum<e_e_trigger_volume_type, short> type;
			c_enum<e_etriggervolumebehavior, char> behavior;
			c_flags<e_triggervolumeflags, char, k_triggervolumeflags_count> flags;
			string_id zone_set_name;
			string_id module_id;
			real_vector3d forward;
			real_vector3d up;
			real_euler_angles3d orientation;
			real_point3d position;
			long _navmeshuidoffaceref;
			long _packedkeyoffaceref;
			real_point3d extents;
			real z_height;
			real z_sink;
			c_typed_tag_block<s_s_real_sector_point> sector_points_block;
			c_typed_tag_block<s_s_trigger_volume_triangle> runtime_triangles_block;
			real runtime_sector_bounds_x0;
			real runtime_sector_bounds_x1;
			real runtime_sector_bounds_y0;
			real runtime_sector_bounds_y1;
			real runtime_sector_bounds_z0;
			real runtime_sector_bounds_z1;
			real c;
			short kill_trigger_volume;
			char generated_padce45[2]; // padding
			long editor_folder;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			long guid;
		};
		static_assert(sizeof(s_scenario_trigger_volume) == 184, "struct s_scenario_trigger_volume is invalid size");

		struct s_acousticstagzonelod
		{
			real voxel_size;
			real breakpoint;
		};
		static_assert(sizeof(s_acousticstagzonelod) == 8, "struct s_acousticstagzonelod is invalid size");

		struct s_acousticstagzone
		{
			long guid;
			string_id name;
			c_flags<e_acousticstagzoneacousticzoneplacementflags, char, k_acousticstagzoneacousticzoneplacementflags_count> placement_flags;
			c_flags<e_acousticstagzoneacousticzoneconfigflags, char, k_acousticstagzoneacousticzoneconfigflags_count> zone_config_flags;
			c_enum<e_acousticstagzoneacousticzonepropagatetype, char> type;
			char generated_pada6e0[1]; // padding
			c_typed_tag_block<s_acousticstagzonelod> voxel_lods_block;
			real voxel_lod_z_ratio;
			real transition_speed;
			c_typed_tag_reference<SOUND_LOOPING_TAG> base_air_sound;
			c_typed_tag_reference<SOUND_LOOPING_TAG> base_air_sweetener_sound;
			c_typed_tag_reference<SOUND_ENVIRONMENT_TAG> reverb_settings;
			string_id mix_state_group;
			string_id mix_state_value;
			real_point3d position;
			real_euler_angles3d rotation;
			real_point3d scale;
			s_s_scenario_dumpling dumpling;
			short local_priority;
			byte kit_depth;
			char generated_padc0c1[1]; // padding
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			s_bspmapruntimerefcounter bspmapruntimerefcounter;
		};
		static_assert(sizeof(s_acousticstagzone) == 204, "struct s_acousticstagzone is invalid size");

		struct s_acousticstagportal
		{
			long guid;
			string_id name;
			c_enum<e_acousticstagportalacousticportaltransmissivitytype, char> transmissivity_type;
			char generated_pad3408[3]; // padding
			s_levelobjectreference manual_zone_front;
			s_levelobjectreference manual_zone_back;
			long detail;
			real tolerance;
			c_flags<e_acousticstagportalacousticportalflags, char, k_acousticstagportalacousticportalflags_count> flags;
			char generated_pad4de9[3]; // padding
			real min_transmissivity;
			real max_transmissivity;
			real min_openness;
			real max_openness;
			real_vector2d door_centre_offset;
			c_typed_tag_reference<SOUND_TAG> front_entry_sound;
			c_typed_tag_reference<SOUND_TAG> front_exit_sound;
			c_typed_tag_reference<SOUND_TAG> back_entry_sound;
			c_typed_tag_reference<SOUND_TAG> back_exit_sound;
			real_point3d position;
			real_euler_angles3d rotation;
			real_vector2d shearx;
			real_vector2d sheary;
			real_vector2d shearz;
			real_point3d extents;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			s_bspmapruntimerefcounter bspmapruntimerefcounter;
		};
		static_assert(sizeof(s_acousticstagportal) == 220, "struct s_acousticstagportal is invalid size");

		struct s_recorded_animation_definition
		{
			c_static_string<32> name;
			char version;
			char raw_animation_data;
			char unit_control_data_version;
			char generated_pade32d[1]; // padding
			short length_of_animation;
			char generated_padc94c[2]; // padding
			s_tag_data recorded_animation_event_stream;
		};
		static_assert(sizeof(s_recorded_animation_definition) == 60, "struct s_recorded_animation_definition is invalid size");

		struct s_scenario_decal
		{
			c_typed_tag_reference<DECAL_SYSTEM_TAG> asset;
			c_flags<e_scenario_decalc_decalplacementflags, char, k_scenario_decalc_decalplacementflags_count> flags;
			char generated_pad9ec6[3]; // padding
			s_compressedbspreferenceflags manual_bsp_flags;
			real_euler_angles3d orientation;
			real_point3d position;
			real scale_x;
			real scale_y;
			real cull_angle;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
		};
		static_assert(sizeof(s_scenario_decal) == 104, "struct s_scenario_decal is invalid size");

		struct s_areageneratordefinition
		{
			c_static_string<32> name;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			real_point3d position;
			real_euler_angles3d orientation;
			real radius;
			real vertical_radius;
			real area_min_radius;
			real area_max_radius;
			real area_height;
			real area_spacing;
			real area_point_count;
		};
		static_assert(sizeof(s_areageneratordefinition) == 96, "struct s_areageneratordefinition is invalid size");

		struct s_squad_group_definition
		{
			c_static_string<32> name;
			short parent;
			short initial_objective;
			long editor_folder;
			string_id module_id;
			s_warzoneobjectivedefinitionmembership warzone_objective_definition_membership;
			char generated_pad5300[2]; // padding
			c_typed_tag_block<s_editormetadata> editormetadata_block;
		};
		static_assert(sizeof(s_squad_group_definition) == 92, "struct s_squad_group_definition is invalid size");

		struct s_s_ai_spawn_conditions
		{
			c_flags<e_gamedifficultyflags, short, k_gamedifficultyflags_count> difficulty_flags;
			char pad0[2]; // padding
		};
		static_assert(sizeof(s_s_ai_spawn_conditions) == 4, "struct s_s_ai_spawn_conditions is invalid size");

		struct s_s_patrol_point
		{
			short point;
			c_flags<e_c_patrol_point_flags, short, k_c_patrol_point_flags_count> flags;
			real delay;
			real _angle;
			string_id activity_name;
			string_id command_script;
		};
		static_assert(sizeof(s_s_patrol_point) == 20, "struct s_s_patrol_point is invalid size");

		struct s_s_spawn_formation_definition
		{
			s_s_ai_spawn_conditions place_on;
			string_id name;
			real_point3d position;
			long _navmeshuidoffaceref;
			long _packedkeyoffaceref;
			real_euler_angles2d facing_yaw_pitch;
			real roll;
			string_id formation;
			real initial_movement_distance;
			c_enum<e_estartingmovementtype, short> initial_movement_mode;
			char generated_padee0b[2]; // padding
			string_id placement_script;
			string_id activity_name;
			string_id movement_set;
			short point_set;
			c_enum<e_patrolmode, short> patrol_mode;
			c_typed_tag_block<s_s_patrol_point> points_block;
			c_flags<e_c_spawn_formation_flags, char, k_c_spawn_formation_flags_count> flags;
			char generated_pada156[3]; // padding
		};
		static_assert(sizeof(s_s_spawn_formation_definition) == 84, "struct s_s_spawn_formation_definition is invalid size");

		struct s_s_spawn_point_definition
		{
			s_s_ai_spawn_conditions place_on;
			string_id name;
			short cell;
			char generated_pad6f52[2]; // padding
			real_point3d position;
			long _navmeshuidoffaceref;
			long _packedkeyoffaceref;
			real_euler_angles2d facing_yaw_pitch;
			real roll;
			c_flags<e_aispawnpointflags, short, k_aispawnpointflags_count> flags;
			char generated_padbc07[2]; // padding
			c_typed_tag_reference<CHARACTER_TAG> character;
			c_typed_tag_reference<WEAPON_TAG> primary_weapon;
			c_typed_tag_reference<WEAPON_TAG> secondary_weapon;
			c_typed_tag_reference<EQUIPMENT_TAG> equipment;
			c_typed_tag_reference<VEHICLE_TAG> vehicle;
			c_typed_tag_reference<VEHICLECONFIGURATION_TAG> vehicle_configuration;
			c_enum<e_aiseatpreference, short> seat_type;
			c_enum<e_unitgrenadetype, char> grenade_type;
			char generated_pad08bc[1]; // padding
			short swarm_count;
			char generated_pad5571[2]; // padding
			string_id actor_variant_name;
			string_id vehicle_variant_name;
			string_id voice_designator;
			real initial_movement_distance;
			c_enum<e_estartingmovementtype, short> initial_movement_mode;
			short emitter_vehicle;
			short giant_body;
			short biped_body;
			string_id placement_script;
			string_id activity_name;
			string_id movement_set;
			short point_set;
			c_enum<e_patrolmode, short> patrol_mode;
			c_typed_tag_block<s_s_patrol_point> points_block;
			short vehicle_body;
			char generated_pada226[2]; // padding
		};
		static_assert(sizeof(s_s_spawn_point_definition) == 208, "struct s_s_spawn_point_definition is invalid size");

		struct s_aicharacterchoice
		{
			s_s_ai_spawn_conditions place_on;
			c_typed_tag_reference<CHARACTER_TAG> character_type;
			short chance;
			char generated_padc8d2[2]; // padding
		};
		static_assert(sizeof(s_aicharacterchoice) == 24, "struct s_aicharacterchoice is invalid size");

		struct s_aiweaponchoice
		{
			s_s_ai_spawn_conditions place_on;
			c_typed_tag_reference<WEAPON_TAG> weapon_type;
			short chance;
			char generated_pada3bd[2]; // padding
		};
		static_assert(sizeof(s_aiweaponchoice) == 24, "struct s_aiweaponchoice is invalid size");

		struct s_aiequipmentchoice
		{
			s_s_ai_spawn_conditions place_on;
			c_typed_tag_reference<EQUIPMENT_TAG> equipment_type;
			short chance;
			char generated_pada94b[2]; // padding
		};
		static_assert(sizeof(s_aiequipmentchoice) == 24, "struct s_aiequipmentchoice is invalid size");

		struct s_s_cell_definition
		{

			/* Character Build */

			string_id name;
			s_s_ai_spawn_conditions place_on;
			short normal_diff_count;
			c_enum<e_squadmajorupgradetype, short> major_upgrade;
			c_typed_tag_block<s_aicharacterchoice> character_block;
			c_typed_tag_block<s_aiweaponchoice> primary_weapon_block;
			c_typed_tag_block<s_aiweaponchoice> secondary_weapon_block;
			c_typed_tag_block<s_aiequipmentchoice> equipment_block;
			c_enum<e_unitgrenadetype, char> grenade_type;
			char generated_pad6c56[3]; // padding
			c_typed_tag_reference<VEHICLE_TAG> vehicle;
			string_id vehicle_variant;
			string_id placement_script;
			string_id activity_name;
			string_id movement_set;
			short point_set;
			c_enum<e_patrolmode, short> patrol_mode;
			c_typed_tag_block<s_s_patrol_point> points_block;
		};
		static_assert(sizeof(s_s_cell_definition) == 112, "struct s_s_cell_definition is invalid size");

		struct s_s_squad_definition_internal
		{
			c_typed_tag_block<s_s_cell_definition> cells_block;
		};
		static_assert(sizeof(s_s_squad_definition_internal) == 12, "struct s_s_squad_definition_internal is invalid size");

		struct s_s_squad_definition
		{
			c_static_string<32> name;
			c_flags<e_c_squad_flags, long, k_c_squad_flags_count> flags;
			c_enum<e_e_campaign_team, short> team;
			short parent;
			s_compressedbspreferenceflags bsp_flags;
			short initial_zone;
			short initial_objective;
			short initial_task;
			char generated_pad8aa2[2]; // padding
			long editor_folder;
			c_typed_tag_block<s_s_spawn_formation_definition> spawn_formations_block;
			c_typed_tag_block<s_s_spawn_point_definition> spawn_points_block;
			string_id module_id;
			string_id _template;
			long squad_template_index;
			s_s_squad_definition_internal designer;
			s_s_squad_definition_internal templated;
			s_warzoneobjectivedefinitionmembership warzone_objective_definition_membership;
			c_enum<e_c_object_bsp_placement_policy, char> bsp_policy;
			char generated_padd757[1]; // padding
			c_typed_tag_block<s_editormetadata> editormetadata_block;
		};
		static_assert(sizeof(s_s_squad_definition) == 196, "struct s_s_squad_definition is invalid size");

		struct s_navmeshattachmentnavmeshattachmentid
		{
			dword navmeshuid;
		};
		static_assert(sizeof(s_navmeshattachmentnavmeshattachmentid) == 4, "struct s_navmeshattachmentnavmeshattachmentid is invalid size");

		struct s_navmeshattachment
		{
			c_typed_tag_block<s_navmeshattachmentnavmeshattachmentid> attachments_block;
		};
		static_assert(sizeof(s_navmeshattachment) == 12, "struct s_navmeshattachment is invalid size");

		struct s_s_ai_sector_point
		{
			real_point3d point;
			long _navmeshuidoffaceref;
			long _packedkeyoffaceref;
		};
		static_assert(sizeof(s_s_ai_sector_point) == 20, "struct s_s_ai_sector_point is invalid size");

		struct s_area_definition
		{
			c_static_string<32> name;
			c_flags<e_aiareaflags, long, k_aiareaflags_count> area_flags;
			real_point3d runtime_relative_mean_point;
			long _navmeshuidoffaceref;
			long _packedkeyoffaceref;
			real runtime_standard_deviation;
			s_navmeshattachment nav_mesh_attachments;
			c_typed_tag_block<s_s_ai_sector_point> points_block;

			/* Generation Properties */

			c_flags<e_aiareagenerateflags, long, k_aiareagenerateflags_count> flags;
			real extrusion;
			real sink;
			real air_firing_point_density;
		};
		static_assert(sizeof(s_area_definition) == 100, "struct s_area_definition is invalid size");

		struct s_zone_definition
		{
			c_static_string<32> name;
			c_flags<e_aizoneflags, short, k_aizoneflags_count> flags;
			char generated_pad0eda[2]; // padding
			long editor_folder_index;
			c_typed_tag_block<s_area_definition> areas_block;
			s_navmeshattachment nav_mesh_attachments;
			s_compressedbspreferenceflags disallowed_attachment_bsps;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
		};
		static_assert(sizeof(s_zone_definition) == 112, "struct s_zone_definition is invalid size");

		struct s_user_hint_parallelogram
		{
			real_point3d point_0;
			real_point3d point_1;
			real_point3d point_2;
			real_point3d point_3;
			c_flags<e_parallelograminvalidflags, short, k_parallelograminvalidflags_count> invalid_points;
			char generated_pad733f[2]; // padding
		};
		static_assert(sizeof(s_user_hint_parallelogram) == 52, "struct s_user_hint_parallelogram is invalid size");

		struct s_user_hint_jump
		{
			c_enum<e_pathfindinghinttype, short> link_type;
			short squad_group_filter;
			long hint_data_0;
			short hint_data_1;
			byte hint_data_2;
			byte pad1;
			string_id name;
			c_flags<e_userhintgeometryflags, short, k_userhintgeometryflags_count> flags;
			c_enum<e_characterjumpheight, short> force_jump_height;
			c_flags<e_userhintjumptypeflags, short, k_userhintjumptypeflags_count> control_flags;
			char generated_pad04d0[2]; // padding
			s_user_hint_parallelogram geometry;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
		};
		static_assert(sizeof(s_user_hint_jump) == 88, "struct s_user_hint_jump is invalid size");

		struct s_aihintsectorpoint
		{
			real_point3d point;
			long _navmeshuidoffaceref;
			long _packedkeyoffaceref;
		};
		static_assert(sizeof(s_aihintsectorpoint) == 20, "struct s_aihintsectorpoint is invalid size");

		struct s_s_cookie_cutterobjectidentifier
		{
			s_c_object_identifier object_id;
		};
		static_assert(sizeof(s_s_cookie_cutterobjectidentifier) == 8, "struct s_s_cookie_cutterobjectidentifier is invalid size");

		struct s_s_cookie_cutter
		{
			c_typed_tag_block<s_aihintsectorpoint> points_block;
			c_typed_tag_block<s_s_cookie_cutterobjectidentifier> pointsobjectids_block;
			real z_height;
			real z_sink;
			c_enum<e_cookiecuttertype, short> type;
			short pad;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			char invalid;
			char generated_pad8e8a[3]; // padding
		};
		static_assert(sizeof(s_s_cookie_cutter) == 52, "struct s_s_cookie_cutter is invalid size");

		struct s_navmesharea
		{
			c_typed_tag_block<s_aihintsectorpoint> points_block;
			real z_height;
			real z_sink;
			c_enum<e_navmeshareatype, long> type;
			byte isvalid;
			char generated_pad7d37[3]; // padding
			c_typed_tag_block<s_editormetadata> editormetadata_block;
		};
		static_assert(sizeof(s_navmesharea) == 40, "struct s_navmesharea is invalid size");

		struct s_i343ainavseedpoint
		{
			string_id name;
			real_point3d position;
		};
		static_assert(sizeof(s_i343ainavseedpoint) == 16, "struct s_i343ainavseedpoint is invalid size");

		struct s_opportunitytasklink
		{
			short objective;
			short task;
		};
		static_assert(sizeof(s_opportunitytasklink) == 4, "struct s_opportunitytasklink is invalid size");

		struct s_opportunityareadata
		{
			c_typed_tag_block<s_aihintsectorpoint> points_block;
			real z_height;
			real z_sink;
			string_id name;
			real_point3d mean_position;
			real std_deviation;
			char area_bounds[24]; // skip
			c_typed_tag_block<s_opportunitytasklink> tasks_block;
			long priority;
			real distribution_range;
			real distribution_probability;
			c_enum<e_opportunityareadatadistributiontype, char> distribution_type;
			char max_uses;
			char user_limit;
			char generated_padc2c0[1]; // padding
			c_typed_tag_reference<CHARACTER_TAG> character_filter_tag;
			c_typed_tag_reference<WEAPON_TAG> weapon_filter_tag;
			c_enum<e_opportunityareadatacombateffect, char> combat_effect;
			char generated_paddca1[3]; // padding
			string_id stimulus;
			string_id script;
			char isvalid;
			char generated_pad2956[3]; // padding

			/* Attraction Area */

			// custom attraction_area
			real_point3d position;
			long _navmeshuidoffaceref;
			long _packedkeyoffaceref;
			real attraction_radius;
			// custom value
			c_enum<e_opportunityareadataopportunitytype, char> opportunity_type;
			char generated_pad4337[3]; // padding
			c_typed_tag_block<s_editormetadata> editormetadata_block;
		};
		static_assert(sizeof(s_opportunityareadata) == 180, "struct s_opportunityareadata is invalid size");

		struct s_ai_recording_reference_definition
		{
			c_static_string<32> recording_name;
		};
		static_assert(sizeof(s_ai_recording_reference_definition) == 32, "struct s_ai_recording_reference_definition is invalid size");

		struct s_cs_point
		{
			c_static_string<32> name;
			string_id name_id;
			real_point3d position;
			long _navmeshuidoffaceref;
			long _packedkeyoffaceref;
			real_euler_angles2d facing_direction;
			real wait_time;
			real reached_radius;
		};
		static_assert(sizeof(s_cs_point) == 72, "struct s_cs_point is invalid size");

		struct s_cs_point_set
		{
			c_static_string<32> name;
			c_typed_tag_block<s_cs_point> points_block;
			short bsp_index;
			char generated_pad901e[2]; // padding
			c_flags<e_aipointsetflags, long, k_aipointsetflags_count> flags;
			c_flags<e_aipointsettraversalflags, long, k_aipointsettraversalflags_count> traversal_flags;
			long editor_folder;
			string_id module_id;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			s_warzoneobjectivedefinitionmembership warzone_objective_definition_membership;
			char generated_paddcd3[2]; // padding
		};
		static_assert(sizeof(s_cs_point_set) == 112, "struct s_cs_point_set is invalid size");

		struct s_scenario_cutscene_flag
		{
			string_id name;
			real_point3d position;
			real_euler_angles3d facing;
			string_id module_id;
			long editor_folder;
			short source_bsp;
			char generated_padce64[2]; // padding
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			long guid;
		};
		static_assert(sizeof(s_scenario_cutscene_flag) == 56, "struct s_scenario_cutscene_flag is invalid size");

		struct s_scenario_cutscene_camera_point
		{
			c_flags<e_scenariocutscenecamerapointflags, short, k_scenariocutscenecamerapointflags_count> flags;
			c_enum<e_scenariocameratype, short> type;
			c_static_string<32> name;
			// custom value
			real_point3d position;
			real_euler_angles3d orientation;
			short zone_set;
			char generated_pad2c94[2]; // padding
			c_typed_tag_block<s_editormetadata> editormetadata_block;
		};
		static_assert(sizeof(s_scenario_cutscene_camera_point) == 76, "struct s_scenario_cutscene_camera_point is invalid size");

		struct s_s_scenario_cutscene_title
		{
			string_id name;
			long guid;
			string_id objective_title;
			string_id objective_description;
			real_bounds text_bounds_x;
			real_bounds text_bounds_y;
			c_enum<e_fontlisttextjustification, short> justification;
			c_enum<e_textverticaljustification, short> vertical_justification;
			c_enum<e_fontlistfontid, short> font;
			char generated_pad7734[2]; // padding
			pixel32 text_color;
			pixel32 shadow_color;
			real fade_in_time_;
			real up_time_;
			real fade_out_time_;
			real letter_print_time;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
		};
		static_assert(sizeof(s_s_scenario_cutscene_title) == 76, "struct s_s_scenario_cutscene_title is invalid size");

		struct s_s_flock_source
		{
			string_id name;
			c_flags<e_c_flock_source_flags, long, k_c_flock_source_flags_count> source_flags;
			real_vector3d position;
			real_euler_angles2d starting_yaw_pitch;
			real radius;
			real weight;
			short bsp_index;
			short cluster_index;
			short source_volume;
			short initial_destination;
		};
		static_assert(sizeof(s_s_flock_source) == 44, "struct s_s_flock_source is invalid size");

		struct s_s_flock_destination
		{
			string_id name;
			c_enum<e_e_destination_type, char> type;
			char generated_pad2d54[3]; // padding
			real_vector3d position;
			real radius;
			real max_destination_volume_penetration;
			short destination_volume;
			short next_destination;
		};
		static_assert(sizeof(s_s_flock_destination) == 32, "struct s_s_flock_destination is invalid size");

		struct s_s_flock_instance
		{
			string_id flock_name;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			real_point3d position;
			c_typed_tag_reference<FLOCK_TAG> flock_asset;
			s_compressedbspreferenceflags active_bsps;
			short bounding_volume;
			char generated_pad2fe7[2]; // padding
			c_typed_tag_block<s_s_flock_source> flock_sources_block;

			/* Destination System */

			c_enum<e_edestinationsystemtype, char> destination_system_type;
			c_flags<e_enableflag, char, k_enableflag_count> looped_path;
			c_flags<e_c_flock_instance_flags, short, k_c_flock_instance_flags_count> placement_flags;
			c_typed_tag_reference<CREATURE_TAG> creature_asset;
			string_id creature_variant_name;
			long boid_count;
			c_enum<e_flockbehaviortype, char> initial_behavior;
			c_enum<e_flockbehaviortype, char> second_behavior;
			c_enum<e_flockreactionbehaviortype, char> reaction_behavior;
			c_enum<e_flockbehaviortype, char> reaction_navigation_behavior;
			c_enum<e_flockreactionbehaviortype, char> second_reaction_behavior;
			c_enum<e_flockbehaviortype, char> second_reaction_navigation_behavior;
			c_enum<e_flockreactionbehaviortype, char> despawn_reaction_behavior;
			c_enum<e_flockbehaviortype, char> despawn_reaction_navigation_behavior;
			c_flags<e_generaloverrideflags, char, k_generaloverrideflags_count> general_override_flags;
			char generated_pad7bfc[3]; // padding
			real torus_inner_radius;
			real torus_cross_section_radius;
			c_enum<e_circlingdirectiontype, char> circling_direction;
			char generated_padf423[3]; // padding
			real leveling_coefficient;
			c_flags<e_circlingoverrideflags, char, k_circlingoverrideflags_count> circling_override_flags;
			char generated_padf6f9[3]; // padding
			real spawn_cylinder_radius;
			real spawn_cylinder_height;
			c_flags<e_perchingwanderingoverrideflags, char, k_perchingwanderingoverrideflags_count> perching_wandering_override_flags;
			char generated_padeb3d[3]; // padding
			real_bounds wandering_time;
			real_bounds grazing_time;
			real change_of_direction_time;
			c_flags<e_wanderingbehaviorflags, char, k_wanderingbehaviorflags_count> flags;
			c_flags<e_enableflag, char, k_enableflag_count> wandering_to_same_source_point_is_allowed;
			char generated_pad094b[2]; // padding
			c_flags<e_wanderingoverrideflags, char, k_wanderingoverrideflags_count> wandering_override_flags;
			char generated_pad7a11[3]; // padding
			c_flags<e_spawnsettingsflags, char, k_spawnsettingsflags_count> spawn_flags;
			c_flags<e_enableflag, char, k_enableflag_count> generate_spawn_point_for_each_boid;
			char generated_padd75d[2]; // padding
			long number_of_spawn_points;
			real distance_of_importance;
			real despawn_distance;
			real spawn_distance;
			real minimum_respawn_delay;
			real_bounds time_before_dehydration_hide_is_forced;
			real distance_enough_for_dehydration_hide;
			c_enum<e_spawnpriority, char> spawn_priority;
			c_flags<e_enableflag, char, k_enableflag_count> disable_backward_flock_relevancy_reduce;
			char generated_padbd7c[2]; // padding
			real_bounds production_frequency_bounds;
			real high_lod_distance;
			c_flags<e_spawnoverrideflags, char, k_spawnoverrideflags_count> spawn_override_flags;
			c_flags<e_enableflag, char, k_enableflag_count> not_initially_spawned;
			short spawn_trigger_volume;
			c_flags<e_enableflag, char, k_enableflag_count> procedural_spawn_in_player_visibility;
			char generated_padd74b[3]; // padding
			real_bounds procedural_spawn_delay_bounds;
			real ecology_margin;
			real source_scale_to_0_radius;
			real sink_scale_to_0_radius;
			real flock_destroy_duration;
			long enemy_flock;
			real enemy_flock_max_target_distance;
			real constant_throttle_override;
			long editor_folder;
			string_id module_id;
			c_typed_tag_block<s_s_flock_destination> flock_destinations_block;
		};
		static_assert(sizeof(s_s_flock_instance) == 312, "struct s_s_flock_instance is invalid size");

		struct s_s_scenario_editor_folder
		{
			long parent_folder;
			string_id name;
			c_typed_tag_reference<LUA_TAG> prototype_script;
			s_s_property_collection scriptable_properties;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			c_flags<e_s_scenario_editor_foldermoduleflags, char, k_s_scenario_editor_foldermoduleflags_count> flags;
			char generated_pad9b2d[3]; // padding
		};
		static_assert(sizeof(s_s_scenario_editor_folder) == 112, "struct s_s_scenario_editor_folder is invalid size");

		struct s_s_opposing_objective
		{
			short objective;
		};
		static_assert(sizeof(s_s_opposing_objective) == 2, "struct s_s_opposing_objective is invalid size");

		struct s_s_area_reference
		{
			c_enum<e_c_zone_set_type, short> area_type;
			c_flags<e_c_zone_set_flags, char, k_c_zone_set_flags_count> flags;
			char generated_pad1249[1]; // padding
			short zone;
			short area;
			angle yaw;
			long connection_flags_0;
			long connection_flags_1;
			long connection_flags_2;
			long connection_flags_3;
		};
		static_assert(sizeof(s_s_area_reference) == 28, "struct s_s_area_reference is invalid size");

		struct s_s_script_fragment
		{
			long script_name;
			c_static_string<256> script_source;
		};
		static_assert(sizeof(s_s_script_fragment) == 260, "struct s_s_script_fragment is invalid size");

		struct s_s_task_direction_point
		{
			real_point3d point0;
			long _navmeshuidoffaceref;
			long _packedkeyoffaceref;
		};
		static_assert(sizeof(s_s_task_direction_point) == 20, "struct s_s_task_direction_point is invalid size");

		struct s_s_task_direction
		{
			c_typed_tag_block<s_s_task_direction_point> points_block;
		};
		static_assert(sizeof(s_s_task_direction) == 12, "struct s_s_task_direction is invalid size");

		struct s_s_task_definition
		{
			c_flags<e_c_task_flags, short, k_c_task_flags_count> flags;
			c_flags<e_c_behavior_inhibit_flags, short, k_c_behavior_inhibit_flags_count> inhibit_groups;
			c_flags<e_gamedifficultyflags, short, k_gamedifficultyflags_count> inhibit_on_difficulty;
			c_enum<e_c_task_movement, short> movement;
			c_enum<e_c_task_follow, short> follow;
			short follow_squad;
			real follow_radius;
			c_flags<e_c_task_follow_players, short, k_c_task_follow_players_count> follow_players;
			char generated_pad4a13[2]; // padding
			c_typed_tag_block<s_s_area_reference> areas_block;
			real maximum_duration;
			real exhaustion_delay;
			string_id entry_script;
			string_id command_script;
			string_id exhaustion_script;
			short squad_group_filter;
			c_enum<e_taskorderdialogue, short> dialogue_type;
			c_flags<e_task_runtime_flags, short, k_task_runtime_flags_count> runtime_flags;
			short kungfu_count;

			/* UI-Controlled */

			c_static_string<32> name;
			short priority;
			short first_child;
			short next_sibling;
			short parent;
			c_typed_tag_block<s_s_script_fragment> activation_script_block;
			dword script_crc;
			short lifetime_count;
			c_flags<e_c_filter_flags, short, k_c_filter_flags_count> filter_flags;
			c_enum<e_c_objective_filter, short> filter;
			short_bounds capacity;
			short max_body_count;
			c_enum<e_c_task_attitude, short> attitude;
			char generated_padfd5e[2]; // padding
			real min_strength;
			c_typed_tag_block<s_s_task_direction> direction_block;
		};
		static_assert(sizeof(s_s_task_definition) == 148, "struct s_s_task_definition is invalid size");

		struct s_s_objective
		{
			c_static_string<32> name;
			c_typed_tag_block<s_s_opposing_objective> opposing_objectives_block;
			c_flags<e_c_objective_flags, short, k_c_objective_flags_count> objective_flags;
			short zone_index;
			short first_task_index;
			short editor_folder;
			c_typed_tag_block<s_s_task_definition> tasks_block;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
		};
		static_assert(sizeof(s_s_objective) == 76, "struct s_s_objective is invalid size");

		struct s_s_scenario_cheap_particle_system
		{
			short palette_index;
			char generated_pad3d05[2]; // padding
			real_point3d position;
			real_euler_angles3d rotation;
		};
		static_assert(sizeof(s_s_scenario_cheap_particle_system) == 28, "struct s_s_scenario_cheap_particle_system is invalid size");

		struct s_composerpuppetoverride
		{
			string_id puppet_name;
			s_composersubject subject;
		};
		static_assert(sizeof(s_composerpuppetoverride) == 48, "struct s_composerpuppetoverride is invalid size");

		struct s_levelobjectparentkitpath
		{
			c_typed_tag_block<s_levelobjectreferenceelement> path_block;
		};
		static_assert(sizeof(s_levelobjectparentkitpath) == 12, "struct s_levelobjectparentkitpath is invalid size");

		struct s_composershowstage
		{
			c_typed_tag_reference<COMPOSITION_TAG> composition;
			string_id instance_name;
			real_point3d position;
			real_euler_angles3d orientation;
			string_id zone_set_name;
			s_levelobjectreference streaming_reference_override;
			c_enum<e_c_object_bsp_placement_policy, char> bsp_policy;
			char generated_pad8015[3]; // padding
			s_compressedbspreferenceflags manual_bsp_flags;
			c_typed_tag_block<s_composerpuppetoverride> puppets_block;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			long editor_folder;
			string_id module_id;
			c_flags<e_composershowstageflags, long, k_composershowstageflags_count> composer_show_stage_flags;
			s_genericvolume stage_volume;
			c_flags<e_stagevolumeflags, long, k_stagevolumeflags_count> stage_volume_flags;
			c_flags<e_stagestreamingflags, char, k_stagestreamingflags_count> streaming_flags;
			char generated_pad6634[3]; // padding
			// custom streaming_range_overrides
			real stream_pinned_resources_radius_override;
			// custom value
			long guid;
			s_levelobjectparentkitpath parent_kits;
		};
		static_assert(sizeof(s_composershowstage) == 240, "struct s_composershowstage is invalid size");

		struct s_i343graphicsdecalsdecalvertex
		{
			real_vector3d position;
			real position_w_component;
			long texcoord;
			long normal;
			char tangent_x;
			char tangent_y;
			char tangent_z;
			char array_index;
			dword rayindex;
		};
		static_assert(sizeof(s_i343graphicsdecalsdecalvertex) == 32, "struct s_i343graphicsdecalsdecalvertex is invalid size");

		struct s_i343graphicsdecalsdecaltriangle
		{
			s_i343graphicsdecalsdecalvertex vertex_0;
			s_i343graphicsdecalsdecalvertex vertex_1;
			s_i343graphicsdecalsdecalvertex vertex_2;
		};
		static_assert(sizeof(s_i343graphicsdecalsdecaltriangle) == 96, "struct s_i343graphicsdecalsdecaltriangle is invalid size");

		struct s_cacheddecalsystem
		{
			c_typed_tag_reference<DECAL_SYSTEM_TAG> definition_ref;
			long component_index;
			c_typed_tag_block<s_i343graphicsdecalsdecaltriangle> decal_triangles_block;
			char generated_pad29ea[4]; // padding
			long long runtimevertexbuffer;
		};
		static_assert(sizeof(s_cacheddecalsystem) == 44, "struct s_cacheddecalsystem is invalid size");

		struct s_staticdecalcache
		{
			long bsp_number;
			c_typed_tag_block<s_cacheddecalsystem> decal_system_block;
		};
		static_assert(sizeof(s_staticdecalcache) == 16, "struct s_staticdecalcache is invalid size");

		struct s_i343unitrecorderunitrecordingreferences
		{
			c_typed_tag_reference<UNITRECORDINGDEFINITION_TAG> recording;
		};
		static_assert(sizeof(s_i343unitrecorderunitrecordingreferences) == 16, "struct s_i343unitrecorderunitrecordingreferences is invalid size");

		struct s_materialbitmapoverrideentry
		{
			string_id parameter_name;
			c_typed_tag_reference<BITMAP_TAG> bitmap;
		};
		static_assert(sizeof(s_materialbitmapoverrideentry) == 20, "struct s_materialbitmapoverrideentry is invalid size");

		struct s_materialbitmapoverrides
		{
			c_typed_tag_reference<MATERIAL_TAG> original_material_ref;
			c_typed_tag_block<s_materialbitmapoverrideentry> bitmap_overrides_block;
			c_typed_tag_reference<MATERIAL_TAG> override_material_ref;
		};
		static_assert(sizeof(s_materialbitmapoverrides) == 44, "struct s_materialbitmapoverrides is invalid size");

		struct s_scenariostaticassetplacement
		{
			string_id name;
			long guid;
			c_typed_tag_reference<ASSET_TAG> prefab_reference;
			string_id variant_name;
			real_point3d position;
			real_euler_angles3d rotation;
			real_vector3d scale;
			c_flags<e_scenarioprefabplacementflags, short, k_scenarioprefabplacementflags_count> flags;
			c_enum<e_prefabflagoverride, char> cinema_only;
			c_enum<e_prefabflagoverride, char> exclude_from_cinema;
			c_enum<e_prefabflagoverride, char> remove_from_dynamic_shadow_map;
			c_enum<e_prefabflagoverride, char> exclude_from_intel_map;
			char generated_pad651e[2]; // padding
			string_id in_game_maps_material;
			c_enum<e_prefabflagoverride, char> ignore_cubemap_volume;
			c_enum<e_prefabflagoverride, char> exclude_from_broadphase_calculation;
			c_enum<e_prefabpathfindingpolicy, char> pathfinding_policy;
			c_enum<e_prefablightmappingpolicy, char> lightmapping_policy;
			c_enum<e_staticcollisiondecalsoverridepolicy, char> collision_decals_policy;
			char generated_padb1d3[3]; // padding
			real_vector3d probe_grid_capture_offset;
			real override_lightmap_resolution_scale;
			real decorator_generator_density;
			real lod_distance_override_1;
			real lod_distance_override_2;
			real lod_distance_override_3;
			real lod_distance_override_4;
			real lod_distance_override_5;
			real lod_distance_override_6;
			real lod_distance_override_7;
			real lod_distance_override_8;
			real lod_distance_override_9;
			real lod_distance_override_10;
			real lod_distance_override_11;
			real lod_distance_override_12;
			real lod_distance_override_13;
			real lod_distance_override_14;
			real lod_distance_override_15;
			real lod_distance_override_16;
			real lod_fade_after_override;
			c_typed_tag_block<s_materialoverrideentry> instance_material_overrides_block;
			c_typed_tag_block<s_materialoverrideentry> material_overrides_block;
			c_typed_tag_block<s_materialbitmapoverrides> mask_painting_material_bitmap_overrides_block;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			c_typed_tag_reference<SCENARIO_STRUCTURE_BSP_TAG> owner_bsp;
		};
		static_assert(sizeof(s_scenariostaticassetplacement) == 236, "struct s_scenariostaticassetplacement is invalid size");

		struct s_scenarioassetcollectionplacement
		{
			string_id name;
			long guid;
			c_typed_tag_reference<ASSET_TAG> prefab_reference;
			string_id variant_name;
			real_point3d position;
			real_euler_angles3d rotation;
			real_vector3d scale;
			c_flags<e_scenarioprefabplacementflags, short, k_scenarioprefabplacementflags_count> flags;
			c_enum<e_prefabflagoverride, char> cinema_only;
			c_enum<e_prefabflagoverride, char> exclude_from_cinema;
			c_enum<e_prefabflagoverride, char> remove_from_dynamic_shadow_map;
			c_enum<e_prefabflagoverride, char> exclude_from_intel_map;
			char generated_pad651e[2]; // padding
			string_id in_game_maps_material;
			c_enum<e_prefabflagoverride, char> ignore_cubemap_volume;
			c_enum<e_prefabflagoverride, char> exclude_from_broadphase_calculation;
			c_enum<e_prefabpathfindingpolicy, char> pathfinding_policy;
			c_enum<e_prefablightmappingpolicy, char> lightmapping_policy;
			c_enum<e_staticcollisiondecalsoverridepolicy, char> collision_decals_policy;
			char generated_padb1d3[3]; // padding
			real_vector3d probe_grid_capture_offset;
			real override_lightmap_resolution_scale;
			real decorator_generator_density;
			real lod_distance_override_1;
			real lod_distance_override_2;
			real lod_distance_override_3;
			real lod_distance_override_4;
			real lod_distance_override_5;
			real lod_distance_override_6;
			real lod_distance_override_7;
			real lod_distance_override_8;
			real lod_distance_override_9;
			real lod_distance_override_10;
			real lod_distance_override_11;
			real lod_distance_override_12;
			real lod_distance_override_13;
			real lod_distance_override_14;
			real lod_distance_override_15;
			real lod_distance_override_16;
			real lod_fade_after_override;
			c_typed_tag_block<s_materialoverrideentry> instance_material_overrides_block;
			c_typed_tag_block<s_materialoverrideentry> material_overrides_block;
			c_typed_tag_block<s_materialbitmapoverrides> mask_painting_material_bitmap_overrides_block;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			c_typed_tag_reference<SCENARIO_STRUCTURE_BSP_TAG> owner_bsp;
			c_typed_tag_reference<ASSETCOLLECTION_TAG> asset_collection;
		};
		static_assert(sizeof(s_scenarioassetcollectionplacement) == 252, "struct s_scenarioassetcollectionplacement is invalid size");

		struct s_foliageassetplacement
		{
			string_id name;
			long guid;
			c_typed_tag_reference<ASSET_TAG> prefab_reference;
			string_id variant_name;
			real_point3d position;
			real_euler_angles3d rotation;
			real_vector3d scale;
			c_flags<e_scenarioprefabplacementflags, short, k_scenarioprefabplacementflags_count> flags;
			c_enum<e_prefabflagoverride, char> cinema_only;
			c_enum<e_prefabflagoverride, char> exclude_from_cinema;
			c_enum<e_prefabflagoverride, char> remove_from_dynamic_shadow_map;
			c_enum<e_prefabflagoverride, char> exclude_from_intel_map;
			char generated_pad651e[2]; // padding
			string_id in_game_maps_material;
			c_enum<e_prefabflagoverride, char> ignore_cubemap_volume;
			c_enum<e_prefabflagoverride, char> exclude_from_broadphase_calculation;
			c_enum<e_prefabpathfindingpolicy, char> pathfinding_policy;
			c_enum<e_prefablightmappingpolicy, char> lightmapping_policy;
			c_enum<e_staticcollisiondecalsoverridepolicy, char> collision_decals_policy;
			char generated_padb1d3[3]; // padding
			real_vector3d probe_grid_capture_offset;
			real override_lightmap_resolution_scale;
			real decorator_generator_density;
			real lod_distance_override_1;
			real lod_distance_override_2;
			real lod_distance_override_3;
			real lod_distance_override_4;
			real lod_distance_override_5;
			real lod_distance_override_6;
			real lod_distance_override_7;
			real lod_distance_override_8;
			real lod_distance_override_9;
			real lod_distance_override_10;
			real lod_distance_override_11;
			real lod_distance_override_12;
			real lod_distance_override_13;
			real lod_distance_override_14;
			real lod_distance_override_15;
			real lod_distance_override_16;
			real lod_fade_after_override;
			c_typed_tag_block<s_materialoverrideentry> instance_material_overrides_block;
			c_typed_tag_block<s_materialoverrideentry> material_overrides_block;
			c_typed_tag_block<s_materialbitmapoverrides> mask_painting_material_bitmap_overrides_block;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			c_typed_tag_reference<SCENARIO_STRUCTURE_BSP_TAG> owner_bsp;
			c_typed_tag_reference<FOLIAGE_ASSET_TAG> foliage_asset;
		};
		static_assert(sizeof(s_foliageassetplacement) == 252, "struct s_foliageassetplacement is invalid size");

		struct s_i343hexgridplacement
		{
			real_vector2d position;
			real bottom;
			real top;
			c_flags<e_i343hexgridhexsidehiddenflags, char, k_i343hexgridhexsidehiddenflags_count> hidden_sides;
			char generated_pad5e99[3]; // padding
		};
		static_assert(sizeof(s_i343hexgridplacement) == 20, "struct s_i343hexgridplacement is invalid size");

		struct s_i343hexgridhexplacements
		{
			c_typed_tag_block<s_i343hexgridplacement> placements_block;
			c_typed_tag_reference<ASSET_TAG> hex_grid_asset;
			c_typed_tag_reference<RUNTIME_GEO_TAG> generatedmodel;
			c_typed_tag_reference<STATIC_COLLISION_TAG> generatedcollisionmodel;
			c_typed_tag_reference<RTMP_TAG> generatedmaterialpalette;
		};
		static_assert(sizeof(s_i343hexgridhexplacements) == 76, "struct s_i343hexgridhexplacements is invalid size");

		struct s_i343hexgridruntimeplacement
		{
			real_vector3d position;
			word height;
			word hidemask;
		};
		static_assert(sizeof(s_i343hexgridruntimeplacement) == 16, "struct s_i343hexgridruntimeplacement is invalid size");

		struct s_i343hexgridquadtreenode
		{
			real_vector3d aabb_min;
			dword start_index;
			real_vector3d aabb_max;
			dword count;
		};
		static_assert(sizeof(s_i343hexgridquadtreenode) == 32, "struct s_i343hexgridquadtreenode is invalid size");

		struct s_i343hexgridhexruntime
		{
			c_typed_tag_reference<RUNTIME_GEO_TAG> runtime_geo;
			c_typed_tag_reference<RTMP_TAG> material_palette;
			c_typed_tag_block<s_i343hexgridruntimeplacement> placements_block;
			c_typed_tag_block<s_i343hexgridquadtreenode> quadtree_block;
			long long hex_runtime;
			long m_maximumvisiblesides;
			long m_maximumvisiblecaps;
		};
		static_assert(sizeof(s_i343hexgridhexruntime) == 72, "struct s_i343hexgridhexruntime is invalid size");

		struct s_structurelightdefinition
		{
			long guid;
			real_point3d position;
			real_euler_angles3d facing;
			char version;
			c_enum<e_lightboolean, char> active;
			char generated_pad2288[2]; // padding
			s_lightdefinition midnight_light_parameters;
			real indirect_amplification_factor;
			real jitter_angle;
			char is_a_lightmapper_only_light;
			c_enum<e_lightboolean, char> indirect_only;
			short runtime_index;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			c_typed_tag_reference<SCENARIO_STRUCTURE_BSP_TAG> owner_bsp;
			string_id owner_variant;
			short runtime_bsp_index;
			short runtime_variant_index;
			string_id bone_name;
			c_enum<e_lightboolean, char> should_contribute_to_adjacent_bsps;
			char generated_pad3c69[3]; // padding
			long editor_folder;
			string_id module_id;
		};
		static_assert(sizeof(s_structurelightdefinition) == 640, "struct s_structurelightdefinition is invalid size");

		struct s_visualenvironment
		{
			c_typed_tag_reference<CAMERA_FX_SETTINGS_TAG> camera_settings;
			c_typed_tag_reference<ATMOSPHERE_FOG_TAG> fog_settings;
			s_customobjectlighting custom_object_lighting;
			c_typed_tag_reference<BITMAP_TAG> cubemap_bitmap_deprecated;
		};
		static_assert(sizeof(s_visualenvironment) == 80, "struct s_visualenvironment is invalid size");

		struct s_visualenvvolume
		{
			string_id name;
			// custom dumpling_settings
			s_s_scenario_dumpling dumpling;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			// custom value
			s_visualenvironment visual_environment;
			c_typed_tag_reference<SCENARIO_STRUCTURE_BSP_TAG> owner_bsp;
			string_id owner_variant;
			short runtime_bsp_index;
			short runtime_variant_index;
		};
		static_assert(sizeof(s_visualenvvolume) == 180, "struct s_visualenvvolume is invalid size");

		struct s_i343terraindefinition
		{
			c_typed_tag_reference<TERRAIN_SYSTEM_TAG> terrain_system;
			s_genericvolume volume;
		};
		static_assert(sizeof(s_i343terraindefinition) == 88, "struct s_i343terraindefinition is invalid size");

		struct s_i343terrainplacement
		{
			s_i343terraindefinition terrain_definition;
			c_typed_tag_reference<RUNTIME_TERRAIN_TAG> runtime_terrain;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
		};
		static_assert(sizeof(s_i343terrainplacement) == 116, "struct s_i343terrainplacement is invalid size");

		struct s_i343terrainvolume
		{
			string_id name;
			s_i343terraindefinition terrain_definition;
			long volume_composition_order;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
		};
		static_assert(sizeof(s_i343terrainvolume) == 108, "struct s_i343terrainvolume is invalid size");

		struct s_levelobjects
		{
			s_anytag_struct_definition anytag;
			// custom decorators
			s_s_scenario_new_decorator_definition decorators;
			// custom value
			c_typed_tag_block<s_editor_comment_definition> comments_block;
			c_typed_tag_block<s_scenarioeditorannotation> editor_annotations_block;
			c_typed_tag_block<s_scenario_object_name> object_names_block;
			c_typed_tag_block<s_s_scenario_scenery> scenery_block;
			c_typed_tag_block<s_s_scenario_biped> bipeds_block;
			c_typed_tag_block<s_s_scenario_vehicle> vehicles_block;
			c_typed_tag_block<s_s_scenario_equipment> equipment_block;
			c_typed_tag_block<s_s_scenario_weapon> weapons_block;
			c_typed_tag_block<s_scenario_device_group> device_groups_block;
			c_typed_tag_block<s_s_scenario_machine> machines_block;
			c_typed_tag_block<s_s_scenario_terminal> terminals_block;
			c_typed_tag_block<s_s_scenario_control> controls_block;
			c_typed_tag_block<s_scenariodispenser> dispensers_block;
			c_typed_tag_block<s_s_scenario_giant> giants_block;
			c_typed_tag_block<s_s_scenario_effect_scenery> effect_scenery_block;
			c_typed_tag_block<s_s_scenario_crate> crates_block;
			c_typed_tag_block<s_s_scenario_creature> creatures_block;
			c_typed_tag_block<s_i343objectsnodegraphplacement> object_node_graph_placements_block;
			c_typed_tag_block<s_i343curvesplineplacement> splines_block;
			c_typed_tag_block<s_warzoneobjectivedefinition> warzone_objective_definitions_block;
			c_typed_tag_block<s_scenarioeffectplacement> scenario_attached_lens_flares_block;
			c_typed_tag_block<s_scenarioattachedlightcone> scenario_attached_light_cones_block;
			c_typed_tag_block<s_soundplacement> sound_placements_block;
			c_typed_tag_block<s_effectplacement> effect_placements_block;
			c_typed_tag_block<s_globalforceplacement> global_forces_block;
			c_typed_tag_block<s_hlodvolume> hlod_volumes_block;
			c_typed_tag_block<s_i343windwindinfluencervolume> wind_influencer_volumes_block;
			c_typed_tag_block<s_i343physicsphysicsvolume> physics_volumes_block;
			c_typed_tag_block<s_pruningvolume> pruning_volumes_block;
			c_typed_tag_block<s_i343aiaimarkupvolume> ai_markup_volumes_block;
			c_typed_tag_block<s_i343aiaimarkuppoint> ai_markup_points_block;
			c_typed_tag_block<s_i343botsbotmarkuppoint> bot_markup_points_block;
			c_typed_tag_block<s_i343aiencounterzone> encounter_zones_block;
			c_typed_tag_block<s_i343aiencountertreenode> encounter_tree_nodes_block;
			c_typed_tag_block<s_i343aiencounterbehaviortree> encounter_behavior_trees_block;
			c_typed_tag_block<s_i343aiplacedorder> placed_orders_block;
			c_typed_tag_block<s_i343aisquadspawner> squad_spawners_block;
			c_typed_tag_block<s_i343aireinforcementpoint> reinforcement_points_block;
			c_typed_tag_block<s_i343activatableregionactivatableregion> activatable_regions_block;
			c_typed_tag_block<s_i343activationvolume> activation_volumes_block;
			c_typed_tag_block<s_i343narrativemoment> narrative_moments_block;
			c_typed_tag_block<s_i343exampleentity> example_entities_block;
			c_typed_tag_block<s_s_scenario_soft_ceiling> soft_ceilings_block;
			c_typed_tag_block<s_scenario_starting_profile> player_starting_profile_block;
			c_typed_tag_block<s_scenario_player_starting_location> player_starting_locations_block;
			c_typed_tag_block<s_ambientactionpointinstance> ambient_action_points_block;
			c_typed_tag_block<s_scenario_trigger_volume> trigger_volumes_block;
			c_typed_tag_block<s_acousticstagzone> acoustic_zones_block;
			c_typed_tag_block<s_acousticstagportal> acoustic_portals_block;
			c_typed_tag_block<s_recorded_animation_definition> recorded_animations_block;

			/* RENDER FLUFF */

			c_typed_tag_block<s_scenario_decal> decals_block;
			c_typed_tag_block<s_areageneratordefinition> area_generators_block;
			c_typed_tag_block<s_squad_group_definition> squad_groups_block;
			c_typed_tag_block<s_s_squad_definition> squads_block;
			c_typed_tag_block<s_zone_definition> zones_block;
			c_typed_tag_block<s_user_hint_jump> nav_links_block;
			c_typed_tag_block<s_s_cookie_cutter> cookie_cutters_block;
			c_typed_tag_block<s_navmesharea> navmesh_areas_block;
			c_typed_tag_block<s_i343ainavseedpoint> navseedpoints_block;
			c_typed_tag_block<s_opportunityareadata> ai_opportunity_areas_block;
			c_typed_tag_block<s_ai_recording_reference_definition> ai_recording_references_block;
			c_typed_tag_block<s_cs_point_set> point_sets_block;
			c_typed_tag_block<s_scenario_cutscene_flag> cutscene_flags_block;
			c_typed_tag_block<s_scenario_cutscene_camera_point> cutscene_camera_points_block;
			c_typed_tag_block<s_s_scenario_cutscene_title> cutscene_titles_block;
			c_typed_tag_block<s_s_flock_instance> flocks_block;
			c_typed_tag_block<s_s_scenario_editor_folder> editor_folders_block;
			c_typed_tag_block<s_s_objective> ai_objectives_block;
			c_typed_tag_block<s_s_scenario_cheap_particle_system> neuticles_block;
			c_typed_tag_block<s_composershowstage> composer_shows_block;
			c_typed_tag_block<s_staticdecalcache> static_decal_cache_block;
			c_typed_tag_block<s_i343unitrecorderunitrecordingreferences> unit_recording_references_block;
			c_typed_tag_block<s_scenariostaticassetplacement> prefab_placements_block;
			c_typed_tag_block<s_scenarioassetcollectionplacement> asset_collection_placements_block;
			c_typed_tag_block<s_foliageassetplacement> foliage_placements_block;
			c_typed_tag_block<s_i343hexgridhexplacements> hex_placements_block;
			c_typed_tag_block<s_i343hexgridhexruntime> hex_runtime_data_block;
			c_typed_tag_block<s_structurelightdefinition> generic_light_definitions_block;
			c_typed_tag_block<s_lightmappriorityvolume> lightmap_priority_volumes_block;
			c_typed_tag_block<s_airprobedensityvolume> air_probe_density_volumes_block;
			c_typed_tag_block<s_airproberegionvolume> air_probe_region_volumes_block;
			c_typed_tag_block<s_cubemapvolume> cubemap_volumes_block;
			c_typed_tag_block<s_visualenvvolume> visual_environment_volumes_block;
			c_typed_tag_block<s_scenariobakedpvsvolume> baked_pvs_volumes_block;
			c_typed_tag_block<s_i343terrainplacement> terrains_block;
			c_typed_tag_block<s_i343terrainvolume> terrain_volumes_block;
			c_typed_tag_block<s_localstatedefinition> local_states_block;
		};
		static_assert(sizeof(s_levelobjects) == 1072, "struct s_levelobjects is invalid size");

		struct s_s_location_name_tag_definition
		{
			string_id name;
		};
		static_assert(sizeof(s_s_location_name_tag_definition) == 4, "struct s_s_location_name_tag_definition is invalid size");

		struct s_s_location_name_globals_tag_definition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_s_location_name_tag_definition> location_names_block;
			c_typed_tag_reference<STRINGLIST_TAG> location_name_string_list;
		};
		static_assert(sizeof(s_s_location_name_globals_tag_definition) == 44, "struct s_s_location_name_globals_tag_definition is invalid size");

		struct s_lodsettings
		{
			string_id name;
			c_typed_tag_reference<SIMPLYGONSETTINGS_TAG> settings_file;
		};
		static_assert(sizeof(s_lodsettings) == 20, "struct s_lodsettings is invalid size");

		struct s_lodsettingstransitiondistanceparam
		{
			real screen_space_size;
		};
		static_assert(sizeof(s_lodsettingstransitiondistanceparam) == 4, "struct s_lodsettingstransitiondistanceparam is invalid size");

		struct s_lodtransitions
		{
			real reference_bounding_sphere_radius;
			c_typed_tag_block<s_lodsettingstransitiondistanceparam> screen_space_lod_reduction_block;
		};
		static_assert(sizeof(s_lodtransitions) == 16, "struct s_lodtransitions is invalid size");

		struct s_lodsettingstag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_lodsettings> settings_block;
			c_typed_tag_block<s_lodtransitions> transitions_block;
		};
		static_assert(sizeof(s_lodsettingstag) == 40, "struct s_lodsettingstag is invalid size");

		struct s_i343levelstaticgeoplacement
		{
			s_scenariostaticassetplacement placement;
			real_vector3d bounding_center;
			real bounding_radius;
			real streaming_radius;
		};
		static_assert(sizeof(s_i343levelstaticgeoplacement) == 256, "struct s_i343levelstaticgeoplacement is invalid size");

		struct s_i343levelstaticgeobsp
		{
			c_typed_tag_reference<SCENARIO_STRUCTURE_BSP_TAG> bsp;
			c_typed_tag_block<s_i343levelstaticgeoplacement> static_placements_block;
			c_typed_tag_block<s_i343levelstaticgeoplacement> foliage_placements_block;
		};
		static_assert(sizeof(s_i343levelstaticgeobsp) == 40, "struct s_i343levelstaticgeobsp is invalid size");

		struct s_i343levelstaticgeotag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<LEVEL_TAG> source_level;
			c_flags<e_i343levelstaticgeoflags, short, k_i343levelstaticgeoflags_count> options;
			char generated_pad3038[2]; // padding
			real minimum_object_size;
			real minimum_screen_size;
			c_typed_tag_block<s_i343levelstaticgeobsp> bsps_block;
			char generated_pad4a19[4]; // padding
		};
		static_assert(sizeof(s_i343levelstaticgeotag) == 60, "struct s_i343levelstaticgeotag is invalid size");

		struct s_loopingsoundtag
		{
			s_anytag_struct_definition anytag;
			string_id start_event;
			string_id stop_event;
			string_id player_start_event;
			string_id player_stop_event;
			c_typed_tag_reference<SOUNDBANK_TAG> sound_bank;
			c_typed_tag_reference<SOUNDBANK_TAG> player_sound_bank;
			real_bounds runtime_distance_bounds;
			real maximum_radius;
			c_typed_tag_reference<SOUND_CATEGORY_TAG> category;
			c_typed_tag_reference<SOUND_CATEGORY_TAG> player_category;
			c_typed_tag_reference<SOUND_TAIL_TAG> sound_tails;
		};
		static_assert(sizeof(s_loopingsoundtag) == 124, "struct s_loopingsoundtag is invalid size");

		struct s_s_leaf_type
		{
			short bitmap_sprite_index;
			char generated_padb751[2]; // padding
			real frequency;
			real mass;
			real_bounds geometry_scale;
			real flitteriness;
			real flitteriness_swing_arm_length;
			real flitteriness_scale;
			real flitteriness_speed;
			real flitteriness_leaves_phase;
			real tumble_scale;
			real rotation_scale;
			real starting_velocity;
			real_bounds air_friction_xy_and_z;
		};
		static_assert(sizeof(s_s_leaf_type) == 60, "struct s_s_leaf_type is invalid size");

		struct s_s_leaf_system_definition
		{
			s_anytag_struct_definition anytag;
			c_flags<e_leafsystemflags, long, k_leafsystemflags_count> flags;
			string_id marker_attach_name;
			c_typed_tag_reference<BITMAP_TAG> bitmap_sprite_plate;
			real_bounds emission_rate;
			real lifetime;
			real_bounds wind_min_max;
			real wind_scale;
			real time_scale;
			real_bounds fade_distance;
			real emissions_sphere_radius;
			real movement_cylinder_radius;
			real fade_in_time;
			real fade_out_time;
			c_typed_tag_block<s_s_leaf_type> leaf_types_block;
			char generated_paddb8c[4]; // padding
		};
		static_assert(sizeof(s_s_leaf_system_definition) == 108, "struct s_s_leaf_system_definition is invalid size");

		struct s_interfacecustomizationuiscenelightsource
		{
			string_id light_name;
			real_vector3d light_position_offset;
			real_euler_angles3d facing;
			rgb_color color;
			real source_energy;
			real dimmer_value;
			real minimum_roughness;
			real fog_intensity;
			real near_attenuation;
			real far_attenuation;

			/* Shared Spot Parameters */

			real inner_cone_angle;
			real outer_cone_angle;
			real shadow_near_clip_plane;
			real shadow_far_clip_plane;
			real shadow_bias_offset;
			real shadow_filter_width;
			real near_begin;
			real far_begin;
			real camera_near_distance_fade_end;
			real camera_near_distance_fade_start;
			real camera_distance_fade_start;
			real camera_distance_fade_end;
			real area_light_radius;
			real area_light_length;
		};
		static_assert(sizeof(s_interfacecustomizationuiscenelightsource) == 120, "struct s_interfacecustomizationuiscenelightsource is invalid size");

		struct s_interfacecustomizationuicubemapvolume
		{
			string_id cubemap_name;
			real_vector3d cubemap_position_offset;
		};
		static_assert(sizeof(s_interfacecustomizationuicubemapvolume) == 16, "struct s_interfacecustomizationuicubemapvolume is invalid size");

		struct s_interfacecustomizationuilightpreset
		{
			string_id preset_name;
			c_enum<e_interfacecustomizationcoretype, short> core_type;
			c_enum<e_interfacecustomizationsocketitemtype, short> item_type;
			real dimmer_transition_time;
			c_typed_tag_block<s_interfacecustomizationuiscenelightsource> lights_block;
			c_typed_tag_block<s_interfacecustomizationuicubemapvolume> cubemap_volume_block;
		};
		static_assert(sizeof(s_interfacecustomizationuilightpreset) == 36, "struct s_interfacecustomizationuilightpreset is invalid size");

		struct s_interfacecustomizationuilightscenepreset
		{
			c_enum<e_interfacecustomizationspartancustomizationscenetypes, short> scene_type;
			char generated_padf35d[2]; // padding
			c_typed_tag_block<s_interfacecustomizationuilightpreset> light_presets_settings_block;
		};
		static_assert(sizeof(s_interfacecustomizationuilightscenepreset) == 16, "struct s_interfacecustomizationuilightscenepreset is invalid size");

		struct s_interfacecustomizationuilightpresetstag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_interfacecustomizationuilightpreset> light_presets_settings_block;
			c_typed_tag_block<s_interfacecustomizationuilightscenepreset> light_scene_presets_settings_block;
		};
		static_assert(sizeof(s_interfacecustomizationuilightpresetstag) == 40, "struct s_interfacecustomizationuilightpresetstag is invalid size");

		struct s_lightvolumepropertyscalar
		{
			c_enum<e_lightvolumestatese_input, char> input_variable;
			c_enum<e_lightvolumestatese_input, char> range_variable;
			c_enum<e_editablepropertybaseoutputmodifier, char> output_modifier;
			c_enum<e_lightvolumestatese_input, char> output_modifier_input;
			// custom mapping
			s_functiondefinition mapping;
			real runtime_m_constant_value;
			word runtime_m_flags;
			char pad[2]; // padding
		};
		static_assert(sizeof(s_lightvolumepropertyscalar) == 32, "struct s_lightvolumepropertyscalar is invalid size");

		struct s_lightvolumepropertycolor
		{
			c_enum<e_lightvolumestatese_input, char> input_variable;
			c_enum<e_lightvolumestatese_input, char> range_variable;
			c_enum<e_editablepropertybaseoutputmodifier, char> output_modifier;
			c_enum<e_lightvolumestatese_input, char> output_modifier_input;
			// custom mapping
			s_functiondefinition mapping;
			real runtime_m_constant_value;
			word runtime_m_flags;
			char pad[2]; // padding
		};
		static_assert(sizeof(s_lightvolumepropertycolor) == 32, "struct s_lightvolumepropertycolor is invalid size");

		struct s_lightvolumedefinition
		{
			// custom value
			string_id light_volume_name;
			// custom material
			// custom value
			s_material actual_material;
			// custom value
			real brightness_ratio;
			c_flags<e_lightvolumedefinitionlightvolumeflags, long, k_lightvolumedefinitionlightvolumeflags_count> flags;
			real_bounds camera_distance_range_override;
			s_lightvolumepropertyscalar length;
			s_lightvolumepropertyscalar offset;
			s_lightvolumepropertyscalar profile_density;
			s_lightvolumepropertyscalar profile_length;
			s_lightvolumepropertyscalar profile_thickness;
			c_enum<e_i343effectscoloroverridemode, char> profile_color_override_mode;
			char generated_pad4685[3]; // padding
			s_lightvolumepropertycolor profile_color;
			s_lightvolumepropertyscalar profile_alpha;
			s_lightvolumepropertyscalar profile_intensity;
			// custom value
			dword runtime_m_used_states;
			dword runtime_m_max_profile_count;
			s_gpupropertyfunctioncolor runtime_m_gpu_data;
			long long m_pipelinestates;
		};
		static_assert(sizeof(s_lightvolumedefinition) == 404, "struct s_lightvolumedefinition is invalid size");

		struct s_c_light_volume_system_definition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_lightvolumedefinition> light_volumes_block;
			char generated_pad6ee1[4]; // padding
		};
		static_assert(sizeof(s_c_light_volume_system_definition) == 32, "struct s_c_light_volume_system_definition is invalid size");

		struct s_luareferencedtagcontainer
		{
			c_typed_tag_reference<ANYTAG_TAG> tagreference;
		};
		static_assert(sizeof(s_luareferencedtagcontainer) == 16, "struct s_luareferencedtagcontainer is invalid size");

		struct s_luascripttagdefinition
		{
			s_anytag_struct_definition anytag;
			// custom import___directory
			// custom import___single_file
			string_id luafilename;
			s_tag_data luafiledata;
			c_static_string<256> luafilenamestring;
			c_typed_tag_block<s_luareferencedtagcontainer> referencedtags_block;
		};
		static_assert(sizeof(s_luascripttagdefinition) == 308, "struct s_luascripttagdefinition is invalid size");

		struct s_ingamemaplightreference
		{
			c_typed_tag_reference<LIGHT_TAG> reference;
		};
		static_assert(sizeof(s_ingamemaplightreference) == 16, "struct s_ingamemaplightreference is invalid size");

		struct s_ingamemaplightplacement
		{
			real_point3d position;
			real_point3d direction;
			real_point3d up;
		};
		static_assert(sizeof(s_ingamemaplightplacement) == 36, "struct s_ingamemaplightplacement is invalid size");

		struct s_ingamemaprendertag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_ingamemaplightreference> map_lights_block;
			c_typed_tag_block<s_ingamemaplightplacement> map_light_placements_block;
			c_typed_tag_reference<STRUCTURE_LIGHTMAP_TAG> lightmap;
			c_typed_tag_reference<DYNAMICWORLDSTATEGLOBALS_TAG> dynamic_world_state_globals;
			c_typed_tag_reference<CAMERA_FX_SETTINGS_TAG> camera_fx_settings;
			c_typed_tag_reference<INGAMEMAPMATERIALVARIATIONS_TAG> material_variations;
			c_typed_tag_reference<SCENERY_TAG> sky_object;
			real_euler_angles3d sky_orientation;
			c_typed_tag_reference<RENDER_MODEL_TAG> ray_collision_object;
			c_flags<e_ingamemaprenderflags, long, k_ingamemaprenderflags_count> flags;
			real min_z_for_fade_out;
			real max_z_for_fade_out;
			real line_frequency;
			c_enum<e_ingamemapexplicitshader, short> explicit_shader_for_explicit_lighting_pass;
			char generated_pad8e93[2]; // padding
			real_vector2d red_offset_in_pixels;
			real_vector2d blue_offset_in_pixels;
			real center_weight;
			char generated_pad41de[4]; // padding
		};
		static_assert(sizeof(s_ingamemaprendertag) == 192, "struct s_ingamemaprendertag is invalid size");

		struct s_ingamemapfunction
		{
			// custom mapping
			s_functiondefinition mapping;
		};
		static_assert(sizeof(s_ingamemapfunction) == 20, "struct s_ingamemapfunction is invalid size");

		struct s_ingamemapanimationsettings
		{
			c_enum<e_ingamemapanimationmode, short> verticaltranslationmode;
			char generated_pad6126[2]; // padding
			real verticaltranslationduration;
			real verticaltranslationcooldownduration;
			s_ingamemapfunction verticaltranslationfunction;
			c_enum<e_ingamemapanimationmode, short> zrotationmode;
			char generated_padaddb[2]; // padding
			real zrotationduration;
			real zrotationcooldownduration;
			s_ingamemapfunction zrotationfunction;
			c_enum<e_ingamemapanimationmode, short> scalemode;
			char generated_padfa90[2]; // padding
			real scaleduration;
			real scalecooldownduration;
			s_ingamemapfunction scalefunction;
		};
		static_assert(sizeof(s_ingamemapanimationsettings) == 96, "struct s_ingamemapanimationsettings is invalid size");

		struct s_i343ingamemapslodcollisionresolution
		{
			c_enum<e_i343ingamemapslodcollisionresolutionmode, short> resolutionmode;
			char generated_pad21e2[2]; // padding
			real collisionnormalizedscreendistance;
		};
		static_assert(sizeof(s_i343ingamemapslodcollisionresolution) == 8, "struct s_i343ingamemapslodcollisionresolution is invalid size");

		struct s_i343ingamemapslodtier
		{
			real fulliconandlabelwithmodelfadestart;

			/* 3D Model Fading */

			real fulliconandlabelfadestart;
		};
		static_assert(sizeof(s_i343ingamemapslodtier) == 8, "struct s_i343ingamemapslodtier is invalid size");

		struct s_i343ingamemapslodsettings
		{
			c_enum<e_i343ingamemapslodmode, short> lodmode;
			char generated_pad4e7d[2]; // padding
			s_i343ingamemapslodcollisionresolution lodcollisionresolution;
			real spotlightradiusscale;
			c_typed_tag_block<s_i343ingamemapslodtier> per_tier_settings_for_pois_block;
		};
		static_assert(sizeof(s_i343ingamemapslodsettings) == 28, "struct s_i343ingamemapslodsettings is invalid size");

		struct s_i343ingamemapsmarkercolor
		{
			c_enum<e_i343ingamemapscampaignmapmarkertype, short> markertype;
			c_enum<e_i343ingamemapscampaignmapmissiontype, short> missiontype;
			rgb_color color;
		};
		static_assert(sizeof(s_i343ingamemapsmarkercolor) == 16, "struct s_i343ingamemapsmarkercolor is invalid size");

		struct s_i343ingamemapsmarkervisibilitysettings
		{
			c_enum<e_i343ingamemapscampaignmapmissiontype, short> missiontype;
			char generated_pad5f56[2]; // padding
			real minimumzoom;
			real maximumzoom;
			real hittestrange;
			real poisnaphittestrangeminzoom;
			real poisnaphittestrangemaxzoom;
		};
		static_assert(sizeof(s_i343ingamemapsmarkervisibilitysettings) == 24, "struct s_i343ingamemapsmarkervisibilitysettings is invalid size");

		struct s_i343ingamemapsiconsettings
		{
			c_typed_tag_reference<BITMAP_DICTIONARY_TAG> fullicons;
			c_typed_tag_reference<BITMAP_DICTIONARY_TAG> smallicons;
			c_typed_tag_reference<BITMAP_DICTIONARY_TAG> detailicons;
			c_typed_tag_reference<BITMAP_DICTIONARY_TAG> highlightedoverlayicons;
			c_typed_tag_reference<BITMAP_DICTIONARY_TAG> outermissionlisticons;
			c_typed_tag_reference<BITMAP_DICTIONARY_TAG> innermissionlisticons;
			c_typed_tag_block<s_i343ingamemapsmarkercolor> markercolors_block;
			c_typed_tag_block<s_i343ingamemapsmarkervisibilitysettings> markervisibilitysettings_block;
		};
		static_assert(sizeof(s_i343ingamemapsiconsettings) == 120, "struct s_i343ingamemapsiconsettings is invalid size");

		struct s_i343ingamemapscamerasettings
		{
			c_flags<e_i343ingamemapscamerasettingsflags, char, k_i343ingamemapscamerasettingsflags_count> flags;
			char generated_pad38bd[3]; // padding
			real defaulthittestrangeminzoom;
			real defaulthittestrangemaxzoom;
			real defaultpoisnaphittestrange;
			real poisnappingthreshold;
			real playericoncollisiondistance;
			real panningvelocitydeadzone;
			real zoomingvelocitydeadzone;
			real min_pan_x;
			real min_pan_y;
			real max_pan_x;
			real max_pan_y;
			real min_zoom;
			real max_zoom;
			real tilt_point;
			real tilt_width;
			real pan_accel_duration;
			real pan_decel_duration;
			real min_pan_speed;
			real max_pan_speed;
			real highlight_distance;
			real max_zoom_factor;
			real zoom_accel_duration;
			real zoom_decel_duration;
			real max_zoom_speed;
			real mission_pan_speed;
			real autopan_time_delay;
			real mission_list_autopan_duration;
			real mission_list_autopan_zoom;
			real autopan_slow_down_speed_ratio;
			real autopan_speed;
			real autopan_slow_down_range;
			real autopanner_bezier_curve_midpoint_height;
			real autopanner_bezier_curve_p1_height;
			real autopanner_bezier_curve_p3_height;
			real duration_for_centering_on_player;
			real min_zoom_spotlight_cone_scale;
			real max_zoom_spotlight_cone_scale;
			real spotlight_moving_speed;
			real initial_pitch;
			real initial_yaw;
			real initial_zoom;
			real pan_height;
			real initial_camera_x;
			real initial_camera_y;
			real initial_camera_z;
			real initial_camera_look_x;
			real initial_camera_look_y;
			real initial_camera_look_z;
			real camera_xy_axis_offset;
			real camera_field_of_view;
			real edge_pan_screen_margin_x;
			real edge_pan_screen_margin_y;
			real help_bar_height;
		};
		static_assert(sizeof(s_i343ingamemapscamerasettings) == 216, "struct s_i343ingamemapscamerasettings is invalid size");

		struct s_i343ingamemapsmarkersettings
		{
			c_enum<e_i343ingamemapscampaignmapmarkertype, short> markertype;
			char generated_pad8446[2]; // padding
			c_typed_tag_reference<CRATE_TAG> model;
			c_typed_tag_reference<BITMAP_TAG> bitmap;
			real bitmapcorrectivescale;
		};
		static_assert(sizeof(s_i343ingamemapsmarkersettings) == 40, "struct s_i343ingamemapsmarkersettings is invalid size");

		struct s_ingamemapdisplayassetdefinition
		{
			string_id name;
			c_typed_tag_reference<CRATE_TAG> model;
			real_point3d rotation;
			real scale;
			real_point3d icon_offset;
			c_flags<e_ingamemapdisplayassetflags, char, k_ingamemapdisplayassetflags_count> flags;
			char generated_pad21a6[3]; // padding
		};
		static_assert(sizeof(s_ingamemapdisplayassetdefinition) == 52, "struct s_ingamemapdisplayassetdefinition is invalid size");

		struct s_i343ingamemapscollectiblesettings
		{
			string_id name;
			c_enum<e_i343collectiblescollectibletype, char> type;
			char generated_padf32a[1]; // padding
			c_enum<e_i343ingamemapscampaignmapmissiontype, short> missiontype;
			long spriteindex;
		};
		static_assert(sizeof(s_i343ingamemapscollectiblesettings) == 12, "struct s_i343ingamemapscollectiblesettings is invalid size");

		struct s_i343ingamemapsregionpoint
		{
			real_point3d region_point;
		};
		static_assert(sizeof(s_i343ingamemapsregionpoint) == 12, "struct s_i343ingamemapsregionpoint is invalid size");

		struct s_i343ingamemapsregionpolygon
		{
			c_typed_tag_block<s_i343ingamemapsregionpoint> region_polygon_block;
		};
		static_assert(sizeof(s_i343ingamemapsregionpolygon) == 12, "struct s_i343ingamemapsregionpolygon is invalid size");

		struct s_i343ingamemapsregionsettings
		{
			string_id name;
			c_typed_tag_block<s_i343ingamemapsregionpolygon> region_polygons_block;
		};
		static_assert(sizeof(s_i343ingamemapsregionsettings) == 16, "struct s_i343ingamemapsregionsettings is invalid size");

		struct s_i343ingamemapsvignettesettings
		{
			rgb_color color;
			real opacity;
			real innerradius;
			real outerradius;
		};
		static_assert(sizeof(s_i343ingamemapsvignettesettings) == 24, "struct s_i343ingamemapsvignettesettings is invalid size");

		struct s_ingamemapmodellookup
		{
			string_id name;
			c_typed_tag_reference<CRATE_TAG> model;
		};
		static_assert(sizeof(s_ingamemapmodellookup) == 20, "struct s_ingamemapmodellookup is invalid size");

		struct s_ingamemaptransitionsettings
		{
			real introminloadtime;
			real intrototaltransitiontime;
			real outtromaptransitiontime;
			real outtrominunloadtime;
			real outtrogameplaytransitiontime;
		};
		static_assert(sizeof(s_ingamemaptransitionsettings) == 20, "struct s_ingamemaptransitionsettings is invalid size");

		struct s_gaktileindex
		{
			long x;
			long y;
		};
		static_assert(sizeof(s_gaktileindex) == 8, "struct s_gaktileindex is invalid size");

		struct s_ingamemapgaksettings
		{
			real gak_poi_spawn_frequency;
			real gak_poi_spawn_chance;
			long gak_max_poi_count;
			long gak_poi_num_types;
			real gak_poi_lifetime_min;
			real gak_poi_lifetime_max;
			real gak_poi_fade_out;
			real gak_tile_origin_x;
			real gak_tile_origin_y;
			real gak_tile_size_x;
			real gak_tile_size_y;
			long gak_tile_count_x;
			long gak_tile_count_y;
			real gak_tile_margin;
			c_typed_tag_block<s_gaktileindex> gak_invalid_tiles_block;
		};
		static_assert(sizeof(s_ingamemapgaksettings) == 68, "struct s_ingamemapgaksettings is invalid size");

		struct s_i343ingamemapszonesetsettings
		{
			string_id zoneset_name;
			string_id point_of_interest_name;
		};
		static_assert(sizeof(s_i343ingamemapszonesetsettings) == 8, "struct s_i343ingamemapszonesetsettings is invalid size");

		struct s_i343ingamemapsplayerpositionoverridesettings
		{
			c_typed_tag_block<s_i343ingamemapszonesetsettings> zone_set_settings_block;
		};
		static_assert(sizeof(s_i343ingamemapsplayerpositionoverridesettings) == 12, "struct s_i343ingamemapsplayerpositionoverridesettings is invalid size");

		struct s_ingamemapsettingstag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_ingamemaplightreference> map_lights_block;
			c_typed_tag_block<s_ingamemaplightplacement> map_light_placements_block;
			c_typed_tag_reference<STRUCTURE_LIGHTMAP_TAG> lightmap;
			c_typed_tag_reference<DYNAMICWORLDSTATEGLOBALS_TAG> dynamic_world_state_globals;
			c_typed_tag_reference<INGAMEMAPMATERIALVARIATIONS_TAG> material_variations;
			c_typed_tag_reference<SCENERY_TAG> sky_object;
			real_euler_angles3d sky_orientation;
			c_typed_tag_reference<ASSET_TAG> ray_collision_asset;
			c_typed_tag_reference<FIXEDDEPTHQUADTREE_TAG> ray_collision_quad_tree;
			c_flags<e_ingamemaprenderflags, long, k_ingamemaprenderflags_count> flags;
			real min_z_for_fade_out;
			real max_z_for_fade_out;
			real line_frequency;
			c_enum<e_ingamemapexplicitshader, short> explicit_shader_for_explicit_lighting_pass;
			char generated_pad7316[2]; // padding
			real_vector2d red_offset_in_pixels;
			real_vector2d blue_offset_in_pixels;
			real center_weight;
			c_flags<e_i343ingamemapsmodeltypeflags, char, k_i343ingamemapsmodeltypeflags_count> animatedmodeltypes;
			char generated_pad9a6d[3]; // padding
			real mainpoimodeloffset;
			real_euler_angles3d mainpoimodelorientation;
			real mainpoimodelscale;
			c_typed_tag_reference<CRATE_TAG> basepoimodel;
			real basepoimodeloffset;
			real_euler_angles3d basepoimodelorientation;
			real basepoimodelscale;
			c_typed_tag_reference<CRATE_TAG> baseverticallinepoimodel;
			real baseverticallinepoimodeloffset;
			real_euler_angles3d baseverticallinepoimodelorientation;
			real baseverticallinepoimodelscale;
			c_typed_tag_reference<CRATE_TAG> topverticallinepoimodel;
			real topverticallinepoimodeloffset;
			real_euler_angles3d topverticallinepoimodelorientation;
			real topverticallinepoimodelscale;
			s_ingamemapanimationsettings poi_animation;
			s_i343ingamemapslodsettings lod_settings;
			s_i343ingamemapsiconsettings icon_settings;
			s_i343ingamemapscamerasettings camera_settings;
			c_typed_tag_block<s_i343ingamemapsmarkersettings> area_of_interest_settings_block;
			c_typed_tag_block<s_ingamemapdisplayassetdefinition> async_loaded_display_assets_block;
			c_typed_tag_block<s_i343ingamemapscollectiblesettings> collectible_settings_block;
			c_typed_tag_block<s_i343ingamemapsregionsettings> regions_block;
			s_i343ingamemapsvignettesettings vignette_settings;
			c_typed_tag_block<s_ingamemapmodellookup> model_dictionary_block;
			s_ingamemaptransitionsettings transition_settings;
			s_ingamemapgaksettings gak_settings;
			s_i343ingamemapsplayerpositionoverridesettings player_position_override_settings;
			char generated_padbfcb[4]; // padding
		};
		static_assert(sizeof(s_ingamemapsettingstag) == 968, "struct s_ingamemapsettingstag is invalid size");

		struct s_materialstyleinfo
		{
			c_typed_tag_reference<MATERIALSTYLES_TAG> material_style;
			string_id region_name;
		};
		static_assert(sizeof(s_materialstyleinfo) == 20, "struct s_materialstyleinfo is invalid size");

		struct s_materialtag
		{
			s_anytag_struct_definition anytag;
			s_tag_reference material_shader;
			c_typed_tag_block<s_shaderparameter> material_parameters_block;
			c_typed_tag_block<s_materialpostprocessdefinition> postprocess_definition_block;
			string_id physics_material_name;
			string_id physics_material_name_2;
			string_id physics_material_name_3;
			string_id physics_material_name_4;
			real sort_offset;
			c_enum<e_alphablendmode, char> alpha_blend_mode;
			c_enum<e_e_transparent_sort_layer, char> sort_layer;
			c_flags<e_materialmaterialflags, char, k_materialmaterialflags_count> flags;
			c_flags<e_materialmaterialrenderflags, char, k_materialmaterialrenderflags_count> render_flags;
			real taa_mask_threshold_start;
			real taa_mask_threshold_end;
			c_typed_tag_block<s_materialstyleinfo> style_info_block;
		};
		static_assert(sizeof(s_materialtag) == 100, "struct s_materialtag is invalid size");

		struct s_i343benchmarkbenchmarkdefinitionblock
		{
			c_typed_tag_reference<BENCHMARKDEFINITION_TAG> benchmark_definition;
		};
		static_assert(sizeof(s_i343benchmarkbenchmarkdefinitionblock) == 16, "struct s_i343benchmarkbenchmarkdefinitionblock is invalid size");

		struct s_s_game_globals
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<SOUND_GLOBALS_TAG> sound_globals;

			/* AI globals */

			c_typed_tag_reference<AI_GLOBALS_TAG> ai_globals_ref;
			c_typed_tag_reference<NAVIGATIONGLOBALS_TAG> navigation_globals_ref;
			c_typed_tag_reference<FORGE_GLOBALS_TAG> forge_globals;
			c_typed_tag_reference<GAME_ENGINE_GLOBALS_TAG> game_engine_globals;
			c_typed_tag_reference<MULTIPLAYER_GLOBALS_TAG> multiplayer_globals;
			c_typed_tag_reference<MULTIPLAYER_OBJECT_TYPE_LIST_TAG> global_multiplayer_object_type_list;
			c_typed_tag_reference<GAME_GLOBALS_GRENADE_LIST_TAG> grenades;
			c_typed_tag_reference<WEAPON_GLOBALS_TAG> weapon_globals;
			c_typed_tag_reference<MELEEGLOBALS_TAG> melee_globals;
			c_typed_tag_reference<GAME_MEDAL_GLOBALS_TAG> game_medal_globals;
			c_typed_tag_reference<HIGHLIGHTEVENTSGLOBALS_TAG> highlight_event_globals;
			c_typed_tag_reference<TOKENSYSTEMGLOBALSDEFINITION_TAG> token_systems_globals;
			c_typed_tag_reference<AIRDROPSYSTEMGLOBALSDEFINITION_TAG> airdrop_system_globals;

			/* Rasterizer globals */

			c_typed_tag_reference<BITMAP_USAGE_TABLE_TAG> bitmap_usage_table;
			c_typed_tag_reference<RASTERIZER_GLOBALS_TAG> rasterizer_globals_ref;

			/* Default camera fx settings */

			c_typed_tag_reference<CAMERA_FX_SETTINGS_TAG> default_camera_fx_settings$2;

			/* Default lighting settings */

			c_typed_tag_reference<LIGHTING_SETTINGS_TAG> default_lighting_settings$2;
			c_typed_tag_reference<ATMOSPHERE_FOG_TAG> default_atmosphere_definition;
			c_typed_tag_reference<LIGHTGROUP_TAG> default_light_group;
			c_typed_tag_reference<LIGHTGROUP_TAG> default_cheap_light_group;

			/* Default wind settings */

			c_typed_tag_reference<WIND_TAG> default_wind_settings$2;

			/* Default collision damage */

			c_typed_tag_reference<DAMAGE_EFFECT_TAG> collision_damage_effect;
			c_typed_tag_reference<COLLISION_DAMAGE_TAG> collision_damage;
			c_typed_tag_reference<EFFECT_GLOBALS_TAG> effect_globals;
			c_typed_tag_reference<COLLISIONFILTERDEFINITION_TAG> collision_filter;
			c_typed_tag_reference<GROUNDED_FRICTION_TAG> default_item_grounded_friction;
			c_typed_tag_reference<PLAYER_MODEL_CUSTOMIZATION_GLOBALS_TAG> player_model_customization_globals;
			c_typed_tag_reference<LOADOUT_GLOBALS_DEFINITION_TAG> loadout_globals;
			c_typed_tag_reference<GAME_PERFORMANCE_THROTTLE_TAG> game_performance_thortles_default;
			c_typed_tag_reference<SPEECHGRAMMARGLOBALS_TAG> speech_globals;
			c_typed_tag_reference<CONTROLGLOBALSDEFINITION_TAG> control_globals;
			c_typed_tag_reference<PLAYERGLOBALSDEFINITION_TAG> player_globals;
			c_typed_tag_reference<DAMAGEGLOBALSDEFINITION_TAG> damage_globals;
			c_typed_tag_reference<LOCGLOBALSDEFINITION_TAG> loc_globals;
			c_typed_tag_reference<MATERIALGLOBALSDEFINITION_TAG> material_globals;
			c_typed_tag_reference<CAMERAGLOBALSDEFINITION_TAG> camera_globals;
			c_typed_tag_reference<DIFFICULTYGLOBALSDEFINITION_TAG> difficulty_globals;
			c_typed_tag_reference<GAMEPLAYOBJECTGLOBALSDEFINITION_TAG> gameplay_object_globals;
			c_typed_tag_reference<COMPOSERGLOBALSDEFINITION_TAG> composer_globals;
			c_typed_tag_reference<GARBAGECOLLECTIONGLOBALSDEFINITION_TAG> garbage_collection_globals;
			c_typed_tag_reference<SOFTCEILINGGLOBALSDEFINITION_TAG> soft_ceiling_globals;
			c_typed_tag_reference<COLORGLOBALSDEFINITION_TAG> color_globals;
			c_typed_tag_reference<SKULLGLOBALSDEFINITION_TAG> skull_globals;
			c_typed_tag_reference<CHEATGLOBALSDEFINITION_TAG> cheat_globals;
			c_typed_tag_reference<INTERFACEGLOBALSDEFINITION_TAG> interface_globals;
			c_typed_tag_reference<SKILLRANKINGGLOBALSDEFINITION_TAG> skill_rank_globals;
			c_typed_tag_reference<CAMPAIGNGLOBALSDEFINITION_TAG> campaign_globals;
			c_typed_tag_reference<SPARTANTRACKINGGLOBALSDEFINITION_TAG> spartan_tracking_globals;
			c_typed_tag_reference<LUA_TAG> lua_refactor_file;
			c_typed_tag_reference<LUA_TAG> lua_preloaded_standard_scripts_definition_file;
			c_typed_tag_reference<LUA_TAG> custom_games_ui_markup_scripts_definition_file;
			c_typed_tag_reference<OUTLINESERVICEGLOBALSDEFINITION_TAG> outline_service_globals;
			c_typed_tag_reference<HIGHLIGHTSERVICEGLOBALSDEFINITION_TAG> highlight_service_globals;
			c_typed_tag_reference<AUDIOTHREATGLOBALS_TAG> audio_threat_globals;
			c_typed_tag_reference<PHYSICSGLOBALSDEFINITION_TAG> physics_globals;
			c_typed_tag_reference<ACTIONPRIORITYDATADEFINITIONTAG_TAG> action_system_globals;
			c_typed_tag_reference<BOTGLOBALSTAG_TAG> bot_globals;
			c_typed_tag_reference<DYNAMICWORLDSTATEGLOBALS_TAG> dws_globals;
			c_typed_tag_reference<CAGEGLOBALSDEFINITION_TAG> cage_system_globals;
			c_typed_tag_reference<OBJECTNODEGRAPH_GLOBALS_TAG> object_node_graph_globals;
			c_typed_tag_reference<GRAPHICSPRESETDEFINITIONS_TAG> preset_definitions_globals;
			c_typed_tag_reference<ASSET_CATEGORY_GLOBALS_TAG> asset_category_globals;
			c_typed_tag_reference<BENCHMARKDEFINITION_TAG> global_benchmark_definition;
			c_typed_tag_block<s_i343benchmarkbenchmarkdefinitionblock> test_benchmark_definitions_block;
			c_typed_tag_reference<TEXTUREGROUP_TAG> texture_group_globals;
			c_typed_tag_reference<CURVEDEFINITION_TAG> fixture_curve_globals;
			c_typed_tag_reference<ANIMGLOBALS_TAG> animation_globals;
			c_typed_tag_reference<EMBLEM_TAG> emblem_tag;
			c_typed_tag_reference<CHROMA_DEFINITION_TAG> chroma_animations_defintion;
			c_typed_tag_reference<NARRATIVEGLOBALS_TAG> narrative_globals;
			c_typed_tag_reference<SUBTITLEGLOBALSDEFINITION_TAG> subtitle_globals;
		};
		static_assert(sizeof(s_s_game_globals) == 1164, "struct s_s_game_globals is invalid size");

		struct s_decoratorplacementdata
		{
			c_typed_tag_reference<DECORATOR_ASSET_TAG> decorator_asset;
			real max_density;
			real_vector2d scale_range;
			real_vector2d rotation_range;
			c_enum<e_i343orientationalignment, char> orientation_alignment;
			char generated_pada6fa[3]; // padding
			real_vector2d vector_mask_angle;
			real cull_distance_scale;
			c_enum<e_i343vectormaskmode, char> vector_mask_mode;
			char generated_padf3af[3]; // padding
		};
		static_assert(sizeof(s_decoratorplacementdata) == 56, "struct s_decoratorplacementdata is invalid size");

		struct s_materialpreset
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_shaderparameter> material_parameters_block;
			c_typed_tag_block<s_decoratorplacementdata> decorator_placement_datas_block;
		};
		static_assert(sizeof(s_materialpreset) == 40, "struct s_materialpreset is invalid size");

		struct s_modeldissolveregiontimeoffset
		{
			string_id region_name;
			real region_time_offset;
		};
		static_assert(sizeof(s_modeldissolveregiontimeoffset) == 8, "struct s_modeldissolveregiontimeoffset is invalid size");

		struct s_modeldissolvedefinition
		{
			s_anytag_struct_definition anytag;
			c_flags<e_modeldissolvedefinitionflag, char, k_modeldissolvedefinitionflag_count> flags;
			c_enum<e_modeldissolvedefinitionparticlepositiontype, char> particle_spawn_position;
			char generated_padc085[2]; // padding
			real particle_spawn_random_radius;
			c_typed_tag_reference<CHEAP_PARTICLE_EMITTER_TAG> cheap_particle_emitter;
			real cheap_particle_spawn_distance_threshold;
			// custom particle_velocity_factors
			real velocity_up;
			real velocity_toward_dissolve_point;
			real velocity_toward_dissolve_surface;
			real velocity_along_dissolve_surface;
			real velocity_random;
			// custom value
			real particle_forced_speed;
			real delay;
			real duration;
			real extra_duration;
			real particle_spawn_time_offset;
			c_typed_tag_block<s_modeldissolveregiontimeoffset> per_region_time_offset_block;
			// custom effects
			c_typed_tag_reference<EFFECT_TAG> dissolve_point;
			c_typed_tag_reference<EFFECT_TAG> opposite_dissolve_point;
			c_typed_tag_reference<EFFECT_TAG> dissolve_surface;
			c_typed_tag_reference<EFFECT_TAG> bounding_sphere_center;
			// custom value
			c_typed_tag_reference<EFFECT_TAG> finish_effect;
			// custom material
			// custom value
			s_material actual_material;
			// custom value
			string_id time_offset_override_function;
			string_id marker_name_for_dissolve_center;
			char generated_pada6a4[4]; // padding
			long long m_pipelinestates;
		};
		static_assert(sizeof(s_modeldissolvedefinition) == 268, "struct s_modeldissolvedefinition is invalid size");

		struct s_i343meleemeleeadditionaldamagetag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> additional_damage_effect;
			c_typed_tag_reference<EFFECT_TAG> effect_on_hit;
		};
		static_assert(sizeof(s_i343meleemeleeadditionaldamagetag) == 48, "struct s_i343meleemeleeadditionaldamagetag is invalid size");

		struct s_s_melee_damage_parameters
		{

			/* melee damage parameters */

			real_euler_angles2d damage_pyramid_angles;
			real damage_pyramid_depth;
			real maximum_lunge_range;
			real damage_lunge_explosive_depth;
			real runtime_damage_lunge_explosive_fraction;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> melee_damage;
			s_tag_reference melee_response;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> lunge_melee_damage;
			s_tag_reference lunge_melee_response;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> empty_melee_damage;
			s_tag_reference empty_melee_response;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> clang_melee_damage;
			s_tag_reference clang_melee_response;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> clang_melee_against_melee_weapon_damage;
			s_tag_reference clang_melee_against_melee_weapon_damage_response;
			c_typed_tag_reference<EFFECT_TAG> lunge_melee_explosive_damage;
			c_typed_tag_reference<EFFECT_TAG> melee_attack_effect;
			c_typed_tag_reference<EFFECT_TAG> biped_melee_hit_effect;
		};
		static_assert(sizeof(s_s_melee_damage_parameters) == 232, "struct s_s_melee_damage_parameters is invalid size");

		struct s_i343meleemeleeframeattachmenttag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_s_melee_damage_parameters> damage_parameters_block;
			string_id animation_set;
		};
		static_assert(sizeof(s_i343meleemeleeframeattachmenttag) == 32, "struct s_i343meleemeleeframeattachmenttag is invalid size");

		struct s_i343materialeffectsdefaultdistances
		{
			real visual_effect_distance;
			real sound_effect_distance;
		};
		static_assert(sizeof(s_i343materialeffectsdefaultdistances) == 8, "struct s_i343materialeffectsdefaultdistances is invalid size");

		struct s_i343materialeffectsglobalsdefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343materialeffectsdefaultdistances> default_max_distances_block;
			char generated_pada5a3[4]; // padding
		};
		static_assert(sizeof(s_i343materialeffectsglobalsdefinition) == 32, "struct s_i343materialeffectsglobalsdefinition is invalid size");

		struct s_i343meleetargetingdefinition
		{
			// custom targeting
			angle_bounds yaw_angles;
			angle_bounds yaw_angles_lunging;
			angle_bounds pitch_angles;
			angle_bounds pitch_angles_lunging;
			angle ground_pitch_down_max;

			/* aim bending */

			angle aim_bend_yaw_max_speed;
			angle aim_bend_yaw_max;
			angle aim_bend_yaw_pitch_speed;
			angle aim_bend_yaw_pitch_up_max;
			angle aim_bend_yaw_pitch_down_max;
			// custom value
		};
		static_assert(sizeof(s_i343meleetargetingdefinition) == 56, "struct s_i343meleetargetingdefinition is invalid size");

		struct s_i343meleephysicsdefinition
		{
			// custom physics
			real lunge_maximum_speed;
			real uber_lunge_maximum_speed;
			real lunge_acceleration_time;
			real lunge_deceleration_time;
			// custom value
		};
		static_assert(sizeof(s_i343meleephysicsdefinition) == 16, "struct s_i343meleephysicsdefinition is invalid size");

		struct s_i343meleemeleeglobalsdefinition
		{
			s_anytag_struct_definition anytag;
			c_flags<e_i343meleemeleeglobalsdefinitionflags, long, k_i343meleemeleeglobalsdefinitionflags_count> flags;
			real melee_death_acceleration;
			real uber_melee_death_acceleration;
			// custom clang

			/* clang */


			/* Network sensitive fields */

			real clang_simultaneous_death_vitality_threshold;
			// custom value
			real input_hold_time;
			s_i343meleetargetingdefinition targeting;
			s_i343meleephysicsdefinition physics;
			// custom default_melee_damage
			c_typed_tag_block<s_s_melee_damage_parameters> default_damage_block;
			// custom value
		};
		static_assert(sizeof(s_i343meleemeleeglobalsdefinition) == 120, "struct s_i343meleemeleeglobalsdefinition is invalid size");

		struct s_render_model_permutation
		{
			string_id name;
			short mesh_index;
			word mesh_count;
			string_id clone_name;
		};
		static_assert(sizeof(s_render_model_permutation) == 12, "struct s_render_model_permutation is invalid size");

		struct s_render_model_region
		{
			string_id name;
			c_typed_tag_block<s_render_model_permutation> permutations_block;
		};
		static_assert(sizeof(s_render_model_region) == 16, "struct s_render_model_region is invalid size");

		struct s_render_model_node
		{
			string_id name;
			short parent_node;
			short first_child_node;
			short next_sibling_node;
			c_flags<e_rendermodelnodeflags, short, k_rendermodelnodeflags_count> flags;
			real_point3d default_translation;
			real_quaternion default_rotation;
			real_vector3d inverse_forward;
			real_vector3d inverse_left;
			real_vector3d inverse_up;
			real_point3d inverse_position;
			real inverse_scale;
			real distance_from_parent;
			// custom procedural_joint
			c_enum<e_e_render_model_node_procedure, char> procedure;
			c_enum<e_e_render_model_node_procedure_axis, char> procedure_axis;
			byte procedure_index;
			char generated_pad3a2d[1]; // padding
			short procedure_node_a;
			short procedure_node_b;
			real procedure_var_1;
			real procedure_var_2;
			real_euler_angles3d procedure_neutral_offset;
			// custom value
		};
		static_assert(sizeof(s_render_model_node) == 124, "struct s_render_model_node is invalid size");

		struct s_i343modelbonephysicsdefinition
		{
			short node;
			char generated_pad07da[2]; // padding
			real spring_coefficient;
			real_fraction dampening_fraction;
			angle max_angle;
		};
		static_assert(sizeof(s_i343modelbonephysicsdefinition) == 16, "struct s_i343modelbonephysicsdefinition is invalid size");

		struct s_render_model_marker
		{
			char region_index;
			char generated_padb0cb[3]; // padding
			dword permutation_index;
			word node_index;
			c_flags<e_render_model_markerflags, char, k_render_model_markerflags_count> flags;
			char generated_pad6416[1]; // padding
			real_point3d translation;
			real_quaternion rotation;
			real scale;
			real_vector3d direction;
		};
		static_assert(sizeof(s_render_model_marker) == 56, "struct s_render_model_marker is invalid size");

		struct s_render_model_marker_group
		{
			string_id name;
			c_typed_tag_block<s_render_model_marker> markers_block;
		};
		static_assert(sizeof(s_render_model_marker_group) == 16, "struct s_render_model_marker_group is invalid size");

		struct s_instancenodemapping
		{
			short instance_node_map_region_node_index;
		};
		static_assert(sizeof(s_instancenodemapping) == 2, "struct s_instancenodemapping is invalid size");

		struct s_defaultnodeorientations
		{
			real_quaternion rotation;
			real_point3d translation;
			real scale;
		};
		static_assert(sizeof(s_defaultnodeorientations) == 32, "struct s_defaultnodeorientations is invalid size");

		struct s_rendermodelnodeindex
		{
			short node_index;
		};
		static_assert(sizeof(s_rendermodelnodeindex) == 2, "struct s_rendermodelnodeindex is invalid size");

		struct s_rendermodelbonegroup
		{
			string_id name;
			c_typed_tag_block<s_rendermodelnodeindex> bones_block;
		};
		static_assert(sizeof(s_rendermodelbonegroup) == 16, "struct s_rendermodelbonegroup is invalid size");

		struct s_clothmeshindex
		{
			long index;
		};
		static_assert(sizeof(s_clothmeshindex) == 4, "struct s_clothmeshindex is invalid size");

		struct s_rendermodelclothmesh
		{
			dword namehash;
			c_typed_tag_block<s_clothmeshindex> meshindex_block;
			long meshlodindex;
			c_flags<e_clothmeshflags, short, k_clothmeshflags_count> flags;
			word numvertexcomponents;
			long vertexcount;
			long trianglecount;
			s_tag_data geometry;
		};
		static_assert(sizeof(s_rendermodelclothmesh) == 52, "struct s_rendermodelclothmesh is invalid size");

		struct s_rendermodelclothdata
		{
			long regionindex;
			c_typed_tag_block<s_clothmeshindex> meshindex_block;
			s_tag_data havokdata;
		};
		static_assert(sizeof(s_rendermodelclothdata) == 36, "struct s_rendermodelclothdata is invalid size");

		struct s_materialpipelinestateinfo
		{
			s_tag_reference shader;
			c_enum<e_alphablendmode, char> alpha_blend_mode;
			c_flags<e_materialpipelinestateinfomaterialpipelinestateflags, char, k_materialpipelinestateinfomaterialpipelinestateflags_count> flags;
			char generated_pad67cc[2]; // padding
		};
		static_assert(sizeof(s_materialpipelinestateinfo) == 20, "struct s_materialpipelinestateinfo is invalid size");

		struct s_render_model_definition
		{
			s_anytag_struct_definition anytag;
			string_id name;
			c_flags<e_rendermodelflags, short, k_rendermodelflags_count> flags;
			word version;
			c_enum<e_rendermodelmeshresourcepackingpolicy, long> mesh_resource_packing_policy;
			c_enum<e_rendermodeldefaultloadvariantpolicy, char> default_load_variant_policy;
			char generated_padd53e[3]; // padding
			// custom value
			long runtime_import_info_checksum;
			// custom value
			c_typed_tag_block<s_render_model_region> regions_block;
			long node_list_checksum;
			c_typed_tag_block<s_render_model_node> nodes_block;
			c_typed_tag_block<s_i343modelbonephysicsdefinition> bone_settings_block;
			c_typed_tag_block<s_render_model_marker_group> marker_groups_block;
			c_typed_tag_block<s_geometry_material> materials_block;
			c_typed_tag_block<s_error_report_category> errors_block;
			real dont_draw_over_camera_cosine_angle;
			char generated_pad21f3[4]; // padding
			s_s_render_geometry render_geometry;
			c_typed_tag_block<s_instancenodemapping> node_map_mapping_block;
			c_typed_tag_block<s_defaultnodeorientations> runtime_node_orientations_block;
			c_typed_tag_block<s_rendermodelbonegroup> bone_groups_block;
			c_typed_tag_block<s_rendermodelclothmesh> cloth_meshes_block;
			c_typed_tag_block<s_rendermodelclothdata> cloth_datas_block;
			c_typed_tag_reference<MODEL_TAG> parent_model;
			c_typed_tag_block<s_materialpipelinestateinfo> materialpipelinestateinfos_block;
			char generated_pad6ea8[4]; // padding
			long long m_instancegrouppipelinestatecache;
		};
		static_assert(sizeof(s_render_model_definition) == 412, "struct s_render_model_definition is invalid size");

		struct s_s_multiplayer_object_type
		{

			/* WARNING */

			string_id name;
			c_typed_tag_reference<OBJECT_TAG> object;
		};
		static_assert(sizeof(s_s_multiplayer_object_type) == 20, "struct s_s_multiplayer_object_type is invalid size");

		struct s_s_multiplayer_object_collection_entry
		{
			long object_type;
			real random_weight;
		};
		static_assert(sizeof(s_s_multiplayer_object_collection_entry) == 8, "struct s_s_multiplayer_object_collection_entry is invalid size");

		struct s_s_multiplayer_object_type_list
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_s_multiplayer_object_type> object_types_block;
			c_typed_tag_block<s_s_multiplayer_object_collection_entry> weapons_block;
			c_typed_tag_block<s_s_multiplayer_object_collection_entry> vehicles_block;
			c_typed_tag_block<s_s_multiplayer_object_collection_entry> grenades_block;
			c_typed_tag_block<s_s_multiplayer_object_collection_entry> equipment_block;
			long random_weapon_menu_sprite_frame;
			long random_equipment_menu_sprite_frame;
			string_id random_weapon_icon_string_id;
			string_id random_equipment_icon_string_id;
			char generated_pad97b8[4]; // padding
		};
		static_assert(sizeof(s_s_multiplayer_object_type_list) == 96, "struct s_s_multiplayer_object_type_list is invalid size");

		struct s_modelmarkerblockwithhiddenvisualregion
		{
			string_id visual_region_name;
			string_id name;
			string_id parent;
			real_point3d position;
			real_euler_angles3d rotation;
			real_vector3d scale;
			real_vector3d direction;
		};
		static_assert(sizeof(s_modelmarkerblockwithhiddenvisualregion) == 60, "struct s_modelmarkerblockwithhiddenvisualregion is invalid size");

		struct s_markergroupblockwithhiddenvisualregion
		{
			string_id group;
			c_typed_tag_block<s_modelmarkerblockwithhiddenvisualregion> markers_block;
		};
		static_assert(sizeof(s_markergroupblockwithhiddenvisualregion) == 16, "struct s_markergroupblockwithhiddenvisualregion is invalid size");

		struct s_hintmarkerblockwithhiddenvisualregion
		{
			string_id visual_region_name;
			string_id name;
			string_id parent;
			real_point3d position;
			real_euler_angles3d rotation;
			real_vector3d scale;
			real length;
		};
		static_assert(sizeof(s_hintmarkerblockwithhiddenvisualregion) == 52, "struct s_hintmarkerblockwithhiddenvisualregion is invalid size");

		struct s_hintmarkergroupblockwithhiddenvisualregion
		{
			c_enum<e_hintmarkertype, long> hint_type;
			c_typed_tag_block<s_hintmarkerblockwithhiddenvisualregion> hint_markers_block;
		};
		static_assert(sizeof(s_hintmarkergroupblockwithhiddenvisualregion) == 16, "struct s_hintmarkergroupblockwithhiddenvisualregion is invalid size");

		struct s_pathfindingmarkerblock
		{
			string_id name;
			string_id parent;
			real_point3d position;
			real radius;
			c_flags<e_pathfindingmarkerflagsdefinition, long, k_pathfindingmarkerflagsdefinition_count> flags;
		};
		static_assert(sizeof(s_pathfindingmarkerblock) == 28, "struct s_pathfindingmarkerblock is invalid size");

		struct s_targetmarkerblockwithhiddenvisualregion
		{
			string_id visual_region_name;
			string_id name;
			string_id parent;
			real_point3d position;
			real radius;
		};
		static_assert(sizeof(s_targetmarkerblockwithhiddenvisualregion) == 28, "struct s_targetmarkerblockwithhiddenvisualregion is invalid size");

		struct s_targetmarkergroupblockwithhiddenvisualregion
		{
			string_id group;
			c_typed_tag_block<s_targetmarkerblockwithhiddenvisualregion> target_markers_block;
		};
		static_assert(sizeof(s_targetmarkergroupblockwithhiddenvisualregion) == 16, "struct s_targetmarkergroupblockwithhiddenvisualregion is invalid size");

		struct s_markertag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_markergroupblockwithhiddenvisualregion> marker_groups_block;
			c_typed_tag_block<s_hintmarkergroupblockwithhiddenvisualregion> hint_marker_groups_block;
			c_typed_tag_block<s_pathfindingmarkerblock> pathfinding_markers_block;
			c_typed_tag_block<s_targetmarkergroupblockwithhiddenvisualregion> target_marker_groups_block;
		};
		static_assert(sizeof(s_markertag) == 64, "struct s_markertag is invalid size");

		struct s_i343unitsmotiontrackerattachmentvisibilityoverrides
		{
			c_flags<e_i343unitsmotiontrackervisibilityoverrideflags, char, k_i343unitsmotiontrackervisibilityoverrideflags_count> visibilityflags;
			char generated_pada9b4[3]; // padding
			angle sector_visibility_yaw_threshold;
			angle blip_visibility_yaw_threshold;
		};
		static_assert(sizeof(s_i343unitsmotiontrackerattachmentvisibilityoverrides) == 12, "struct s_i343unitsmotiontrackerattachmentvisibilityoverrides is invalid size");

		struct s_i343unitsmotiontrackerattachmentdefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343unitsmotiontrackerattachmentvisibilityoverrides> visibility_overrides_block;
			char generated_padb628[4]; // padding
		};
		static_assert(sizeof(s_i343unitsmotiontrackerattachmentdefinition) == 32, "struct s_i343unitsmotiontrackerattachmentdefinition is invalid size");

		struct s_musketeerdefinition
		{
			c_typed_tag_reference<CHARACTER_TAG> character;
		};
		static_assert(sizeof(s_musketeerdefinition) == 16, "struct s_musketeerdefinition is invalid size");

		struct s_i343musketeerdifficultytuningset
		{
			c_enum<e_i343musketeerdifficultytuningsettype, long> type;

			/* health */

			real scale_enemy_damage;
			real min_enemy_damage;
			real scale_enemy_vitality;
			real min_enemy_vitality;
			real scale_enemy_shield;
			real min_enemy_shield;
			real scale_enemy_recharge;
			real min_enemy_recharge;
			real scale_friend_damage;
			real min_friend_damage;
			real scale_friend_vitality;
			real min_friend_vitality;
			real scale_friend_shield;
			real min_friend_shield;
			real scale_friend_recharge;
			real min_friend_recharge;
			char pad0[16]; // padding

			/* ranged fire */

			real scale_rate_of_fire;
			real min_rate_of_fire;
			real scale_projectile_error;
			real min_projectile_error;
			real scale_burst_error;
			real min_burst_error;
			real scale_new_target_delay;
			real min_new_target_delay;
			real scale_burst_separation;
			real min_burst_separation;
			real scale_target_tracking;
			real min_target_tracking;
			real scale_target_leading;
			real min_target_leading;
			real scale_overcharge_chance;
			real min_overcharge_chance;
			real scale_special_fire_delay;
			real min_special_fire_delay;
			real scale_guidance_vs_player;
			real min_guidance_vs_player;
			real scale_melee_delay_base;
			real min_melee_delay_base;
			real scale_melee_delay_scale;
			real min_melee_delay_scale;
			char pad1[8]; // padding

			/* grenades */

			real scale_grenade_chance_scale;
			real min_grenade_chance_scale;
			real scale_grenade_timer_scale;
			real min_grenade_timer_scale;
			real scale_grenade_detonation_timer_scale;
			real min_grenade_detonation_timer_scale;
			real scale_grenade_arming_timer_scale;
			real min_grenade_arming_timer_scale;
			real scale_grenade_velocity_scale;
			real min_grenade_velocity_scale;

			/* placement */

			real scale_major_upgrade_normal;
			real min_major_upgrade_normal;
			real scale_major_upgrade_few;
			real min_major_upgrade_few;
			real scale_major_upgrade_many;
			real min_major_upgrade_many;

			/* vehicles */

			real scale_player_vehicle_ram_chance;
			real min_player_vehicle_ram_chance;
			real scale_trick_dodge_chance_scale;
			real min_trick_dodge_chance_scale;
			real scale_vehicle_boarding_chance;
			real min_vehicle_boarding_chance;

			/* cover */

			real scale_hide_time;
			real min_hide_time;
			real scale_shield_fraction_hide;
			real min_shield_fraction_hide;
			real scale_cover_vitality_threshold;
			real min_cover_vitality_threshold;
			real scale_bunker_open_duration;
			real min_bunker_open_duration;
			real scale_bunker_closed_duration;
			real min_bunker_closed_duration;
			char pad2[8]; // padding

			/* global kung fu */

			real scale_max_attackers;
			real min_max_attackers;

			/* threat tokens */

			real scale_max_high_tokens;
			real min_max_high_tokens;
			real scale_max_low_tokens;
			real min_max_low_tokens;
			real scale_max_engagement_tokens;
			real min_max_engagement_tokens;

			/* grenade tokens */

			real scale_max_grenade_tokens;
			real min_max_grenade_tokens;
			real scale_grenade_token_cooldown;
			real min_grenade_token_cooldown;

			/* effectiveness tokens */

			real scale_max_effectiveness_tokens;
			real min_max_effectiveness_tokens;

			/* weapon fidget */

			real scale_weapon_fidget_chance_per_second;
			real min_weapon_fidget_chance_per_second;

			/* Damage Scaling */

			real scale_damage_received_from_enemy_ai;
			real min_damage_received_from_enemy_ai;
		};
		static_assert(sizeof(s_i343musketeerdifficultytuningset) == 396, "struct s_i343musketeerdifficultytuningset is invalid size");

		struct s_i343musketeerdifficultytunings
		{
			c_typed_tag_block<s_i343musketeerdifficultytuningset> tuning_sets_block;

			/* clamps */

			real minimum_value_for_starting_accuracy;
			real minimum_value_for_ending_accuracy;
		};
		static_assert(sizeof(s_i343musketeerdifficultytunings) == 20, "struct s_i343musketeerdifficultytunings is invalid size");

		struct s_musketeerteamdefinition
		{
			c_typed_tag_block<s_musketeerdefinition> musketeer_block;
			c_typed_tag_block<s_i343musketeerdifficultytunings> difficulty_tunings_block;
		};
		static_assert(sizeof(s_musketeerteamdefinition) == 24, "struct s_musketeerteamdefinition is invalid size");

		struct s_musketeertoedefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_musketeerteamdefinition> musketeer_teams_block;
			char generated_pad4122[4]; // padding
		};
		static_assert(sizeof(s_musketeertoedefinition) == 32, "struct s_musketeertoedefinition is invalid size");

		struct s_teamdefinition
		{
			string_id name;
			rgb_color primary_color;
			rgb_color secondary_color;
			// custom __emblem_data
			string_id themename;
			string_id emblemshadername;
			string_id coatingname;
			string_id markername;
			// custom value
		};
		static_assert(sizeof(s_teamdefinition) == 44, "struct s_teamdefinition is invalid size");

		struct s_s_multiplayer_universal_globals_definition
		{
			c_typed_tag_block<s_teamdefinition> teams_block;
			c_typed_tag_block<s_scenario_starting_profile> player_starting_profile_block;
			c_typed_tag_reference<STRINGLIST_TAG> random_player_names_v2;
			c_typed_tag_reference<STRINGLIST_TAG> team_names_v2;
			c_typed_tag_reference<STRINGLIST_TAG> disposition_labels_v2;
			c_typed_tag_reference<STRINGLIST_TAG> random_bot_names_v2;
			c_enum<e_mvarscriptcompilemode, char> mvar_scripts_compile_mode;
			char generated_pad1ab1[3]; // padding
		};
		static_assert(sizeof(s_s_multiplayer_universal_globals_definition) == 92, "struct s_s_multiplayer_universal_globals_definition is invalid size");

		struct s_soundblock
		{
			c_typed_tag_reference<SOUND_TAG> sound;
		};
		static_assert(sizeof(s_soundblock) == 16, "struct s_soundblock is invalid size");

		struct s_loopingsoundblock
		{
			c_typed_tag_reference<SOUND_LOOPING_TAG> looping_sound;
		};
		static_assert(sizeof(s_loopingsoundblock) == 16, "struct s_loopingsoundblock is invalid size");

		struct s_s_multiplayer_constants
		{

			/* PLAYER SPAWN INFLUENCERS */

			c_typed_tag_reference<SPAWNSETTINGS_TAG> default_spawn_settings;

			/* MORE MP CONSTANTS */

			real teleporter_recharge_time;
			c_typed_tag_reference<EFFECT_TAG> sandbox_effect;
			string_id blocked_teleporter_string;

			/* RESPAWN STRINGS */

			string_id voluntary_respawn_control_instructions;
			string_id spawn_allowed_default_respawn;
			string_id spawn_at_player_allowed_looking_at_self;
			string_id spawn_at_player_allowed_looking_at_target;
			string_id spawn_at_player_allowed_looking_at_potential_target;
			string_id spawn_at_territory_allowed_looking_at_target;
			string_id spawn_at_territory_allowed_looking_at_potential_target;
			string_id you_are_out_of_lives;
			string_id invalid_spawn_target_selected;
			string_id targetted_player_enemies_nearby;
			string_id targetted_player_unfriendly_team;
			string_id targetted_player_dead;
			string_id targetted_player_in_combat;
			string_id targetted_player_too_far_from_owned_flag;
			string_id no_available_netpoints;
			string_id targetted_netpoint_contested;
		};
		static_assert(sizeof(s_s_multiplayer_constants) == 104, "struct s_s_multiplayer_constants is invalid size");

		struct s_s_multiplayer_runtime_globals_definition
		{
			c_typed_tag_reference<OBJECT_TAG> editor_helper;
			c_typed_tag_block<s_soundblock> sounds_block;
			c_typed_tag_block<s_loopingsoundblock> looping_sounds_block;
			c_typed_tag_block<s_s_multiplayer_constants> multiplayer_constants_block;
			c_typed_tag_reference<MATERIAL_TAG> hill_shader;
			c_typed_tag_reference<MATERIAL_TAG> spline_shader;
			c_typed_tag_reference<SIMULATION_INTERPOLATION_TAG> default_biped_simulation_interpolation;
			c_typed_tag_reference<SIMULATION_INTERPOLATION_TAG> default_vehicle_simulation_interpolation;
			c_typed_tag_reference<SIMULATION_INTERPOLATION_TAG> default_crate_simulation_interpolation;
			c_typed_tag_reference<SIMULATION_INTERPOLATION_TAG> default_item_simulation_interpolation;
			c_typed_tag_reference<SIMULATION_INTERPOLATION_TAG> default_projectile_simulation_interpolation;
			c_typed_tag_reference<SIMULATION_INTERPOLATION_TAG> default_object_simulation_interpolation;
			long long m_hillpipelinestate;
			long long m_splinepipelinestate;
			c_typed_tag_reference<SUPPLYLINESSYSTEMGLOBALSDEFINITION_TAG> supply_lines_system_globals;
			c_typed_tag_reference<PERSONALAIGLOBALSDEFINITION_TAG> personal_ai_globals;
			c_typed_tag_reference<SPOTTINGSERVICEGLOBALS_TAG> spotting_service_globals;
			c_typed_tag_reference<WEAPON_TAG> unarmed_weapon_reference;
		};
		static_assert(sizeof(s_s_multiplayer_runtime_globals_definition) == 260, "struct s_s_multiplayer_runtime_globals_definition is invalid size");

		struct s_s_multiplayer_globals_definition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_s_multiplayer_universal_globals_definition> universal_block;
			c_typed_tag_block<s_s_multiplayer_runtime_globals_definition> runtime_block;
		};
		static_assert(sizeof(s_s_multiplayer_globals_definition) == 40, "struct s_s_multiplayer_globals_definition is invalid size");

		struct s_musicactionblockdefinition
		{
			c_enum<e_musicactionblockdefinitione_musicactiontype, long> music_action;
			string_id name;
			long event_or_group_name_hash;
			string_id group_value;
			long value;
			real delay_time;
		};
		static_assert(sizeof(s_musicactionblockdefinition) == 24, "struct s_musicactionblockdefinition is invalid size");

		struct s_musiccontroldefinition
		{
			s_anytag_struct_definition anytag;
			c_flags<e_musiccontrolflag, long, k_musiccontrolflag_count> flags;
			c_typed_tag_block<s_musicactionblockdefinition> music_action_list_block;
			long event_priority;
			// custom damage_listener
			c_enum<e_musiccontroldefinitione_musiclistenerstate, long> force_damage_listener;
			c_flags<e_damagelistenerflag, long, k_damagelistenerflag_count> damage_listener_flags;
			short damage_threshold;
			short enemy_tracking_proximity;
			// custom value
			// custom combat_intensity
			c_enum<e_musiccontroldefinitione_musiclistenerstate, long> enable_comabat_intensities;
			short low_combat_threshold;
			short medium_combat_threshold;
			short high_combat_threshold;
			short transition_up_slew;
			short transition_down_slew;
			short tracking_weighted_average_slew_time;
			// custom value
			c_typed_tag_reference<SOUNDBANK_TAG> sound_bank;
			char generated_pad4359[4]; // padding
		};
		static_assert(sizeof(s_musiccontroldefinition) == 84, "struct s_musiccontroldefinition is invalid size");

		struct s_materialswatchentry
		{
			string_id name;
			c_typed_tag_reference<MATERIALSWATCH_TAG> swatch;
			string_id color;
			c_enum<e_materialroughnessoverride, char> roughnessoverride;
			char generated_pade215[3]; // padding
			// custom emissive
			real emissiveintensity;
			real emissiveamount;
			// custom value
			string_id notes;
			string_id groupname;
		};
		static_assert(sizeof(s_materialswatchentry) == 44, "struct s_materialswatchentry is invalid size");

		struct s_materialpalettetag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_materialswatchentry> swatches_block;
			char generated_pad0d32[4]; // padding
		};
		static_assert(sizeof(s_materialpalettetag) == 32, "struct s_materialpalettetag is invalid size");

		struct s_materialcolorvariants
		{
			string_id name;
			rgb_color gradient_top_color;
			rgb_color gradient_mid_color;
			rgb_color gradient_bottom_color;
			string_id notes;
			string_id groupname;
		};
		static_assert(sizeof(s_materialcolorvariants) == 48, "struct s_materialcolorvariants is invalid size");

		struct s_materialswatchtag
		{
			s_anytag_struct_definition anytag;
			// custom base
			real_vector2d colorandroughnesstexturetransform;
			real_vector2d normaltexturetransform;
			c_typed_tag_reference<BITMAP_TAG> color_gradient_map;
			real roughness_white;
			real roughness_black;
			c_typed_tag_reference<BITMAP_TAG> normal_detail_map;
			real metallic;
			real ior;
			real albedo_tint_spec;
			real sss_strength;
			// custom value
			// custom scratches
			rgb_color scratch_color;
			real scratch_brightness;
			real scratch_roughness;
			real scratch_metallic;
			real scratch_ior;
			real scratch_albedo_tint_spec;
			// custom value
			// custom subsurface
			real sss_intensity;
			// custom value
			c_typed_tag_block<s_materialcolorvariants> color_variants_block;
		};
		static_assert(sizeof(s_materialswatchtag) == 136, "struct s_materialswatchtag is invalid size");

		struct s_materialregion
		{
			string_id name;
		};
		static_assert(sizeof(s_materialregion) == 4, "struct s_materialregion is invalid size");

		struct s_coatingmaterialsetreference
		{
			c_typed_tag_reference<COATINGMATERIALSET_TAG> coatingmaterialset;
		};
		static_assert(sizeof(s_coatingmaterialsetreference) == 16, "struct s_coatingmaterialsetreference is invalid size");

		struct s_materiallayer
		{
			string_id name;
			c_enum<e_materialstate, char> hero_reveal;
			c_enum<e_materialstate, char> color_blend;
			c_enum<e_materialstate, char> normal_blend;
			c_enum<e_materialstate, char> ignore_texel_density_scalar;
			rgb_color forge_color_top;
			rgb_color forge_color_mid;
			rgb_color forge_color_bottom;
			real forge_color_intensity;
			real forge_layer_opacity;
			real forge_max_roughness;
			c_enum<e_materialstate, char> forge_override_metallic;
			c_enum<e_materialstate, char> forge_metallic;
			char generated_pad910e[2]; // padding
		};
		static_assert(sizeof(s_materiallayer) == 60, "struct s_materiallayer is invalid size");

		struct s_materialstyleregion
		{
			string_id name;
			short coating_material_set;
			char generated_pad4b96[2]; // padding
			c_typed_tag_block<s_materiallayer> layers_block;
			long layers_flags;
			long layers_vector1;
			long layers_vector2;
		};
		static_assert(sizeof(s_materialstyleregion) == 32, "struct s_materialstyleregion is invalid size");

		struct s_materialstyle
		{
			string_id name;
			c_typed_tag_reference<MATERIALPALETTE_TAG> palette;
			string_id global_damage;
			string_id hero_damage;
			string_id global_emissive;
			real emissive_amount;
			real scratch_amount;
			string_id grime_type;
			real grime_amount;
			c_typed_tag_block<s_materialstyleregion> regions_block;
			long regions_flags;
			long regions_vector1;
			long regions_vector2;
		};
		static_assert(sizeof(s_materialstyle) == 72, "struct s_materialstyle is invalid size");

		struct s_preloadswatchentry
		{
			c_typed_tag_reference<MATERIALSWATCH_TAG> swatch;
		};
		static_assert(sizeof(s_preloadswatchentry) == 16, "struct s_preloadswatchentry is invalid size");

		struct s_materialstylestag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_materialregion> regions_block;
			long regions_flags;
			long regions_vector1;
			long regions_vector2;
			c_typed_tag_block<s_coatingmaterialsetreference> coatingmaterialsets_block;
			long coatingmaterialsets_flags;
			long coatingmaterialsets_vector1;
			long coatingmaterialsets_vector2;
			c_typed_tag_block<s_materialstyle> style_block;
			long style_flags;
			long style_vector1;
			long style_vector2;
			short defaultlookindex;
			char generated_pad7113[2]; // padding
			c_typed_tag_reference<MATERIALVISORSWATCH_TAG> visorswatch;
			c_flags<e_materialstylestagpreloadswatchoptionflags, char, k_materialstylestagpreloadswatchoptionflags_count> preload_swatch_options;
			char generated_pad245e[3]; // padding
			c_typed_tag_block<s_preloadswatchentry> preloaded_swatches_block;
		};
		static_assert(sizeof(s_materialstylestag) == 124, "struct s_materialstylestag is invalid size");

		struct s_materialvisorpatternreference
		{
			string_id name;
			c_typed_tag_reference<MATERIALSWATCH_TAG> visorpattern;
		};
		static_assert(sizeof(s_materialvisorpatternreference) == 20, "struct s_materialvisorpatternreference is invalid size");

		struct s_materialvisorswatchtag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_materialvisorpatternreference> pattern_variants_block;
			c_typed_tag_block<s_materialcolorvariants> color_variants_block;
		};
		static_assert(sizeof(s_materialvisorswatchtag) == 40, "struct s_materialvisorswatchtag is invalid size");

		struct s_navigationglobalsdata
		{
			real clearance_bucket_radius___small;
			real clearance_bucket_radius___medium;
			real clearance_bucket_radius___large;
			real hoist_path_cost;
			real smash_path_cost;
			real destroy_path_cost;
		};
		static_assert(sizeof(s_navigationglobalsdata) == 24, "struct s_navigationglobalsdata is invalid size");

		struct s_navigationglobalsdefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_navigationglobalsdata> data_block;
			char generated_padddbd[4]; // padding
		};
		static_assert(sizeof(s_navigationglobalsdefinition) == 32, "struct s_navigationglobalsdefinition is invalid size");

		struct s_i343narrativenarrativefirsttofirsttransitionpreset
		{
			string_id name;
			real camera_blend_in_time;
			c_enum<e_i343curvecurvebuiltin, char> camera_blend_in_curve;
			char generated_pada170[3]; // padding
			real camera_blend_out_time;
			c_enum<e_i343curvecurvebuiltin, char> camera_blend_out_curve;
			char generated_padbb51[3]; // padding
			s_composerfirsttofirsttransition transition_data;
		};
		static_assert(sizeof(s_i343narrativenarrativefirsttofirsttransitionpreset) == 100, "struct s_i343narrativenarrativefirsttofirsttransitionpreset is invalid size");

		struct s_i343narrativenarrativeglobalstag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343narrativenarrativefirsttofirsttransitionpreset> first_to_first_transitions_block;
			char generated_pad40b9[4]; // padding
		};
		static_assert(sizeof(s_i343narrativenarrativeglobalstag) == 32, "struct s_i343narrativenarrativeglobalstag is invalid size");

		struct s_interfacenavpointspritekeyframe
		{
			c_flags<e_interfacenavpointspritekeyframeflags, long, k_interfacenavpointspritekeyframeflags_count> flags;
			c_enum<e_interfacenavpointtagspritesequence, long> sequenceindex;
			real_point2d width_and_height;
			rgb_color color;
			real alpha;
		};
		static_assert(sizeof(s_interfacenavpointspritekeyframe) == 32, "struct s_interfacenavpointspritekeyframe is invalid size");

		struct s_interfacenavpointtwocolorkeyframe
		{
			c_flags<e_interfacenavpointtwocolorkeyframeflags, long, k_interfacenavpointtwocolorkeyframeflags_count> flags;
			real_point2d width_and_height;
			rgb_color left_color;
			rgb_color right_color;
			real alpha;
		};
		static_assert(sizeof(s_interfacenavpointtwocolorkeyframe) == 40, "struct s_interfacenavpointtwocolorkeyframe is invalid size");

		struct s_interfacenavpointkeyframe
		{
			c_flags<e_interfacenavpointkeyframeflags, long, k_interfacenavpointkeyframeflags_count> flags;
			real_point2d width_and_height;
			rgb_color color;
			real alpha;
		};
		static_assert(sizeof(s_interfacenavpointkeyframe) == 28, "struct s_interfacenavpointkeyframe is invalid size");

		struct s_interfacenavpointnavpointanimationdefinition
		{
			s_anytag_struct_definition anytag;
			c_enum<e_interfacenavpointelooping, long> loop_type;
			real total_time_animation_runs_for;
			real delay_before_looping;
			s_scalarfunctionname progress_time_function;

			/* center sprite bg */

			s_interfacenavpointspritekeyframe center_sprite_bg$2;

			/* center sprite fg */

			s_interfacenavpointspritekeyframe center_sprite_fg$2;

			/* center radial progress bar */

			s_interfacenavpointtwocolorkeyframe center_radial_progress_bar$2;

			/* top sprite */

			s_interfacenavpointspritekeyframe top_sprite$2;

			/* top center sprite */

			s_interfacenavpointspritekeyframe top_center_sprite$2;

			/* top label */

			s_interfacenavpointkeyframe top_label$2;

			/* right progress bar */

			s_interfacenavpointtwocolorkeyframe right_progress_bar$2;

			/* right progress bar 2 */

			s_interfacenavpointtwocolorkeyframe right_progress_bar_2$2;

			/* right label */

			s_interfacenavpointkeyframe right_label$2;

			/* right timer */

			s_interfacenavpointkeyframe right_timer$2;

			/* left timer */

			s_interfacenavpointkeyframe left_timer$2;

			/* yaw sprite */

			s_interfacenavpointspritekeyframe yaw_sprite$2;
			char generated_pada240[4]; // padding
		};
		static_assert(sizeof(s_interfacenavpointnavpointanimationdefinition) == 444, "struct s_interfacenavpointnavpointanimationdefinition is invalid size");

		struct s_interfacenavpointgenericlayout
		{
			real_point2d width_and_height;
			real alpha;
		};
		static_assert(sizeof(s_interfacenavpointgenericlayout) == 12, "struct s_interfacenavpointgenericlayout is invalid size");

		struct s_interfacenavpointrotatedspritelayout
		{
			real_point2d width_and_height;
			real alpha;
			real pivot_offset;
		};
		static_assert(sizeof(s_interfacenavpointrotatedspritelayout) == 16, "struct s_interfacenavpointrotatedspritelayout is invalid size");

		struct s_interfacenavpointnavpointlayoutdefinition
		{
			s_anytag_struct_definition anytag;
			real morph_fraction;
			real_point2d anchor_offset;
			real_point2d center_box_width_height;

			/* center sprite bg */

			s_interfacenavpointgenericlayout center_sprite_bg$2;

			/* center sprite fg */

			s_interfacenavpointgenericlayout center_sprite_fg$2;

			/* center radial progress bar */

			s_interfacenavpointgenericlayout center_radial_progress_bar$2;

			/* top sprite */

			s_interfacenavpointgenericlayout top_sprite$2;

			/* top center sprite */

			s_interfacenavpointgenericlayout top_center_sprite$2;

			/* top label */

			s_interfacenavpointgenericlayout top_label$2;

			/* right progress bar */

			s_interfacenavpointgenericlayout right_progress_bar$2;

			/* right progress bar 2 */

			s_interfacenavpointgenericlayout right_progress_bar_2$2;

			/* right label */

			s_interfacenavpointgenericlayout right_label$2;

			/* right timer */

			s_interfacenavpointgenericlayout right_timer$2;

			/* left timer */

			s_interfacenavpointgenericlayout left_timer$2;

			/* yaw sprite */

			s_interfacenavpointrotatedspritelayout yaw_sprite$2;
		};
		static_assert(sizeof(s_interfacenavpointnavpointlayoutdefinition) == 184, "struct s_interfacenavpointnavpointlayoutdefinition is invalid size");

		struct s_interfacenavpointspriteparameterstag
		{
			argb_color color;
			c_enum<e_interfacenavpointespritesequence, long> sequence_index;
			c_enum<e_interfacenavpointelooping, long> flipbook_loop_type;
			real flipbook_delay_before_looping;
			c_flags<e_interfacenavpointdrawwhenflags, long, k_interfacenavpointdrawwhenflags_count> drawing_flags;
		};
		static_assert(sizeof(s_interfacenavpointspriteparameterstag) == 32, "struct s_interfacenavpointspriteparameterstag is invalid size");

		struct s_interfacenavpointradialprogressbarparameterstag
		{
			argb_color left_color;
			argb_color right_color;
			c_enum<e_interfacenavpointtagspritesequence, long> sequenceindex;
			real fraction;
			c_flags<e_interfacenavpointdrawwhenflags, long, k_interfacenavpointdrawwhenflags_count> drawing_flags;
		};
		static_assert(sizeof(s_interfacenavpointradialprogressbarparameterstag) == 44, "struct s_interfacenavpointradialprogressbarparameterstag is invalid size");

		struct s_interfacenavpointlabelparameterstag
		{
			argb_color color;
			string_id label;
			c_flags<e_interfacenavpointdrawwhenflags, long, k_interfacenavpointdrawwhenflags_count> drawing_flags;
		};
		static_assert(sizeof(s_interfacenavpointlabelparameterstag) == 24, "struct s_interfacenavpointlabelparameterstag is invalid size");

		struct s_interfacenavpointprogressbarparameterstag
		{
			argb_color left_color;
			argb_color right_color;
			real fraction;
			c_flags<e_interfacenavpointdrawwhenflags, long, k_interfacenavpointdrawwhenflags_count> drawing_flags;
		};
		static_assert(sizeof(s_interfacenavpointprogressbarparameterstag) == 40, "struct s_interfacenavpointprogressbarparameterstag is invalid size");

		struct s_interfacenavpointnumericparameterstag
		{
			argb_color color;
			c_enum<e_interfacenavpointenumberformat, long> number_format;
			real number;
			c_flags<e_interfacenavpointdrawwhenflags, long, k_interfacenavpointdrawwhenflags_count> drawing_flags;
		};
		static_assert(sizeof(s_interfacenavpointnumericparameterstag) == 28, "struct s_interfacenavpointnumericparameterstag is invalid size");

		struct s_interfacenavpointrotatedspriteparameterstag
		{
			argb_color color;
			c_enum<e_interfacenavpointtagspritesequence, long> sequence_index;
			c_flags<e_interfacenavpointdrawwhenflags, long, k_interfacenavpointdrawwhenflags_count> drawing_flags;
		};
		static_assert(sizeof(s_interfacenavpointrotatedspriteparameterstag) == 24, "struct s_interfacenavpointrotatedspriteparameterstag is invalid size");

		struct s_interfacenavpointanimationparameterstag
		{
			c_enum<e_interfacenavpointeanimation, long> animation_type;
			c_flags<e_interfacenavpointdrawwhenflags, long, k_interfacenavpointdrawwhenflags_count> drawing_flags;
		};
		static_assert(sizeof(s_interfacenavpointanimationparameterstag) == 8, "struct s_interfacenavpointanimationparameterstag is invalid size");

		struct s_interfacenavpointnavpointparameterstagdefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<NAVPOINTPARAMETERSTAG_TAG> navpoint_tag;
			c_flags<e_interfacenavpointdatumflags, long, k_interfacenavpointdatumflags_count> navpoint_flags;

			/* center sprite bg */

			s_interfacenavpointspriteparameterstag center_sprite_bg$2;

			/* center sprite fg */

			s_interfacenavpointspriteparameterstag center_sprite_fg$2;

			/* center radial progress bar */

			s_interfacenavpointradialprogressbarparameterstag center_radial_progress_bar$2;

			/* top sprite */

			s_interfacenavpointspriteparameterstag top_sprite$2;

			/* top center sprite */

			s_interfacenavpointspriteparameterstag top_center_sprite$2;

			/* top label */

			s_interfacenavpointlabelparameterstag top_label$2;

			/* right progress bar */

			s_interfacenavpointprogressbarparameterstag right_progress_bar$2;

			/* right progress bar 2 */

			s_interfacenavpointprogressbarparameterstag right_progress_bar_2$2;

			/* right label */

			s_interfacenavpointlabelparameterstag right_label$2;

			/* right timer */

			s_interfacenavpointnumericparameterstag right_timer$2;

			/* left timer */

			s_interfacenavpointnumericparameterstag left_timer$2;

			/* yaw sprite */

			s_interfacenavpointrotatedspriteparameterstag yaw_sprite$2;

			/* animation */

			s_interfacenavpointanimationparameterstag animation$2;
			char generated_padfb2e[4]; // padding
		};
		static_assert(sizeof(s_interfacenavpointnavpointparameterstagdefinition) == 428, "struct s_interfacenavpointnavpointparameterstagdefinition is invalid size");

		struct s_nodegraphcontentgraphreference
		{
			c_typed_tag_reference<NODEGRAPH_TAG> graph_reference;
		};
		static_assert(sizeof(s_nodegraphcontentgraphreference) == 16, "struct s_nodegraphcontentgraphreference is invalid size");

		struct s_nodegraphcontenttagreferenceingraph
		{
			c_typed_tag_reference<ANYTAG_TAG> tag_reference;
		};
		static_assert(sizeof(s_nodegraphcontenttagreferenceingraph) == 16, "struct s_nodegraphcontenttagreferenceingraph is invalid size");

		struct s_nodegraphcontentnodegraphcontenttag
		{
			s_anytag_struct_definition anytag;
			s_tag_data graphcontent;
			c_typed_tag_block<s_nodegraphcontentgraphreference> graph_references_block;
			c_typed_tag_block<s_nodegraphcontenttagreferenceingraph> tag_references_block;
			c_enum<e_nodegraphexportstatus, long> graph_export_status;
			char generated_padefa8[4]; // padding
		};
		static_assert(sizeof(s_nodegraphcontentnodegraphcontenttag) == 68, "struct s_nodegraphcontentnodegraphcontenttag is invalid size");

		struct s_interfacenodegraphtransitiondefinition
		{
			string_id event;
			string_id target_node;
			c_static_string<256> out_animation_name;
			c_static_string<256> in_animation_name;
			c_flags<e_interfacenodegraphtransitiondefinitionflags, long, k_interfacenodegraphtransitiondefinitionflags_count> flags;
			real editor_from_angle;
			real editor_to_angle;
			real editor_bezier_from_x;
			real editor_bezier_from_y;
			real editor_bezier_to_x;
			real editor_bezier_to_y;
			real editor_caption_x;
			real editor_caption_y;
		};
		static_assert(sizeof(s_interfacenodegraphtransitiondefinition) == 556, "struct s_interfacenodegraphtransitiondefinition is invalid size");

		struct s_interfacenodegraphnodegraphstackreferencedefinition
		{
			c_typed_tag_reference<NODE_GRAPH_STACK_TAG> child_stack_reference;
		};
		static_assert(sizeof(s_interfacenodegraphnodegraphstackreferencedefinition) == 16, "struct s_interfacenodegraphnodegraphstackreferencedefinition is invalid size");

		struct s_interfacenodegraphnodedefinition
		{
			string_id name;
			string_id placement_node_name;
			c_typed_tag_block<s_interfacenodegraphtransitiondefinition> transitions_block;
			c_enum<e_interfacescreenscreenwrappertype, long> screen_wrapper;
			s_tag_reference screen_reference;
			c_typed_tag_reference<SCREENDEFINITION_TAG> fui_screen_reference;
			string_id uri_name;
			c_enum<e_interfacenodegraphslamsnodetype, long> slams_node_type;
			c_enum<e_interfacenodegrapheloadingmode, long> loading_mode;
			c_typed_tag_block<s_interfacenodegraphnodegraphstackreferencedefinition> child_stacks_block;
			c_flags<e_interfacenodegraphnodegraphflags, long, k_interfacenodegraphnodegraphflags_count> state_flags;
			real editor_pos_x;
			real editor_pos_y;
			c_flags<e_interfacenodegraphnodeeditorflags, long, k_interfacenodegraphnodeeditorflags_count> editor_flags;
			c_enum<e_interfacenodegraphenodeshape, long> editor_shape;
		};
		static_assert(sizeof(s_interfacenodegraphnodedefinition) == 100, "struct s_interfacenodegraphnodedefinition is invalid size");

		struct s_interfacenodegraphnodegraphdefinition
		{
			string_id name;
			string_id initial_node;
			c_typed_tag_block<s_interfacenodegraphnodedefinition> nodes_block;
		};
		static_assert(sizeof(s_interfacenodegraphnodegraphdefinition) == 20, "struct s_interfacenodegraphnodegraphdefinition is invalid size");

		struct s_interfacenodegraphnodegraphstackdefinition
		{
			s_anytag_struct_definition anytag;
			string_id name;
			c_enum<e_interfacenodegraphetransformmethodtype, long> transform_method;
			c_enum<e_interfacenodegrapheprojectionmethodtype, long> projection_method;
			c_enum<e_interfacenodegraphestackrendermode, long> render_mode;
			string_id markername;
			real scale;
			c_enum<e_interfacenodegrapheloadingmode, long> loading_mode;
			c_typed_tag_block<s_interfacenodegraphnodegraphdefinition> node_graphs_block;
		};
		static_assert(sizeof(s_interfacenodegraphnodegraphstackdefinition) == 56, "struct s_interfacenodegraphnodegraphstackdefinition is invalid size");

		struct s_i343narrativemalleablepropertydef
		{
			string_id property_name;
			c_enum<e_i343narrativemalleablepropertydeftype, char> type;
			char generated_pad67ba[3]; // padding
			string_id activate_curve_name;
			string_id deactivate_curve_name;
		};
		static_assert(sizeof(s_i343narrativemalleablepropertydef) == 16, "struct s_i343narrativemalleablepropertydef is invalid size");

		struct s_i343narrativecurvedmalleablepropertiesdef
		{
			c_typed_tag_reference<CURVEDEFINITION_TAG> curve_definition;
			c_typed_tag_block<s_i343narrativemalleablepropertydef> malleable_properties_block;
		};
		static_assert(sizeof(s_i343narrativecurvedmalleablepropertiesdef) == 28, "struct s_i343narrativecurvedmalleablepropertiesdef is invalid size");

		struct s_i343narrativemalleablepropertydefinitiontag
		{
			s_anytag_struct_definition anytag;
			s_i343narrativecurvedmalleablepropertiesdef modifications;
		};
		static_assert(sizeof(s_i343narrativemalleablepropertydefinitiontag) == 44, "struct s_i343narrativemalleablepropertydefinitiontag is invalid size");

		struct s_nodegraphcontentnarrativenodegraphcontenttag
		{
			s_nodegraphcontentnodegraphcontenttag nodegraph;
		};
		static_assert(sizeof(s_nodegraphcontentnarrativenodegraphcontenttag) == 68, "struct s_nodegraphcontentnarrativenodegraphcontenttag is invalid size");

		struct s_interfacenarrationnarrationphonemedefinition
		{

			/* Narration Phonemes */

			string_id string_to_find;
			string_id string_to_remove;
			string_id string_to_add;
			c_enum<e_interfacenarrationnarrationphonemetype, char> phoneme_type;
			char generated_pad6e70[3]; // padding
		};
		static_assert(sizeof(s_interfacenarrationnarrationphonemedefinition) == 16, "struct s_interfacenarrationnarrationphonemedefinition is invalid size");

		struct s_interfacenarrationnarrationphonemesgroup
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_interfacenarrationnarrationphonemedefinition> narration_phonemes_block;
			char generated_pad803b[4]; // padding
		};
		static_assert(sizeof(s_interfacenarrationnarrationphonemesgroup) == 32, "struct s_interfacenarrationnarrationphonemesgroup is invalid size");

		struct s_interfacenavpointcolortracktag
		{
			string_id track_name;
			s_scalarfunctionname function;
			string_id destination_value;
		};
		static_assert(sizeof(s_interfacenavpointcolortracktag) == 28, "struct s_interfacenavpointcolortracktag is invalid size");

		struct s_interfacenavpointfloattracktag
		{
			string_id track_name;
			s_scalarfunctionname function;
			real destination_value;
		};
		static_assert(sizeof(s_interfacenavpointfloattracktag) == 28, "struct s_interfacenavpointfloattracktag is invalid size");

		struct s_interfacenavpointimagetracktag
		{
			string_id track_name;
			long destination_frame_index;
		};
		static_assert(sizeof(s_interfacenavpointimagetracktag) == 8, "struct s_interfacenavpointimagetracktag is invalid size");

		struct s_interfacenavpointflipbooktracktag
		{
			string_id track_name;
			real speed;
		};
		static_assert(sizeof(s_interfacenavpointflipbooktracktag) == 8, "struct s_interfacenavpointflipbooktracktag is invalid size");

		struct s_interfacenavpointstringidtracktag
		{
			string_id track_name;
			string_id destination_stringid;
		};
		static_assert(sizeof(s_interfacenavpointstringidtracktag) == 8, "struct s_interfacenavpointstringidtracktag is invalid size");

		struct s_interfacenavpointanimationtag
		{
			string_id animation_name;
			c_typed_tag_reference<NAVPOINTANIMATIONGROUP_TAG> template_animation_group;
			string_id template_animation_name;
			real duration;
			c_enum<e_interfacenavpointelooping, long> loop_type;
			real delay_before_looping;
			c_typed_tag_block<s_interfacenavpointcolortracktag> color_tracks_block;
			c_typed_tag_block<s_interfacenavpointfloattracktag> float_tracks_block;
			c_typed_tag_block<s_interfacenavpointimagetracktag> image_tracks_block;
			c_typed_tag_block<s_interfacenavpointflipbooktracktag> flipbook_tracks_block;
			c_typed_tag_block<s_interfacenavpointstringidtracktag> stringid_tracks_block;
		};
		static_assert(sizeof(s_interfacenavpointanimationtag) == 96, "struct s_interfacenavpointanimationtag is invalid size");

		struct s_interfacenavpointnavpointanimationgrouptag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_interfacenavpointanimationtag> animations_block;
			char generated_pad3780[4]; // padding
		};
		static_assert(sizeof(s_interfacenavpointnavpointanimationgrouptag) == 32, "struct s_interfacenavpointnavpointanimationgrouptag is invalid size");

		struct s_interfacenavpointlabelelementtag
		{
			string_id element_name;
			string_id draw_flags_name;
			c_flags<e_interfacenavpointdrawwhenflags, long, k_interfacenavpointdrawwhenflags_count> draw_flags;
			long draw_order;
			real width;
			real height;
			string_id color;
			real alpha;
			string_id tint_color;
			c_enum<e_interfacenavpointnavpointtintblendmode, short> tint_blend_mode;
			char generated_pad4916[2]; // padding
			real tint_blend_interpolation;
			string_id show_event_name;
			string_id hide_event_name;
			real width_scale;
			real height_scale;
			c_enum<e_interfacenavpointhorizontalalignment, short> justification;
			c_enum<e_interfacenavpointverticalalignment, short> alignment;
			string_id typeface;
			long type_size;
			string_id text_source;
			string_id drop_shadow;
			c_flags<e_forceuppercaseflag, char, k_forceuppercaseflag_count> upper_case;
			char generated_pad54de[3]; // padding
			real tracking_horizontal;
		};
		static_assert(sizeof(s_interfacenavpointlabelelementtag) == 88, "struct s_interfacenavpointlabelelementtag is invalid size");

		struct s_interfacenavpointnumberelementtag
		{
			string_id element_name;
			string_id draw_flags_name;
			c_flags<e_interfacenavpointdrawwhenflags, long, k_interfacenavpointdrawwhenflags_count> draw_flags;
			long draw_order;
			real width;
			real height;
			string_id color;
			real alpha;
			string_id tint_color;
			c_enum<e_interfacenavpointnavpointtintblendmode, short> tint_blend_mode;
			char generated_pad4916[2]; // padding
			real tint_blend_interpolation;
			string_id show_event_name;
			string_id hide_event_name;
			real width_scale;
			real height_scale;
			c_enum<e_interfacenavpointhorizontalalignment, short> justification;
			c_enum<e_interfacenavpointverticalalignment, short> alignment;
			string_id typeface;
			long type_size;
			string_id text_source;
			string_id drop_shadow;
			c_flags<e_forceuppercaseflag, char, k_forceuppercaseflag_count> upper_case;
			char generated_pad54de[3]; // padding
			real tracking_horizontal;
			c_enum<e_interfacenavpointenumberformat, long> format;
		};
		static_assert(sizeof(s_interfacenavpointnumberelementtag) == 92, "struct s_interfacenavpointnumberelementtag is invalid size");

		struct s_interfacenavpointimageelementtag
		{
			string_id element_name;
			string_id draw_flags_name;
			c_flags<e_interfacenavpointdrawwhenflags, long, k_interfacenavpointdrawwhenflags_count> draw_flags;
			long draw_order;
			real width;
			real height;
			string_id color;
			real alpha;
			string_id tint_color;
			c_enum<e_interfacenavpointnavpointtintblendmode, short> tint_blend_mode;
			char generated_pad4916[2]; // padding
			real tint_blend_interpolation;
			string_id show_event_name;
			string_id hide_event_name;
			real width_scale;
			real height_scale;
			c_typed_tag_reference<BITMAP_TAG> bitmap;
			long frame_index;
		};
		static_assert(sizeof(s_interfacenavpointimageelementtag) == 80, "struct s_interfacenavpointimageelementtag is invalid size");

		struct s_interfacenavpointrotatedimageelementtag
		{
			string_id element_name;
			string_id draw_flags_name;
			c_flags<e_interfacenavpointdrawwhenflags, long, k_interfacenavpointdrawwhenflags_count> draw_flags;
			long draw_order;
			real width;
			real height;
			string_id color;
			real alpha;
			string_id tint_color;
			c_enum<e_interfacenavpointnavpointtintblendmode, short> tint_blend_mode;
			char generated_pad4916[2]; // padding
			real tint_blend_interpolation;
			string_id show_event_name;
			string_id hide_event_name;
			real width_scale;
			real height_scale;
			c_typed_tag_reference<BITMAP_TAG> bitmap;
			long frame_index;
			real pivot_offset;
			string_id rotation_angle;
		};
		static_assert(sizeof(s_interfacenavpointrotatedimageelementtag) == 88, "struct s_interfacenavpointrotatedimageelementtag is invalid size");

		struct s_interfacenavpointmeterelementtag
		{
			string_id element_name;
			string_id draw_flags_name;
			c_flags<e_interfacenavpointdrawwhenflags, long, k_interfacenavpointdrawwhenflags_count> draw_flags;
			long draw_order;
			real width;
			real height;
			string_id color;
			real alpha;
			string_id tint_color;
			c_enum<e_interfacenavpointnavpointtintblendmode, short> tint_blend_mode;
			char generated_pad4916[2]; // padding
			real tint_blend_interpolation;
			string_id show_event_name;
			string_id hide_event_name;
			real width_scale;
			real height_scale;
			c_typed_tag_reference<BITMAP_TAG> bitmap;
			long frame_index;
			string_id fill_color;
			string_id progress;
		};
		static_assert(sizeof(s_interfacenavpointmeterelementtag) == 88, "struct s_interfacenavpointmeterelementtag is invalid size");

		struct s_interfacenavpointelementgrouptag
		{
			string_id group_name;
			string_id tint_color;
			real alpha;
			real anchor_offset_x;
			real anchor_offset_y;
			c_enum<e_interfacenavpointhorizontalalignment, short> anchor_justification;
			c_enum<e_interfacenavpointverticalalignment, short> anchor_alignment;
			string_id anchor_element_name;
			c_enum<e_interfacenavpointgrouplayout, long> element_layout;
			c_enum<e_interfacenavpointhorizontalalignment, short> element_justification;
			c_enum<e_interfacenavpointverticalalignment, short> element_alignment;
			real element_horizontal_spacing;
			real element_vertical_spacing;
			c_flags<e_usehorizontalflipzoneflag, char, k_usehorizontalflipzoneflag_count> use_horizontal_flip_zone;
			char generated_pad4787[3]; // padding
			c_typed_tag_block<s_interfacenavpointlabelelementtag> label_elements_block;
			c_typed_tag_block<s_interfacenavpointnumberelementtag> number_elements_block;
			c_typed_tag_block<s_interfacenavpointimageelementtag> image_elements_block;
			c_typed_tag_block<s_interfacenavpointrotatedimageelementtag> rotated_image_elements_block;
			c_typed_tag_block<s_interfacenavpointmeterelementtag> gradient_meter_elements_block;
			c_typed_tag_block<s_interfacenavpointmeterelementtag> radial_meter_elements_block;
		};
		static_assert(sizeof(s_interfacenavpointelementgrouptag) == 120, "struct s_interfacenavpointelementgrouptag is invalid size");

		struct s_interfacenavpointtargetpropertytag
		{
			string_id track_name;
			string_id element_or_group_name;
			string_id property_name;
		};
		static_assert(sizeof(s_interfacenavpointtargetpropertytag) == 12, "struct s_interfacenavpointtargetpropertytag is invalid size");

		struct s_interfacenavpointtimelinetag
		{
			string_id timeline_name;
			c_typed_tag_reference<NAVPOINTANIMATIONGROUP_TAG> animation_group;
			string_id animation_name;
			c_typed_tag_block<s_interfacenavpointtargetpropertytag> target_properties_block;
		};
		static_assert(sizeof(s_interfacenavpointtimelinetag) == 36, "struct s_interfacenavpointtimelinetag is invalid size");

		struct s_interfacenavpointvisualstatetag
		{
			string_id name;
			c_typed_tag_block<s_interfacenavpointtimelinetag> color_animation_timelines_block;
			c_typed_tag_block<s_interfacenavpointtimelinetag> float_animation_timelines_block;
			c_typed_tag_block<s_interfacenavpointtimelinetag> image_animation_timelines_block;
			c_typed_tag_block<s_interfacenavpointtimelinetag> stringid_animation_timelines_block;
		};
		static_assert(sizeof(s_interfacenavpointvisualstatetag) == 52, "struct s_interfacenavpointvisualstatetag is invalid size");

		struct s_interfacenavpointvisualstategrouptag
		{
			string_id visual_state_group_name;
			c_typed_tag_block<s_interfacenavpointvisualstatetag> visual_states_block;
		};
		static_assert(sizeof(s_interfacenavpointvisualstategrouptag) == 16, "struct s_interfacenavpointvisualstategrouptag is invalid size");

		struct s_interfacenavpointsampledatafloat
		{
			string_id variable_name;
			real value;
		};
		static_assert(sizeof(s_interfacenavpointsampledatafloat) == 8, "struct s_interfacenavpointsampledatafloat is invalid size");

		struct s_interfacenavpointsampledatastringid
		{
			string_id variable_name;
			string_id value;
		};
		static_assert(sizeof(s_interfacenavpointsampledatastringid) == 8, "struct s_interfacenavpointsampledatastringid is invalid size");

		struct s_interfacenavpointsampledatatext
		{
			string_id variable_name;
			c_static_string<256> value;
		};
		static_assert(sizeof(s_interfacenavpointsampledatatext) == 260, "struct s_interfacenavpointsampledatatext is invalid size");

		struct s_interfacenavpointnavpointpresentationtag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<NAVPOINTPRESENTATION_TAG> template_navpoint;
			real alpha;
			real anchor_offset_x;
			real anchor_offset_y;
			string_id show_event_name;
			string_id hide_event_name;
			real scale_far_override;
			c_typed_tag_block<s_interfacenavpointelementgrouptag> element_groups_block;
			c_typed_tag_block<s_interfacenavpointvisualstategrouptag> state_groups_block;
			c_typed_tag_block<s_interfacenavpointvisualstatetag> external_events_block;
			c_typed_tag_block<s_interfacenavpointvisualstatetag> show_and_hide_events_block;
			c_typed_tag_block<s_interfacenavpointsampledatafloat> sample_data_floats_block;
			c_typed_tag_block<s_interfacenavpointsampledatastringid> sample_data_string_ids_block;
			c_typed_tag_block<s_interfacenavpointsampledatatext> sample_data_strings_block;
		};
		static_assert(sizeof(s_interfacenavpointnavpointpresentationtag) == 140, "struct s_interfacenavpointnavpointpresentationtag is invalid size");

		struct s_i343objectsattachmentvariantname
		{
			string_id variant_name;
		};
		static_assert(sizeof(s_i343objectsattachmentvariantname) == 4, "struct s_i343objectsattachmentvariantname is invalid size");

		struct s_object_attachment_definition
		{
			string_id name;
			s_tag_reference type;
			s_tag_reference tag_graph_output;
			string_id output_node_name;
			c_typed_tag_block<s_taggraphtaggraphfloatparam> tag_graph_float_params_block;
			s_tag_reference override_type;

			/* variant names */

			c_typed_tag_block<s_i343objectsattachmentvariantname> variant_names_block;
			// custom value
			string_id marker;
			c_enum<e_e_change_color_reference, char> change_color;
			c_flags<e_objectattachmentdefinitionflags, char, k_objectattachmentdefinitionflags_count> flags;
			char generated_padbd3f[2]; // padding
			string_id primary_scale;
			string_id secondary_scale;
		};
		static_assert(sizeof(s_object_attachment_definition) == 96, "struct s_object_attachment_definition is invalid size");

		struct s_i343objectsobjectattachments
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_object_attachment_definition> attachments_block;
			char generated_pad85d0[4]; // padding
		};
		static_assert(sizeof(s_i343objectsobjectattachments) == 32, "struct s_i343objectsobjectattachments is invalid size");

		struct s_nodegraphcontentobjectivebehaviorcontenttag
		{
			s_nodegraphcontentnodegraphcontenttag nodegraph;
		};
		static_assert(sizeof(s_nodegraphcontentobjectivebehaviorcontenttag) == 68, "struct s_nodegraphcontentobjectivebehaviorcontenttag is invalid size");

		struct s_interfacecustomizationuicamerasettings
		{
			c_enum<e_interfacecustomizationcorefocusmode, short> core_focus_mode;
			c_enum<e_interfacecustomizationanimationeasing, short> animation_easing;
			c_typed_tag_block<s_interfacecustomizationuicamerapositionoffset> camera_positions_block;
			real camera_fov;
			real camera_transition;
			real_euler_angles3d orientation;
		};
		static_assert(sizeof(s_interfacecustomizationuicamerasettings) == 36, "struct s_interfacecustomizationuicamerasettings is invalid size");

		struct s_interfacecustomizationuiregiondata
		{
			string_id ui_display_string;
			string_id ui_description_string;
			long cms_customization_item_type;
			c_enum<e_interfacecustomizationcoretype, short> cms_customization_core_type;
			char generated_pade424[2]; // padding
			string_id region_name;
			string_id marker_name;
			real marker_offset;
			c_enum<e_interfacecustomizationanimationeasing, short> animation_easing;
			char generated_padfe05[2]; // padding
			c_typed_tag_block<s_interfacecustomizationuicamerapositionoffset> camera_positions_block;
			real camera_fov;
			real camera_transition_time;
			real_euler_angles3d camera_orientation;
			real_euler_angles3d focused_object_orientation;
			string_id idle_animation;
			string_id to_idle_animation;
			string_id from_idle_animation;
		};
		static_assert(sizeof(s_interfacecustomizationuiregiondata) == 88, "struct s_interfacecustomizationuiregiondata is invalid size");

		struct s_interfacecustomizationuicustomizationorientationlimits
		{
			string_id name;
			real minimum_yaw;
			real maximum_yaw;
			real minimum_roll;
			real maximum_roll;
		};
		static_assert(sizeof(s_interfacecustomizationuicustomizationorientationlimits) == 20, "struct s_interfacecustomizationuicustomizationorientationlimits is invalid size");

		struct s_interfacecustomizationuicustomizationspeedparameters
		{
			real step_fraction;
			real close_enough_distance;
		};
		static_assert(sizeof(s_interfacecustomizationuicustomizationspeedparameters) == 8, "struct s_interfacecustomizationuicustomizationspeedparameters is invalid size");

		struct s_interfacecustomizationuiobjectcustomizationdata
		{
			c_static_string<32> camera_point;
			string_id default_idle_animation;
			string_id idle_animation;
			string_id idle_2_focused_animation;
			string_id idle_focused_animation;
			string_id focused_2_idle_animation;
			string_id armor_change_reaction_animation;
			string_id holo_table_animation;
			string_id idle_spartan_ai_animation;
			string_id spartan_platform_glow_effect;
			real_euler_angles3d rotation_angle_limitation;
			real_euler_angles3d default_weapon_orientation;
			c_typed_tag_block<s_interfacecustomizationuicamerasettings> camera_settings_data_block;
			c_typed_tag_block<s_interfacecustomizationuiregiondata> region_data_block;
			c_typed_tag_block<s_interfacecustomizationuirttregiondata> rtt_region_data_block;
			string_id ai_spartan_marker;
			real ai_spartan_marker_scale;

			/* Complex Rotation Settings */

			c_typed_tag_block<s_interfacecustomizationuicustomizationorientationlimits> orientation_limits_block;
			c_typed_tag_block<s_interfacecustomizationuicustomizationspeedparameters> default_speed_block;
			c_typed_tag_block<s_interfacecustomizationuicustomizationspeedparameters> drag_speed_block;
			c_typed_tag_block<s_interfacecustomizationuicustomizationspeedparameters> impulse_speed_block;
		};
		static_assert(sizeof(s_interfacecustomizationuiobjectcustomizationdata) == 184, "struct s_interfacecustomizationuiobjectcustomizationdata is invalid size");

		struct s_interfacecustomizationuiobjectcustomizationdatatag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_interfacecustomizationuiobjectcustomizationdata> customization_data_block;
			char generated_pad77ac[4]; // padding
		};
		static_assert(sizeof(s_interfacecustomizationuiobjectcustomizationdatatag) == 32, "struct s_interfacecustomizationuiobjectcustomizationdatatag is invalid size");

		struct s_impactaudiodefinition
		{
			// custom impact_audio
			real small_impact_minimum_speed;
			real medium_impact_minimum_speed;
			real large_impact_minimum_speed;
			real large_impact_maximum_speed;
			// custom value
		};
		static_assert(sizeof(s_impactaudiodefinition) == 16, "struct s_impactaudiodefinition is invalid size");

		struct s_sidecarpathdefinition
		{
			c_static_string<256> sidecar_path;
		};
		static_assert(sizeof(s_sidecarpathdefinition) == 256, "struct s_sidecarpathdefinition is invalid size");

		struct s_s_object_early_mover_obb_definition
		{
			string_id node_name;
			long runtime_node_index;
			real x0;
			real x1;
			real y0;
			real y1;
			real z0;
			real z1;
			real_euler_angles3d angles;
		};
		static_assert(sizeof(s_s_object_early_mover_obb_definition) == 44, "struct s_s_object_early_mover_obb_definition is invalid size");

		struct s_i343weaponaiheatgeneratedperroundoverrideparam
		{
			real heat_generated_per_round_override_easy;
			real heat_generated_per_round_override_normal;
			real heat_generated_per_round_override_heroic;
			real heat_generated_per_round_override_legendary;
		};
		static_assert(sizeof(s_i343weaponaiheatgeneratedperroundoverrideparam) == 16, "struct s_i343weaponaiheatgeneratedperroundoverrideparam is invalid size");

		struct s_object_ai_properties
		{
			c_flags<e_objectaipropertiesflags, long, k_objectaipropertiesflags_count> ai_flags;
			string_id ai_type_name;
			string_id interaction_name;
			c_enum<e_objectaisize, short> ai_size;
			c_enum<e_characterjumpheight, short> leap_jump_speed;
			real unattached_damage_modifier;
			c_flags<e_botobjectmarkupflags, char, k_botobjectmarkupflags_count> bot_markup_flags;
			char generated_pad9518[3]; // padding

			/* Heat Override */

			c_typed_tag_block<s_i343weaponaiheatgeneratedperroundoverrideparam> override_heat_generated_per_round_block;
			real actor_lod_cost;
		};
		static_assert(sizeof(s_object_ai_properties) == 40, "struct s_object_ai_properties is invalid size");

		struct s_s_object_function_interpolation_definition
		{
			c_enum<e_e_object_function_interpolation_mode, long> interpolation_mode;
			real linear_travel_time;
			real acceleration;

			/* springs */

			real spring_k;
			real spring_c;
			real fraction;
		};
		static_assert(sizeof(s_s_object_function_interpolation_definition) == 24, "struct s_s_object_function_interpolation_definition is invalid size");

		struct s_s_object_function_definition
		{
			c_flags<e_objectfunctionflags, long, k_objectfunctionflags_count> flags;
			string_id import_name;
			string_id export_name;
			string_id turn_off_with;
			string_id ranged_interpolation_name;
			real min_value;
			// custom default_function
			s_functiondefinition default_function;
			string_id scale_by;
			c_enum<e_objectfunctioninterpolationpov, char> interpolation_point_of_view;
			char generated_pad73a4[3]; // padding
			c_typed_tag_block<s_s_object_function_interpolation_definition> interpolation_block;
			long runtime_interpolator_index;
		};
		static_assert(sizeof(s_s_object_function_definition) == 68, "struct s_s_object_function_definition is invalid size");

		struct s_objectruntimeinterpolatorfunctionsblock
		{
			long runtime_interpolator_to_object_function_mapping;
		};
		static_assert(sizeof(s_objectruntimeinterpolatorfunctionsblock) == 4, "struct s_objectruntimeinterpolatorfunctionsblock is invalid size");

		struct s_objectfunctionswitchdefinitionfunction
		{
			real_bounds selection_bounds;
			string_id function_name;
		};
		static_assert(sizeof(s_objectfunctionswitchdefinitionfunction) == 12, "struct s_objectfunctionswitchdefinitionfunction is invalid size");

		struct s_objectfunctionswitchdefinition
		{
			string_id switch_function_name;
			string_id export_name;
			c_typed_tag_block<s_objectfunctionswitchdefinitionfunction> switched_functions_block;
		};
		static_assert(sizeof(s_objectfunctionswitchdefinition) == 20, "struct s_objectfunctionswitchdefinition is invalid size");

		struct s_i343objectsobjectfunctionforwarding
		{

			/* Object Function Forwarding */

			string_id function_to_forward;
		};
		static_assert(sizeof(s_i343objectsobjectfunctionforwarding) == 4, "struct s_i343objectsobjectfunctionforwarding is invalid size");

		struct s_i343objectsammorefillvariant
		{
			string_id variant_name;
			c_flags<e_i343munitionsammorefilltypeflags, short, k_i343munitionsammorefilltypeflags_count> ammo_refill_flags;
			c_flags<e_i343munitionsammorefillbehaviorflags, char, k_i343munitionsammorefillbehaviorflags_count> ammo_refill_behavior_flags;
			char generated_pad055c[1]; // padding
		};
		static_assert(sizeof(s_i343objectsammorefillvariant) == 8, "struct s_i343objectsammorefillvariant is invalid size");

		struct s_object_indirect_lighting_settings_definition
		{
			string_id name;
			c_typed_tag_block<s_i343objectsattachmentvariantname> variant_names_block;
			c_typed_tag_reference<STRUCTURE_LIGHTMAP_TAG> object_lightmap;
			c_typed_tag_block<s_cubemapvolume> object_cubemap_set_block;
		};
		static_assert(sizeof(s_object_indirect_lighting_settings_definition) == 44, "struct s_object_indirect_lighting_settings_definition is invalid size");

		struct s_s_physics_force_function
		{
			// custom velocity_to_force
			s_functiondefinition velocity_to_pressure;
			real max_velocity;
		};
		static_assert(sizeof(s_s_physics_force_function) == 24, "struct s_s_physics_force_function is invalid size");

		struct s_s_water_physics_drag_properties
		{
			// custom pressure
			s_s_physics_force_function pressure;
			// custom value
			// custom suction
			s_s_physics_force_function suction;
			// custom value
			real linear_damping;
			real angular_damping;
		};
		static_assert(sizeof(s_s_water_physics_drag_properties) == 56, "struct s_s_water_physics_drag_properties is invalid size");

		struct s_s_water_physics_drag_override
		{
			string_id material;
			s_s_water_physics_drag_properties drag;
		};
		static_assert(sizeof(s_s_water_physics_drag_override) == 60, "struct s_s_water_physics_drag_override is invalid size");

		struct s_s_water_physics_hull_surface_definition
		{
			c_flags<e_s_water_physics_hull_surface_definitionc_flags, short, k_s_water_physics_hull_surface_definitionc_flags_count> flags;
			char generated_pad978b[2]; // padding
			// custom value
			string_id marker_name;
			real radius;
			c_typed_tag_block<s_s_water_physics_drag_override> drag_block;
		};
		static_assert(sizeof(s_s_water_physics_hull_surface_definition) == 24, "struct s_s_water_physics_hull_surface_definition is invalid size");

		struct s_s_jetwash_definition
		{
			// custom value
			string_id marker_name;
			real radius;
			long maximum_traces;
			real maximum_emission_length;
			angle_bounds trace_yaw_angle;
			angle_bounds trace_pitch_angle;
			real particle_offset;
		};
		static_assert(sizeof(s_s_jetwash_definition) == 36, "struct s_s_jetwash_definition is invalid size");

		struct s_object_definition_widget
		{
			s_tag_reference type;
		};
		static_assert(sizeof(s_object_definition_widget) == 16, "struct s_object_definition_widget is invalid size");

		struct s_object_change_color_initial_permutation
		{
			real weight;
			rgb_color color_lower_bound;
			rgb_color color_upper_bound;
			string_id variant_name;
		};
		static_assert(sizeof(s_object_change_color_initial_permutation) == 32, "struct s_object_change_color_initial_permutation is invalid size");

		struct s_object_change_color_function
		{
			c_flags<e_rgbcolorinterpolateflag, long, k_rgbcolorinterpolateflag_count> scale_flags;
			rgb_color color_lower_bound;
			rgb_color color_upper_bound;
			string_id darken_by;
			string_id scale_by;
		};
		static_assert(sizeof(s_object_change_color_function) == 36, "struct s_object_change_color_function is invalid size");

		struct s_object_change_color_definition
		{
			c_typed_tag_block<s_object_change_color_initial_permutation> initial_permutations_block;
			c_typed_tag_block<s_object_change_color_function> functions_block;
		};
		static_assert(sizeof(s_object_change_color_definition) == 24, "struct s_object_change_color_definition is invalid size");

		struct s_spawninfluenceweightfallofffunctionblock
		{
			s_scalarfunctionname function;
		};
		static_assert(sizeof(s_spawninfluenceweightfallofffunctionblock) == 20, "struct s_spawninfluenceweightfallofffunctionblock is invalid size");

		struct s_s_multiplayer_object_properties_definition
		{

			/* TYPE AND FLAGS */

			c_enum<e_c_multiplayer_object_type, char> type;
			c_flags<e_c_teleporter_passability, char, k_c_teleporter_passability_count> teleporter_passability;
			c_enum<e_i343netprotocolbondenumhelper_i343netprotocolmapvariantspawntimertype_enum, char> spawn_timer_type;
			char generated_padd1ba[1]; // padding
			short number_of_fx_color_overrides;
			char generated_pad1e6f[2]; // padding

			/* GOAL AND RESPAWN ZONE OBJECT BOUNDARY */

			real boundary_width_radius;
			real boundary_box_length;
			real boundary_positive_height;
			real boundary_negative_height;
			c_enum<e_i343netprotocolbondenumhelper_i343netprotocolboundarytype_enum, char> boundary_shape;
			char pad_shape1[1]; // padding
			char pad_shape2[2]; // padding

			/* SPAWNING DATA */

			short default_spawn_time;
			short default_abandonment_time;
			c_flags<e_c_multiplayer_object_data_flags, long, k_c_multiplayer_object_data_flags_count> flags;

			/* RESPAWN ZONE DATA */

			real normal_weight;
			c_typed_tag_block<s_spawninfluenceweightfallofffunctionblock> falloff_function_block;

			/* MARKER DATA */

			// custom value
			string_id boundary_center_marker;
			// custom value
			string_id spawned_object_marker_name;

			/* SPAWNED OBJECT */

			c_typed_tag_reference<OBJECT_TAG> spawned_object$2;
			string_id nyi_boundary_material;

			/* BOUNDARY SHADER - DEFAULT */

			c_typed_tag_reference<MATERIAL_TAG> boundary_standard_shader;

			/* BOUNDARY SHADER - SPHERE */

			c_typed_tag_reference<MATERIAL_TAG> sphere_standard_shader;

			/* BOUNDARY SHADER - CYLINDER */

			c_typed_tag_reference<MATERIAL_TAG> cylinder_standard_shader;

			/* BOUNDARY SHADER - BOX */

			c_typed_tag_reference<MATERIAL_TAG> box_standard_shader;

			/* FORGE DATA */

			c_flags<e_forgeengineforgeobjectpropertyflags, short, k_forgeengineforgeobjectpropertyflags_count> forge_property_flags;
			c_enum<e_i343netprotocolbondenumhelper_i343netprotocolmapvariantphysicsmode_enum, char> default_physics_type;
			char generated_pad6b24[1]; // padding
			string_id default_primary_color;
			string_id default_secondary_color;
			string_id default_tertiary_color;
			byte default_primary_glossiness;
			byte default_secondary_glossiness;
			byte default_tertiary_glossiness;
			char generated_padb7d9[1]; // padding
			string_id default_label_;
			string_id default_label_$2;
			string_id default_label_$3;
			string_id default_label_$4;
			long long m_defaultboundarypipelinestate;
			long long m_sphereboundarypipelinestates;
			long long m_cylinderboundarypipelinestates;
			long long m_boxboundarypipelinestates;
			real callout_radius;
			char generated_pad048e[4]; // padding
		};
		static_assert(sizeof(s_s_multiplayer_object_properties_definition) == 220, "struct s_s_multiplayer_object_properties_definition is invalid size");

		struct s_i343objectsforgeobjectentrydefinition
		{
			c_typed_tag_reference<FORGEPALETTEDEFINITION_TAG> palette;
			string_id name;
			string_id description;
			real placement_priority;
			string_id variant_name;
			s_tag_reference configuration;
			real_vector3d starting_yaw_pitch_roll;
		};
		static_assert(sizeof(s_i343objectsforgeobjectentrydefinition) == 60, "struct s_i343objectsforgeobjectentrydefinition is invalid size");

		struct s_s_object_spawn_effects
		{

			/* Spawn Effects */

			c_typed_tag_reference<EFFECT_TAG> multiplayer_spawn_effect;
			c_typed_tag_reference<EFFECT_TAG> campaign_spawn_effect;
		};
		static_assert(sizeof(s_s_object_spawn_effects) == 32, "struct s_s_object_spawn_effects is invalid size");

		struct s_modeldissolvedatablock
		{
			c_typed_tag_reference<MODEL_DISSOLVE_DEFINITION_TAG> model_dissolve_data;
		};
		static_assert(sizeof(s_modeldissolvedatablock) == 16, "struct s_modeldissolvedatablock is invalid size");

		struct s_hsreferencesblock
		{
			c_typed_tag_reference<ANYTAG_TAG> reference;
		};
		static_assert(sizeof(s_hsreferencesblock) == 16, "struct s_hsreferencesblock is invalid size");

		struct s_objectabandonmentdefinition
		{
			real vitality_limit_to_start_countdown;
			real countdown_time_in_seconds;
			c_flags<e_objectabandonmentdefinitionc_flags, char, k_objectabandonmentdefinitionc_flags_count> flags;
			char generated_pade8bf[3]; // padding
		};
		static_assert(sizeof(s_objectabandonmentdefinition) == 12, "struct s_objectabandonmentdefinition is invalid size");

		struct s_soundrtpcblockdefinition
		{
			long attachment_index;
			string_id function;
			string_id rtpc_name;
			long rtpc_name_hash_value;
		};
		static_assert(sizeof(s_soundrtpcblockdefinition) == 16, "struct s_soundrtpcblockdefinition is invalid size");

		struct s_soundsweetenerblockdefinition
		{
			string_id function;
			c_typed_tag_reference<SOUND_TAG> sound;
			real switch_point;
			long mode;
		};
		static_assert(sizeof(s_soundsweetenerblockdefinition) == 28, "struct s_soundsweetenerblockdefinition is invalid size");

		struct s_i343objectscomputefunctionsmoothingblockdefinition
		{
			string_id id;
			string_id alias_of;
			real_fraction smoothing_factor;
		};
		static_assert(sizeof(s_i343objectscomputefunctionsmoothingblockdefinition) == 12, "struct s_i343objectscomputefunctionsmoothingblockdefinition is invalid size");

		struct s_interactionopportunitydefinition
		{
			string_id marker;
			c_typed_tag_block<s_ambientactioninfo> ambient_info_block;
		};
		static_assert(sizeof(s_interactionopportunitydefinition) == 16, "struct s_interactionopportunitydefinition is invalid size");

		struct s_scriptedsequencecomponentaction
		{
			c_static_string<32> request_action_lua_function_name;
			c_static_string<32> go_to_next_action_condition_lua_function_name;
		};
		static_assert(sizeof(s_scriptedsequencecomponentaction) == 64, "struct s_scriptedsequencecomponentaction is invalid size");

		struct s_scriptedsequenceactiondefinition
		{
			c_static_string<32> prototype_trigger_lua_function_name;
			c_typed_tag_block<s_scriptedsequencecomponentaction> component_actions_block;
		};
		static_assert(sizeof(s_scriptedsequenceactiondefinition) == 44, "struct s_scriptedsequenceactiondefinition is invalid size");

		struct s_animsettableentryvariantid
		{
			string_id variant;
		};
		static_assert(sizeof(s_animsettableentryvariantid) == 4, "struct s_animsettableentryvariantid is invalid size");

		struct s_animsettableentry
		{
			string_id token;
			c_typed_tag_reference<ANIMSET_TAG> animset;
			c_typed_tag_reference<RUNTIMEANIMSET_TAG> runtime_animset_used_by_code_only;
			byte is_default;
			char generated_padca09[1]; // padding
			c_flags<e_animsettableentryflags, short, k_animsettableentryflags_count> flags;
			c_typed_tag_block<s_animsettableentryvariantid> variants_block;
		};
		static_assert(sizeof(s_animsettableentry) == 52, "struct s_animsettableentry is invalid size");

		struct s_animsettabledefinition
		{
			c_typed_tag_block<s_animchannelentry> channels_block;
			c_typed_tag_block<s_animsettableentry> table_entries_block;
		};
		static_assert(sizeof(s_animsettabledefinition) == 24, "struct s_animsettabledefinition is invalid size");

		struct s_rootbonecorrectionsettings
		{
			c_flags<e_rootbonecorrectionflags, char, k_rootbonecorrectionflags_count> flags;
			c_enum<e_rootbonecorrectiontype, char> root_bone_correction_type;
			char generated_pad0a63[2]; // padding
			real root_bone_correction_duration;
			c_enum<e_rootboneselectiontype, char> root_bone_correction_bone_index;
			char generated_padbdae[3]; // padding
		};
		static_assert(sizeof(s_rootbonecorrectionsettings) == 12, "struct s_rootbonecorrectionsettings is invalid size");

		struct s_leggroundingsettings
		{
			string_id marker;
			real max_compression;
			real planted_threshold;
			real lifted_threshold;
			real lifted_minimum_time;
			c_enum<e_animationframeeventtype, short> event;
			char generated_paddc16[2]; // padding
		};
		static_assert(sizeof(s_leggroundingsettings) == 24, "struct s_leggroundingsettings is invalid size");

		struct s_i343objectsanimationmatchingtableentry
		{

			/* ANIMATION REMAPPING */

			string_id animation_on_parent;
			string_id animation_to_play_on_object;
			string_id animation_set_to_use_with_the_child_objects_animation;
		};
		static_assert(sizeof(s_i343objectsanimationmatchingtableentry) == 12, "struct s_i343objectsanimationmatchingtableentry is invalid size");

		struct s_i343objectsmodelvariantswappingtableentry
		{
			real_bounds function_result_range;
			string_id model_variant_name;
		};
		static_assert(sizeof(s_i343objectsmodelvariantswappingtableentry) == 12, "struct s_i343objectsmodelvariantswappingtableentry is invalid size");

		struct s_i343itemslocationsensordefinition
		{
			// custom sensor_parameters
			c_flags<e_i343itemslocationsensorflags, long, k_i343itemslocationsensorflags_count> sensor_flags;
			real ping_frequency;
			real ping_radius;
			real reveal_duration;
			real scanning_duration;
			real minimum_delay_between_marks;
			real delay_per_distance;
			// custom value
			// custom sensor_visuals
			c_typed_tag_reference<EFFECT_TAG> sensor_radius_effect;
			string_id sensor_radius_effect_marker;
			c_typed_tag_reference<EFFECT_TAG> sensor_ping_effect;
			// custom value
			// custom target_visuals
			c_typed_tag_reference<OUTLINETYPEDEFINITION_TAG> target_outline;
			c_typed_tag_reference<EFFECT_TAG> target_visor_ping_effect;
			string_id target_visor_ping_effect_marker;
			// custom value
			// custom navpoints
			string_id sensor_navpoint_name;
			string_id sensor_navpoint_marker;
			string_id target_navpoint_name;
			string_id target_navpoint_marker;
			// custom value
		};
		static_assert(sizeof(s_i343itemslocationsensordefinition) == 116, "struct s_i343itemslocationsensordefinition is invalid size");

		struct s_i343itemswallbuilderwallcellmapping
		{
			short cell_mapping;
		};
		static_assert(sizeof(s_i343itemswallbuilderwallcellmapping) == 2, "struct s_i343itemswallbuilderwallcellmapping is invalid size");

		struct s_i343itemswallbuilderwallvertmarkernames
		{
			string_id marker_name;
		};
		static_assert(sizeof(s_i343itemswallbuilderwallvertmarkernames) == 4, "struct s_i343itemswallbuilderwallvertmarkernames is invalid size");

		struct s_i343itemswallbuilderwalldefinition
		{
			// custom wall_builder_wall
			short root_marker_index;
			short wall_builder_width_in_vertices;
			short wall_builder_height_in_vertices;
			char generated_pad9b37[2]; // padding

			/* Cell Mappings */

			c_typed_tag_block<s_i343itemswallbuilderwallcellmapping> cell_mappings_block;

			/* Vert Markers */

			c_typed_tag_block<s_i343itemswallbuilderwallvertmarkernames> vert_markers_block;
			// custom value
		};
		static_assert(sizeof(s_i343itemswallbuilderwalldefinition) == 32, "struct s_i343itemswallbuilderwalldefinition is invalid size");

		struct s_i343itemsshroudgeneratordefinition
		{
			real outer_radius;
			string_id edge_effect_marker;
			c_typed_tag_reference<EFFECT_TAG> biped_enter_effect;
			c_typed_tag_reference<EFFECT_TAG> biped_inside_effect;
			c_typed_tag_reference<EFFECT_TAG> biped_leave_effect;
			// custom mapping_function
			s_functiondefinition inside_shrouded_mapping;
			real max_distance_inside_for_shroud;
			// custom mapping_function
			s_functiondefinition outside_shrouded_mapping;
			real max_distance_outside_for_shroud;
			// custom blocker
			c_typed_tag_reference<OBJECT_TAG> blocker_object;
			string_id blocker_attach_marker;
			string_id blocker_attach_child_marker;
			real blocker_scale;
			// custom value
		};
		static_assert(sizeof(s_i343itemsshroudgeneratordefinition) == 132, "struct s_i343itemsshroudgeneratordefinition is invalid size");

		struct s_i343objectspowersourceconfiguration
		{
			string_id name;
			real_fraction capacity;
		};
		static_assert(sizeof(s_i343objectspowersourceconfiguration) == 8, "struct s_i343objectspowersourceconfiguration is invalid size");

		struct s_i343objectspowersourcestateconfiguration
		{
			c_enum<e_modelstates, short> region_state;
			short configuration;
		};
		static_assert(sizeof(s_i343objectspowersourcestateconfiguration) == 4, "struct s_i343objectspowersourcestateconfiguration is invalid size");

		struct s_i343objectspowersourcedefinition
		{
			string_id region_name;
			long runtime_region_index;

			/* Model Region Damage State Configurations */

			c_typed_tag_block<s_i343objectspowersourcestateconfiguration> state_configurations_block;
		};
		static_assert(sizeof(s_i343objectspowersourcedefinition) == 20, "struct s_i343objectspowersourcedefinition is invalid size");

		struct s_i343objectspowersourcedefinitionreference
		{
			short component;
		};
		static_assert(sizeof(s_i343objectspowersourcedefinitionreference) == 2, "struct s_i343objectspowersourcedefinitionreference is invalid size");

		struct s_i343objectspowercomponentdefinition
		{

			/* Power Component System */

			c_typed_tag_block<s_i343objectspowersourceconfiguration> power_source_configurations_block;
			c_typed_tag_block<s_i343objectspowersourcedefinition> power_sources_block;
			// custom communication_node_capacity
			c_typed_tag_block<s_i343objectspowersourcedefinitionreference> communication_node_power_sources_block;
			string_id communication_node_power_modifier_id;
			// custom value
			// custom locomotion_capacity
			c_typed_tag_block<s_i343objectspowersourcedefinitionreference> locomotion_power_sources_block;
			string_id locomotion_power_modifier_id;
			// custom locomotion_power_modifier
			s_i343malleablepropertybasefloatstructdefinition locomotion_power_modifier;
			// custom value
			// custom weapon_capacity
			c_typed_tag_block<s_i343objectspowersourcedefinitionreference> weapon_power_sources_block;
			string_id weapon_power_modifier_id;
			// custom value
		};
		static_assert(sizeof(s_i343objectspowercomponentdefinition) == 84, "struct s_i343objectspowercomponentdefinition is invalid size");

		struct s_i343objectsselfdestructsoundblock
		{

			/* SELF DESTRUCTION SOUNDS */

			long active_damage_section_count;
			c_typed_tag_reference<SOUND_TAG> sound_to_play;
		};
		static_assert(sizeof(s_i343objectsselfdestructsoundblock) == 20, "struct s_i343objectsselfdestructsoundblock is invalid size");

		struct s_i343objectsselfdestructhandlerdefinition
		{
			c_typed_tag_block<s_i343objectsselfdestructsoundblock> self_destruct_sounds_block;
		};
		static_assert(sizeof(s_i343objectsselfdestructhandlerdefinition) == 12, "struct s_i343objectsselfdestructhandlerdefinition is invalid size");

		struct s_i343objectsindirectlightingcomponentdefinition
		{
			string_id lightmap_attachment_bone;
		};
		static_assert(sizeof(s_i343objectsindirectlightingcomponentdefinition) == 4, "struct s_i343objectsindirectlightingcomponentdefinition is invalid size");

		struct s_objectdefinition
		{
			s_anytag_struct_definition anytag;
			// custom object
			short runtime_object_type;
			c_enum<e_navmeshcuttingoverride, char> nav_mesh_cutting;
			c_enum<e_navmeshcuttingmode, char> nav_mesh_cutting_mode;
			real nav_mesh_silhouette_expansion;
			c_enum<e_booleanoverride, char> navmesh_collision_node_opt_in;
			char generated_pad19c8[3]; // padding
			// custom nav_dangerous_objects

			/* Avoidance */

			real avoidance_multiplier;
			real avoidance_radius;
			// custom value
			c_flags<e_c_object_definition_flags, long, k_c_object_definition_flags_count> object_flags;
			real bounding_radius;
			real_point3d bounding_offset;
			real horizontal_acceleration_scale;
			real vertical_acceleration_scale;
			real angular_acceleration_scale;
			c_enum<e_lightmapshadowmodes, char> lightmap_shadow_mode;
			c_enum<e_multipleairprobesamplingmode, char> multiple_airprobe_mode;
			c_enum<e_e_water_density_type, char> water_density;
			// custom streaming

			/* Streaming */

			c_flags<e_i343objectsstreamingcontrolflags, char, k_i343objectsstreamingcontrolflags_count> streaming_control_flags;
			// custom value
			s_impactaudiodefinition impact_audio;
			dword runtime_flags;
			c_typed_tag_block<s_sidecarpathdefinition> source_sidecar_block;
			string_id default_model_variant;
			string_id default_style_id;
			c_typed_tag_reference<MODEL_TAG> model;
			s_tag_reference asset;
			c_typed_tag_reference<FRAMEDEFINITION_TAG> frame;
			c_typed_tag_reference<CRATE_TAG> crate_object;

			/* Damage Source */

			s_i343damagedamagesourcedefinition damagesource;
			real navpoint_vertical_offset;

			/* only set this tag if you want to override the default collision damage values in globals.globals */

			c_typed_tag_reference<COLLISION_DAMAGE_TAG> collision_damage;
			c_typed_tag_block<s_s_object_early_mover_obb_definition> early_mover_obb_block;
			c_typed_tag_reference<EFFECT_TAG> creation_effect;
			// custom material_effect_references

			/* Material Effects Section */

			c_typed_tag_reference<MATERIAL_EFFECTS_TAG> material_effects;
			c_typed_tag_reference<VISUALMATERIALEFFECTSDEFINITION_TAG> visual_material_effects;
			c_typed_tag_reference<SOUNDMATERIALEFFECTSDEFINITION_TAG> sound_material_effects;
			// custom value
			c_typed_tag_reference<SOUND_TAG> melee_sound;
			real kill_on_first_contact_or_damage_after_time;
			real self_destruct_time;
			real self_destruct_time_max;
			c_typed_tag_block<s_object_ai_properties> ai_properties_block;
			c_typed_tag_block<s_s_object_function_definition> functions_block;
			c_typed_tag_block<s_objectruntimeinterpolatorfunctionsblock> runtime_interpolator_functions_block;
			c_typed_tag_block<s_objectfunctionswitchdefinition> function_switches_block;
			c_typed_tag_block<s_i343objectsobjectfunctionforwarding> functions_forwarded_to_parent_block;
			c_flags<e_i343munitionsammorefilltypeflags, short, k_i343munitionsammorefilltypeflags_count> ammo_refill_flags;
			c_flags<e_i343munitionsammorefillbehaviorflags, char, k_i343munitionsammorefillbehaviorflags_count> ammo_refill_behavior_flags;
			char generated_pad33a9[1]; // padding
			c_typed_tag_block<s_i343objectsammorefillvariant> ammo_refill_variant_flags_block;
			c_flags<e_c_object_definition_secondary_flags, long, k_c_object_definition_secondary_flags_count> object_secondary_flags;
			// custom customization
			string_id customization_set;
			// custom value
			c_typed_tag_block<s_object_attachment_definition> attachments_block;
			c_typed_tag_block<s_object_indirect_lighting_settings_definition> indirect_lighting_data_block;
			c_typed_tag_block<s_s_water_physics_hull_surface_definition> hull_surfaces_block;
			c_typed_tag_block<s_s_jetwash_definition> jetwash_block;
			c_typed_tag_block<s_object_definition_widget> widgets_block;
			c_typed_tag_block<s_object_change_color_definition> change_colors_block;
			c_typed_tag_block<s_s_multiplayer_object_properties_definition> multiplayer_object_block;
			c_typed_tag_block<s_i343objectsforgeobjectentrydefinition> forge_data_block;
			c_typed_tag_reference<SIMULATION_INTERPOLATION_TAG> simulation_interpolation;
			c_typed_tag_reference<UCN_AUTHORITY_TRUST_SETTINGS_TAG> authority_trust_settings;
			c_typed_tag_block<s_s_object_spawn_effects> spawn_effects_block;
			c_typed_tag_block<s_modeldissolvedatablock> model_dissolve_data_block;
			c_static_string<256> class_name;
			c_typed_tag_block<s_hsreferencesblock> script_tagalongs_block;
			c_typed_tag_reference<LUA_TAG> prototype_script;

			/* Object Abandoment */

			s_objectabandonmentdefinition object_abandonment;
			c_typed_tag_block<s_s_object_meta_label> designer_metadata_block;

			/* Object Function Smoothing */

			c_typed_tag_block<s_soundrtpcblockdefinition> object_sound_rtpcs_block;
			c_typed_tag_block<s_soundsweetenerblockdefinition> object_sound_sweeteners_block;
			string_id audio_acoustics_root_marker_override;
			real audio_acoustics_transparency;
			c_typed_tag_block<s_i343objectscomputefunctionsmoothingblockdefinition> object_function_smoothing_block;
			c_enum<e__object_definitions_animatedmeshinfoeanimationtype, char> animated_mesh_animation_type;
			char generated_pad805e[3]; // padding
			c_typed_tag_reference<TRIGGER_VOLUME_COMPONENT_TAG> trigger_volume_component_info;
			c_typed_tag_block<s_i343spartantrackingobjectdefinition> tracking_info_block;
			c_typed_tag_reference<PROPERTYBASEDEFFECTSTAG_TAG> property_based_effects;
			c_typed_tag_block<s_interactionopportunitydefinition> interactions_block;
			// custom motion_tracker_blips
			c_enum<e_motionsensorblipsprite, char> blip_sprite_index_override;
			char generated_pad9a3f[3]; // padding
			// custom value
			c_typed_tag_block<s_scriptedsequenceactiondefinition> data_driven_scripted_sequence_actions_definitions_block;
			c_typed_tag_reference<XANIMNODEGRAPH_TAG> animation_node_graph;
			s_animsettabledefinition anim_set_table;
			real inertialization_duration;
			real pill_offset_blend_rate_for_ground_ik;
			real_bounds stationary_root_offset_limit;
			real_bounds moving_root_offset_limit;
			real ground_ik_marker_above_ground_tolerance;
			real ground_probe_start_position_height_scale_for_ground_ik;
			s_tag_data anim_set_nodegraph_metadata;
			// custom root_bone_correction_settings
			s_rootbonecorrectionsettings rootbonecorrectionsettings;
			// custom value
			c_typed_tag_block<s_leggroundingsettings> leg_grounding_settings_block;
			// custom wrist_break_fixup
			real wrist_break_interp_time;
			real wrist_break_angle_limit;
			real wrist_break_fixup_scale;
			// custom value
			c_flags<e_animationdefinitionflags, char, k_animationdefinitionflags_count> flags;
			char generated_pad6f99[3]; // padding
			// custom object_node_graph
			c_typed_tag_block<s_i343objectsobjectnodegraphdefinition> object_node_graphs_block;
			// custom value
			c_typed_tag_block<s_i343objectsanimationmatchingtableentry> parent_animation_matching_block;
			// custom model_variant_switching

			/* MODEL VARIANT SWITCHING */

			string_id model_variant_switching_function;
			c_typed_tag_block<s_i343objectsmodelvariantswappingtableentry> model_variant_switching_table_block;
			// custom value
			// custom knockback
			real knockback_impulse_scalar;
			// custom value
			// custom ability_components
			c_typed_tag_block<s_i343itemslocationsensordefinition> location_sensor_block;
			c_typed_tag_block<s_i343itemswallbuilderwalldefinition> wall_builder_wall_block;
			c_typed_tag_block<s_i343itemsshroudgeneratordefinition> shroud_generator_block;
			// custom value
			c_typed_tag_block<s_i343objectspowercomponentdefinition> power_component_block;
			c_typed_tag_block<s_i343objectsselfdestructhandlerdefinition> self_destruct_handler_block;
			c_typed_tag_block<s_i343objectsindirectlightingcomponentdefinition> indirect_lighting_component_block;
			// custom value
			char generated_paddd0c[4]; // padding
		};
		static_assert(sizeof(s_objectdefinition) == 1220, "struct s_objectdefinition is invalid size");

		struct s_i343objectcustomizationmarkers
		{
			string_id marker_name;
			real_vector3d translation;
			real_vector3d rotation;
			real_vector3d scale;
		};
		static_assert(sizeof(s_i343objectcustomizationmarkers) == 40, "struct s_i343objectcustomizationmarkers is invalid size");

		struct s_i343objectcustomizationmodelattachment
		{
			c_typed_tag_reference<ANYTAG_TAG> attachment_model;
			string_id variant;
			c_typed_tag_block<s_i343objectcustomizationmarkers> markers_block;
			c_enum<e_i343objectcustomizationcmsattachmentitemtype, short> cms_customization_item_type;
			c_enum<e_i343objectcustomizationcmsattachmentlocationflag, short> attachment_location;
		};
		static_assert(sizeof(s_i343objectcustomizationmodelattachment) == 36, "struct s_i343objectcustomizationmodelattachment is invalid size");

		struct s_i343objectcustomizationattachmentconfiguration
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343objectcustomizationmodelattachment> model_attachments_block;
			char generated_pad5112[4]; // padding
		};
		static_assert(sizeof(s_i343objectcustomizationattachmentconfiguration) == 32, "struct s_i343objectcustomizationattachmentconfiguration is invalid size");

		struct s_i343objectcustomizationeffectoverridedefinition
		{
			c_typed_tag_reference<EFFECT_TAG> source_effect;
			c_typed_tag_reference<EFFECT_TAG> override_effect;
		};
		static_assert(sizeof(s_i343objectcustomizationeffectoverridedefinition) == 32, "struct s_i343objectcustomizationeffectoverridedefinition is invalid size");

		struct s_i343objectcustomizationeffectoverride
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343objectcustomizationeffectoverridedefinition> effect_overrides_block;
			char generated_pad6db2[4]; // padding
		};
		static_assert(sizeof(s_i343objectcustomizationeffectoverride) == 32, "struct s_i343objectcustomizationeffectoverride is invalid size");

		struct s_i343objectsobjectconfigurationdefinitioninternal
		{
			c_typed_tag_reference<OBJECT_TAG> object_definition;
			string_id variant_name;
			string_id style_id;
			c_typed_tag_reference<FRAMEDEFINITION_TAG> frame_override;
			// custom customization
			string_id customization_set_override;
			// custom value
		};
		static_assert(sizeof(s_i343objectsobjectconfigurationdefinitioninternal) == 44, "struct s_i343objectsobjectconfigurationdefinitioninternal is invalid size");

		struct s_i343objectsobjectconfigurationdefinition
		{
			s_anytag_struct_definition anytag;
			// custom object
			s_i343objectsobjectconfigurationdefinitioninternal object;
			// custom value
			char generated_pad01af[4]; // padding
		};
		static_assert(sizeof(s_i343objectsobjectconfigurationdefinition) == 64, "struct s_i343objectsobjectconfigurationdefinition is invalid size");

		struct s_i343objectcustomizationthemeconfigs
		{
			string_id theme_name;
			string_id theme_variant_name;
			c_typed_tag_reference<CUSTOMIZATIONTHEMECONFIGURATION_TAG> theme_configs;
		};
		static_assert(sizeof(s_i343objectcustomizationthemeconfigs) == 24, "struct s_i343objectcustomizationthemeconfigs is invalid size");

		struct s_i343objectcustomizationtheme
		{
			string_id asset_name;
			c_typed_tag_reference<RENDER_MODEL_TAG> model;
			c_typed_tag_reference<OBJECT_TAG> object_reference;
			c_typed_tag_block<s_i343objectcustomizationthemeconfigs> theme_configurations_block;
		};
		static_assert(sizeof(s_i343objectcustomizationtheme) == 48, "struct s_i343objectcustomizationtheme is invalid size");

		struct s_i343objectcustomizationemblemmarker
		{
			string_id marker;
		};
		static_assert(sizeof(s_i343objectcustomizationemblemmarker) == 4, "struct s_i343objectcustomizationemblemmarker is invalid size");

		struct s_i343objectcustomizationbigemblemconfiguration
		{
			string_id theme_id;
			string_id marker;
		};
		static_assert(sizeof(s_i343objectcustomizationbigemblemconfiguration) == 8, "struct s_i343objectcustomizationbigemblemconfiguration is invalid size");

		struct s_i343objectcustomizationemblemconfiguration
		{
			c_typed_tag_block<s_interfaceemblemelementname> theme_ids_block;
			c_typed_tag_block<s_i343objectcustomizationemblemmarker> markers_block;
			c_typed_tag_block<s_i343objectcustomizationbigemblemconfiguration> bigemblems_block;
		};
		static_assert(sizeof(s_i343objectcustomizationemblemconfiguration) == 36, "struct s_i343objectcustomizationemblemconfiguration is invalid size");

		struct s_i343objectcustomizationconfigurationthemeeffectoverride
		{
			c_typed_tag_reference<EFFECTOVERRIDE_TAG> effect_override_definition;
		};
		static_assert(sizeof(s_i343objectcustomizationconfigurationthemeeffectoverride) == 16, "struct s_i343objectcustomizationconfigurationthemeeffectoverride is invalid size");

		struct s_i343objectcustomizationobjectattachmentcustomization
		{
			c_typed_tag_reference<OBJECTATTACHMENTSDEFINITION_TAG> attachments;
		};
		static_assert(sizeof(s_i343objectcustomizationobjectattachmentcustomization) == 16, "struct s_i343objectcustomizationobjectattachmentcustomization is invalid size");

		struct s_i343objectcustomizationweaponthemeconfigs
		{
			string_id theme_name;
			string_id theme_variant_name;
			c_typed_tag_reference<ANYTAG_TAG> object_configuration;
			c_typed_tag_reference<CUSTOMIZATIONWEAPONTHEMECONFIGURATION_TAG> theme_configs;
		};
		static_assert(sizeof(s_i343objectcustomizationweaponthemeconfigs) == 40, "struct s_i343objectcustomizationweaponthemeconfigs is invalid size");

		struct s_i343objectcustomizationweapontheme
		{
			string_id asset_name;
			c_typed_tag_reference<RENDER_MODEL_TAG> model;
			c_typed_tag_reference<OBJECT_TAG> object_reference;
			c_typed_tag_block<s_i343objectcustomizationweaponthemeconfigs> theme_configurations_block;
		};
		static_assert(sizeof(s_i343objectcustomizationweapontheme) == 48, "struct s_i343objectcustomizationweapontheme is invalid size");

		struct s_i343objectcustomizationplayerkilleffect
		{
			c_typed_tag_reference<WEAPON_TAG> weapon_definition;
			c_typed_tag_reference<EFFECT_TAG> player_kill_effects;
		};
		static_assert(sizeof(s_i343objectcustomizationplayerkilleffect) == 32, "struct s_i343objectcustomizationplayerkilleffect is invalid size");

		struct s_i343objectcustomizationcharm
		{
			c_typed_tag_reference<CUSTOMIZATIONATTACHMENTCONFIGURATION_TAG> charm;
		};
		static_assert(sizeof(s_i343objectcustomizationcharm) == 16, "struct s_i343objectcustomizationcharm is invalid size");

		struct s_i343objectcustomizationvehiclethemeconfigs
		{
			string_id theme_name;
			string_id theme_variant_name;
			c_typed_tag_reference<ANYTAG_TAG> object_configuration;
			c_typed_tag_reference<CUSTOMIZATIONVEHICLETHEMECONFIGURATION_TAG> theme_configs;
		};
		static_assert(sizeof(s_i343objectcustomizationvehiclethemeconfigs) == 40, "struct s_i343objectcustomizationvehiclethemeconfigs is invalid size");

		struct s_i343objectcustomizationvehicletheme
		{
			string_id asset_name;
			c_typed_tag_reference<RENDER_MODEL_TAG> model;
			c_typed_tag_reference<OBJECT_TAG> object_reference;
			c_typed_tag_block<s_i343objectcustomizationvehiclethemeconfigs> theme_configurations_block;
		};
		static_assert(sizeof(s_i343objectcustomizationvehicletheme) == 48, "struct s_i343objectcustomizationvehicletheme is invalid size");

		struct s_i343objectcustomizationstanceandposeanimations
		{
			string_id animation;
			c_typed_tag_reference<OBJECT_TAG> weapon_reference;
		};
		static_assert(sizeof(s_i343objectcustomizationstanceandposeanimations) == 20, "struct s_i343objectcustomizationstanceandposeanimations is invalid size");

		struct s_i343objectcustomizationconsumableobjects
		{
			c_typed_tag_reference<OBJECT_TAG> object_reference;
		};
		static_assert(sizeof(s_i343objectcustomizationconsumableobjects) == 16, "struct s_i343objectcustomizationconsumableobjects is invalid size");

		struct s_i343objectcustomizationglobals
		{
			s_anytag_struct_definition anytag;
			// custom armor_properties
			c_typed_tag_block<s_i343objectcustomizationtheme> themes_block;
			c_typed_tag_block<s_i343objectcustomizationemblemconfiguration> shared_armor_emblems_block;
			c_typed_tag_block<s_i343objectcustomizationconfigurationthemeeffectoverride> effect_overrides_block;
			c_typed_tag_block<s_i343objectcustomizationobjectattachmentcustomization> object_attachments_block;
			// custom value
			// custom weapon_properties
			c_typed_tag_block<s_i343objectcustomizationweapontheme> weapon_themes_block;
			c_typed_tag_block<s_i343objectcustomizationemblemconfiguration> shared_weapon_emblems_block;
			c_typed_tag_block<s_i343objectcustomizationplayerkilleffect> player_kill_effects_block;
			c_typed_tag_block<s_i343objectcustomizationcharm> shared_weapon_charms_block;
			// custom value
			// custom vehicle_properties
			c_typed_tag_block<s_i343objectcustomizationvehicletheme> vehicle_themes_block;
			c_typed_tag_block<s_i343objectcustomizationemblemconfiguration> shared_vehicle_emblems_block;
			c_typed_tag_block<s_i343objectcustomizationcharm> shared_vehicle_charms_block;
			// custom value
			// custom spartan_properties
			c_typed_tag_block<s_i343objectcustomizationstanceandposeanimations> stances_block;
			c_typed_tag_block<s_i343objectcustomizationstanceandposeanimations> action_poses_block;
			// custom value
			// custom ai_properties
			c_typed_tag_reference<ANYTAG_TAG> ai_object_reference;
			c_typed_tag_reference<ANYTAG_TAG> ai_device_reference;
			// custom value
			// custom other_properties
			c_typed_tag_block<s_i343objectcustomizationconsumableobjects> xpboosts_block;
			c_typed_tag_block<s_i343objectcustomizationconsumableobjects> xpgrants_block;
			c_typed_tag_block<s_i343objectcustomizationconsumableobjects> rerolls_block;
		};
		static_assert(sizeof(s_i343objectcustomizationglobals) == 240, "struct s_i343objectcustomizationglobals is invalid size");

		struct s_i343objectcustomizationpermutationregions
		{
			string_id permutation_region;
		};
		static_assert(sizeof(s_i343objectcustomizationpermutationregions) == 4, "struct s_i343objectcustomizationpermutationregions is invalid size");

		struct s_i343objectcustomizationpermutationsettings
		{
			string_id permutation_name;
			c_typed_tag_reference<MATERIALSTYLES_TAG> material_style;
		};
		static_assert(sizeof(s_i343objectcustomizationpermutationsettings) == 20, "struct s_i343objectcustomizationpermutationsettings is invalid size");

		struct s_i343objectcustomizationregion
		{
			string_id region_name;
			c_typed_tag_block<s_i343objectcustomizationpermutationregions> permutation_regions_block;
			c_typed_tag_block<s_i343objectcustomizationpermutationsettings> permutation_settings_block;
		};
		static_assert(sizeof(s_i343objectcustomizationregion) == 28, "struct s_i343objectcustomizationregion is invalid size");

		struct s_i343objectcustomizationattachment
		{
			c_typed_tag_reference<CUSTOMIZATIONATTACHMENTCONFIGURATION_TAG> attachment;
		};
		static_assert(sizeof(s_i343objectcustomizationattachment) == 16, "struct s_i343objectcustomizationattachment is invalid size");

		struct s_i343objectcustomizationmeshes
		{
			string_id name;
			c_typed_tag_block<s_i343objectcustomizationpermutationregions> permutation_regions_block;
			c_typed_tag_block<s_i343objectcustomizationpermutationsettings> permutation_settings_block;
		};
		static_assert(sizeof(s_i343objectcustomizationmeshes) == 28, "struct s_i343objectcustomizationmeshes is invalid size");

		struct s_i343objectcustomizationthemeconfiguration
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343objectcustomizationregion> regions_block;
			c_typed_tag_block<s_i343objectcustomizationattachment> attachments_block;
			c_typed_tag_block<s_i343objectcustomizationmeshes> prosthetics_block;
			c_typed_tag_block<s_i343objectcustomizationmeshes> body_types_block;
			c_typed_tag_block<s_i343objectcustomizationemblemconfiguration> emblems_block;
			c_typed_tag_reference<MATERIALSTYLES_TAG> material_styles;
		};
		static_assert(sizeof(s_i343objectcustomizationthemeconfiguration) == 92, "struct s_i343objectcustomizationthemeconfiguration is invalid size");

		struct s_i343objectcustomizationvehiclethemeconfiguration
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343objectcustomizationregion> regions_block;
			c_typed_tag_block<s_i343objectcustomizationcharm> charm_block;
			c_typed_tag_block<s_i343objectcustomizationemblemconfiguration> emblems_block;
			c_typed_tag_block<s_i343objectcustomizationconfigurationthemeeffectoverride> effect_overrides_block;
			c_typed_tag_reference<MATERIALSTYLES_TAG> material_styles;
			char generated_pad0f9a[4]; // padding
		};
		static_assert(sizeof(s_i343objectcustomizationvehiclethemeconfiguration) == 84, "struct s_i343objectcustomizationvehiclethemeconfiguration is invalid size");

		struct s_i343objectcustomizationweaponthemeconfiguration
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343objectcustomizationregion> regions_block;
			c_typed_tag_block<s_i343objectcustomizationcharm> charm_block;
			c_typed_tag_block<s_i343objectcustomizationemblemconfiguration> emblems_block;
			c_typed_tag_block<s_i343objectcustomizationconfigurationthemeeffectoverride> effect_overrides_block;
			c_typed_tag_reference<EFFECT_TAG> player_kill_effect;
			c_typed_tag_reference<MATERIALSTYLES_TAG> material_styles;
		};
		static_assert(sizeof(s_i343objectcustomizationweaponthemeconfiguration) == 96, "struct s_i343objectcustomizationweaponthemeconfiguration is invalid size");

		struct s_i343objectdispenserdispenseslotdefinition
		{
			string_id slot_name;
			string_id slot_marker;
		};
		static_assert(sizeof(s_i343objectdispenserdispenseslotdefinition) == 8, "struct s_i343objectdispenserdispenseslotdefinition is invalid size");

		struct s_i343objectdispenserdispensercomponentinternaldefinition
		{
			c_typed_tag_block<s_i343objectdispenserdispenseslotdefinition> dispense_slots_block;
			c_typed_tag_reference<EFFECT_TAG> incoming_creation_effect;
			c_typed_tag_reference<EFFECT_TAG> ready_effect;
			string_id action_string_incoming;
			c_enum<e_i343objectdispensererespawntype, char> respawn_type;
			c_flags<e_i343objectdispenserdefinitionflags, char, k_i343objectdispenserdefinitionflags_count> flags;
			char generated_pad1e39[2]; // padding
			real respawn_time;
			real incoming_time_mark;
			real constructing_time_mark;
			real damage_acceleration_scale_horizontal;
			real damage_acceleration_scale_vertical;
			real damage_acceleration_min_horizontal;
			real damage_acceleration_min_vertical;
			string_id incoming_navpoint_ui_screen;
			real navpoint_visibility_distance;
			// custom terminal
			real interaction_radius;
			string_id terminal_navpoint_ui_screen;
			// custom value
		};
		static_assert(sizeof(s_i343objectdispenserdispensercomponentinternaldefinition) == 96, "struct s_i343objectdispenserdispensercomponentinternaldefinition is invalid size");

		struct s_i343objectdispenserdispensercomponentdefinition
		{
			s_anytag_struct_definition anytag;
			s_i343objectdispenserdispensercomponentinternaldefinition object_dispenser_component;
		};
		static_assert(sizeof(s_i343objectdispenserdispensercomponentdefinition) == 112, "struct s_i343objectdispenserdispensercomponentdefinition is invalid size");

		struct s_i343objectsdockingalignmentpoints
		{
			string_id slot_marker;
			string_id tab_marker;
		};
		static_assert(sizeof(s_i343objectsdockingalignmentpoints) == 8, "struct s_i343objectsdockingalignmentpoints is invalid size");

		struct s_i343objectsdockingconnectionpoints
		{
			string_id origin_marker;
			string_id target_marker;
		};
		static_assert(sizeof(s_i343objectsdockingconnectionpoints) == 8, "struct s_i343objectsdockingconnectionpoints is invalid size");

		struct s_i343objectsdockingsitedefinition
		{
			s_anytag_struct_definition anytag;
			c_enum<e_i343objectsdockingsimulationtype, char> simulation_type;
			char generated_padc4dc[3]; // padding

			/* Docking States */

			// custom docking_state_timing
			real connection_duration;
			real disconnection_duration;
			real attachment_duration;
			real detachment_duration;
			real docking_duration;
			// custom value
			s_i343objectsdockingalignmentpoints alignment_points;
			c_typed_tag_block<s_i343objectsdockingconnectionpoints> connection_points_block;
			c_typed_tag_reference<EFFECT_TAG> connection_effect;
			real attachment_linear_velocity_test;
			real attachment_angular_velocity_test;
		};
		static_assert(sizeof(s_i343objectsdockingsitedefinition) == 84, "struct s_i343objectsdockingsitedefinition is invalid size");

		struct s_nodegraphcontentobjectnodegraphcontenttag
		{
			s_nodegraphcontentnodegraphcontenttag nodegraph;
		};
		static_assert(sizeof(s_nodegraphcontentobjectnodegraphcontenttag) == 68, "struct s_nodegraphcontentobjectnodegraphcontenttag is invalid size");

		struct s_i343objectsobjectnodegraphglobals
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<CRATE_TAG> placement_global_object;
			char generated_padd6dc[4]; // padding
		};
		static_assert(sizeof(s_i343objectsobjectnodegraphglobals) == 36, "struct s_i343objectsobjectnodegraphglobals is invalid size");

		struct s_behaviortreenode
		{
			string_id node_type;
			long node_id;
		};
		static_assert(sizeof(s_behaviortreenode) == 8, "struct s_behaviortreenode is invalid size");

		struct s_behaviortreenodeconnection
		{
			long parent_node_id;
			long child_node_id;
		};
		static_assert(sizeof(s_behaviortreenodeconnection) == 8, "struct s_behaviortreenodeconnection is invalid size");

		struct s_behaviortreenodeparameterconnection
		{
			long owning_node_id;
			string_id parameter_identifier;
			c_enum<e_behaviornodeparametertypes, char> parameter_type;
			char generated_pad818f[3]; // padding
			long parameter_index;
		};
		static_assert(sizeof(s_behaviortreenodeparameterconnection) == 16, "struct s_behaviortreenodeparameterconnection is invalid size");

		struct s_behaviortreenodeparameterbool
		{
			string_id blackboard_identifier;
			char parameter_value;
			char generated_pad1bf7[3]; // padding
		};
		static_assert(sizeof(s_behaviortreenodeparameterbool) == 8, "struct s_behaviortreenodeparameterbool is invalid size");

		struct s_behaviortreenodeparameterint
		{
			string_id blackboard_identifier;
			long parameter_value;
		};
		static_assert(sizeof(s_behaviortreenodeparameterint) == 8, "struct s_behaviortreenodeparameterint is invalid size");

		struct s_behaviortreenodeparameterfloat
		{
			string_id blackboard_identifier;
			real parameter_value;
		};
		static_assert(sizeof(s_behaviortreenodeparameterfloat) == 8, "struct s_behaviortreenodeparameterfloat is invalid size");

		struct s_behaviortreenodeparameterstringid
		{
			string_id blackboard_identifier;
			string_id parameter_value;
		};
		static_assert(sizeof(s_behaviortreenodeparameterstringid) == 8, "struct s_behaviortreenodeparameterstringid is invalid size");

		struct s_behaviortreenodeparameterruntimeref
		{
			string_id blackboard_identifier;
		};
		static_assert(sizeof(s_behaviortreenodeparameterruntimeref) == 4, "struct s_behaviortreenodeparameterruntimeref is invalid size");

		struct s_objectivebehaviortreenodegraph
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<OBJECTIVENODEGRAPH_TAG> source_graph;
			c_typed_tag_block<s_behaviortreenode> nodes_block;
			c_typed_tag_block<s_behaviortreenodeconnection> node_connections_block;
			c_typed_tag_block<s_behaviortreenodeparameterconnection> node_parameter_connections_block;
			c_typed_tag_block<s_behaviortreenodeparameterbool> bool_parameters_block;
			c_typed_tag_block<s_behaviortreenodeparameterint> int_parameters_block;
			c_typed_tag_block<s_behaviortreenodeparameterfloat> float_parameters_block;
			c_typed_tag_block<s_behaviortreenodeparameterstringid> string_parameters_block;
			c_typed_tag_block<s_behaviortreenodeparameterruntimeref> asset_parameters_block;
			char generated_pada36f[4]; // padding
		};
		static_assert(sizeof(s_objectivebehaviortreenodegraph) == 132, "struct s_objectivebehaviortreenodegraph is invalid size");

		struct s_i343outlineserviceoutlineserviceglobalsdefinition
		{
			s_anytag_struct_definition anytag;
			// custom system_priorities
			real spartan_tracking_active;
			real spartan_tracking_passive;
			real custom_active_tracking;
			real spectator_team_coloring;
			real target_tracking;
			real enemy_identification;
			real scripting;
			real forge_outlining;
			real location_sensor;
			real polaris_outlining;
			// custom value
			c_typed_tag_reference<OUTLINETYPEDEFINITION_TAG> default_outline_type;
			c_flags<e_i343outlineserviceoutlineglobalflags, char, k_i343outlineserviceoutlineglobalflags_count> flags;
			char generated_pada18e[3]; // padding
			real transparent_threshold;
			real transparent_alpha_influence;
			real transparent_luma_influence;
			real transparent_luma_alpha_influence;
			c_typed_tag_reference<BITMAP_TAG> texture_1;
			real_vector2d texture_1_scale;
			real_vector2d texture_1_velocity;
			real texture_1_resolution_scaling;
			real texture_1_influence;
			real texture_1_fill_influence;
			c_typed_tag_reference<BITMAP_TAG> texture_2;
			real_vector2d texture_2_scale;
			real_vector2d texture_2_velocity;
			real texture_2_resolution_scaling;
			real texture_2_influence;
			real texture_2_fill_influence;
			c_typed_tag_reference<BITMAP_TAG> texture_3;
			real_vector2d texture_3_scale;
			real_vector2d texture_3_velocity;
			real texture_3_resolution_scaling;
			real texture_3_influence;
			real texture_3_fill_influence;
			c_typed_tag_reference<BITMAP_TAG> texture_4;
			real_vector2d texture_4_scale;
			real_vector2d texture_4_velocity;
			real texture_4_resolution_scaling;
			real texture_4_influence;
			real texture_4_fill_influence;
		};
		static_assert(sizeof(s_i343outlineserviceoutlineserviceglobalsdefinition) == 268, "struct s_i343outlineserviceoutlineserviceglobalsdefinition is invalid size");

		struct s_i343outlineservicetypedefinition
		{
			s_anytag_struct_definition anytag;
			string_id material_name;
			c_flags<e_i343outlineserviceoutlinerenderflags, long, k_i343outlineserviceoutlinerenderflags_count> flags;
			c_enum<e_i343outlineservicechildoutlinebehaviour, char> child_outlining_behaviour;
			char generated_pada225[3]; // padding
			real fade_in_duration;
			real fade_out_duration;
			rgb_color color;
			real opacity;
			real additiveness;
			real intensity;
			real outline_weight;
			real inline_weight;
			real distance_fade_start;
			real distance_fade_end;
			real distance_fade_end_value;
			real distance_thin_start;
			real distance_thin_end;
			real distance_thin_end_value;
			c_enum<e_i343outlineserviceocclusionmode, char> occlusion_mode;
			char generated_pad8844[3]; // padding
			real occlusion_bias;
			real occlusion_fade_range;
			real occlusion_fade_multiplier;
			rgb_color fill_color;
			real fill_opacity;
			real fill_intensity;
			real fill_distance_fade_start;
			real fill_distance_fade_end;
			real fill_distance_fade_end_value;
			c_enum<e_i343outlineserviceocclusionmode, char> fill_occlusion_mode;
			char generated_pad3b8f[3]; // padding
			real vertical_fade_start;
			real vertical_fade_end;
			real vertical_fade_end_value;
			real transition_to_duration;
			c_typed_tag_reference<OUTLINETYPEDEFINITION_TAG> outline_override_protanopia;
			c_typed_tag_reference<OUTLINETYPEDEFINITION_TAG> outline_override_deuteranopia;
			c_typed_tag_reference<OUTLINETYPEDEFINITION_TAG> outline_override_tritanopia;
			char generated_pad21ae[4]; // padding
		};
		static_assert(sizeof(s_i343outlineservicetypedefinition) == 212, "struct s_i343outlineservicetypedefinition is invalid size");

		struct s_i343graphicspainterbrushdefinition
		{
			s_anytag_struct_definition anytag;
			c_flags<e_i343graphicspainterbrushflags, long, k_i343graphicspainterbrushflags_count> flags;
			c_typed_tag_reference<MATERIAL_TAG> brush_material;
			c_typed_tag_reference<RENDERGRAPH_TAG> generate_data_graph;
			c_typed_tag_reference<RENDERGRAPH_TAG> paint_graph;
			c_typed_tag_reference<RENDERGRAPH_TAG> highlight_graph;
			c_typed_tag_reference<RENDERGRAPH_TAG> live_preview_graph;
			c_typed_tag_reference<RENDERGRAPH_TAG> begin_stroke_generate_data_graph;
			c_typed_tag_reference<RENDERGRAPH_TAG> begin_stroke_graph;
			c_typed_tag_reference<RENDERGRAPH_TAG> end_stroke_graph;
			c_typed_tag_reference<RENDERGRAPH_TAG> on_activate_graph;
			c_typed_tag_reference<RENDERGRAPH_TAG> on_deactivate_graph;
			char generated_pad576a[4]; // padding
		};
		static_assert(sizeof(s_i343graphicspainterbrushdefinition) == 184, "struct s_i343graphicspainterbrushdefinition is invalid size");

		struct s_particleassettag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<ASSET_TAG> asset;
			string_id variant;
			long lod_level;
			real_euler_angles3d rotation;
			real_vector3d scale;
			c_typed_tag_reference<PARTICLE_MODEL_TAG> generated_particlemodel;
		};
		static_assert(sizeof(s_particleassettag) == 80, "struct s_particleassettag is invalid size");

		struct s_i343propertybasedeffectskeyedeffectdata
		{
			string_id id;
			real priority;
			c_typed_tag_reference<EFFECT_TAG> effect;
		};
		static_assert(sizeof(s_i343propertybasedeffectskeyedeffectdata) == 24, "struct s_i343propertybasedeffectskeyedeffectdata is invalid size");

		struct s_i343propertybasedeffectstagdefinition
		{
			s_anytag_struct_definition anytag;

			/* The following data pairs boolean malleable properties with full body effect tags.  It also assigns a priority to each pair.  */

			c_typed_tag_block<s_i343propertybasedeffectskeyedeffectdata> full_body_effects_block;
			char generated_padb4c4[4]; // padding
		};
		static_assert(sizeof(s_i343propertybasedeffectstagdefinition) == 32, "struct s_i343propertybasedeffectstagdefinition is invalid size");

		struct s_pcaimportedframedataelement
		{
			s_tag_data coefficients;
		};
		static_assert(sizeof(s_pcaimportedframedataelement) == 20, "struct s_pcaimportedframedataelement is invalid size");

		struct s_pcaimportedanimationdata
		{
			string_id name;
			long offset;
			long count;
			long pca_shape_offset;
			long pca_coefficient_count;

			/* Resource Data */

			s_tag_resource coefficientresource;
		};
		static_assert(sizeof(s_pcaimportedanimationdata) == 28, "struct s_pcaimportedanimationdata is invalid size");

		struct s_pcaimportedmeshdata
		{
			long render_mesh_index;
			long vertices_per_shape;
			long position_buffer_index;
			long normal_buffer_index;
			real_vector3d position_scale;
			real tension_scale;
			real_vector3d position_offset;
			real tension_offset;
			real_vector3d normal_scale;
			real stretch_scale;
			real_vector3d normal_offset;
			real stretch_offset;

			/* Animations */

			c_typed_tag_block<s_pcaimportedanimationdata> animations_block;

			/* Vertices */

			c_typed_tag_block<s_rawblendshapevertex> raw_blendshape_verts_block;
		};
		static_assert(sizeof(s_pcaimportedmeshdata) == 104, "struct s_pcaimportedmeshdata is invalid size");

		struct s_pcaanimationtag
		{
			s_anytag_struct_definition anytag;

			/* Links */

			c_typed_tag_reference<RENDER_MODEL_TAG> rendermodel;
			c_typed_tag_reference<MODEL_ANIMATION_GRAPH_TAG> animationgraph;
			c_flags<e_pcaanimationtagflags, long, k_pcaanimationtagflags_count> pcaflags;
			long pca_animation_count;
			long pca_checksum;

			/* Imported Data */

			c_typed_tag_block<s_pcaimportedframedataelement> frame_data_block;
			c_typed_tag_block<s_pcaimportedmeshdata> mesh_data_block;

			/* Resource Data */

			s_tag_resource api_resource;
			char generated_pad7a1a[4]; // padding
		};
		static_assert(sizeof(s_pcaanimationtag) == 96, "struct s_pcaanimationtag is invalid size");

		struct s_s_particle_emitter_custom_pointss_point
		{
			short position_x;
			short position_y;
			short position_z;
			char normal_x;
			char normal_y;
			char normal_z;
			byte correlation;
		};
		static_assert(sizeof(s_s_particle_emitter_custom_pointss_point) == 10, "struct s_s_particle_emitter_custom_pointss_point is invalid size");

		struct s_s_particle_emitter_custom_points
		{
			s_anytag_struct_definition anytag;
			// custom import

			/* PARTICLE POINTS */

			c_typed_tag_reference<PARTICLE_MODEL_TAG> source_reference;
			real_vector3d compression_scale;
			real_vector3d compression_offset;
			c_typed_tag_block<s_s_particle_emitter_custom_pointss_point> points_block;
		};
		static_assert(sizeof(s_s_particle_emitter_custom_points) == 68, "struct s_s_particle_emitter_custom_points is invalid size");

		struct s_s_performance_throttles
		{
			c_flags<e_s_performance_throttlesflag, long, k_s_performance_throttlesflag_count> flags;
			real water_tessellation_scale;
			real decorator_fade_dist_scale;
			real effect_lod_distance_scale;
			// custom object_settings
			real instance_fade_modifier;
			real object_fade_modifier;
			real object_detail_fade_modifier;
			real object_lighting_time_limit;
			// custom value
			// custom lod_settings
			real lod_modifier;
			real lod_vertical_modifier;
			long maximum_instance_group_lod_draw_bundles;
			// custom value
			// custom dynamic_light_settings
			long max_forward_dynamic_lights;
			real forward_dynamic_light_fade_distance_scale;
			long max_screenspace_dynamic_lights;
			real screenspace_light_fade_distance_scale;
			long max_effect_lights_screenspace;
			// custom value
			// custom shadow_settings
			long max_shadow_casting_objects;
			real shadow_quality_lod;
			real floating_shadow_quality_lod;
			// custom value
		};
		static_assert(sizeof(s_s_performance_throttles) == 76, "struct s_s_performance_throttles is invalid size");

		struct s_c_performance_throttles
		{
			s_anytag_struct_definition anytag;

			/* Performance Throttles */

			c_typed_tag_block<s_s_performance_throttles> performance_throttles_block;
			char generated_pada5ca[4]; // padding
		};
		static_assert(sizeof(s_c_performance_throttles) == 32, "struct s_c_performance_throttles is invalid size");

		struct s_navmeshdata
		{
			s_tag_resource resource_data;
			short major_version;
			short minor_version;
			long structure_checksum;
		};
		static_assert(sizeof(s_navmeshdata) == 16, "struct s_navmeshdata is invalid size");

		struct s_mobilenavmeshdata
		{
			s_tag_resource resource_data;
			short major_version;
			short minor_version;
			s_c_object_identifier object_id;
			long nodeindex;
			c_flags<e_mobilenavmeshflags, char, k_mobilenavmeshflags_count> flags;
			char generated_pad5c22[3]; // padding
		};
		static_assert(sizeof(s_mobilenavmeshdata) == 28, "struct s_mobilenavmeshdata is invalid size");

		struct s_navvolumebucket
		{
			s_tag_resource resource_data;
			char bucketid;
			char generated_padfba7[3]; // padding
		};
		static_assert(sizeof(s_navvolumebucket) == 12, "struct s_navvolumebucket is invalid size");

		struct s_navvolumedata
		{
			long navmeshareaindex;
			real_vector3d navmeshareaposition;
			real navmeshareaheight;
			real navmeshareasink;
			short major_version;
			short minor_version;
			c_typed_tag_block<s_navvolumebucket> buckets_block;
		};
		static_assert(sizeof(s_navvolumedata) == 40, "struct s_navvolumedata is invalid size");

		struct s_user_hint_data
		{
			c_typed_tag_block<s_user_hint_jump> nav_links_block;
			c_typed_tag_block<s_s_cookie_cutter> cookie_cutters_block;
			c_typed_tag_block<s_navmesharea> navmesh_areas_block;
		};
		static_assert(sizeof(s_user_hint_data) == 36, "struct s_user_hint_data is invalid size");

		struct s_ai_pathfinding
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_navmeshdata> navmeshes_block;
			c_typed_tag_block<s_mobilenavmeshdata> mobilenavmeshes_block;
			c_typed_tag_block<s_navvolumedata> navvolumes_block;
			c_typed_tag_block<s_user_hint_data> hints_block;
		};
		static_assert(sizeof(s_ai_pathfinding) == 64, "struct s_ai_pathfinding is invalid size");

		struct s_i343physicscharactercommonmobilityparameters
		{
			c_flags<e_i343physicscharactercommonmobilityflags, char, k_i343physicscharactercommonmobilityflags_count> flags;
			c_enum<e_i343physicscharactercommonmobilitythrottle, char> activation_throttle_requirements;
			c_enum<e_i343physicscharactercommonmobilitythrottle, char> cancellation_throttle_requirements;
			char generated_pad8441[1]; // padding
			real_fraction throttle_cancellation_point_of_no_return;
			real_fraction firing_cancellation_start_point;
			real_fraction throttle_threshold;
			real initial_button_press_hold_time_to_trigger;
			angle maximum_ledge_slope;
			angle minimum_edge_sharpness;
			real maximum_backward_reach;
			real apex_vertical_offset;
			real max_exit_speed;

			/* entry time */

			real min_entry_time;
			real max_entry_time;

			/* movement time */

			real min_movement_time;
			real max_movement_time;

			/* camera height function */

			// custom camera_height_function
			s_functiondefinition camera_height_function$2;
			real max_anchor_object_relative_speed;
			// custom auto
			real auto_push_time_min;
			angle auto_push_contact_max_angle;
			// custom value
		};
		static_assert(sizeof(s_i343physicscharactercommonmobilityparameters) == 88, "struct s_i343physicscharactercommonmobilityparameters is invalid size");

		struct s_i343physicscharacterclamberingparameters
		{
			// custom step_jump

			/* explanation */

			real_bounds step_jump_range;
			angle step_jump_contact_max_angle;
			real step_jump_extra_height;
			// custom value
			real horizontal_range;
			real vertical_range_min_ascending;
			real vertical_range_min_descending;
			real ascending_velocity_threshold;
			real vertical_range_max;
			real entry_point_vertical_offset_to_apex;
			real entry_point_adjustment_benchmark_speed;
			real entry_point_horizontal_adjustment_range;
			real minimum_downward_speed_required_to_move_entry_point_down;
			real entry_point_vertical_adjustment_range;
			c_flags<e_i343physicscharacterclamberingflags, char, k_i343physicscharacterclamberingflags_count> clamber_flags;
			char generated_pad9eaf[3]; // padding
			real post_exit_block_time;
			real cancel_weapon_block_time;
			s_i343physicscharactercommonmobilityparameters common_parameters;
		};
		static_assert(sizeof(s_i343physicscharacterclamberingparameters) == 156, "struct s_i343physicscharacterclamberingparameters is invalid size");

		struct s_i343physicscharacterclamberingdefinition
		{
			s_anytag_struct_definition anytag;
			s_i343physicscharacterclamberingparameters parameters;
		};
		static_assert(sizeof(s_i343physicscharacterclamberingdefinition) == 172, "struct s_i343physicscharacterclamberingdefinition is invalid size");

		struct s_i343physicsmodeldampedspringmotor
		{
			string_id name;
			real maximum_force;
			real minimum_force;
			real spring_k;
			real damping;
			real initial_position;
		};
		static_assert(sizeof(s_i343physicsmodeldampedspringmotor) == 24, "struct s_i343physicsmodeldampedspringmotor is invalid size");

		struct s_i343physicsmodelpositionmotor
		{
			string_id name;
			real maximum_force;
			real minimum_force;
			real tau;
			real damping;
			real proportion_recover_vel;
			real constant_recover_vel;
			real initial_position;
		};
		static_assert(sizeof(s_i343physicsmodelpositionmotor) == 32, "struct s_i343physicsmodelpositionmotor is invalid size");

		struct s_i343physicsmodelphantomtype
		{
			c_flags<e_i343physicsmodelphysicsmodelphantomflags, long, k_i343physicsmodelphysicsmodelphantomflags_count> flags;
			c_flags<e_i343physicsmodelphantomteamflags, long, k_i343physicsmodelphantomteamflags_count> team_flags;
			real brittle_timer;
			real collision_damage_scale;
			c_enum<e_i343physicsmodelerigidbodysize, char> minimum_size;
			c_enum<e_i343physicsmodelerigidbodysize, char> maximum_size;
			char generated_pad7e7c[2]; // padding
			// custom value
			string_id marker_name;
			// custom value
			string_id mancannon_launched_object_marker_name;
			// custom value
			string_id alignment_marker_name;

			/* Linear Motion */

			real hookes_law_e;
			real linear_dead_radius;
			real center_acc;
			real center_max_vel;
			real axis_acc;
			real axis_max_vel;
			real direction_acc;
			real direction_max_vel;
			real orbit_acc;
			real orbit_max_vel;
			real nearest_unit_acc;
			real nearest_unit_max_vel;

			/* Angular Motion */

			real alignment_hookes_law_e;
			real alignment_acc;
			real alignment_max_vel;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> damage_per_second_effect;
			c_typed_tag_reference<MATERIAL_EFFECTS_TAG> damage_per_second_combined_material_effects;
			c_typed_tag_reference<VISUALMATERIALEFFECTSDEFINITION_TAG> damage_per_second_visual_material_effects;
			c_typed_tag_reference<SOUNDMATERIALEFFECTSDEFINITION_TAG> damage_per_second_sound_material_effects;
			string_id damage_per_second_object_function;
			real damage_per_second_object_function_threshold;
		};
		static_assert(sizeof(s_i343physicsmodelphantomtype) == 164, "struct s_i343physicsmodelphantomtype is invalid size");

		struct s_i343physicsmodelphysicsmodelnodehandle
		{
			long node;
		};
		static_assert(sizeof(s_i343physicsmodelphysicsmodelnodehandle) == 4, "struct s_i343physicsmodelphysicsmodelnodehandle is invalid size");

		struct s_i343physicsmodelmotorreference
		{
			c_enum<e_i343physicsmodelephysicsmodelmotortype, short> motor_type;
			short index;
		};
		static_assert(sizeof(s_i343physicsmodelmotorreference) == 4, "struct s_i343physicsmodelmotorreference is invalid size");

		struct s_i343physicsmodelpoweredchainconstraint
		{
			c_enum<e_i343physicsmodelephysicsmodelconstrainttype, short> constraint_type;
			short constraint_index;
			s_i343physicsmodelmotorreference motor_x;
			s_i343physicsmodelmotorreference motor_y;
			s_i343physicsmodelmotorreference motor_z;
		};
		static_assert(sizeof(s_i343physicsmodelpoweredchainconstraint) == 16, "struct s_i343physicsmodelpoweredchainconstraint is invalid size");

		struct s_i343physicsmodelpoweredchain
		{
			c_typed_tag_block<s_i343physicsmodelphysicsmodelnodehandle> nodes_block;
			c_typed_tag_block<s_i343physicsmodelpoweredchainconstraint> constraints_block;
		};
		static_assert(sizeof(s_i343physicsmodelpoweredchain) == 24, "struct s_i343physicsmodelpoweredchain is invalid size");

		struct s_i343physicsmodelragdollmotors
		{

			/* twist */

			s_i343physicsmodelmotorreference twist_motor;

			/* cone */

			s_i343physicsmodelmotorreference cone_motor;

			/* plane */

			s_i343physicsmodelmotorreference plane_motor;
		};
		static_assert(sizeof(s_i343physicsmodelragdollmotors) == 12, "struct s_i343physicsmodelragdollmotors is invalid size");

		struct s_i343physicsmodellimitedhingemotors
		{
			s_i343physicsmodelmotorreference motor;
		};
		static_assert(sizeof(s_i343physicsmodellimitedhingemotors) == 4, "struct s_i343physicsmodellimitedhingemotors is invalid size");

		struct s_i343physicsmodelnodeconstraintedgeconstraint
		{
			c_enum<e_i343physicsmodelephysicsmodelconstrainttype, short> type;
			short index;
			c_flags<e_i343physicsmodelphysicsmodelrigidbodyconstraintedgeconstraintflag, long, k_i343physicsmodelphysicsmodelrigidbodyconstraintedgeconstraintflag_count> flags;
			real friction;
			c_typed_tag_block<s_i343physicsmodelragdollmotors> ragdoll_motors_block;
			c_typed_tag_block<s_i343physicsmodellimitedhingemotors> limited_hinge_motors_block;
		};
		static_assert(sizeof(s_i343physicsmodelnodeconstraintedgeconstraint) == 36, "struct s_i343physicsmodelnodeconstraintedgeconstraint is invalid size");

		struct s_i343physicsmodelnodeconstraintedge
		{
			short runtime_material_type_a;
			short runtime_material_type_b;
			long node_a;
			long node_b;
			c_typed_tag_block<s_i343physicsmodelnodeconstraintedgeconstraint> constraints_block;
			string_id node_a_material;
			string_id node_b_material;
		};
		static_assert(sizeof(s_i343physicsmodelnodeconstraintedge) == 32, "struct s_i343physicsmodelnodeconstraintedge is invalid size");

		struct s_i343physicsmodelshapereference
		{
			c_enum<e_i343physicsmodelephysicsshapetype, long> shape_type;
			long shape;
		};
		static_assert(sizeof(s_i343physicsmodelshapereference) == 8, "struct s_i343physicsmodelshapereference is invalid size");

		struct s_i343physicsmodelphysicsmodelrigidbody
		{
			long node;
			long region;
			long permutation;
			real_point3d bouding_sphere_offset;
			real bounding_sphere_radius;
			c_flags<e_i343physicsmodelrigidbodyflags, char, k_i343physicsmodelrigidbodyflags_count> flags;
			c_enum<e_i343physicsmodelerigidbodymotiontype, char> motion_type;
			c_enum<e_i343physicsmodelerigidbodysize, char> size;
			char generated_pad3d04[1]; // padding
			long no_phantom_power_alt;

			/* collision layer override */

			string_id collision_layer;
			real inertia_tensor_scale;
			real linear_air_drag;
			real angular_air_drag;
			real_vector3d center_off_mass_offset;

			/* water physics bounding box */

			real water_physics_x0;
			real water_physics_x1;
			real water_physics_y0;
			real water_physics_y1;
			real water_physics_z0;
			real water_physics_z1;
			real_vector3d center_of_mass;
			real_vector3d inertia_tensor_x;
			real_vector3d inertia_tensor_y;
			real_vector3d inertia_tensor_z;
			s_i343physicsmodelshapereference shape;
			c_typed_tag_block<s_i343physicscollisiontypename> primitive_collision_layers_block;
			real mass;
			real bounding_sphere_pad;

			/* Stupid mass override */

			real mass_body_override;
			real_vector3d mass_distribution_override;
			c_enum<e_i343physicsmodelerigidbodycollisionqualityoverride, char> collision_quality_override_type;
			c_flags<e_i343physicsmodelrigidbodyruntimeflags, char, k_i343physicsmodelrigidbodyruntimeflags_count> runtime_flags;
			char generated_pad56e5[2]; // padding
		};
		static_assert(sizeof(s_i343physicsmodelphysicsmodelrigidbody) == 184, "struct s_i343physicsmodelphysicsmodelrigidbody is invalid size");

		struct s_i343physicsmodelmaterial
		{
			string_id name;
			c_flags<e_i343physicsmodelphysicsmodelmaterialflag, char, k_i343physicsmodelphysicsmodelmaterialflag_count> flags;
			char generated_pad8900[3]; // padding
			string_id global_material_name;
			long phantom_type;

			/* collision layer override */

			string_id collision_layer;
			string_id runtime_collision_layer;
		};
		static_assert(sizeof(s_i343physicsmodelmaterial) == 24, "struct s_i343physicsmodelmaterial is invalid size");

		struct s_i343physicsmodelprimitive
		{
			string_id name;
			real relative_mass_scale;
			real_fraction friction;
			real_fraction restitution;
			real volume_;
			real mass;
			long phantom;
			short runtime_material_type;
			char material;
			c_flags<e_i343physicsmodelphysicsmodelmaterialflag, char, k_i343physicsmodelphysicsmodelmaterialflag_count> material_flags;
			short mass_distribution_index;
			short should_use;

			/* collision layer override */

			string_id collision_layer;
		};
		static_assert(sizeof(s_i343physicsmodelprimitive) == 40, "struct s_i343physicsmodelprimitive is invalid size");

		struct s_i343physicsmodelhavokserializedshape
		{
			long long field_pointer_skip;
			c_typed_tag_block<s_i343physicsmodelprimitive> primitive_block;
			s_tag_data havok_shape_data;
			char generated_pad9227[4]; // padding
		};
		static_assert(sizeof(s_i343physicsmodelhavokserializedshape) == 44, "struct s_i343physicsmodelhavokserializedshape is invalid size");

		struct s_i343physicsmodelhavokserializedmass
		{
			long long field_pointer_skip;
			s_tag_data havok_serialized_data;
		};
		static_assert(sizeof(s_i343physicsmodelhavokserializedmass) == 28, "struct s_i343physicsmodelhavokserializedmass is invalid size");

		struct s_i343physicsmodelconstraintbodies
		{
			string_id name;
			long node_a;
			long node_b;
			real a_scale;
			real_vector3d a_forward;
			real_vector3d a_left;
			real_vector3d a_up;
			real_point3d a_position;
			real b_scale;
			real_vector3d b_forward;
			real_vector3d b_left;
			real_vector3d b_up;
			real_point3d b_position;
			long edge_index;
		};
		static_assert(sizeof(s_i343physicsmodelconstraintbodies) == 120, "struct s_i343physicsmodelconstraintbodies is invalid size");

		struct s_i343physicsmodelhingeconstraint
		{
			s_i343physicsmodelconstraintbodies constraint_bodies;
		};
		static_assert(sizeof(s_i343physicsmodelhingeconstraint) == 120, "struct s_i343physicsmodelhingeconstraint is invalid size");

		struct s_i343physicsmodelragdollconstraint
		{
			s_i343physicsmodelconstraintbodies constraint_bodies;
			real min_twist;
			real max_twist;
			real min_cone;
			real max_cone;
			real min_plane;
			real max_plane;
			real max_friciton_torque;
		};
		static_assert(sizeof(s_i343physicsmodelragdollconstraint) == 148, "struct s_i343physicsmodelragdollconstraint is invalid size");

		struct s_i343physicsmodelragdollsubgroupindex
		{
			long node;
		};
		static_assert(sizeof(s_i343physicsmodelragdollsubgroupindex) == 4, "struct s_i343physicsmodelragdollsubgroupindex is invalid size");

		struct s_i343physicsmodelragdollsubgroup
		{
			string_id name;
			c_typed_tag_block<s_i343physicsmodelragdollsubgroupindex> nodes_block;
		};
		static_assert(sizeof(s_i343physicsmodelragdollsubgroup) == 16, "struct s_i343physicsmodelragdollsubgroup is invalid size");

		struct s_i343physicsmodelselfcollisionpair
		{
			char nodea;
			char nodeb;
		};
		static_assert(sizeof(s_i343physicsmodelselfcollisionpair) == 2, "struct s_i343physicsmodelselfcollisionpair is invalid size");

		struct s_i343physicsmodelpointtopathcurvepoint
		{
			real_point3d position;
			real t_value;
		};
		static_assert(sizeof(s_i343physicsmodelpointtopathcurvepoint) == 16, "struct s_i343physicsmodelpointtopathcurvepoint is invalid size");

		struct s_i343physicsmodelpointtopathcurve
		{
			string_id name;
			long node_index;
			c_typed_tag_block<s_i343physicsmodelpointtopathcurvepoint> points_block;
		};
		static_assert(sizeof(s_i343physicsmodelpointtopathcurve) == 20, "struct s_i343physicsmodelpointtopathcurve is invalid size");

		struct s_i343physicsmodellimitedhingeconstraint
		{
			s_i343physicsmodelconstraintbodies constraint_bodies;
			real limit_friction;
			real limit_min_angle;
			real limit_max_angle;
		};
		static_assert(sizeof(s_i343physicsmodellimitedhingeconstraint) == 132, "struct s_i343physicsmodellimitedhingeconstraint is invalid size");

		struct s_i343physicsmodelballandsocketconstraint
		{
			s_i343physicsmodelconstraintbodies constraint_bodies;
		};
		static_assert(sizeof(s_i343physicsmodelballandsocketconstraint) == 120, "struct s_i343physicsmodelballandsocketconstraint is invalid size");

		struct s_i343physicsmodelstiffspringconstraint
		{
			s_i343physicsmodelconstraintbodies constraint_bodies;
			real spring_length;
		};
		static_assert(sizeof(s_i343physicsmodelstiffspringconstraint) == 124, "struct s_i343physicsmodelstiffspringconstraint is invalid size");

		struct s_i343physicsmodelprismaticconstraint
		{
			s_i343physicsmodelconstraintbodies constraint_bodies;
			real min_limit;
			real max_limit;
			real max_friction_force;
		};
		static_assert(sizeof(s_i343physicsmodelprismaticconstraint) == 132, "struct s_i343physicsmodelprismaticconstraint is invalid size");

		struct s_i343physicsmodelrigidbodyblockhandle
		{
			long rigid_body;
		};
		static_assert(sizeof(s_i343physicsmodelrigidbodyblockhandle) == 4, "struct s_i343physicsmodelrigidbodyblockhandle is invalid size");

		struct s_i343physicsmodelpermutation
		{
			string_id name;
			c_typed_tag_block<s_i343physicsmodelrigidbodyblockhandle> rigid_bodies_block;
		};
		static_assert(sizeof(s_i343physicsmodelpermutation) == 16, "struct s_i343physicsmodelpermutation is invalid size");

		struct s_i343physicsmodelregion
		{
			string_id name;
			c_typed_tag_block<s_i343physicsmodelpermutation> permutations_block;
		};
		static_assert(sizeof(s_i343physicsmodelregion) == 16, "struct s_i343physicsmodelregion is invalid size");

		struct s_i343physicsmodelnode
		{
			string_id name;
			c_flags<e_i343physicsmodelnodephysicsmodelnodeflags, long, k_i343physicsmodelnodephysicsmodelnodeflags_count> flags;
			long parent;
			long sibling;
			long child;
		};
		static_assert(sizeof(s_i343physicsmodelnode) == 20, "struct s_i343physicsmodelnode is invalid size");

		struct s_i343physicsmodelphysicsmodeldefinition
		{
			s_anytag_struct_definition anytag;
			c_flags<e_i343physicsmodelphysicsmodelflag, long, k_i343physicsmodelphysicsmodelflag_count> flags;
			real mass_override;
			real mass_scale_override;
			real low_freq_deactivation_scale;
			real high_freq_deactivation_scale;
			char import_version;
			char generated_pad19c2[3]; // padding
			real welding_tolerance;
			c_typed_tag_block<s_i343physicsmodeldampedspringmotor> damped_spring_motors_block;
			c_typed_tag_block<s_i343physicsmodelpositionmotor> position_motors_block;
			c_typed_tag_block<s_i343physicsmodelphantomtype> phantom_types_block;
			c_typed_tag_block<s_i343physicsmodelpoweredchain> powered_chains_block;
			c_typed_tag_block<s_i343physicsmodelnodeconstraintedge> node_edges_block;
			c_typed_tag_block<s_i343physicsmodelphysicsmodelrigidbody> rigid_bodies_block;
			c_typed_tag_block<s_i343physicsmodelmaterial> materials_block;
			c_typed_tag_block<s_i343physicsmodelhavokserializedshape> convex_hulls_block;
			c_typed_tag_block<s_i343physicsmodelhavokserializedshape> spheres_block;
			c_typed_tag_block<s_i343physicsmodelhavokserializedshape> multi_spheres_block;
			c_typed_tag_block<s_i343physicsmodelhavokserializedshape> pills_block;
			c_typed_tag_block<s_i343physicsmodelhavokserializedshape> boxes_block;
			c_typed_tag_block<s_i343physicsmodelhavokserializedshape> compound_shapes_block;
			c_typed_tag_block<s_i343physicsmodelhavokserializedshape> triangles_block;
			c_typed_tag_block<s_i343physicsmodelhavokserializedshape> triangle_meshs_block;
			c_typed_tag_block<s_i343physicsmodelhavokserializedmass> mass_distributions_block;
			c_typed_tag_block<s_i343physicsmodelhingeconstraint> hinge_constraints_block;
			c_typed_tag_block<s_i343physicsmodelragdollconstraint> ragdoll_constraints_block;
			c_typed_tag_block<s_i343physicsmodelragdollsubgroup> ragdoll_subgroups_block;
			c_typed_tag_block<s_i343physicsmodelselfcollisionpair> self_collision_pairs_block;
			c_typed_tag_block<s_i343physicsmodelpointtopathcurve> point_to_path_curves_block;
			c_typed_tag_block<s_i343physicsmodellimitedhingeconstraint> limited_hinge_constraints_block;
			c_typed_tag_block<s_i343physicsmodelballandsocketconstraint> ball_and_socket_constraints_block;
			c_typed_tag_block<s_i343physicsmodelstiffspringconstraint> stiff_spring_constraints_block;
			c_typed_tag_block<s_i343physicsmodelprismaticconstraint> prismatic_constraints_block;
			c_typed_tag_block<s_i343physicsmodelregion> regions_block;
			c_typed_tag_block<s_i343physicsmodelnode> nodes_block;
			c_typed_tag_block<s_error_report_category> errors_block;
			char generated_pad6677[4]; // padding
		};
		static_assert(sizeof(s_i343physicsmodelphysicsmodeldefinition) == 384, "struct s_i343physicsmodelphysicsmodeldefinition is invalid size");

		struct s_i343physicsshapedensitythresholds
		{
			real shape_density_error_threshold;
			real shape_density_warning_threshold;
		};
		static_assert(sizeof(s_i343physicsshapedensitythresholds) == 8, "struct s_i343physicsshapedensitythresholds is invalid size");

		struct s_i343physicsphysicsglobalsdefinition
		{
			s_anytag_struct_definition anytag;
			// custom shape_density_configuration

			/* Shape density configuration */


			/* Play collision density thresholds for assets */

			s_i343physicsshapedensitythresholds play_collision_thresholds_for_assets;

			/* Bullet collision density thresholds for assets */

			s_i343physicsshapedensitythresholds bullet_collision_thresholds_for_assets;

			/* Play collision density thresholds for levels */

			s_i343physicsshapedensitythresholds play_collision_thresholds_for_levels;

			/* Bullet collision density thresholds for levels */

			s_i343physicsshapedensitythresholds bullet_collision_thresholds_for_levels;
			// custom value
		};
		static_assert(sizeof(s_i343physicsphysicsglobalsdefinition) == 48, "struct s_i343physicsphysicsglobalsdefinition is invalid size");

		struct s_i343assetphysicsphysicsmaterial
		{
			string_id property_region;
			c_flags<e_i343assetphysicsphysicsmaterialflags, char, k_i343assetphysicsphysicsmaterialflags_count> flags;
			char generated_padfd60[3]; // padding
			string_id phantom_type_name;

			/* Collision layer override */

			string_id collision_layer;
		};
		static_assert(sizeof(s_i343assetphysicsphysicsmaterial) == 16, "struct s_i343assetphysicsphysicsmaterial is invalid size");

		struct s_i343assetphysicshavokdata
		{
			c_flags<e_i343assetphysicshavokdataflags, char, k_i343assetphysicshavokdataflags_count> flags;
			char generated_padebef[3]; // padding
			real mass;
			real_vector3d center_of_mass_offset;
			real inertial_tensor_scale;
			real linear_air_drag;
			real angular_air_drag;
		};
		static_assert(sizeof(s_i343assetphysicshavokdata) == 32, "struct s_i343assetphysicshavokdata is invalid size");

		struct s_i343assetphysicsphysicsshape
		{
			string_id name;
			c_enum<e_i343assetphysicscompoundshapepolicy, char> compound_shape_policy;
			char generated_pad2544[3]; // padding
			real relative_mass_scale;
			c_enum<e_i343assetphysicsrigidbodymotiontype, char> motion_type;
			c_enum<e_i343assetphysicsrigidbodysize, char> size;
			char generated_pad3f25[2]; // padding
			real bounding_sphere_pad;
			c_typed_tag_block<s_i343assetphysicshavokdata> havok_data_block;
			// custom collision_layer

			/* Collision layer override */

			string_id collision_layer;
			c_enum<e_i343assetphysicsrigidbodycollisionqualityoverride, char> collision_quality_override_type;
			char generated_pad8bda[3]; // padding
			// custom value
			// custom stupid_mass

			/* Stupid mass override */

			real mass_body_override;
			real_vector3d mass_distribution_override;
			// custom value
			// custom water_physics

			/* Water physics bounding box */

			real water_physics_x0;
			real water_physics_x1;
			real water_physics_y0;
			real water_physics_y1;
			real water_physics_z0;
			real water_physics_z1;
			// custom value
		};
		static_assert(sizeof(s_i343assetphysicsphysicsshape) == 80, "struct s_i343assetphysicsphysicsshape is invalid size");

		struct s_i343assetphysicsselfcollisionpair
		{
			short first_shape_setting;
			short second_shape_setting;
		};
		static_assert(sizeof(s_i343assetphysicsselfcollisionpair) == 4, "struct s_i343assetphysicsselfcollisionpair is invalid size");

		struct s_i343assetphysicsphantomtype
		{
			string_id name;
			// custom flags
			c_flags<e_i343assetphysicsphantomflags, long, k_i343assetphysicsphantomflags_count> flags;
			// custom value
			real brittle_timer;
			c_enum<e_i343assetphysicsrigidbodysize, char> minimum_size;
			c_enum<e_i343assetphysicsrigidbodysize, char> maximum_size;
			char generated_paddcef[2]; // padding
			// custom value
			string_id marker_name;
			// custom value
			string_id mancannon_launched_object_marker_name;
			// custom value
			string_id alignment_marker_name;
			// custom linear_motion

			/* Linear motion */

			real hookes_law_e;
			real linear_dead_radius;
			real center_acceleration;
			real center_maximum_velocity;
			real axis_acceleration;
			real axis_maximum_velocity;
			real direction_acceleration;
			real direction_maximum_velocity;
			real orbit_acceleration;
			real orbit_maximum_velocity;
			// custom value
			// custom angular_motion

			/* Angular motion */

			real alignment_hookes_law_e;
			real alignment_acceleration;
			real alignment_maximum_velocity;
			// custom value
			// custom damage_per_second
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> damage_per_second_effect;
			c_typed_tag_reference<VISUALMATERIALEFFECTSDEFINITION_TAG> damage_per_second_visual_material_effects;
			c_typed_tag_reference<SOUNDMATERIALEFFECTSDEFINITION_TAG> damage_per_second_sound_material_effects;
			string_id damage_per_second_object_function;
			real damage_per_second_object_function_threshold;
			// custom value
		};
		static_assert(sizeof(s_i343assetphysicsphantomtype) == 136, "struct s_i343assetphysicsphantomtype is invalid size");

		struct s_i343assetphysicsragdollconstraintsettings
		{
			real minimum_twist;
			real maximum_twist;
			real minimum_cone;
			real maximum_cone;
			real minimum_plane;
			real maximum_plane;
			real maximum_friction_torque;
		};
		static_assert(sizeof(s_i343assetphysicsragdollconstraintsettings) == 28, "struct s_i343assetphysicsragdollconstraintsettings is invalid size");

		struct s_i343assetphysicsmotor
		{
			c_enum<e_i343assetphysicsmotortype, char> motor_type;
			char generated_pad18f3[3]; // padding
			string_id motor_name_reference;
		};
		static_assert(sizeof(s_i343assetphysicsmotor) == 8, "struct s_i343assetphysicsmotor is invalid size");

		struct s_i343assetphysicsragdollmotors
		{

			/* Twist */

			s_i343assetphysicsmotor twist_motor;

			/* Cone */

			s_i343assetphysicsmotor cone_motor;

			/* Plane */

			s_i343assetphysicsmotor plane_motor;
		};
		static_assert(sizeof(s_i343assetphysicsragdollmotors) == 24, "struct s_i343assetphysicsragdollmotors is invalid size");

		struct s_i343assetphysicslimitedhingeconstraintsettings
		{
			real limit_friction;
			real limit_minimum_angle;
			real limit_maximum_angle;
		};
		static_assert(sizeof(s_i343assetphysicslimitedhingeconstraintsettings) == 12, "struct s_i343assetphysicslimitedhingeconstraintsettings is invalid size");

		struct s_i343assetphysicslimitedhingemotor
		{
			s_i343assetphysicsmotor motor;
		};
		static_assert(sizeof(s_i343assetphysicslimitedhingemotor) == 8, "struct s_i343assetphysicslimitedhingemotor is invalid size");

		struct s_i343assetphysicsstiffspringconstraintsettings
		{
			real spring_length;
		};
		static_assert(sizeof(s_i343assetphysicsstiffspringconstraintsettings) == 4, "struct s_i343assetphysicsstiffspringconstraintsettings is invalid size");

		struct s_i343assetphysicsprismaticconstraintsettings
		{
			real minimum_limit;
			real maximum_limit;
			real maximum_friction_force;
		};
		static_assert(sizeof(s_i343assetphysicsprismaticconstraintsettings) == 12, "struct s_i343assetphysicsprismaticconstraintsettings is invalid size");

		struct s_i343assetphysicsconstraintsettings
		{
			string_id name;
			c_enum<e_i343assetphysicsconstrainttype, char> type;
			c_flags<e_i343assetphysicsrigidbodyconstraintedgeconstraintflags, char, k_i343assetphysicsrigidbodyconstraintedgeconstraintflags_count> flags;
			char generated_padd2a4[2]; // padding
			real friction;
			c_typed_tag_block<s_i343assetphysicsragdollconstraintsettings> ragdoll_settings_block;
			c_typed_tag_block<s_i343assetphysicsragdollmotors> ragdoll_motors_block;
			c_typed_tag_block<s_i343assetphysicslimitedhingeconstraintsettings> limited_hinge_settings_block;
			c_typed_tag_block<s_i343assetphysicslimitedhingemotor> limited_hinge_motors_block;
			c_typed_tag_block<s_i343assetphysicsstiffspringconstraintsettings> stiff_spring_settings_block;
			c_typed_tag_block<s_i343assetphysicsprismaticconstraintsettings> prismatic_settings_block;
		};
		static_assert(sizeof(s_i343assetphysicsconstraintsettings) == 84, "struct s_i343assetphysicsconstraintsettings is invalid size");

		struct s_i343assetphysicsdampedspringmotor
		{
			string_id name;
			real maximum_force;
			real minimum_force;
			real spring_k;
			real damping;
			real initial_position;
		};
		static_assert(sizeof(s_i343assetphysicsdampedspringmotor) == 24, "struct s_i343assetphysicsdampedspringmotor is invalid size");

		struct s_i343assetphysicspositionmotor
		{
			string_id name;
			real maximum_force;
			real minimum_force;
			real tau;
			real damping;
			real proportion_recover_velocity;
			real constant_recover_velocity;
			real initial_position;
		};
		static_assert(sizeof(s_i343assetphysicspositionmotor) == 32, "struct s_i343assetphysicspositionmotor is invalid size");

		struct s_assetphysicstag
		{
			s_anytag_struct_definition anytag;
			c_flags<e_i343assetphysicsassetphysicsflags, char, k_i343assetphysicsassetphysicsflags_count> flags;
			char generated_pad7535[3]; // padding
			real mass_override;
			real mass_scale_override;
			c_typed_tag_block<s_i343assetphysicsphysicsmaterial> materials_block;
			// custom shapes
			c_typed_tag_block<s_i343assetphysicsphysicsshape> shapes_block;
			c_typed_tag_block<s_i343assetphysicsselfcollisionpair> self_collision_pairs_block;
			// custom value
			c_typed_tag_block<s_i343assetphysicsphantomtype> phantom_types_block;
			// custom constraints_and_motors
			c_typed_tag_block<s_i343assetphysicsconstraintsettings> constraints_block;
			c_typed_tag_block<s_i343assetphysicsdampedspringmotor> damped_spring_motors_block;
			c_typed_tag_block<s_i343assetphysicspositionmotor> position_motors_block;
			// custom value
		};
		static_assert(sizeof(s_assetphysicstag) == 112, "struct s_assetphysicstag is invalid size");

		struct s_interfacecustomizationuiplatformanimationsettings
		{
			string_id platfrom_name;
			c_enum<e_interfacecustomizationplatforms, short> platform_type;
			char generated_padd394[2]; // padding
			real vertical_animation_offset;
			real transition_time;
			c_enum<e_interfacecustomizationanimationeasing, short> animation_easing;
			char generated_paded75[2]; // padding
			real_euler_angles3d platform_selection_orientation_offset;
			real_euler_angles3d default_orientation;
			c_static_string<32> platform_camera_point;
		};
		static_assert(sizeof(s_interfacecustomizationuiplatformanimationsettings) == 76, "struct s_interfacecustomizationuiplatformanimationsettings is invalid size");

		struct s_interfacecustomizationuiplatformanimationstag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_interfacecustomizationuiplatformanimationsettings> customization_platform_animation_settings_block;
			char generated_padd22a[4]; // padding
		};
		static_assert(sizeof(s_interfacecustomizationuiplatformanimationstag) == 32, "struct s_interfacecustomizationuiplatformanimationstag is invalid size");

		struct s_i343physicslowceilingcontrol
		{
			real cast_length;
			real cast_radius;
			real_fraction ceiling_normal_max_z;
			real acceleration_max;
		};
		static_assert(sizeof(s_i343physicslowceilingcontrol) == 16, "struct s_i343physicslowceilingcontrol is invalid size");

		struct s_i343physicslowceilingcontroltag
		{
			s_anytag_struct_definition anytag;
			s_i343physicslowceilingcontrol lowceiling;
		};
		static_assert(sizeof(s_i343physicslowceilingcontroltag) == 32, "struct s_i343physicslowceilingcontroltag is invalid size");

		struct s_s_model_customization_player_region_permutation
		{
			string_id region_name;
			string_id permutation_name;
			c_flags<e_c_model_customization_player_permutation_flags, char, k_c_model_customization_player_permutation_flags_count> flags;
			char generated_pad5691[3]; // padding
		};
		static_assert(sizeof(s_s_model_customization_player_region_permutation) == 12, "struct s_s_model_customization_player_region_permutation is invalid size");

		struct s_s_model_customization_selection
		{
			string_id selection_name;
			c_typed_tag_block<s_s_model_customization_player_region_permutation> customized_bits_block;
		};
		static_assert(sizeof(s_s_model_customization_selection) == 16, "struct s_s_model_customization_selection is invalid size");

		struct s_i343objectcustomizationdefaultpermutationregions
		{
			string_id permutation_region;
			string_id default_permutation_name;
		};
		static_assert(sizeof(s_i343objectcustomizationdefaultpermutationregions) == 8, "struct s_i343objectcustomizationdefaultpermutationregions is invalid size");

		struct s_i343objectcustomizationdefaultregiondata
		{
			string_id title;
			string_id description;
			long cms_customization_item_type;
			c_static_string<256> cms_path;
			c_typed_tag_block<s_i343objectcustomizationdefaultpermutationregions> permutation_regions_block;
		};
		static_assert(sizeof(s_i343objectcustomizationdefaultregiondata) == 280, "struct s_i343objectcustomizationdefaultregiondata is invalid size");

		struct s_i343objectcustomizationdefaultcoredata
		{
			string_id default_theme_name;
			string_id default_variant_id;
			string_id default_style_id;
			string_id title;
			string_id description;
			c_typed_tag_reference<RENDER_MODEL_TAG> default_rendermodeldefinition;
			c_static_string<256> cms_id;
			c_typed_tag_block<s_i343objectcustomizationdefaultregiondata> permutation_regions_block;
		};
		static_assert(sizeof(s_i343objectcustomizationdefaultcoredata) == 304, "struct s_i343objectcustomizationdefaultcoredata is invalid size");

		struct s_s_player_model_customization_globals_definition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<RENDER_MODEL_TAG> spartan_render_model;
			c_typed_tag_reference<RENDER_MODEL_TAG> elite_render_model;
			c_typed_tag_block<s_s_model_customization_selection> helmet_selections_block;
			c_typed_tag_block<s_s_model_customization_selection> chest_selections_block;
			c_typed_tag_block<s_s_model_customization_selection> elite_selections_block;
			c_typed_tag_block<s_s_model_customization_selection> left_shoulder_block;
			c_typed_tag_block<s_s_model_customization_selection> right_shoulder_block;
			c_typed_tag_block<s_s_model_customization_selection> arms_block;
			c_typed_tag_block<s_s_model_customization_selection> legs_block;
			c_typed_tag_block<s_s_model_customization_selection> unused_5_block;
			c_typed_tag_block<s_s_model_customization_selection> spartan_armor_effect_selections_block;
			c_typed_tag_block<s_s_model_customization_selection> elite_armor_effect_selections_block;
			c_typed_tag_block<s_s_model_customization_player_region_permutation> male_spartan_selections_block;
			c_typed_tag_block<s_s_model_customization_player_region_permutation> female_spartan_selections_block;
			c_typed_tag_block<s_i343objectcustomizationdefaultcoredata> spartan_model_defaults_block;
			c_typed_tag_block<s_s_model_customization_player_region_permutation> elite_model_defaults_block;
		};
		static_assert(sizeof(s_s_player_model_customization_globals_definition) == 216, "struct s_s_player_model_customization_globals_definition is invalid size");

		struct s_particledefinitiongpudatagpuconstantregister
		{
			real runtime_gpu_real;
		};
		static_assert(sizeof(s_particledefinitiongpudatagpuconstantregister) == 4, "struct s_particledefinitiongpudatagpuconstantregister is invalid size");

		struct s_c_particle_model_definitions_gpu_datas_variant
		{
			s_particledefinitiongpudatagpuconstantregister runtime_m_count[4];
		};
		static_assert(sizeof(s_c_particle_model_definitions_gpu_datas_variant) == 16, "struct s_c_particle_model_definitions_gpu_datas_variant is invalid size");

		struct s_c_particle_model_definitions_gpu_data
		{
			c_typed_tag_block<s_c_particle_model_definitions_gpu_datas_variant> m_variants_block;
		};
		static_assert(sizeof(s_c_particle_model_definitions_gpu_data) == 12, "struct s_c_particle_model_definitions_gpu_data is invalid size");

		struct s_c_particle_model_definition
		{
			s_anytag_struct_definition anytag;
			s_s_render_geometry render_geometry;
			s_c_particle_model_definitions_gpu_data m_gpu_data;
			char generated_pad910e[4]; // padding
		};
		static_assert(sizeof(s_c_particle_model_definition) == 224, "struct s_c_particle_model_definition is invalid size");

		struct s_particlemovementdefinitiontag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<PARTICLE_PHYSICS_TAG> _template;
			c_flags<e_c_particle_movement_definitionflags, short, k_c_particle_movement_definitionflags_count> flags;
			char collision_controller_index;
			char turbulence_controller_index;
			char global_force_controller_index;
			char generated_pada13e[3]; // padding
			c_typed_tag_block<s_c_particle_controller> movements_block;
			c_typed_tag_reference<BITMAP_TAG> turbulence_texture;
			char generated_padedf3[4]; // padding
		};
		static_assert(sizeof(s_particlemovementdefinitiontag) == 72, "struct s_particlemovementdefinitiontag is invalid size");

		struct s_i343personalaicolorpresetdata
		{
			string_id color_preset;
			real color_intensity;
			rgb_color base_color;
			real glow_color_intensity;
			rgb_color glow_color;
			long scanline_pattern;
			real scanline_scale;
			real scanline_speed;
			real face_color_intensity;
			rgb_color face_color;
		};
		static_assert(sizeof(s_i343personalaicolorpresetdata) == 64, "struct s_i343personalaicolorpresetdata is invalid size");

		struct s_i343personalaifacialanimationframeeventdata
		{
			long bitmap_index;
			real display_frame_length;
		};
		static_assert(sizeof(s_i343personalaifacialanimationframeeventdata) == 8, "struct s_i343personalaifacialanimationframeeventdata is invalid size");

		struct s_i343personalaianimationdata
		{
			c_enum<e_i343personalaianimationtype, long> animation_type;
			string_id body_transition_parameter;
			c_flags<e_i343personalaianimationflags, short, k_i343personalaianimationflags_count> flags;
			char generated_pad60f5[2]; // padding
			c_typed_tag_block<s_i343personalaifacialanimationframeeventdata> facial_animation_data_block;
		};
		static_assert(sizeof(s_i343personalaianimationdata) == 24, "struct s_i343personalaianimationdata is invalid size");

		struct s_i343personalaiavatarconfigurationdata
		{
			c_enum<e_i343personalaiavatartype, long> avatar_type;
			string_id avatar_variant_name;
			long facial_bitmap_index_count;
			string_id facial_animation_parameter;
			real effect_on_spawn_delay;
			real effect_on_despawn_delay;
			c_typed_tag_block<s_i343personalaianimationdata> animations_block;
		};
		static_assert(sizeof(s_i343personalaiavatarconfigurationdata) == 36, "struct s_i343personalaiavatarconfigurationdata is invalid size");

		struct s_i343personalaipersonalaiglobalsdefinition
		{
			s_anytag_struct_definition anytag;
			c_flags<e_i343personalaiavatarflags, short, k_i343personalaiavatarflags_count> flags;
			char generated_pad7f42[2]; // padding
			real effect_on_spawn_duration;
			real effect_on_despawn_duration;
			real gaze_return_orientation_speed;
			real initial_gaze_duration;
			long maximum_base_color_intensity;
			long maximum_face_color_intensity;
			long maximum_glow_color_intensity;
			long maximum_scanline_scale;
			long maximum_scanline_speed;
			long scanline_pattern_count;
			c_typed_tag_block<s_i343personalaicolorpresetdata> color_preset_definitions_block;
			c_typed_tag_block<s_i343personalaiavatarconfigurationdata> avatar_configurations_block;
			char generated_padcbf7[4]; // padding
		};
		static_assert(sizeof(s_i343personalaipersonalaiglobalsdefinition) == 88, "struct s_i343personalaipersonalaiglobalsdefinition is invalid size");

		struct s_physicsphantomindices
		{
			char phantom_index;
		};
		static_assert(sizeof(s_physicsphantomindices) == 1, "struct s_physicsphantomindices is invalid size");

		struct s_physicsphantomsoundeventpair
		{
			c_enum<e_physicsphantomobjecttype, char> object_type;
			char generated_padad5f[3]; // padding
			string_id enter_event;
			string_id exit_event;
			c_typed_tag_block<s_physicsphantomindices> restrict_to_phantoms_block;
		};
		static_assert(sizeof(s_physicsphantomsoundeventpair) == 24, "struct s_physicsphantomsoundeventpair is invalid size");

		struct s_physicsphantomsoundtagpair
		{
			c_enum<e_physicsphantomobjecttype, char> object_type;
			char generated_pad7bb7[3]; // padding
			c_typed_tag_reference<SOUND_TAG> enter_sound_tag;
			c_typed_tag_reference<SOUND_TAG> exit_sound_tag;
			c_typed_tag_block<s_physicsphantomindices> restrict_to_phantoms_block;
		};
		static_assert(sizeof(s_physicsphantomsoundtagpair) == 48, "struct s_physicsphantomsoundtagpair is invalid size");

		struct s_physicsphantomssounddefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_physicsphantomsoundeventpair> sound_events_block;
			string_id biped_travel_event;
			c_typed_tag_block<s_physicsphantomsoundtagpair> legacy_sound_tags_block;
			c_typed_tag_reference<SOUND_TAG> legacy_biped_travel_tag;
			c_typed_tag_reference<SOUND_TAG> biped_launch_sound;
			c_typed_tag_reference<SOUND_TAG> biped_launch_sound___player;
			c_typed_tag_reference<SOUND_TAG> vehicle_launch_sound;
			c_typed_tag_reference<SOUND_TAG> grenade_launch_sound;
		};
		static_assert(sizeof(s_physicsphantomssounddefinition) == 124, "struct s_physicsphantomssounddefinition is invalid size");

		struct s_point_physics_definition
		{
			s_anytag_struct_definition anytag;
			c_flags<e_pointphysicsdefinitionflags, long, k_pointphysicsdefinitionflags_count> flags;
			real runtime_mass_over_radius_cubed;
			real runtime_inverse_density;
			long ignore1;
			long ignore2;
			long ignore3;
			long ignore4;
			long ignore5;
			real density;
			real air_friction;
			real water_friction;
			real surface_friction;
			real elasticity;

			/* Densities (g/mL) */

			char generated_pad1ff6[4]; // padding
		};
		static_assert(sizeof(s_point_physics_definition) == 72, "struct s_point_physics_definition is invalid size");

		struct s_prefabmaterialoverridevariant
		{
			string_id material_override_variant_name;
			c_typed_tag_block<s_materialoverrideentry> material_override_entries_block;
		};
		static_assert(sizeof(s_prefabmaterialoverridevariant) == 16, "struct s_prefabmaterialoverridevariant is invalid size");

		struct s_structure_prefab
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<SCENARIO_STRUCTURE_BSP_TAG> bsp_reference;
			c_typed_tag_block<s_prefabmaterialoverridevariant> material_overrides_block;
		};
		static_assert(sizeof(s_structure_prefab) == 44, "struct s_structure_prefab is invalid size");

		struct s_projectileflybytag
		{
			s_anytag_struct_definition anytag;
			s_tag_reference flyby_enter_sound;
			s_tag_reference flyby_exit_sound;
			string_id flyby_switch_container_name;
			short flyby_sound_variations;
			short avoid_repeating_the_last;
			real flyby_sound_stereo_width_pan;
			real flyby_sound_enter_offset;
			real flyby_sound_exit_offset;
			char generated_pad9d4f[4]; // padding
		};
		static_assert(sizeof(s_projectileflybytag) == 72, "struct s_projectileflybytag is invalid size");

		struct s_i343projectilesmaterialresponsedefinition
		{

			/* matching criteria */

			string_id material_name;
			short runtime_material_index;
			c_flags<e_i343projectilespossibleresponseflags, short, k_i343projectilespossibleresponseflags_count> response_flags;
			real_fraction chance_fraction;
			angle_bounds between;
			real_bounds _and;

			/* response */

			c_enum<e_i343projectilesmaterialresponse, short> response$2;

			/* misc */

			c_enum<e_i343projectilesmaterialresponsescalemode, short> scale_effects_by;
			angle angular_noise;
			real velocity_noise;

			/* overpenetration */

			real initial_friction;

			/* reflection */

			real parallel_friction;
			real perpendicular_friction;

			/* flags */

			c_flags<e_i343projectilesmaterialresponseflags, char, k_i343projectilesmaterialresponseflags_count> misc_flags;
			char generated_pad3f48[3]; // padding
		};
		static_assert(sizeof(s_i343projectilesmaterialresponsedefinition) == 56, "struct s_i343projectilesmaterialresponsedefinition is invalid size");

		struct s_i343projectilesprojectilematerialresponsedefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343projectilesmaterialresponsedefinition> material_response_block;
			char generated_padf741[4]; // padding
		};
		static_assert(sizeof(s_i343projectilesprojectilematerialresponsedefinition) == 32, "struct s_i343projectilesprojectilematerialresponsedefinition is invalid size");

		struct s_superdetonationdamagestruct
		{
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> super_detonation_damage;
		};
		static_assert(sizeof(s_superdetonationdamagestruct) == 16, "struct s_superdetonationdamagestruct is invalid size");

		struct s_angularvelocitylowerboundstructdeprecated
		{
			angle guided_angular_velocity_lower;
		};
		static_assert(sizeof(s_angularvelocitylowerboundstructdeprecated) == 4, "struct s_angularvelocitylowerboundstructdeprecated is invalid size");

		struct s_i343projectilesdeprecatedprojectilematerialresponsedefinitionv0
		{

			/* default result */

			c_enum<e_i343projectilesmaterialresponse, short> default_response;
			char generated_pad1fd0[2]; // padding
			string_id material_name;
			short runtime_material_index;

			/* potential result */

			c_enum<e_i343projectilesmaterialresponse, short> potential_response;
			c_flags<e_i343projectilespossibleresponseflags, short, k_i343projectilespossibleresponseflags_count> response_flags;
			char generated_pad39b1[2]; // padding
			real_fraction chance_fraction;
			angle_bounds between;
			real_bounds _and;

			/* misc */

			c_enum<e_i343projectilesmaterialresponsescalemode, short> scale_effects_by;
			char generated_pad8666[2]; // padding
			angle angular_noise;
			real velocity_noise;

			/* penetration */

			real initial_friction;

			/* reflection */

			real parallel_friction;
			real perpendicular_friction;
		};
		static_assert(sizeof(s_i343projectilesdeprecatedprojectilematerialresponsedefinitionv0) == 60, "struct s_i343projectilesdeprecatedprojectilematerialresponsedefinitionv0 is invalid size");

		struct s_projectileangularrotationdefinition
		{
			angle minimum_angular_vel;
			angle maximum_angular_vel;
			angle spin_angular_vel;
			real angular_damping;
			real drag_angle_constant;
			real drag_speed_constant;
			real drag_exponent;
			real attach_sample_radius;
			real attach_acceleration_constant;
			real attach_acceleration_scalar;
			real attach_acceleration_exponent;
			real attach_acceleration_damping;
		};
		static_assert(sizeof(s_projectileangularrotationdefinition) == 48, "struct s_projectileangularrotationdefinition is invalid size");

		struct s_s_projectile_fire_bomb_grenade_definition
		{
			real projection_offset;
		};
		static_assert(sizeof(s_s_projectile_fire_bomb_grenade_definition) == 4, "struct s_s_projectile_fire_bomb_grenade_definition is invalid size");

		struct s_s_projectile_conical_projection_defintion
		{

			/* conical_projection - AKA shotgun */

			short yaw_count;
			short pitch_count;
			real distribution_exponent;
			angle spread;
			c_typed_tag_reference<EFFECT_TAG> per_conical_projectile_firing_effect;
		};
		static_assert(sizeof(s_s_projectile_conical_projection_defintion) == 28, "struct s_s_projectile_conical_projection_defintion is invalid size");

		struct s_projectilesoundrtpcblockdefinition
		{
			long attachment_index;
			string_id function;
			string_id rtpc_name;
		};
		static_assert(sizeof(s_projectilesoundrtpcblockdefinition) == 12, "struct s_projectilesoundrtpcblockdefinition is invalid size");

		struct s_i343projectilestargetacquisitiondefinition
		{
			// custom target_acquisition

			/* Evaluation Order */

			c_enum<e_i343projectilesetargetacqusitionevaluationorder, char> evaluation_order$2;
			c_flags<e_i343projectilestargetacquisitionfilterflags, char, k_i343projectilestargetacquisitionfilterflags_count> filter_flags;
			c_flags<e_i343projectilestargetacquisitiontargettypeflags, short, k_i343projectilestargetacquisitiontargettypeflags_count> target_types;

			/* Domain Extents */

			real near_distance;
			real orientation_check_distance;

			/* Max Deviation */

			angle max_deviation_at_near_distance;
			angle max_deviation_at_far_distance;

			/* Probability */

			real_fraction probability_at_near_distance;
			real_fraction probability_at_far_distance;
			real_fraction ai_probability_modifier;

			/* Spread */

			angle spread_at_near_distance;
			angle spread_at_far_distance;
			// custom value
		};
		static_assert(sizeof(s_i343projectilestargetacquisitiondefinition) == 40, "struct s_i343projectilestargetacquisitiondefinition is invalid size");

		struct s_i343projectilessubmunitioneventdefinition
		{
			c_typed_tag_reference<PROJECTILE_TAG> type;
			short count;
			c_enum<e_i343projectilessubmunitionprediction, char> network_prediction;
			c_enum<e_i343projectilesesubmunitionplacement, char> placement;
			c_enum<e_i343projectilesesubmunitionorientation, short> orientation;
			c_enum<e_i343projectilesesubmunitiontrigger, short> trigger;
			c_flags<e_i343projectilessubmunitionflags, char, k_i343projectilessubmunitionflags_count> flags;
			c_enum<e_i343projectilessubmunitioncritmode, char> crit_mode;
			byte max_recursion_depth;
			char generated_pad564d[1]; // padding
			// custom delay_bounds
			real_bounds delay_bounds;
			real_fraction inherited_velocity;
			// custom initial_velocity_bounds
			real_bounds initial_velocity_bounds;
			real_fraction damage_scale;
			// custom default_placement

			/* The following fields are for default placment only */

			real_vector3d relative_offset;
			real_vector3d offset_variance;
			// custom value
			// custom spherical_placement

			/* The following fields are for spherical placment only */

			// custom radius_bounds
			real_bounds radius_bounds;
			real_vector3d individual_variance;
			// custom value
			// custom default_orientation

			/* The following fields are for default orientation */

			real_euler_angles2d relative_orientation;
			real_euler_angles2d orientation_variance;
			// custom value
			// custom target_orientation

			/* The following fields are used for target orientation only. */

			c_flags<e_i343projectilessubmunitionbipedorientationflags, char, k_i343projectilessubmunitionbipedorientationflags_count> biped_orientation_flags;
			char generated_pad3c6c[3]; // padding
			string_id unique_target_bucket_id;

			/* The following field is used for new target acquisition. */

			s_i343projectilestargetacquisitiondefinition target_acquisition;

			/* The following field is used for hit object validation. */

			s_i343projectilestargetacquisitiondefinition hit_object_validation;
			// custom value
		};
		static_assert(sizeof(s_i343projectilessubmunitioneventdefinition) == 200, "struct s_i343projectilessubmunitioneventdefinition is invalid size");

		struct s_projectile_definition
		{
			s_objectdefinition object;
			// custom $$$_projectile_$$$
			c_flags<e_c_projectile_definition_flags, long, k_c_projectile_definition_flags_count> flags;
			c_flags<e_c_secondary_projectile_definition_flags, long, k_c_secondary_projectile_definition_flags_count> secondary_flags;
			c_enum<e_detonationtimermodes, short> detonation_timer_starts;
			c_enum<e_i343aisoundvolume, short> impact_noise;
			real detonation_biped_proximity;
			real air_burst_proximity;
			real max_lifetime_to_detonate;
			real extent_____to_which_max_lifetime_may_vary;
			real collision_radius;

			/* detonation */

			real arming_time;
			real danger_radius;
			real danger_stimuli_radius;
			short danger_group_burst_count;
			short danger_group_burst_max_count;
			real_bounds timer;
			real minimum_velocity;
			real maximum_range;
			real bounce_maximum_range;
			real max_latch_time_to_detonate;
			real max_latch_time_to_arm;

			/* sequenced detonation */

			c_enum<e_i343projectilessequencedetonationdirection, char> sequenced_detonation_direction;
			char generated_pad56f8[3]; // padding
			real time_between_sequenced_detonations;
			c_enum<e_i343aisoundvolume, short> detonation_noise;
			short super_combine_contribution;
			short super_det_projectile_count;
			char generated_pad70d9[2]; // padding
			real super_det_time;
			real tether_release_safety_delay;

			/* tethering */

			c_typed_tag_reference<EFFECT_TAG> detonation_started;
			c_typed_tag_reference<EFFECT_TAG> detonation_effect_airborne;
			c_typed_tag_reference<EFFECT_TAG> detonation_effect_ground;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> detonation_damage;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> attached_detonation_damage;
			// custom continuous_damage
			c_typed_tag_reference<EFFECT_TAG> attached_continuous_effect;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> attached_continuous_damage;
			real attached_continuous_damage_period;
			// custom value
			s_tag_reference super_combine_definition;
			c_typed_tag_reference<SUPERCOMBINE_TAG> tag_graph_output;
			string_id output_node_name;
			c_typed_tag_block<s_taggraphtaggraphfloatparam> float_params_block;
			c_typed_tag_reference<EFFECT_TAG> super_detonation;
			s_superdetonationdamagestruct your_momma;
			s_tag_reference detonation_sound;
			s_tag_reference super_detonation_sound;
			s_tag_reference submerged_detonation_sound;
			c_flags<e_scenarioobjecttypeflag, short, k_scenarioobjecttypeflag_count> super_detonation_object_types;
			char generated_padbd8e[2]; // padding
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> super_attached_detonation_damage;
			// custom material_effect
			real material_effect_radius;
			real material_effect_bounce_hard_speed_threshold;
			real material_effect_bounce_medium_speed_threshold;
			// custom value

			/* flyby/impact */

			c_typed_tag_reference<PROJECTILEFLYBY_TAG> flyby_sound_reference;
			c_typed_tag_reference<DAMAGE_RESPONSE_DEFINITION_TAG> flyby_damage_response;
			real flyby_damage_response_max_distance;
			c_typed_tag_reference<EFFECT_TAG> chaining_attach_effect;
			string_id chaining_attach_end_marker;
			string_id chaining_attach_start_marker;
			c_typed_tag_reference<EFFECT_TAG> impact_effect;
			c_typed_tag_reference<EFFECT_TAG> object_impact_effect;
			s_tag_reference impact_damage;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> impact_tag_graph_output;
			string_id impact_output_node_name;
			c_typed_tag_block<s_taggraphtaggraphfloatparam> impact_float_params_block;

			/* boarding fields */

			real boarding_detonation_time;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> boarding_detonation_damage;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> boarding_attached_detonation_damage;

			/* physics */

			real air_gravity_scale;
			real_bounds air_damage_range;
			real water_gravity_scale;
			real_bounds water_damage_range;
			real initial_velocity;
			real final_velocity;
			real indirect_fire_velocity;
			real ai_velocity_scale_normal;
			real ai_velocity_scale_heroic;
			real ai_velocity_scale_legendary;
			real ai_guided_angular_velocity_scale_normal;
			real ai_guided_angular_velocity_scale_legendary;
			s_angularvelocitylowerboundstructdeprecated blah;
			angle guided_angular_velocity_upper;
			angle_bounds guided_angular_velocity_random_range;
			angle guided_angular_velocity_at_rest;
			real_bounds acceleration_range;
			real runtime_acceleration_bound_inverse;
			real_fraction ai_target_leading_scale_easy;
			real_fraction ai_target_leading_scale_normal;
			real_fraction ai_target_leading_scale_heroic;
			real_fraction ai_target_leading_scale_legendary;
			real_fraction targeted_leading_fraction;
			real guided_projectile_outer_range_error_radius;
			real autoaim_leading_max_lead_time;
			c_typed_tag_reference<PROJECTILEMATERIALRESPONSE_TAG> material_response_reference;
			c_typed_tag_block<s_i343projectilesdeprecatedprojectilematerialresponsedefinitionv0> old_material_responses_block;
			c_typed_tag_block<s_i343projectilesmaterialresponsedefinition> material_response_block;
			c_typed_tag_block<s_projectileangularrotationdefinition> brute_grenade_block;
			c_typed_tag_block<s_s_projectile_fire_bomb_grenade_definition> fire_bomb_grenade_block;
			c_typed_tag_block<s_s_projectile_conical_projection_defintion> conical_spread_block;
			c_typed_tag_reference<GROUNDED_FRICTION_TAG> grounded_friction_settings;
			real_point3d killcam_projectile_camera_offsets;
			c_typed_tag_block<s_projectilesoundrtpcblockdefinition> sound_rtpcs_block;
			real sound_projectile_rtpc_weight;
			c_typed_tag_block<s_i343projectilessubmunitioneventdefinition> submunition_events_block;
			c_enum<e_i343projectileseacquiretargetmode, char> target_selection_condition;
			char generated_padd76f[3]; // padding
			s_i343projectilestargetacquisitiondefinition target_selection;
			// custom value
			// custom charged_properties
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> charged_detonation_damage;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> charged_impact_damage;
			c_typed_tag_reference<EFFECT_TAG> charged_visual_effect;
			c_typed_tag_reference<EFFECT_TAG> charged_detonation_effect;
			real charged_damage_scale;
			// custom value
		};
		static_assert(sizeof(s_projectile_definition) == 2132, "struct s_projectile_definition is invalid size");

		struct s_propspawnentry
		{
			c_typed_tag_reference<OBJECT_TAG> object_definition;
			real_vector3d position_offset;
			real_euler_angles2d yaw_pitch;
		};
		static_assert(sizeof(s_propspawnentry) == 36, "struct s_propspawnentry is invalid size");

		struct s_propspawntemplate
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_propspawnentry> prop_entries_block;
			char generated_pad36ca[4]; // padding
		};
		static_assert(sizeof(s_propspawntemplate) == 32, "struct s_propspawntemplate is invalid size");

		struct s_particledefinitiongpudatas_sprite
		{
			s_particledefinitiongpudatagpuconstantregister runtime_gpu_sprite_array[4];
		};
		static_assert(sizeof(s_particledefinitiongpudatas_sprite) == 16, "struct s_particledefinitiongpudatas_sprite is invalid size");

		struct s_particledefinitiongpudata
		{
			c_typed_tag_block<s_particledefinitiongpudatas_sprite> runtime_m_sprite_block;
		};
		static_assert(sizeof(s_particledefinitiongpudata) == 12, "struct s_particledefinitiongpudata is invalid size");

		struct s_c_particle_definition_tag
		{
			s_anytag_struct_definition anytag;
			c_flags<e_c_particle_definitionparticleappearanceflags, long, k_c_particle_definitionparticleappearanceflags_count> appearance_flags;
			c_enum<e_c_particle_emitter_definitionc_particle_emitter_billboard_type, short> particle_billboard_style;
			short pad;
			real_point2d center_offset;
			// custom material
			// custom value
			s_material actual_material;
			// custom value
			// custom value
			real tint_factor;
			c_typed_tag_reference<PARTICLEASSET_TAG> asset;
			c_typed_tag_reference<PARTICLE_MODEL_TAG> model;
			s_particledefinitiongpudata runtime_m_gpu_data;
			char generated_pad8af4[4]; // padding
			long long m_pipelinestates;
		};
		static_assert(sizeof(s_c_particle_definition_tag) == 164, "struct s_c_particle_definition_tag is invalid size");

		struct s_nodegraphcontentparticleshadergraphcontenttag
		{
			s_nodegraphcontentnodegraphcontenttag nodegraph;
		};
		static_assert(sizeof(s_nodegraphcontentparticleshadergraphcontenttag) == 68, "struct s_nodegraphcontentparticleshadergraphcontenttag is invalid size");

		struct s_i343aisquadconstructionpassengercellentry
		{
			s_i343aisquadconstructionactorcellentry actorcellentrytag;
			c_enum<e_aiseatpreference, short> seat_preference;
			char generated_pade676[6]; // padding
		};
		static_assert(sizeof(s_i343aisquadconstructionpassengercellentry) == 76, "struct s_i343aisquadconstructionpassengercellentry is invalid size");

		struct s_shaderreference
		{
			c_typed_tag_reference<SHADER_BYTECODE_TAG> shader_bytecode;
		};
		static_assert(sizeof(s_shaderreference) == 16, "struct s_shaderreference is invalid size");

		struct s_i343graphicspipelinestateprecachedata
		{
			s_shaderreference shaderbytecodes[6];
			c_typed_tag_reference<SHADER_ROOT_SIGNATURE_TAG> rootsignature;
			long numreferences;
			byte vertextype;
			byte rasterizeroutputtype;
			byte rasterizermode;
			byte blendmode;
			byte depthstencilmode;
			byte primitivetopologytype;
			char generated_pad78d6[2]; // padding
		};
		static_assert(sizeof(s_i343graphicspipelinestateprecachedata) == 124, "struct s_i343graphicspipelinestateprecachedata is invalid size");

		struct s_i343graphicspipelinestatetypedata
		{
			c_typed_tag_block<s_i343graphicspipelinestateprecachedata> psodata_block;
		};
		static_assert(sizeof(s_i343graphicspipelinestatetypedata) == 12, "struct s_i343graphicspipelinestatetypedata is invalid size");

		struct s_i343graphicspipelinestatebucketdata
		{
			s_i343graphicspipelinestatetypedata psodata[4];
		};
		static_assert(sizeof(s_i343graphicspipelinestatebucketdata) == 48, "struct s_i343graphicspipelinestatebucketdata is invalid size");

		struct s_i343graphicspipelinestatedictionary
		{
			s_anytag_struct_definition anytag;
			s_i343graphicspipelinestatebucketdata psobucketdata[6];
			long numpipelinestates;
			char generated_pad1d21[4]; // padding
		};
		static_assert(sizeof(s_i343graphicspipelinestatedictionary) == 312, "struct s_i343graphicspipelinestatedictionary is invalid size");

		struct s_i343poweruppowerupdefinition
		{
			s_anytag_struct_definition anytag;
			string_id type;
			rgb_color color;
			rgb_color ui_fill_meter_color;
			rgb_color ui_backer_bitmap_color;
			c_typed_tag_reference<GENERICMODIFIERDEFINITIONTAG_TAG> generic_modifiers;
			char generated_pad6516[4]; // padding
		};
		static_assert(sizeof(s_i343poweruppowerupdefinition) == 76, "struct s_i343poweruppowerupdefinition is invalid size");

		struct s_i343scenariozonesetbakedpvssubregionlongparam
		{
			long value;
		};
		static_assert(sizeof(s_i343scenariozonesetbakedpvssubregionlongparam) == 4, "struct s_i343scenariozonesetbakedpvssubregionlongparam is invalid size");

		struct s_i343scenariozonesetbakedpvssubregiondwordparam
		{
			dword value;
		};
		static_assert(sizeof(s_i343scenariozonesetbakedpvssubregiondwordparam) == 4, "struct s_i343scenariozonesetbakedpvssubregiondwordparam is invalid size");

		struct s_i343scenariozonesetbakedpvssubregion
		{
			c_typed_tag_block<s_i343scenariozonesetbakedpvssubregiondwordparam> visibility_array_block;
			word sx;
			word sy;
			real z_min;
			real z_max;
		};
		static_assert(sizeof(s_i343scenariozonesetbakedpvssubregion) == 24, "struct s_i343scenariozonesetbakedpvssubregion is invalid size");

		struct s_i343scenariozonesetbakedpvsperbspdata
		{
			c_typed_tag_block<s_i343scenariozonesetbakedpvssubregion> subregion_array_block;
			real_point3d aabb_min;
			real_point3d aabb_max;
			real_vector3d block_size;
			long instance_count;
			long block_count_x;
			long block_count_y;
			long bsp_index;
			long long instance_postprocess_checksum;
		};
		static_assert(sizeof(s_i343scenariozonesetbakedpvsperbspdata) == 72, "struct s_i343scenariozonesetbakedpvsperbspdata is invalid size");

		struct s_i343scenariozonesetbakedpvsbakedpvstag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343scenariozonesetbakedpvssubregionlongparam> bsp_index_map_block;
			c_typed_tag_block<s_i343scenariozonesetbakedpvsperbspdata> per_bsp_data_block;
			s_tag_resource resource_data;
		};
		static_assert(sizeof(s_i343scenariozonesetbakedpvsbakedpvstag) == 48, "struct s_i343scenariozonesetbakedpvsbakedpvstag is invalid size");

		struct s_globalbitmaps
		{
			c_typed_tag_reference<BITMAP_TAG> default_bitmaps;
		};
		static_assert(sizeof(s_globalbitmaps) == 16, "struct s_globalbitmaps is invalid size");

		struct s_i343graphicsglobalmaterial
		{
			string_id name;
			c_typed_tag_reference<MATERIAL_TAG> material;
			char countpsos[4]; // padding
			char generated_pad8d40[4]; // padding
			long long ptr_psos;
		};
		static_assert(sizeof(s_i343graphicsglobalmaterial) == 36, "struct s_i343graphicsglobalmaterial is invalid size");

		struct s_i343graphicsdisplayoutputtransform
		{
			string_id display_output_preset_name;
			c_typed_tag_reference<BITMAP_TAG> reference_rendering_transform;
			c_typed_tag_reference<BITMAP_TAG> hdr_to_ldr_lut;
			c_typed_tag_reference<BITMAP_TAG> hdr_output_lut;
		};
		static_assert(sizeof(s_i343graphicsdisplayoutputtransform) == 52, "struct s_i343graphicsdisplayoutputtransform is invalid size");

		struct s_rasterizerglobalstag
		{
			s_anytag_struct_definition anytag;

			/* default bitmaps */

			c_typed_tag_block<s_globalbitmaps> default_bitmaps_block;
			c_typed_tag_reference<EXPLICITSHADERS_TAG> explicit_shader_table;

			/* global materials */

			c_typed_tag_block<s_i343graphicsglobalmaterial> global_materials_block;
			c_typed_tag_reference<PERFORMANCE_THROTTLES_TAG> default_performance_throttles;
			c_typed_tag_reference<SCENARIO_RENDER_DATA_TAG> default_scenario_render_data;
			c_typed_tag_reference<CHEAP_PARTICLE_TYPE_LIBRARY_TAG> cheap_particle_type_library;
			c_typed_tag_block<s_i343graphicsdisplayoutputtransform> display_output_transformations_block;
			real hdr_bloom_intensity_scale;
			real bloom_max_pixel_intensity;

			/* Motion blur parameters */

			real max_blur;
			real blur_scale;
			real center_falloff_x;
			real center_falloff_y;
			c_typed_tag_reference<CAMERA_FX_SETTINGS_TAG> hologram_camera_fx;

			/* lighting debug parameters */

			c_typed_tag_reference<RENDER_MODEL_TAG> airprobe_render_model;
			real debug_lighting_value;
			real albedo_clip_min;
			real albedo_clip_max;
			c_typed_tag_reference<RENDERGRAPH_TAG> post_process_graph;
			c_typed_tag_reference<RENDER_WATER_RIPPLE_TAG> default_ripple_definition;
			c_typed_tag_reference<SSSPROFILE_TAG> subsurface_scatter_profile_tag;
			c_typed_tag_reference<MATERIALSWATCH_TAG> empty_swatch_tag;
			c_typed_tag_reference<HAIR_TAG> hair_profile_tag;
			c_typed_tag_reference<PSODICTIONARY_TAG> pso_dictionary;
		};
		static_assert(sizeof(s_rasterizerglobalstag) == 280, "struct s_rasterizerglobalstag is invalid size");

		struct s_i343graphicsrendergraphparameterdefinition
		{
			string_id name;
			c_enum<e_i343graphicsrendergraphparametertype, long> type;
			long _int;
			real _float;
			real_vector3d float3;
			s_tag_reference _tag;
			s_tag_data datapath;
			string_id _string;
		};
		static_assert(sizeof(s_i343graphicsrendergraphparameterdefinition) == 68, "struct s_i343graphicsrendergraphparameterdefinition is invalid size");

		struct s_i343graphicsrendergraphparameterdefinitionb
		{
			s_i343graphicsrendergraphparameterdefinition parameter;
		};
		static_assert(sizeof(s_i343graphicsrendergraphparameterdefinitionb) == 68, "struct s_i343graphicsrendergraphparameterdefinitionb is invalid size");

		struct s_i343graphicsrendergrapheditormetadatadefinition
		{
			real_vector2d ui_position;
		};
		static_assert(sizeof(s_i343graphicsrendergrapheditormetadatadefinition) == 8, "struct s_i343graphicsrendergrapheditormetadatadefinition is invalid size");

		struct s_i343graphicsrendergraphnodedefinition
		{
			string_id name;
			c_enum<e_i343graphicsrendergraphnodetype, long> type;
			c_typed_tag_block<s_i343graphicsrendergraphparameterdefinitionb> parameters_block;
			c_typed_tag_block<s_i343graphicsrendergrapheditormetadatadefinition> editormetadata_block;
		};
		static_assert(sizeof(s_i343graphicsrendergraphnodedefinition) == 32, "struct s_i343graphicsrendergraphnodedefinition is invalid size");

		struct s_i343graphicsrendergraphconnectiondefinition
		{
			// custom from

			/* Connection From Port */

			// custom from_graph_input
			long from_graph_input;
			// custom value
			// custom from_graph_node
			long from_node;
			string_id from_output_name;
			long from_output_index;
			string_id from_output_key;
			// custom value
			// custom from_graph_constant
			long from_graph_constant;
			// custom value
			// custom value
			// custom to

			/* Connection To Port */

			// custom to_graph_node
			long to_node;
			string_id to_input_name;
			long to_input_index;
			string_id to_input_key;
			// custom value
			// custom to_graph_output
			long to_graph_output;
			// custom value
			// custom value
		};
		static_assert(sizeof(s_i343graphicsrendergraphconnectiondefinition) == 44, "struct s_i343graphicsrendergraphconnectiondefinition is invalid size");

		struct s_i343graphicsrendergraphuienumvaluedefinition
		{
			c_static_string<32> display_name;
			long value;
		};
		static_assert(sizeof(s_i343graphicsrendergraphuienumvaluedefinition) == 36, "struct s_i343graphicsrendergraphuienumvaluedefinition is invalid size");

		struct s_i343graphicsrendergraphuipropertydefinition
		{
			c_flags<e_i343graphicsrendergraphgraphuipropertyflag, long, k_i343graphicsrendergraphgraphuipropertyflag_count> flags;
			c_static_string<32> display_name;
			c_static_string<256> description;
			c_static_string<32> category;
			long order;
			c_enum<e_i343graphicsrendergraphparametertype, long> type;
			c_static_string<32> range_min;
			c_enum<e_i343graphicsrendergraphgraphuipropertyrangesetting, long> range_min_setting;
			c_static_string<32> range_max;
			c_enum<e_i343graphicsrendergraphgraphuipropertyrangesetting, long> range_max_setting;
			c_typed_tag_block<s_i343graphicsrendergraphuienumvaluedefinition> enum_values_block;
		};
		static_assert(sizeof(s_i343graphicsrendergraphuipropertydefinition) == 416, "struct s_i343graphicsrendergraphuipropertydefinition is invalid size");

		struct s_i343graphicsrendergraphinputdefinition
		{
			string_id name;
			c_enum<e_i343graphicsrendergraphparametertype, long> type;
			c_typed_tag_block<s_i343graphicsrendergraphuipropertydefinition> ui_property_block;
			c_typed_tag_block<s_i343graphicsrendergrapheditormetadatadefinition> editormetadata_block;
		};
		static_assert(sizeof(s_i343graphicsrendergraphinputdefinition) == 32, "struct s_i343graphicsrendergraphinputdefinition is invalid size");

		struct s_i343graphicsrendergraphoutputdefinition
		{
			string_id name;
			c_enum<e_i343graphicsrendergraphparametertype, long> type;
			c_typed_tag_block<s_i343graphicsrendergrapheditormetadatadefinition> editormetadata_block;
		};
		static_assert(sizeof(s_i343graphicsrendergraphoutputdefinition) == 20, "struct s_i343graphicsrendergraphoutputdefinition is invalid size");

		struct s_i343graphicsrendergraphconstantdefinition
		{
			s_i343graphicsrendergraphparameterdefinition parameter;
			c_typed_tag_block<s_i343graphicsrendergrapheditormetadatadefinition> editormetadata_block;
		};
		static_assert(sizeof(s_i343graphicsrendergraphconstantdefinition) == 80, "struct s_i343graphicsrendergraphconstantdefinition is invalid size");

		struct s_i343graphicsrendergraphgraphdefinition
		{
			s_anytag_struct_definition anytag;
			string_id name;
			c_flags<e_i343graphicsrendergraphgraphflag, long, k_i343graphicsrendergraphgraphflag_count> flags;
			c_typed_tag_block<s_i343graphicsrendergraphnodedefinition> nodes_block;
			c_typed_tag_block<s_i343graphicsrendergraphconnectiondefinition> connections_block;
			c_typed_tag_block<s_i343graphicsrendergraphinputdefinition> inputs_block;
			c_typed_tag_block<s_i343graphicsrendergraphoutputdefinition> outputs_block;
			c_typed_tag_block<s_i343graphicsrendergraphconstantdefinition> constants_block;
			char generated_pad0e69[4]; // padding
			long long rendergraph;
		};
		static_assert(sizeof(s_i343graphicsrendergraphgraphdefinition) == 96, "struct s_i343graphicsrendergraphgraphdefinition is invalid size");

		struct s_s_rumble_frequency_definition
		{
			real duration;
			// custom mapping_function
			s_functiondefinition mapping;
		};
		static_assert(sizeof(s_s_rumble_frequency_definition) == 24, "struct s_s_rumble_frequency_definition is invalid size");

		struct s_s_rumble_definition_dummy
		{
			c_flags<e_rumbleflags, char, k_rumbleflags_count> rumble_flags;
			char generated_pad3d9e[3]; // padding

			/* low frequency rumble */

			s_s_rumble_frequency_definition low_frequency_rumble$2;

			/* high frequency rumble */

			s_s_rumble_frequency_definition high_frequency_rumble$2;

			/* primary trigger rumble */

			s_s_rumble_frequency_definition primary_trigger_rumble$2;

			/* secondary trigger rumble */

			s_s_rumble_frequency_definition secondary_trigger_rumble$2;
		};
		static_assert(sizeof(s_s_rumble_definition_dummy) == 100, "struct s_s_rumble_definition_dummy is invalid size");

		struct s_s_rumble_definition
		{
			s_anytag_struct_definition anytag;
			s_s_rumble_definition_dummy rumble;
			char generated_padf313[4]; // padding
		};
		static_assert(sizeof(s_s_rumble_definition) == 120, "struct s_s_rumble_definition is invalid size");

		struct s_nodegraphcontentrendergraphcontenttag
		{
			s_nodegraphcontentnodegraphcontenttag nodegraph;
		};
		static_assert(sizeof(s_nodegraphcontentrendergraphcontenttag) == 68, "struct s_nodegraphcontentrendergraphcontenttag is invalid size");

		struct s_i343surfacinginput
		{
			c_enum<e_i343surfacinginputtype, char> type;
			char generated_pad6a41[3]; // padding
			string_id id;
			real default_value;
			c_typed_tag_reference<BITMAP_TAG> bitmap_reference;
			real_vector2d uv_scale;
		};
		static_assert(sizeof(s_i343surfacinginput) == 36, "struct s_i343surfacinginput is invalid size");

		struct s_i343surfacingmateriallayer
		{
			string_id id;
			long index;
			long gpu_interpreter_instructions;
			c_typed_tag_reference<MATERIALPRESET_TAG> material_preset;
			long physicsmaterialid;
		};
		static_assert(sizeof(s_i343surfacingmateriallayer) == 32, "struct s_i343surfacingmateriallayer is invalid size");

		struct s_i343surfacingplacementdescription
		{
			string_id id;
			long gpu_interpreter_density_instructions;
			long gpu_interpreter_scale_instructions;
			s_tag_reference runtime_tag_reference;
			s_tag_reference content_tag_reference;
			real_vector2d positionz_offset_range;
			real_vector2d scale_range;
			real_vector2d rotation_range;
			c_enum<e_i343orientationalignment, char> orientation_alignment;
			char generated_pada2d4[3]; // padding
			s_s_basic_spec_control_setting_float cull_distance_scale;
			s_s_basic_spec_control_setting_float density_multiplier;
			string_id variant_name;
			argb_color debug_color;
			long precompiled_technique_index;
			s_s_basic_spec_control_setting_float distance_dither_start;
			real distance_dither_transition_width;
		};
		static_assert(sizeof(s_i343surfacingplacementdescription) == 196, "struct s_i343surfacingplacementdescription is invalid size");

		struct s_i343surfacingplacementlayer
		{
			c_typed_tag_block<s_i343surfacingplacementdescription> placement_descriptions_block;
			real footprint_radius;
		};
		static_assert(sizeof(s_i343surfacingplacementlayer) == 16, "struct s_i343surfacingplacementlayer is invalid size");

		struct s_i343gpuinterpreterinstruction
		{
			long data;
		};
		static_assert(sizeof(s_i343gpuinterpreterinstruction) == 4, "struct s_i343gpuinterpreterinstruction is invalid size");

		struct s_i343layergpuinterpreterbytecode
		{
			qword hash;
			c_typed_tag_block<s_i343gpuinterpreterinstruction> gpu_interpreter_instructions_block;
			char generated_pad5fcf[4]; // padding
		};
		static_assert(sizeof(s_i343layergpuinterpreterbytecode) == 24, "struct s_i343layergpuinterpreterbytecode is invalid size");

		struct s_i343surfacingruntimetag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343surfacinginput> inputs_block;
			c_typed_tag_block<s_i343surfacingmateriallayer> material_layers_block;
			c_typed_tag_block<s_i343surfacingplacementlayer> placement_layers_block;
			c_typed_tag_block<s_i343layergpuinterpreterbytecode> layers_bytecode_block;
		};
		static_assert(sizeof(s_i343surfacingruntimetag) == 64, "struct s_i343surfacingruntimetag is invalid size");

		struct s_runtimegeopermeshdata
		{
			string_id name;
			short mesh_index;
			c_flags<e_permeshflagsdefinition, char, k_permeshflagsdefinition_count> per_mesh_flags;
			byte lightmapping_policy;
			real_vector3d scale;
			real_vector3d forward;
			real_vector3d left;
			real_vector3d up;
			real_point3d position;
			real_point3d bounds_min;
			real_point3d bounds_max;
			real_point3d bounding_sphere_center;
			real bounding_sphere_radius;
			c_typed_tag_block<s_lodtransitiondistanceblock> lod_levels_block;
			real fade_out_after_distance;
			char generated_pad359f[4]; // padding
			long long mesh_checksum;
		};
		static_assert(sizeof(s_runtimegeopermeshdata) == 136, "struct s_runtimegeopermeshdata is invalid size");

		struct s_staticgeomarker
		{
			real_point3d translation;
			real_quaternion rotation;
		};
		static_assert(sizeof(s_staticgeomarker) == 28, "struct s_staticgeomarker is invalid size");

		struct s_staticgeomarkergroup
		{
			string_id name;
			c_typed_tag_block<s_staticgeomarker> markers_block;
		};
		static_assert(sizeof(s_staticgeomarkergroup) == 16, "struct s_staticgeomarkergroup is invalid size");

		struct s_runtimegeotag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_runtimegeopermeshdata> per_mesh_data_block;
			char generated_pad8ff5[4]; // padding
			s_s_render_geometry render_geometry;
			c_typed_tag_block<s_staticgeomarkergroup> marker_groups_block;
			string_id asset_category_name;
			long asset_category_index;
			char generated_pad7614[4]; // padding
		};
		static_assert(sizeof(s_runtimegeotag) == 248, "struct s_runtimegeotag is invalid size");

		struct s_scenario_layer_reference
		{
			c_typed_tag_reference<LAYER_TAG> _tag;
			c_static_string<256> editor_display_name;
			c_flags<e_layerusageflags, char, k_layerusageflags_count> layer_usage_flags;
			char generated_pad26e0[3]; // padding
		};
		static_assert(sizeof(s_scenario_layer_reference) == 276, "struct s_scenario_layer_reference is invalid size");

		struct s_runtimelayertag
		{
			s_levelobjects levelobjects;
			c_typed_tag_block<s_scenario_layer_reference> child_layers_block;
			char generated_pad8b11[4]; // padding
		};
		static_assert(sizeof(s_runtimelayertag) == 1088, "struct s_runtimelayertag is invalid size");

		struct s_runtimematerialpalettetag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_geometry_material> palette_block;
			string_id style_id;
			long damage_style_index;
			char generated_pad0d48[4]; // padding
		};
		static_assert(sizeof(s_runtimematerialpalettetag) == 40, "struct s_runtimematerialpalettetag is invalid size");

		struct s_i343physicsterraincollisiongeoentry
		{
			c_typed_tag_reference<TERRAIN_CELL_GEO_TAG> terraincollisioncellgeotag;
		};
		static_assert(sizeof(s_i343physicsterraincollisiongeoentry) == 16, "struct s_i343physicsterraincollisiongeoentry is invalid size");

		struct s_i343terrainnodelayerindex
		{
			long node_shared_index;
		};
		static_assert(sizeof(s_i343terrainnodelayerindex) == 4, "struct s_i343terrainnodelayerindex is invalid size");

		struct s_i343terrainquadtreenodebitmapremapinfo
		{
			word texture_index;
			short channel_masks;
			real solid_color;
		};
		static_assert(sizeof(s_i343terrainquadtreenodebitmapremapinfo) == 8, "struct s_i343terrainquadtreenodebitmapremapinfo is invalid size");

		struct s_i343terrainnodebitmapindex
		{
			dword index;
		};
		static_assert(sizeof(s_i343terrainnodebitmapindex) == 4, "struct s_i343terrainnodebitmapindex is invalid size");

		struct s_i343surfacingtexturedata
		{
			long output_id;
			long bitmap_index;
			string_id red_channel;
			string_id green_channel;
			string_id blue_channel;
			string_id alpha_channel;
		};
		static_assert(sizeof(s_i343surfacingtexturedata) == 24, "struct s_i343surfacingtexturedata is invalid size");

		struct s_i343terrainquadtreenodedata
		{
			c_typed_tag_block<s_i343terrainnodelayerindex> material_layers_indices_block;
			c_typed_tag_block<s_i343terrainquadtreenodebitmapremapinfo> texture_remap_info_block;
			c_typed_tag_block<s_i343surfacingplacementlayer> placement_layers_block;
			c_typed_tag_block<s_i343terrainnodebitmapindex> input_bitmap_indices_block;
			real min_height_value;
			real max_height_value;
			c_typed_tag_block<s_i343surfacingtexturedata> input_texture_data_block;
			long unoptimized_instructions_count;
		};
		static_assert(sizeof(s_i343terrainquadtreenodedata) == 72, "struct s_i343terrainquadtreenodedata is invalid size");

		struct s_i343terraingeneratedoutputbitmapdescription
		{
			long bitmap_reference_index;
			real_vector2d scale_of_the_uv_transform;
		};
		static_assert(sizeof(s_i343terraingeneratedoutputbitmapdescription) == 12, "struct s_i343terraingeneratedoutputbitmapdescription is invalid size");

		struct s_i343terraingeneratedoutputreference
		{
			string_id id;
			s_i343terraingeneratedoutputbitmapdescription output_bitmap_references[3];
		};
		static_assert(sizeof(s_i343terraingeneratedoutputreference) == 40, "struct s_i343terraingeneratedoutputreference is invalid size");

		struct s_i343gpumateriallayerbitmapreference
		{
			long offset_in_bytes;
			c_typed_tag_reference<BITMAP_TAG> bitmap_reference;
		};
		static_assert(sizeof(s_i343gpumateriallayerbitmapreference) == 20, "struct s_i343gpumateriallayerbitmapreference is invalid size");

		struct s_i343sharedgpuinterpreterbitmapreference
		{
			c_typed_tag_reference<BITMAP_TAG> bitmap_reference;
			real_vector2d uv_scale;
		};
		static_assert(sizeof(s_i343sharedgpuinterpreterbitmapreference) == 24, "struct s_i343sharedgpuinterpreterbitmapreference is invalid size");

		struct s_s_basic_spec_control_setting_int
		{
			long very_low;
			long low;
			long medium;
			long high;
			long ultra;
			real _2_player_splitscreen;
			real _3_player_splitscreen;
			real _4_player_splitscreen;
		};
		static_assert(sizeof(s_s_basic_spec_control_setting_int) == 32, "struct s_s_basic_spec_control_setting_int is invalid size");

		struct s_i343terrainruntimetag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<BITMAP_TAG> bitmap;
			c_typed_tag_block<s_i343physicsterraincollisiongeoentry> terraincollisiongeotag_cells_block;
			c_typed_tag_reference<MATERIAL_TAG> render_material;
			c_typed_tag_reference<MATERIAL_TAG> masks_composite_material;
			long quad_tree_lod_resolution;
			word quad_tree_level_count;
			word quad_tree_collision_data_level;
			real_vector3d quad_tree_position;
			real_vector3d quad_tree_size;
			c_typed_tag_block<s_i343terrainquadtreenodedata> quad_tree_node_data_block;
			c_typed_tag_block<s_i343terraingeneratedoutputreference> material_layer_ids_block;
			long placements_layers_count;
			long placements_precompiled_techniques_first_index;
			c_typed_tag_block<s_i343gpumateriallayerbitmapreference> material_layer_bitmap_references_block;
			c_typed_tag_block<s_i343sharedgpuinterpreterbitmapreference> shared_gpu_interpreter_bitmap_references_block;
			c_typed_tag_block<s_i343layergpuinterpreterbytecode> shared_gpu_interpreter_instructions_block;
			c_typed_tag_block<s_i343surfacingmateriallayer> shared_node_material_layers_block;
			s_tag_data material_layer_data;
			real macro_color_near_distance;
			real macro_color_far_distance;
			real macro_color_near_opacity;
			real macro_color_far_opacity;
			s_s_basic_spec_control_setting_float micro_height_vertex_density;
			s_s_basic_spec_control_setting_float micro_height_radius;
			s_s_basic_spec_control_setting_int micro_height_mip_level;
			real micro_height_scale;
			char generated_padfa1a[4]; // padding
			long long runtime_terrain_system;
			long long m_pipelinestates;
		};
		static_assert(sizeof(s_i343terrainruntimetag) == 344, "struct s_i343terrainruntimetag is invalid size");

		struct s_s_render_water_ripple_definition
		{
			s_anytag_struct_definition anytag;

			/* TYPE FLAGS */

			c_flags<e_ripplebehaviorflags, long, k_ripplebehaviorflags_count> flags;

			/* INITIAL SETTINGS */

			real initial_radius;
			real initial_amplitude;
			real spread_speed;
			real speed_bias;
			real position_random_range;
			real max_visibility_distance;

			/* LIFE SETTINGS */

			real duration_max;
			real duration_min;
			real rise_period_ratio;
			c_enum<e_transitionfunction, short> rise_function;
			c_enum<e_transitionfunction, short> descend_function;

			/* PENDULUM SETTINGS */

			real phase_revolution_speed;
			real phase_repeat_along_radius;

			/* SHAPE TRANSITION */

			real pattern_start_idx;
			real pattern_end_idx;
			c_enum<e_transitionfunction, short> pattern_transition;
			char generated_pad8f3f[2]; // padding

			/* FOAM */

			real foam_out_radius;
			real foam_fade_distance;
			real foam_duration;
			c_enum<e_transitionfunction, short> foam_rise_function;
			c_enum<e_transitionfunction, short> foam_fade_function;
		};
		static_assert(sizeof(s_s_render_water_ripple_definition) == 96, "struct s_s_render_water_ripple_definition is invalid size");

		struct s_i343spartanabilitiesspartanabilitycommonparameters
		{
			// custom common_ability_parameters
			c_enum<e_i343unitsarmorinput, long> input;
			c_flags<e_i343spartanabilitiesspartanabilitydefinitionflags, long, k_i343spartanabilitiesspartanabilitydefinitionflags_count> flags;
			real_fraction activation_energy_cost;
			real active_energy_consumption;
			real recharge_duration;
			real recharge_delay;
			real cooldown_delay;
			c_typed_tag_reference<EFFECT_TAG> activation_effect;
			real activation_effect_kill_delay;
			c_enum<e_i343spartanabilitiessprintpreservation, char> sprint_preservation;
			char generated_pad0aca[3]; // padding
			c_typed_tag_reference<GENERICMODIFIERDEFINITIONTAG_TAG> active_malleable_property_modifiers;
			c_typed_tag_reference<GENERICMODIFIERDEFINITIONTAG_TAG> timed_malleable_property_modifiers;
			// custom value
		};
		static_assert(sizeof(s_i343spartanabilitiesspartanabilitycommonparameters) == 84, "struct s_i343spartanabilitiesspartanabilitycommonparameters is invalid size");

		struct s_i343spartanabilitiesboostjumpdefinition
		{
			s_i343spartanabilitiesspartanabilitycommonparameters common_ability_parameters;
			c_flags<e_i343spartanabilitiesboostjumpdefinitionflags, long, k_i343spartanabilitiesboostjumpdefinitionflags_count> flags;

			/* Acceleration time */

			real acceleration_time$2;

			/* acceleration z */

			real velocity_cap;
			real acceleration;
			s_scalarfunctionname acceleration_scalar;

			/* acceleration xy */

			real acceleration_xy$2;
			s_scalarfunctionname acceleration_scalar_xy;
		};
		static_assert(sizeof(s_i343spartanabilitiesboostjumpdefinition) == 144, "struct s_i343spartanabilitiesboostjumpdefinition is invalid size");

		struct s_i343spartanabilitiesboostjumpdefinitiontag
		{
			s_anytag_struct_definition anytag;
			s_i343spartanabilitiesboostjumpdefinition boostjump;
			char generated_pad2ea2[4]; // padding
		};
		static_assert(sizeof(s_i343spartanabilitiesboostjumpdefinitiontag) == 164, "struct s_i343spartanabilitiesboostjumpdefinitiontag is invalid size");

		struct s_s_spring_acceleration_linear_definition
		{
			real acceleration_range;
			real inverse_acceleration_range;
			real world_acceleration_scale;

			/* damping */

			s_scalarfunctionname spring_damping;
			real velocity_domain;
			s_scalarfunctionname spring_acceleration;
		};
		static_assert(sizeof(s_s_spring_acceleration_linear_definition) == 56, "struct s_s_spring_acceleration_linear_definition is invalid size");

		struct s_s_spring_acceleration_definition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_s_spring_acceleration_linear_definition> linear_acceleartions_block;
			short x_axis;
			short y_axis;
			short z_axis;
			char generated_pad2bda[6]; // padding
		};
		static_assert(sizeof(s_s_spring_acceleration_definition) == 40, "struct s_s_spring_acceleration_definition is invalid size");

		struct s_i343spartanabilitiesevadedefinition
		{
			s_i343spartanabilitiesspartanabilitycommonparameters common_ability_parameters;
			c_flags<e_i343spartanabilitiesevadedefinitionflags, long, k_i343spartanabilitiesevadedefinitionflags_count> evade_flags;
			real_fraction throttle_dead_zone;
			string_id evade_left_animation;
			string_id evade_right_animation;
			string_id evade_forward_animation;
			string_id evade_backward_animation;
			real evade_duration;
			real_fraction evade_exit_sprint_fraction;
			real_fraction evade_melee_interrupt_fraction;
			real_fraction evade_grenade_interrupt_fraction;

			/* speed function */

			// custom speed_function
			s_functiondefinition speed_function$2;

			/* speed function scalar */

			// custom speed_function_scalar
			s_i343malleablepropertybasefloatstructdefinition speed_function_scalar$2;
			real forward_speed_modifier;
			real_bounds speed_modifier_values;

			/* ground speed modifier function */

			// custom ground_speed_modifier_function
			s_functiondefinition ground_speed_modifier_function$2;

			/* air speed modifier function */

			// custom air_speed_modifier_function
			s_functiondefinition air_speed_modifier_function$2;

			/* horizontal camera offset function */

			// custom horizontal_camera_offset_function
			s_functiondefinition horizontal_camera_offset_function$2;

			/* camera tilt ROLL function */

			// custom camera_tilt_roll_function
			s_functiondefinition camera_tilt_roll_function$2;

			/* camera tilt PITCH function */

			// custom camera_tilt_pitch_function
			s_functiondefinition camera_tilt_pitch_function$2;

			/* FOV delta function */

			// custom fov_delta_function
			s_functiondefinition fov_delta_function$2;

			/* overlay animation function */

			// custom overlay_animation_function
			s_functiondefinition overlay_animation_function$2;
			real maximum_vertical_impulse;
			real maximum_vertical_impulse_speed_threshold;
		};
		static_assert(sizeof(s_i343spartanabilitiesevadedefinition) == 316, "struct s_i343spartanabilitiesevadedefinition is invalid size");

		struct s_i343spartanabilitiesevadedefinitiontag
		{
			s_anytag_struct_definition anytag;
			s_i343spartanabilitiesevadedefinition data;
		};
		static_assert(sizeof(s_i343spartanabilitiesevadedefinitiontag) == 332, "struct s_i343spartanabilitiesevadedefinitiontag is invalid size");

		struct s_i343spartanabilitiesgrapplehookdefinition
		{
			s_i343spartanabilitiesspartanabilitycommonparameters common_ability_parameters;
			c_flags<e_i343spartanabilitiesgrapplehookdefinitionflags, long, k_i343spartanabilitiesgrapplehookdefinitionflags_count> grapple_hook_flags;
			string_id first_person_animation_set;
			angle max_aim_vector_angle;
			string_id animation_yaw_and_pitch_origin_marker;
			// custom effects
			c_typed_tag_reference<EFFECT_TAG> rope_beam_effect;
			string_id rope_beam_effect_start_marker;
			c_typed_tag_reference<EFFECT_TAG> pulling_effect;
			c_typed_tag_reference<EFFECT_TAG> reeling_in_effect;
			c_typed_tag_reference<EFFECT_TAG> deactivate_effect;
			// custom value
			// custom hook_deployment_parameters
			c_typed_tag_reference<PROJECTILE_TAG> hook_projectile;
			string_id hook_projectile_spawn_marker;
			c_typed_tag_reference<OBJECT_TAG> hook_projectile_spawn_object;
			real_vector3d hook_projectile_spawn_offset;
			real warmup_time;
			real post_deploy_transition_delay;
			// custom value
			// custom line_of_sight_testing

			/* line of sight testing */

			real line_of_sight_test_offset;
			real line_of_sight_test_offset_toward_user;
			// custom value
			// custom deploy_stage
			string_id deploy_animation;
			real deploy_duration_override;
			real max_range;
			// custom value
			// custom attaching
			real_vector3d biped_attach_offset;
			// custom value
			// custom pull_stage
			string_id pull_animation_airborne;
			string_id pull_animation_grounded;
			real pull_time_to_detach_allowed;
			real pull_detach_damage_threshold;
			real pull_stuck_timeout;
			real pull_min_progress_per_update;
			real pull_post_crouch_suppression_wait_time;
			real pull_collision_rejection_post_completion_duration;
			real pull_collision_rejection_threshold_target_velocity;
			real pull_collision_damage_immunity_delay;
			real pull_collision_damage_immunity_minimum_velocity;
			real pull_collision_damage_immunity_post_completion_duration;
			real_bounds pull_close_range_definition;
			real pull_physics_pill_offset_scalar_grounded;
			real pull_physics_pill_offset_scalar_airborne;
			// custom value
			// custom pull_velocity_control
			real pull_launch_vertical_impulse;
			real pull_launch_aim_impulse;
			real pull_launch_decay_duration;
			real pull_acceleration_phase_duration;
			real pull_base_target_velocity;
			real pull_exit_max_velocity;

			/* base pull acceleration function */

			// custom base_pull_acceleration_function
			s_functiondefinition base_pull_acceleration_function$2;

			/* launch impulse decay function */

			// custom launch_impulse_decay_function
			s_functiondefinition launch_impulse_decay_function$2;

			/* pull target movement filtering */

			real pull_target_velocity_filter_fraction;
			// custom value
			// custom pull_aim_influence

			/* pull velocity aim influence */

			real pull_aim_vector_influence_level_geo;
			real pull_aim_vector_influence_bipeds;
			real pull_aim_vector_influence_vehicles;
			angle pull_aim_vector_influence_falloff_inner_angle;
			angle pull_aim_vector_influence_falloff_outer_angle;
			real pull_aim_vector_influence_accumulation_rate;
			real pull_aim_vector_influence_accumulation_starting_scalar;

			/* pull aim vector influence falloff function */

			// custom pull_aim_vector_influence_falloff_function
			s_functiondefinition pull_aim_vector_influence_falloff_function$2;

			/* pull aim vector influence scale function */

			// custom pull_aim_vector_influence_falloff_function
			s_functiondefinition pull_aim_vector_influence_scale_function$2;
			// custom value
			// custom pull_air_control

			/* pull velocity aim influence */

			real pull_air_control_scalar_level_geo;
			real pull_air_control_scalar_forward_and_back_level_geo;
			real pull_air_control_scalar_left_and_right_level_geo;
			real pull_air_control_scalar_bipeds;
			real pull_air_control_scalar_forward_and_back_bipeds;
			real pull_air_control_scalar_left_and_right_bipeds;
			real pull_air_control_scalar_vehicles;
			real pull_air_control_scalar_forward_and_back_vehicles;
			real pull_air_control_scalar_left_and_right_vehicles;
			real pull_air_control_accumulation_rate;
			real pull_air_control_accumulation_starting_scalar;
			// custom value
			// custom pull_completion

			/* pull completion */

			real pull_completion_distance_level_geo;
			real pull_completion_distance_level_geo_ceilings;
			real pull_completion_distance_level_geo_floors;
			real pull_completion_distance_bipeds;
			real pull_completion_distance_vehicles;
			real pull_vehicle_interaction_distance;
			real pull_vehicle_interaction_time;
			angle pull_biped_automelee_max_angle;
			angle max_allowed_angle_deviation_ceiling;
			angle max_allowed_angle_deviation_floor;
			real pull_line_of_sight_break_time;
			// custom value
			// custom reel_in_stage
			real reel_in_acceleration_phase_duration;
			real reel_in_base_target_velocity;
			angle reel_in_launch_grounded_slope;
			real reel_in_launch_vertical_impulse_duration;
			real reel_in_launch_vertical_impulse_grounded;
			real reel_in_launch_vertical_impulse_airborne;
			real_bounds reel_in_launch_roll_impulse_airborne;
			real_bounds reel_in_launch_roll_rotation_impulse_grounded;
			real_bounds reel_in_launch_pitch_impulse_airborne;
			real_bounds reel_in_launch_pitch_rotation_impulse_grounded;
			real reel_in_exit_velocity;
			real reel_in_grab_distance;
			real reel_in_grab_vertical_offset;
			real reel_in_time_to_detach_allowed;
			real reel_in_detach_damage_threshold;
			real reel_in_line_of_sight_break_time;
			real reel_in_min_acceleration_percentage_to_break;
			real_bounds reel_in_close_range_definition;
			string_id reel_in_animation;

			/* reel in acceleration function */

			// custom reel_in_acceleration_function
			s_functiondefinition reel_in_acceleration_function$2;

			/* reel in tangential velocity damping function */

			// custom reel_in_tangential_velocity_damping_function
			s_functiondefinition reel_in_tangential_velocity_damping_function$2;
			// custom value
			// custom bash_stage

			/* grapple bash */

			real bash_activation_input_hold_time;
			angle bash_activation_max_aim_angle;
			real bash_max_aim_lock_rate_of_change;
			real bash_peak_velocity;
			real bash_charge_up_duration;

			/* bash charge up velocity scale function */

			// custom bash_charge_up_velocity_scale_function
			s_functiondefinition bash_charge_up_velocity_scale_function$2;
			real bash_acceleration_duration;

			/* bash acceleration velocity scale function */

			// custom bash_acceleration_velocity_scale_function
			s_functiondefinition bash_acceleration_velocity_scale_function$2;
			real bash_stuck_timeout;
			real bash_aftermath_duration;
			real bash_aftermath_recoil_peak_velocity;

			/* bash recoil velocity scale function */

			// custom bash_recoil_velocity_scale_function
			s_functiondefinition bash_recoil_velocity_scale_function$2;
			string_id bash_charge_up_animation;
			string_id bash_flight_animation;
			string_id bash_finish_grounded_animation;
			string_id bash_finish_airborne_animation;
			angle bash_finish_animation_vertical_angle_tolerance;
			c_typed_tag_reference<EFFECT_TAG> bash_charge_up_effect;
			c_typed_tag_reference<EFFECT_TAG> bash_launch_effect;
			c_typed_tag_reference<EFFECT_TAG> bash_active_effect;
			c_typed_tag_reference<EFFECT_TAG> bash_completion_effect;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> bash_owner_damage;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> bash_pound_aoe_damage;
			real bash_pound_aoe_epicenter_walkback_distance;
			// custom value
			// custom exit_stage
			string_id retract_animation;
			real exit_animation_speed_scalar;
			real miss_cooldown_delay;
			// custom value
			// custom aim_assist

			/* AIM ASSIST */

			real aim_assist_range;
			angle aim_assist_cone_angle_at_projectile_launch;
			angle aim_assist_cone_angle_while_projectile_flying;
			real aim_assist_weight_angle;
			real aim_assist_weight_distance;
			real aim_assist_weight_biped;
			real aim_assist_weight_vehicle;
			real aim_assist_weight_weapon;
			// custom value
		};
		static_assert(sizeof(s_i343spartanabilitiesgrapplehookdefinition) == 940, "struct s_i343spartanabilitiesgrapplehookdefinition is invalid size");

		struct s_i343spartanabilitiesgrapplehookdefinitiontag
		{
			s_anytag_struct_definition anytag;
			s_i343spartanabilitiesgrapplehookdefinition data;
			char generated_pad6d7d[4]; // padding
		};
		static_assert(sizeof(s_i343spartanabilitiesgrapplehookdefinitiontag) == 960, "struct s_i343spartanabilitiesgrapplehookdefinitiontag is invalid size");

		struct s_i343spartanabilitiesstabilizerdefinition
		{
			s_i343spartanabilitiesspartanabilitycommonparameters common_ability_parameters;
			c_flags<e_i343spartanabilitiesstabilizerdefinitionflags, long, k_i343spartanabilitiesstabilizerdefinitionflags_count> flags;
			real minimum_height_above_floor;
			real activation_deceleration;
			real stall_duration;
			// custom malleable_time_limit
			s_i343malleablepropertybasefloatstructdefinition malleable_time_limit;
			real cooldown;
			// custom malleable_time_scale
			s_i343malleablepropertybasefloatstructdefinition malleable_time_scale;
			real max_horizontal_speed;
			s_scalarfunctionname vertical_speed_boost_at_exit;
			c_typed_tag_reference<RUMBLE_TAG> rumble;
		};
		static_assert(sizeof(s_i343spartanabilitiesstabilizerdefinition) == 168, "struct s_i343spartanabilitiesstabilizerdefinition is invalid size");

		struct s_i343spartanabilitiesgroundpounddefinition
		{
			s_i343spartanabilitiesspartanabilitycommonparameters common_ability_parameters;
			c_flags<e_i343spartanabilitiesgroundpounddefinitionflags, long, k_i343spartanabilitiesgroundpounddefinitionflags_count> ground_pound_flags;
			real minimum_height_above_floor;

			/* Stabilization/Charge up */

			s_i343spartanabilitiesstabilizerdefinition stabilizer_definition;

			/* Charge Up Settings */

			real charge_up_min_time;
			real charge_up_auto_release_time;
			// custom charge_up_min_time_scale
			s_i343malleablepropertybasefloatstructdefinition charge_up_min_time_scale;
			// custom charge_up_auto_release_time_scale
			s_i343malleablepropertybasefloatstructdefinition charge_up_auto_release_time_scale;
			real_fraction charge_up_damage_acceleration_scalar;

			/* Launch */

			c_typed_tag_reference<EFFECT_TAG> launch_ready_effect;
			c_typed_tag_reference<EFFECT_TAG> launch_post_ready_effect;
			real_fraction launch_post_ready_effect_activation_fraction;
			real_fraction launch_activation_energy_cost;
			c_typed_tag_reference<EFFECT_TAG> launch_effect;
			c_typed_tag_reference<EFFECT_TAG> launch_fail_effect;
			real launch_continuous_rumble_loop_time;
			c_typed_tag_reference<RUMBLE_TAG> launch_continuous_rumble;

			/* Aiming */

			c_typed_tag_reference<EFFECT_TAG> aim_effect;
			c_enum<e_i343spartanabilitiesgroundpoundfailselector, long> aim_vector_fail_selector;
			real aim_effect_min_fail_display_time;
			real aim_vector_fail_distance;
			real aim_vector_fail_early_time;
			real aim_vector_ray_cast_distance;
			angle aim_vector_camera_pitch_limit;
			angle aim_vector_pitch_limit;
			angle aim_vector_pitch_adjustment_limit;
			real aim_vector_interpolation_seconds_charging;
			real aim_vector_interpolation_seconds_launching;
			real aim_vector_interpolation_seconds_exiting;
			real aim_vector_interpolation_exit_stage_time_limit;

			/* Collision */

			real hit_sphere_initial_offset_z;
			real hit_sphere_offset;
			real hit_sphere_radius;
			real hit_sphere_start_point_offset;

			/* Motion */

			angle max_slope_angle;
			angle max_opposing_contact_angle;
			// custom pound_fall_speed_malleable
			s_i343malleablepropertybasefloatstructdefinition pound_fall_speed_malleable;
			real pound_fall_duration;
			real pound_hit_duration;
			real pound_exit_no_collision_damage_duration;

			/* Impact */

			real aoe_contact_offset;
			// custom knockback_scalar
			s_i343malleablepropertybasefloatstructdefinition knockback_scalar;
			// custom pound_ground_damage_scalar
			s_i343malleablepropertybasefloatstructdefinition pound_ground_damage_scalar;
			// custom pound_ground_aoe_radius_scalar
			s_i343malleablepropertybasefloatstructdefinition pound_ground_aoe_radius_scalar;

			/* Damage effects (regular) */

			c_typed_tag_reference<DAMAGE_EFFECT_TAG> pound_object_damage_effect;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> pound_object_clang_damage_effect;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> pound_ground_damage_effect;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> pound_ground_clang_damage_effect;
			c_typed_tag_reference<EFFECT_TAG> pound_object_instigator_effect;
			c_typed_tag_reference<EFFECT_TAG> pound_ground_instigator_effect;

			/* Damage effects (weak) */

			c_typed_tag_reference<DAMAGE_EFFECT_TAG> pound_object_damage_effect_weak;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> pound_object_clang_damage_effect_weak;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> pound_ground_damage_effect_weak;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> pound_ground_clang_damage_effect_weak;
			c_typed_tag_reference<EFFECT_TAG> pound_object_instigator_effect_weak;
			c_typed_tag_reference<EFFECT_TAG> pound_ground_instigator_effect_weak;
			real time_to_switch_from_weak_to_regular;

			/* Animations */

			string_id pound_fall_animation;
			string_id pound_fall_exit_animation;
			string_id pound_hit_animation;
			string_id pound_hit_exit_animation;
			c_enum<e_i343aisoundvolume, short> pound_hit_ai_sound_level;
			char generated_padba74[2]; // padding

			/* Aim Assist */

			angle auto_aim_angle;
			real auto_aim_range;
			real auto_aim_falloff_range;
			real auto_aim_near_falloff_range;
			angle magnetism_angle;
			real magnetism_range;
			real magnetism_falloff_range;
			real magnetism_near_falloff_range;
			angle maximum_assist_angular_velocity;

			/* FOV delta function (charge up) */

			// custom fov_delta_function_charge_up
			s_functiondefinition fov_delta_function_charge_up$2;
			real_fraction looks_speed_scalar_charge_up;
			real_fraction looks_speed_scalar_launched;
		};
		static_assert(sizeof(s_i343spartanabilitiesgroundpounddefinition) == 820, "struct s_i343spartanabilitiesgroundpounddefinition is invalid size");

		struct s_i343spartanabilitiesgroundpounddefinitiontag
		{
			s_anytag_struct_definition anytag;
			s_i343spartanabilitiesgroundpounddefinition data;
		};
		static_assert(sizeof(s_i343spartanabilitiesgroundpounddefinitiontag) == 836, "struct s_i343spartanabilitiesgroundpounddefinitiontag is invalid size");

		struct s_sampledataluascripttagdefinition
		{
			s_luascripttagdefinition lua_script;
		};
		static_assert(sizeof(s_sampledataluascripttagdefinition) == 308, "struct s_sampledataluascripttagdefinition is invalid size");

		struct s_i343spartanabilitiesmaterialnamestringidblock
		{
			string_id material_name;
		};
		static_assert(sizeof(s_i343spartanabilitiesmaterialnamestringidblock) == 4, "struct s_i343spartanabilitiesmaterialnamestringidblock is invalid size");

		struct s_i343spartanabilitiesshoulderbashdefinition
		{
			s_i343spartanabilitiesspartanabilitycommonparameters common_ability_parameters;
			c_flags<e_i343spartanabilitiesshoulderbashdefinitionflags, long, k_i343spartanabilitiesshoulderbashdefinitionflags_count> shoulder_bash_flags;
			real_fraction sprint_speed_fraction_threshold;
			real sprint_active_minimum_duration;
			real bash_speed;
			real target_speed_scalar;
			real bash_duration;
			real bash_duration_with_target;
			// custom target_range_scalar
			s_i343malleablepropertybasefloatstructdefinition target_range_scalar;
			real yaw_speed_scale;
			real pitch_speed_scale;
			real off_the_ground_tolerance;
			real hit_sphere_offset_x;
			real hit_sphere_offset_z;
			real hit_sphere_radius;
			real hit_sphere_start_point_offset;
			real surface_adhesion_velocity;
			real surface_adhesion_airborne_time_limit;
			angle maximum_shoulder_bash_assist_angular_velocity;
			angle assist_pitch_angle_min;
			angle assist_pitch_angle_max;
			angle contact_angle_threshold_for_damage;
			real contact_ignore_offset;
			angle bash_direction_pitch_offset_for_damage;
			// custom knockback_scalar
			s_i343malleablepropertybasefloatstructdefinition knockback_scalar;

			/* camera tilt pitch function */

			// custom camera_tilt_pitch_function
			s_functiondefinition camera_tilt_pitch_function$2;

			/* camera forward offset function */

			// custom camera_forward_offset_function
			s_functiondefinition camera_forward_offset_function$2;

			/* camera FOV delta function */

			// custom camera_fov_delta_function
			s_functiondefinition camera_fov_delta_function$2;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> bash_damage_effect;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> bash_clang_damage_effect;
			c_typed_tag_reference<EFFECT_TAG> bash_effect;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> bash_response_damage_effect;
			c_typed_tag_reference<EFFECT_TAG> bash_response_effect;
			// custom damage_scalar
			s_i343malleablepropertybasefloatstructdefinition damage_scalar;
			string_id shoulder_bash_animation;
			string_id shoulder_bash_success_follow_through;
			real shoulder_bash_success_follow_through_duration;
			real shoulder_bash_success_follow_through_fp_camera_restore_time;
			string_id shoulder_bash_success_rebound;
			real shoulder_bash_success_rebound_duration;
			real shoulder_bash_success_rebound_fp_camera_restore_time;
			real shoulder_bash_success_rebound_speed_duration;
			real shoulder_bash_success_rebound_speed;

			/* no rebound surfaces */

			c_typed_tag_block<s_i343spartanabilitiesmaterialnamestringidblock> no_rebound_materials_block;
			string_id shoulder_bash_miss_follow_through;
			real shoulder_bash_miss_follow_through_fp_camera_restore_time;
			real_fraction shoulder_bash_miss_follow_through_early_out_fraction;

			/* Aim Assist */

			angle auto_aim_angle;
			real auto_aim_range;
			real auto_aim_falloff_range;
			real auto_aim_near_falloff_range;

			/* AI Response */

			c_enum<e_i343aisoundvolume, short> bash_ai_sound_level;
			char generated_padf9a1[2]; // padding
		};
		static_assert(sizeof(s_i343spartanabilitiesshoulderbashdefinition) == 428, "struct s_i343spartanabilitiesshoulderbashdefinition is invalid size");

		struct s_i343spartanabilitiesshoulderbashdefinitiontag
		{
			s_anytag_struct_definition anytag;
			s_i343spartanabilitiesshoulderbashdefinition data;
		};
		static_assert(sizeof(s_i343spartanabilitiesshoulderbashdefinitiontag) == 444, "struct s_i343spartanabilitiesshoulderbashdefinitiontag is invalid size");

		struct s_i343spartanabilitiessprintdefinition
		{
			s_i343spartanabilitiesspartanabilitycommonparameters common_ability_parameters;
			c_flags<e_i343spartanabilitiessprintdefinitionflags, long, k_i343spartanabilitiessprintdefinitionflags_count> flags;
			c_enum<e_i343spartanabilitiessprintpreservation, char> maintain_through_clamber;
			c_enum<e_i343spartanabilitiessprintpreservation, char> maintain_through_evade;
			c_enum<e_i343spartanabilitiessprintpreservation, char> maintain_through_reload;
			c_enum<e_i343spartanabilitiessprintpreservation, char> maintain_through_melee;
			c_enum<e_i343spartanabilitiessprintpreservation, char> maintain_through_airborne;
			char generated_pad3793[3]; // padding
			c_enum<e_i343damagestuntimercontrol, long> stun_timer_control;
			real evade_delay_time;
			// custom time_to_full_speed
			s_i343malleablepropertybasefloatstructdefinition time_to_full_speed;
			real falloff_time;
			real falloff_time_melee;

			/* speed ramp up function */

			// custom speed_ramp_up_function
			s_functiondefinition speed_ramp_up_function$2;
			// custom full_speed_scalar
			s_i343malleablepropertybasefloatstructdefinition full_speed_scalar;

			/* look velocity scale function */

			// custom look_velocity_scale_function
			s_functiondefinition look_velocity_scale_function$2;
			real yaw_velocity_scale_at_full_sprint;
			real pitch_velocity_scale_at_full_sprint;

			/* max strafe throttle magnitude function */

			// custom max_strafe_throttle_magnitude_function
			s_functiondefinition max_strafe_throttle_magnitude_function$2;
			real max_strafe_throttle_magnitude_at_full_sprint;
			real pegged_magnitude;
			angle pegged_angular_threshold;
			angle max_angle_between_facing_and_velocity;
			real minimum_player_velocity_to_be_considered_in_a_sprinting_state;
			string_id animation_stance;
			// custom exit_animation_speed_scalar
			s_i343malleablepropertybasefloatstructdefinition exit_animation_speed_scalar;
		};
		static_assert(sizeof(s_i343spartanabilitiessprintdefinition) == 240, "struct s_i343spartanabilitiessprintdefinition is invalid size");

		struct s_i343spartanabilitiessprintdefinitiontag
		{
			s_anytag_struct_definition anytag;
			s_i343spartanabilitiessprintdefinition sprint;
		};
		static_assert(sizeof(s_i343spartanabilitiessprintdefinitiontag) == 256, "struct s_i343spartanabilitiessprintdefinitiontag is invalid size");

		struct s_i343spartanabilitiesstabilizerdefinitiontag
		{
			s_anytag_struct_definition anytag;
			s_i343spartanabilitiesstabilizerdefinition data;
			char generated_pad8d36[4]; // padding
		};
		static_assert(sizeof(s_i343spartanabilitiesstabilizerdefinitiontag) == 188, "struct s_i343spartanabilitiesstabilizerdefinitiontag is invalid size");

		struct s_i343spartanabilitiesteleportdefinition
		{
			s_i343spartanabilitiesspartanabilitycommonparameters common_ability_parameters;
			c_flags<e_i343spartanabilitiesteleportdefinitionflags, long, k_i343spartanabilitiesteleportdefinitionflags_count> teleport_flags;

			/* Stabilization/Charge up */

			c_typed_tag_block<s_i343spartanabilitiesstabilizerdefinition> stabilizer_block;

			/* Charge Up Settings */

			real charge_up_button_down_delay;
			real charge_up_min_time;
			real charge_up_max_distance_time;
			real charge_up_auto_release_time;

			/* Teleport */

			c_typed_tag_reference<EFFECT_TAG> teleport_ready_effect;
			c_typed_tag_reference<EFFECT_TAG> teleport_post_ready_effect;
			real_fraction teleport_post_ready_effect_activation_fraction;
			real_fraction teleport_activation_energy_cost;
			c_typed_tag_reference<EFFECT_TAG> teleport_source_effect;
			c_typed_tag_reference<EFFECT_TAG> teleport_destination_effect;
			c_typed_tag_reference<EFFECT_TAG> teleport_fail_effect;

			/* Aiming */

			c_enum<e_i343spartanabilitiesteleportdefinitionaimstyle, char> aim_style;
			c_enum<e_i343spartanabilitiesteleportdefinitionsweptspherecapsulepositioning, char> capsule_positioning;
			char generated_paddaca[2]; // padding
			c_typed_tag_reference<EFFECT_TAG> aim_effect;
			real_bounds aim_distance;
			real swept_shape_pull_back_distance;
			real swept_sphere_radius;

			/* Object function ids */

			string_id overlay_animation_function_id;
			string_id charge_up_fraction_function_id;
			string_id obstructed_function_id;

			/* FOV delta function (charge up) */

			// custom fov_delta_function_charge_up
			s_functiondefinition fov_delta_function_charge_up$2;
		};
		static_assert(sizeof(s_i343spartanabilitiesteleportdefinition) == 272, "struct s_i343spartanabilitiesteleportdefinition is invalid size");

		struct s_i343spartanabilitiesteleportdefinitiontag
		{
			s_anytag_struct_definition anytag;
			s_i343spartanabilitiesteleportdefinition teleport;
		};
		static_assert(sizeof(s_i343spartanabilitiesteleportdefinitiontag) == 288, "struct s_i343spartanabilitiesteleportdefinitiontag is invalid size");

		struct s_i343spartanabilitieswallclingdefinition
		{
			s_i343spartanabilitiesspartanabilitycommonparameters common_ability_parameters;
			c_flags<e_i343spartanabilitieswallclingdefinitionflags, long, k_i343spartanabilitieswallclingdefinitionflags_count> flags;
			real cooldown;

			/* Contact point checks */

			real minimum_height_above_floor;
			real velocity_threshold;
			real_fraction contact_normal_threshold_z;
			real contact_offset_threshold_z;
			real_fraction contact_throttle_dot_threshold;
			real maximum_distance_allowed_between_current_position_and_desired_position_before_snapping;

			/* Hang parameters */

			real hang_time_limit;
			real slide_start_time;
			real slide_speed;

			/* Camera parameters */

			angle camera_roll_max;
			real camera_blend_time;

			/* Jump parameters */

			real_fraction jump_throttle_threshold;
			angle jump_pitch;
			real jump_velocity;
		};
		static_assert(sizeof(s_i343spartanabilitieswallclingdefinition) == 148, "struct s_i343spartanabilitieswallclingdefinition is invalid size");

		struct s_i343spartanabilitieswallclingdefinitiontag
		{
			s_anytag_struct_definition anytag;
			s_i343spartanabilitieswallclingdefinition wallcling;
		};
		static_assert(sizeof(s_i343spartanabilitieswallclingdefinitiontag) == 164, "struct s_i343spartanabilitieswallclingdefinitiontag is invalid size");

		struct s_i343spartanabilitieswalljumpdefinition
		{
			s_i343spartanabilitiesspartanabilitycommonparameters common_ability_parameters;
			c_flags<e_i343spartanabilitieswalljumpdefinitionflags, long, k_i343spartanabilitieswalljumpdefinitionflags_count> flags;

			/* Contact point checks */

			real hit_sphere_offset_z;
			real gap_to_wall_tolerance;
			real_fraction contact_normal_threshold_z;

			/* Jump parameters */

			real_fraction throttle_threshold;
			real_fraction default_throttle_xy;
			real velocity_z;
			real velocity_xy;
		};
		static_assert(sizeof(s_i343spartanabilitieswalljumpdefinition) == 116, "struct s_i343spartanabilitieswalljumpdefinition is invalid size");

		struct s_i343spartanabilitieswalljumpdefinitiontag
		{
			s_anytag_struct_definition anytag;
			s_i343spartanabilitieswalljumpdefinition walljump;
		};
		static_assert(sizeof(s_i343spartanabilitieswalljumpdefinitiontag) == 132, "struct s_i343spartanabilitieswalljumpdefinitiontag is invalid size");

		struct s_soundbankdatafiletag
		{
			s_anytag_struct_definition anytag;
			s_tag_data sound_bank_data;
		};
		static_assert(sizeof(s_soundbankdatafiletag) == 36, "struct s_soundbankdatafiletag is invalid size");

		struct s_soundbankblockdefinition
		{
			string_id sound_bank_name;
		};
		static_assert(sizeof(s_soundbankblockdefinition) == 4, "struct s_soundbankblockdefinition is invalid size");

		struct s_soundbankresourceblockdefinition
		{
			s_tag_resource sound_bank_resource;
		};
		static_assert(sizeof(s_soundbankresourceblockdefinition) == 8, "struct s_soundbankresourceblockdefinition is invalid size");

		struct s_soundbanktag
		{
			s_anytag_struct_definition anytag;
			c_flags<e_soundbanktagflag, long, k_soundbanktagflag_count> flags;
			c_typed_tag_block<s_soundbankblockdefinition> sound_bank_list_block;
			s_tag_resource sound_bank_sfx_resource;
			c_typed_tag_block<s_soundbankresourceblockdefinition> sound_bank_loc_resources_block;
			long bank_priority;
			long bank_unique_id;
			char generated_pad437b[4]; // padding
		};
		static_assert(sizeof(s_soundbanktag) == 64, "struct s_soundbanktag is invalid size");

		struct s_s_structure_manifest_build_identifier_definition
		{
			long manifest_id0;
			long manifest_id1;
			long manifest_id2;
			long manifest_id3;
			long build_index;
			long structure_importer_version;
		};
		static_assert(sizeof(s_s_structure_manifest_build_identifier_definition) == 24, "struct s_s_structure_manifest_build_identifier_definition is invalid size");

		struct s_s_structure_seam_identifier
		{
			long seam_id0;
			long seam_id1;
			long seam_id2;
			long seam_id3;
		};
		static_assert(sizeof(s_s_structure_seam_identifier) == 16, "struct s_s_structure_seam_identifier is invalid size");

		struct s_structureseamedgemapping
		{
			long structure_edge_index;
		};
		static_assert(sizeof(s_structureseamedgemapping) == 4, "struct s_structureseamedgemapping is invalid size");

		struct s_s_structure_seam_cluster_mapping
		{
			long cluster_index;
			real_point3d cluster_center;
		};
		static_assert(sizeof(s_s_structure_seam_cluster_mapping) == 16, "struct s_s_structure_seam_cluster_mapping is invalid size");

		struct s_s_structure_seam_mapping
		{
			s_s_structure_seam_identifier seams_identifier;
			c_typed_tag_block<s_structureseamedgemapping> edge_mapping_block;
			c_typed_tag_block<s_s_structure_seam_cluster_mapping> cluster_mapping_block;
		};
		static_assert(sizeof(s_s_structure_seam_mapping) == 40, "struct s_s_structure_seam_mapping is invalid size");

		struct s_structure_collision_material
		{
			short conveyor_surface_index;
			short seam_mapping_index;
			c_flags<e_structure_collision_materialc_flags, short, k_structure_collision_materialc_flags_count> flags;
		};
		static_assert(sizeof(s_structure_collision_material) == 6, "struct s_structure_collision_material is invalid size");

		struct s_structure_leaf
		{
			byte cluster;
		};
		static_assert(sizeof(s_structure_leaf) == 1, "struct s_structure_leaf is invalid size");

		struct s_s_structure_super_node_mapping
		{
			short parent_super_node_index;
			char parent_internal_node_index;
			c_flags<e_s_structure_super_node_mappingt_flags, char, k_s_structure_super_node_mappingt_flags_count> flags;
			long has_traversal_geometry_mask;
			short first_traversal_geometry_index;
			short first_aabb_index;
			long aabb_mask;
			short non_terminal_traversal_geometry_index;
			char generated_pad5df5[2]; // padding
		};
		static_assert(sizeof(s_s_structure_super_node_mapping) == 20, "struct s_s_structure_super_node_mapping is invalid size");

		struct s_supernoderecursablemasks
		{
			word mask;
		};
		static_assert(sizeof(s_supernoderecursablemasks) == 2, "struct s_supernoderecursablemasks is invalid size");

		struct s_structuresupernodetraversalgeometryindices
		{
			short index;
		};
		static_assert(sizeof(s_structuresupernodetraversalgeometryindices) == 2, "struct s_structuresupernodetraversalgeometryindices is invalid size");

		struct s_s_structure_super_node_traversal_geometry
		{
			c_typed_tag_block<s_structuresupernodetraversalgeometryindices> portal_indices_block;
			c_typed_tag_block<s_structuresupernodetraversalgeometryindices> seam_indices_block;
		};
		static_assert(sizeof(s_s_structure_super_node_traversal_geometry) == 24, "struct s_s_structure_super_node_traversal_geometry is invalid size");

		struct s_cluster_portals_oriented_bounds
		{
			real_point3d center;
			real_vector3d extents;
			real_quaternion orientation;
		};
		static_assert(sizeof(s_cluster_portals_oriented_bounds) == 40, "struct s_cluster_portals_oriented_bounds is invalid size");

		struct s_cluster_portalstructurebspclusterportalvertexblock
		{
			real_point3d point;
		};
		static_assert(sizeof(s_cluster_portalstructurebspclusterportalvertexblock) == 12, "struct s_cluster_portalstructurebspclusterportalvertexblock is invalid size");

		struct s_cluster_portal
		{
			s_cluster_portals_oriented_bounds oriented_bounds;
			short back_cluster;
			short front_cluster;
			long plane_index;
			real_point3d centroid;
			real bounding_radius;
			c_flags<e_clusterportalflags, long, k_clusterportalflags_count> flags;
			c_typed_tag_block<s_cluster_portalstructurebspclusterportalvertexblock> vertices_block;
		};
		static_assert(sizeof(s_cluster_portal) == 80, "struct s_cluster_portal is invalid size");

		struct s_structurebspclusterportalindex
		{
			short portal_index;
		};
		static_assert(sizeof(s_structurebspclusterportalindex) == 2, "struct s_structurebspclusterportalindex is invalid size");

		struct s_seamindicesblockdefinition
		{
			short seam_index;
		};
		static_assert(sizeof(s_seamindicesblockdefinition) == 2, "struct s_seamindicesblockdefinition is invalid size");

		struct s_instanceindex
		{
			short instance_index;
		};
		static_assert(sizeof(s_instanceindex) == 2, "struct s_instanceindex is invalid size");

		struct s_s_instance_bucket
		{
			long runtime_geo_mesh_index;
			c_typed_tag_reference<RUNTIME_GEO_TAG> runtime_geo_tag_reference;
			long pad;
			c_typed_tag_block<s_instanceindex> instances_data_block;
			long instances_data_block_flags;
			long instances_data_block_vector1;
			long instances_data_block_vector2;
		};
		static_assert(sizeof(s_s_instance_bucket) == 48, "struct s_s_instance_bucket is invalid size");

		struct s_structure_cluster
		{

			/* CLUSTER INFO */

			real_bounds bounds_x;
			real_bounds bounds_y;
			real_bounds bounds_z;
			c_typed_tag_block<s_structurebspclusterportalindex> portals_block;
			short mesh_index;
			short instance_imposter_cluster_mopp_index;
			c_typed_tag_block<s_seamindicesblockdefinition> seam_indices_block;
			c_typed_tag_block<s_s_instance_bucket> instance_buckets_block;
			long instance_buckets_flags;
			long instance_buckets_vector1;
			long instance_buckets_vector2;
		};
		static_assert(sizeof(s_structure_cluster) == 76, "struct s_structure_cluster is invalid size");

		struct s_s_structure_cookie_cutter
		{
			// custom cookie_cutter
			s_collision_bsp collision_model;
			// custom value
		};
		static_assert(sizeof(s_s_structure_cookie_cutter) == 108, "struct s_s_structure_cookie_cutter is invalid size");

		struct s_structure_marker
		{
			c_enum<e_e_structure_marker_type, char> marker_type;
			c_static_string<32> marker_parameter;
			char generated_padbec6[3]; // padding
			real_quaternion rotation;
			real_point3d position;
		};
		static_assert(sizeof(s_structure_marker) == 64, "struct s_structure_marker is invalid size");

		struct s_mapleaffacevertex
		{
			real_point3d vertex;
		};
		static_assert(sizeof(s_mapleaffacevertex) == 12, "struct s_mapleaffacevertex is invalid size");

		struct s_map_leaf_face
		{
			long node_index;
			c_typed_tag_block<s_mapleaffacevertex> vertices_block;
		};
		static_assert(sizeof(s_map_leaf_face) == 16, "struct s_map_leaf_face is invalid size");

		struct s_mapleafconnectionindex
		{
			long connection_index;
		};
		static_assert(sizeof(s_mapleafconnectionindex) == 4, "struct s_mapleafconnectionindex is invalid size");

		struct s_map_leaf
		{
			c_typed_tag_block<s_map_leaf_face> faces_block;
			c_typed_tag_block<s_mapleafconnectionindex> connection_indices_block;
		};
		static_assert(sizeof(s_map_leaf) == 24, "struct s_map_leaf is invalid size");

		struct s_leafconnectionvertex
		{
			real_point3d vertex;
		};
		static_assert(sizeof(s_leafconnectionvertex) == 12, "struct s_leafconnectionvertex is invalid size");

		struct s_leaf_connection
		{
			long plane_index;
			long back_leaf_index;
			long front_leaf_index;
			c_typed_tag_block<s_leafconnectionvertex> vertices_block;
			real area;
		};
		static_assert(sizeof(s_leaf_connection) == 28, "struct s_leaf_connection is invalid size");

		struct s_lodinfooverrides
		{
			c_typed_tag_block<s_lodtransitiondistanceblock> lod_levels_block;
			long lod_levels_block_flags;
			long lod_levels_block_vector1;
			long lod_levels_block_vector2;
			real lod_fade_after_distance;
		};
		static_assert(sizeof(s_lodinfooverrides) == 28, "struct s_lodinfooverrides is invalid size");

		struct s_structureinstancematerialoverridedata
		{
			c_typed_tag_block<s_geometry_material> per_instance_material_block;
			long per_instance_material_flags;
			long per_instance_material_vector1;
			long per_instance_material_vector2;
			c_flags<e_meshflags, short, k_meshflags_count> mesh_flags_override;
			char generated_pad58dd[2]; // padding
		};
		static_assert(sizeof(s_structureinstancematerialoverridedata) == 28, "struct s_structureinstancematerialoverridedata is invalid size");

		struct s_streamingbitmapinfo
		{
			long bitmap_index_in_bsp;
			real bitmap_scale;
		};
		static_assert(sizeof(s_streamingbitmapinfo) == 8, "struct s_streamingbitmapinfo is invalid size");

		struct s_structure_instanced_geometry_instance_with_name
		{
			real_vector3d scale;
			real_vector3d forward;
			real_vector3d left;
			real_vector3d up;
			real_point3d position;
			c_typed_tag_reference<RUNTIME_GEO_TAG> runtime_geo_mesh_reference;
			c_typed_tag_reference<RTMP_TAG> foliage_material_palette_reference;
			word runtime_geo_mesh_index;
			c_flags<e_instancedgeometryflags, short, k_instancedgeometryflags_count> flags;
			real bounds_x0;
			real bounds_x1;
			real bounds_y0;
			real bounds_y1;
			real bounds_z0;
			real bounds_z1;
			real_point3d world_bounding_sphere_center;
			real world_bounding_sphere_radius;
			long long placement_checksum;
			c_enum<e_instancedgeometrypathfindingpolicy, char> pathfinding_policy;
			c_enum<e_instancedgeometrystreamingpriority, char> streaming_priority;
			c_flags<e_instancedgeometrygfxflags, short, k_instancedgeometrygfxflags_count> flags2;
			word hlod_index;
			char generated_pad89b2[2]; // padding
			s_lodinfooverrides lod_overrides;
			string_id style_id;
			long damage_style_index;
			char generated_padd667[4]; // padding
			long long style_tag_override_data;
			s_structureinstancematerialoverridedata material_override_data;
			real_point3d rectmin;
			real_point3d rectmax;
			long external_guid;
			long long coating_entry;
			long long editordata;
			c_typed_tag_block<s_streamingbitmapinfo> streamingbitmapinfo_block;
			long streamingbitmapinfo_block_flags;
			long streamingbitmapinfo_block_vector1;
			long streamingbitmapinfo_block_vector2;
			string_id name;
			char generated_pad19d5[4]; // padding
		};
		static_assert(sizeof(s_structure_instanced_geometry_instance_with_name) == 304, "struct s_structure_instanced_geometry_instance_with_name is invalid size");

		struct s_i343physicsinstancedphysicsmaterial
		{
			short per_instance_material_palette;
		};
		static_assert(sizeof(s_i343physicsinstancedphysicsmaterial) == 2, "struct s_i343physicsinstancedphysicsmaterial is invalid size");

		struct s_havokbodyidarray
		{
			dword havok_body_id;
		};
		static_assert(sizeof(s_havokbodyidarray) == 4, "struct s_havokbodyidarray is invalid size");

		struct s_i343physicsinstancedphysicsinstance
		{
			c_typed_tag_reference<STATIC_COLLISION_TAG> m_collisiontagreference;
			c_typed_tag_block<s_i343physicsinstancedphysicsmaterial> instanced_physics_instances_block;
			long instanced_physics_instances_flags;
			long instanced_physics_instances_vector1;
			long instanced_physics_instances_vector2;
			real_vector3d scale;
			real_vector3d forward;
			real_vector3d left;
			real_vector3d up;
			real_point3d position;
			c_flags<e_collisiontypeenablebitmask, long, k_collisiontypeenablebitmask_count> m_typemask;
			long m_guid;
			s_havokbodyidarray havok_body_id_array[4];
			c_flags<e_i343physicsinstancedphysicsflags, char, k_i343physicsinstancedphysicsflags_count> flags;
			char generated_pad119d[7]; // padding
			long long m_scene;
		};
		static_assert(sizeof(s_i343physicsinstancedphysicsinstance) == 140, "struct s_i343physicsinstancedphysicsinstance is invalid size");

		struct s_s_structure_debug_info_render_line
		{
			c_enum<e_debuginforenderlinetype, short> type;
			short code;
			short pad_thai;
			char generated_pada37a[2]; // padding
			real_point3d point_0;
			real_point3d point_1;
		};
		static_assert(sizeof(s_s_structure_debug_info_render_line) == 32, "struct s_s_structure_debug_info_render_line is invalid size");

		struct s_structurebspdebuginfoindicesblock
		{
			long index;
		};
		static_assert(sizeof(s_structurebspdebuginfoindicesblock) == 4, "struct s_structurebspdebuginfoindicesblock is invalid size");

		struct s_s_structure_cluster_debug_info
		{
			c_flags<e_clusterdebuginfoerrorflags, short, k_clusterdebuginfoerrorflags_count> errors;
			c_flags<e_clusterdebuginfoclusterwarningflags, short, k_clusterdebuginfoclusterwarningflags_count> warnings;
			c_typed_tag_block<s_s_structure_debug_info_render_line> lines_block;
			c_typed_tag_block<s_structurebspdebuginfoindicesblock> fog_plane_indices_block;
			c_typed_tag_block<s_structurebspdebuginfoindicesblock> visible_fog_plane_indices_block;
			c_typed_tag_block<s_structurebspdebuginfoindicesblock> vis_fog_omission_cluster_indices_block;
			c_typed_tag_block<s_structurebspdebuginfoindicesblock> containing_fog_zone_indices_block;
		};
		static_assert(sizeof(s_s_structure_cluster_debug_info) == 64, "struct s_s_structure_cluster_debug_info is invalid size");

		struct s_s_structure_fog_plane_debug_info
		{
			long fog_zone_index;
			long connected_plane_designator;
			c_typed_tag_block<s_s_structure_debug_info_render_line> lines_block;
			c_typed_tag_block<s_structurebspdebuginfoindicesblock> intersected_cluster_indices_block;
			c_typed_tag_block<s_structurebspdebuginfoindicesblock> inf_extent_cluster_indices_block;
		};
		static_assert(sizeof(s_s_structure_fog_plane_debug_info) == 44, "struct s_s_structure_fog_plane_debug_info is invalid size");

		struct s_s_structure_fog_zone_debug_info
		{
			long media_index;
			long base_fog_plane_index;
			c_typed_tag_block<s_s_structure_debug_info_render_line> lines_block;
			c_typed_tag_block<s_structurebspdebuginfoindicesblock> immersed_cluster_indices_block;
			c_typed_tag_block<s_structurebspdebuginfoindicesblock> bounding_fog_plane_indices_block;
			c_typed_tag_block<s_structurebspdebuginfoindicesblock> collision_fog_plane_indices_block;
		};
		static_assert(sizeof(s_s_structure_fog_zone_debug_info) == 56, "struct s_s_structure_fog_zone_debug_info is invalid size");

		struct s_s_structure_debug_info
		{
			c_typed_tag_block<s_s_structure_cluster_debug_info> clusters_block;
			c_typed_tag_block<s_s_structure_fog_plane_debug_info> fog_planes_block;
			c_typed_tag_block<s_s_structure_fog_zone_debug_info> fog_zones_block;
		};
		static_assert(sizeof(s_s_structure_debug_info) == 36, "struct s_s_structure_debug_info is invalid size");

		struct s_s_widget_marker_reference
		{
			short marker_index;
			char generated_pad3469[2]; // padding
			c_typed_tag_reference<LEAF_SYSTEM_TAG> widget_ref;
		};
		static_assert(sizeof(s_s_widget_marker_reference) == 20, "struct s_s_widget_marker_reference is invalid size");

		struct s_collisionbspblock
		{
			c_typed_tag_block<s_bsp3d_node> bsp3d_nodes_block;
			c_typed_tag_block<s_s_bsp3d_kd_super_node> bsp3d_supernodes_block;
			c_typed_tag_block<s_planesparams> planes_block;
			c_typed_tag_block<s_collision_leaf> leaves_block;
			c_typed_tag_block<s_bsp2d_reference> bsp2d_references_block;
			c_typed_tag_block<s_bsp2d_node> bsp2d_nodes_block;
			c_typed_tag_block<s_collision_surface> surfaces_block;
			c_typed_tag_block<s_collision_edge> edges_block;
			c_typed_tag_block<s_collision_vertex> vertices_block;
		};
		static_assert(sizeof(s_collisionbspblock) == 108, "struct s_collisionbspblock is invalid size");

		struct s_large_bsp3d_node
		{
			long plane;
			long back_child;
			long front_child;
		};
		static_assert(sizeof(s_large_bsp3d_node) == 12, "struct s_large_bsp3d_node is invalid size");

		struct s_large_collision_leaf
		{
			c_flags<e_leafflags, char, k_leafflags_count> flags;
			char generated_pad7ea5[1]; // padding
			short bsp2d_reference_count;
			long first_bsp2d_reference;
		};
		static_assert(sizeof(s_large_collision_leaf) == 8, "struct s_large_collision_leaf is invalid size");

		struct s_large_bsp2d_reference
		{
			long plane;
			long bsp2d_node;
		};
		static_assert(sizeof(s_large_bsp2d_reference) == 8, "struct s_large_bsp2d_reference is invalid size");

		struct s_large_bsp2d_node
		{
			real_plane2d plane;
			long left_child;
			long right_child;
		};
		static_assert(sizeof(s_large_bsp2d_node) == 20, "struct s_large_bsp2d_node is invalid size");

		struct s_large_collision_surface
		{
			long plane_index;
			long first_edge;
			short material;
			c_flags<e_surfaceflags, char, k_surfaceflags_count> flags;
			byte best_plane_calculation_vertex_index_;
		};
		static_assert(sizeof(s_large_collision_surface) == 12, "struct s_large_collision_surface is invalid size");

		struct s_large_collision_edge
		{
			long start_vertex;
			long end_vertex;
			long forward_edge;
			long reverse_edge;
			long left_surface;
			long right_surface;
		};
		static_assert(sizeof(s_large_collision_edge) == 24, "struct s_large_collision_edge is invalid size");

		struct s_large_collision_vertex
		{
			real_point3d point;
			long first_edge;
			short sink;
			char generated_pad06d3[2]; // padding
		};
		static_assert(sizeof(s_large_collision_vertex) == 20, "struct s_large_collision_vertex is invalid size");

		struct s_large_collision_bsp
		{
			c_typed_tag_block<s_large_bsp3d_node> bsp3d_nodes_block;
			c_typed_tag_block<s_s_bsp3d_kd_super_node> bsp3d_supernodes_block;
			c_typed_tag_block<s_planesparams> planes_block;
			c_typed_tag_block<s_large_collision_leaf> leaves_block;
			c_typed_tag_block<s_large_bsp2d_reference> bsp2d_references_block;
			c_typed_tag_block<s_large_bsp2d_node> bsp2d_nodes_block;
			c_typed_tag_block<s_large_collision_surface> surfaces_block;
			c_typed_tag_block<s_large_collision_edge> edges_block;
			c_typed_tag_block<s_large_collision_vertex> vertices_block;
		};
		static_assert(sizeof(s_large_collision_bsp) == 108, "struct s_large_collision_bsp is invalid size");

		struct s_s_structure_bsp_resources
		{
			c_typed_tag_block<s_collisionbspblock> collision_bsp_block;
			c_typed_tag_block<s_large_collision_bsp> large_collision_bsp_block;
		};
		static_assert(sizeof(s_s_structure_bsp_resources) == 24, "struct s_s_structure_bsp_resources is invalid size");

		struct s_structurebsprawresources
		{
			s_s_structure_bsp_resources raw_items;
		};
		static_assert(sizeof(s_structurebsprawresources) == 24, "struct s_structurebsprawresources is invalid size");

		struct s_c_structure_bsp_resource_interface
		{
			c_typed_tag_block<s_structurebsprawresources> raw_resources_block;
			s_tag_resource tag_resources;
			long use_resource_items;
		};
		static_assert(sizeof(s_c_structure_bsp_resource_interface) == 24, "struct s_c_structure_bsp_resource_interface is invalid size");

		struct s_prefablodoverridearray
		{
			real lod_transition_distance_override;
		};
		static_assert(sizeof(s_prefablodoverridearray) == 4, "struct s_prefablodoverridearray is invalid size");

		struct s_structure_external_instanced_geometry_reference
		{
			c_typed_tag_reference<RUNTIME_GEO_TAG> static_render_geometry;
			c_typed_tag_reference<STATIC_COLLISION_TAG> static_collision_geometry;
			c_typed_tag_reference<RTMP_TAG> material_palette;
			string_id name;
			string_id material_override_variant_name;
			real_vector3d scale;
			real_vector3d forward;
			real_vector3d left;
			real_vector3d up;
			real_point3d position;
			c_flags<e_instancedgeometryflags, short, k_instancedgeometryflags_count> override_flags;
			c_flags<e_instancedgeometryflags, short, k_instancedgeometryflags_count> instance_flags_mask;
			c_flags<e_i343physicsinstancedphysicsflags, char, k_i343physicsinstancedphysicsflags_count> physics_override_flags;
			c_flags<e_i343physicsinstancedphysicsflags, char, k_i343physicsinstancedphysicsflags_count> physics_instance_flags_mask;
			c_enum<e_instancedgeometrypathfindingpolicy, char> override_pathfinding_policy;
			c_enum<e_instancedgeometrystreamingpriority, char> override_streaming_priority;
			c_flags<e_prefaboverrideflags, short, k_prefaboverrideflags_count> instance_policy_mask;
			char generated_pad81ce[2]; // padding
			s_prefablodoverridearray lod_distance_overrides[16];
			real lod_fade_after_override;
			c_enum<e_staticgeotype, long> instance_type;
			long guid;
			dword hlodindex;
			string_id styleid;
			long long styletagoverride;
			c_typed_tag_block<s_materialoverrideentry> instance_material_overrides_block;
			c_typed_tag_block<s_materialoverrideentry> material_overrides_block;
		};
		static_assert(sizeof(s_structure_external_instanced_geometry_reference) == 244, "struct s_structure_external_instanced_geometry_reference is invalid size");

		struct s_s_structure_bsp_obb_volume
		{
			real_point3d origin;
			real_vector3d axis_1;
			real_vector3d axis_2;
			real_vector3d axis_3;
			dword type;
		};
		static_assert(sizeof(s_s_structure_bsp_obb_volume) == 52, "struct s_s_structure_bsp_obb_volume is invalid size");

		struct s_i343graphicsindexlistblock
		{
			word index;
		};
		static_assert(sizeof(s_i343graphicsindexlistblock) == 2, "struct s_i343graphicsindexlistblock is invalid size");

		struct s_i343graphicshierarchynode
		{
			real_point3d rectmin;
			real_point3d rectmax;
			real_plane3d groupboundingsphere;
			long instanceindex;
			long groupinstanceoffset;
			c_typed_tag_block<s_i343graphicsindexlistblock> instance_group_indices_block;
			long instance_group_indices_flags;
			long instance_group_indices_vector1;
			long instance_group_indices_vector2;
			word descendantscount;
			word iocount;
		};
		static_assert(sizeof(s_i343graphicshierarchynode) == 76, "struct s_i343graphicshierarchynode is invalid size");

		struct s_i343graphicsclustermaskblock
		{
			dword chunk;
		};
		static_assert(sizeof(s_i343graphicsclustermaskblock) == 4, "struct s_i343graphicsclustermaskblock is invalid size");

		struct s_i343graphicsclusternodecount
		{
			c_typed_tag_block<s_i343graphicsclustermaskblock> clustermask_block;
			long clustermask_flags;
			long clustermask_vector1;
			long clustermask_vector2;
			word startingnodeindex;
			word nodecount;
		};
		static_assert(sizeof(s_i343graphicsclusternodecount) == 28, "struct s_i343graphicsclusternodecount is invalid size");

		struct s_bspstructurebitfieldstoragetype
		{
			dword chunk;
		};
		static_assert(sizeof(s_bspstructurebitfieldstoragetype) == 4, "struct s_bspstructurebitfieldstoragetype is invalid size");

		struct s_gpuvisibilitybitfield
		{
			long long bsp_structure_bitfield_buffer;
			s_bspstructurebitfieldstoragetype cpu_bsp_structure__bitfield[1024];
		};
		static_assert(sizeof(s_gpuvisibilitybitfield) == 4104, "struct s_gpuvisibilitybitfield is invalid size");

		struct s_i343graphicsgpusubmissiongpusubmissionpasssources
		{
			c_flags<e_i343graphicsgpusubmissiongpusubmissionpasssourcesflags, long, k_i343graphicsgpusubmissiongpusubmissionpasssourcesflags_count> flags;
			char generated_padc013[4]; // padding
			long long batch_checksum;
			long long command_packets_buffer;
			long long submesh_buffer;
			long long hw_instance_group_buffer;
			long long instance_data_buffer;
			long long instance_buffer_constants;
			long long resource_collection_state;
			s_guidbyte gpu_submission_batches[24];
			long extern_textures_in_use;
			long submeshpassthreadcount;
			long paddedsubmeshcount;
			long hwinstancethreadcount;
			long m_paddedhwinstancecount;
			char generated_pad735e[4]; // padding
		};
		static_assert(sizeof(s_i343graphicsgpusubmissiongpusubmissionpasssources) == 112, "struct s_i343graphicsgpusubmissiongpusubmissionpasssources is invalid size");

		struct s_i343foliagefoliagetype
		{
			c_typed_tag_reference<RUNTIME_GEO_TAG> runtime_geo;
			c_typed_tag_reference<RTMP_TAG> material_palette;
		};
		static_assert(sizeof(s_i343foliagefoliagetype) == 32, "struct s_i343foliagefoliagetype is invalid size");

		struct s_i343foliagefoliageruntime
		{
			c_typed_tag_block<s_i343foliagefoliagetype> foliage_types_block;
			char generated_pad1383[4]; // padding
			long long foliage_runtime_gpu;
			long long foliage_runtime_cpu;
		};
		static_assert(sizeof(s_i343foliagefoliageruntime) == 32, "struct s_i343foliagefoliageruntime is invalid size");

		struct s_bspbitmapreference
		{
			c_typed_tag_reference<BITMAP_TAG> bitmap;
		};
		static_assert(sizeof(s_bspbitmapreference) == 16, "struct s_bspbitmapreference is invalid size");

		struct s_i343decoratorsdecoratorsetplacementrange
		{
			c_typed_tag_reference<RUNTIME_DEC_TAG> decorator_asset;
			long offset;
			long count;
			byte set_type_index;
			char generated_pad961e[3]; // padding
		};
		static_assert(sizeof(s_i343decoratorsdecoratorsetplacementrange) == 28, "struct s_i343decoratorsdecoratorsetplacementrange is invalid size");

		struct s_i343decoratorsdecoratorcluster
		{
			real_vector3d scale;
			real max_render_distance_squared;
			real_vector3d offset;
			real_vector3d bounding_sphere_center;
			real bounding_sphere_radius;
			real_vector3d bounding_aabb_min;
			real_vector3d bounding_aabb_max;
		};
		static_assert(sizeof(s_i343decoratorsdecoratorcluster) == 68, "struct s_i343decoratorsdecoratorcluster is invalid size");

		struct s_i343decoratorsdecoratorruntime
		{
			c_typed_tag_block<s_i343decoratorsdecoratorsetplacementrange> sets_block;
			c_typed_tag_block<s_i343decoratorsdecoratorcluster> clusters_block;
			long bspindex;
			char generated_pad92da[4]; // padding
			long long decorator_runtime_gpu;
			long long decorator_runtime_cpu;
		};
		static_assert(sizeof(s_i343decoratorsdecoratorruntime) == 48, "struct s_i343decoratorsdecoratorruntime is invalid size");

		struct s_structure_bsp
		{
			s_anytag_struct_definition anytag;
			s_s_structure_manifest_build_identifier_definition build_identifier;
			s_s_structure_manifest_build_identifier_definition parent_build_identifier;
			long import_info_checksum;
			long import_version;
			c_typed_tag_reference<LEVEL_TAG> owner_level;
			c_typed_tag_reference<STRUCTURE_META_TAG> structure_meta_data;
			c_flags<e_structurebspflags, short, k_structurebspflags_count> flags;
			c_flags<e_c_structure_bsp_content_policy_flags, short, k_c_structure_bsp_content_policy_flags_count> content_policy_flags;
			c_flags<e_c_structure_bsp_content_policy_flags, short, k_c_structure_bsp_content_policy_flags_count> failed_content_policy_flags;
			char generated_pad7169[2]; // padding
			c_typed_tag_block<s_s_structure_seam_mapping> seam_identifiers_block;
			c_typed_tag_block<s_structure_collision_material> collision_materials_block;
			c_typed_tag_block<s_structure_leaf> leaves_block;
			c_typed_tag_block<s_s_structure_super_node_mapping> super_node_parent_mappings_block;
			c_typed_tag_block<s_supernoderecursablemasks> super_node_recursable_masks_block;
			c_typed_tag_block<s_s_structure_super_node_traversal_geometry> structure_super_node_traversal_geometry_block;
			real_bounds world_bounds_x;
			real_bounds world_bounds_y;
			real_bounds world_bounds_z;
			c_typed_tag_block<s_cluster_portal> cluster_portals_block;
			c_typed_tag_block<s_structure_cluster> clusters_block;
			c_typed_tag_block<s_s_structure_cookie_cutter> cookie_cutters_block;
			c_typed_tag_block<s_structure_marker> markers_block;
			c_typed_tag_block<s_map_leaf> leaf_map_leaves_block;
			c_typed_tag_block<s_leaf_connection> leaf_map_connections_block;
			c_typed_tag_block<s_error_report_category> errors_block;
			c_typed_tag_block<s_structure_instanced_geometry_instance_with_name> instanced_geometry_instances_block;
			long instanced_geometry_instances_flags;
			long instanced_geometry_instances_vector1;
			long instanced_geometry_instances_vector2;
			c_typed_tag_block<s_structure_instanced_geometry_instance_with_name> instanced_foliage_instances_block;
			long instanced_foliage_instances_flags;
			long instanced_foliage_instances_vector1;
			long instanced_foliage_instances_vector2;
			c_typed_tag_block<s_i343physicsinstancedphysicsinstance> instanced_physics_instances_block;
			long instanced_physics_instances_flags;
			long instanced_physics_instances_vector1;
			long instanced_physics_instances_vector2;
			long instance_geometry_tag_instance_count;
			long long instance_postprocess_checksum;
			c_typed_tag_block<s_s_structure_debug_info> debug_info_block;
			char generated_pad5788[4]; // padding
			s_s_render_geometry render_geometry;
			c_typed_tag_block<s_s_widget_marker_reference> widget_references_block;
			s_c_structure_bsp_resource_interface resource_interface;
			c_typed_tag_block<s_structure_external_instanced_geometry_reference> external_references_block;
			long base_material_count;
			c_typed_tag_block<s_s_structure_bsp_obb_volume> obb_volume_list_block;
			c_typed_tag_block<s_i343graphicshierarchynode> io_hierarchy_block;
			long io_hierarchy_flags;
			long io_hierarchy_vector1;
			long io_hierarchy_vector2;
			c_typed_tag_block<s_i343graphicsclusternodecount> visibility_cluster_node_counts_block;
			long visibility_cluster_node_counts_flags;
			long visibility_cluster_node_counts_vector1;
			long visibility_cluster_node_counts_vector2;
			long long m_instancegrouppipelinestatecache;
			s_tag_data growable_dataof;
			long long heap_array_pointer;
			long heap_current_size;
			long active_growth_state;
			long long instancedata;
			long long instancebufferconstants;
			long long ioplacementgputestingbuffer;
			long long ioplacementgputestingsrv;
			long long iolodstaticinfobuffer;
			long long iolodindexbuffer;
			s_gpuvisibilitybitfield activeiobitfield;
			long long newlyvisibleiobitfieldbuffer;
			long long ioplacementlodinfobuffer;
			c_typed_tag_reference<ACOUSTICSDATA_TAG> acoustics_data;
			long number_of_io_over_the_limit;
			long needtoclearshadowsubmissionsbuffers;
			char generated_pad0ad3[4]; // padding
			long long gpufloatingshadowsubmissiondata;
			s_i343graphicsgpusubmissiongpusubmissionpasssources gpu_submission_sources[2];
			s_bspstructurebitfieldstoragetype instances_with_non_gpu_submission_parts[1024];
			c_typed_tag_block<s_i343foliagefoliageruntime> foliage_runtime_block;
			c_typed_tag_block<s_bspbitmapreference> bitmaps_block;
			long bitmaps_flags;
			long bitmaps_vector1;
			long bitmaps_vector2;
			c_typed_tag_block<s_s_decorator_scenario_set_placements> decorator_sets_block;
			c_typed_tag_block<s_i343decoratorsdecoratorruntime> decorator_runtime_block;
			char generated_pad8b4a[4]; // padding
		};
		static_assert(sizeof(s_structure_bsp) == 9328, "struct s_structure_bsp is invalid size");

		struct s_i343projectilessupercombineeffects
		{
			c_typed_tag_reference<EFFECT_TAG> super_detonation;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> super_detonation_damage;
			s_tag_reference super_detonation_sound;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> super_attached_detonation_damage;
		};
		static_assert(sizeof(s_i343projectilessupercombineeffects) == 64, "struct s_i343projectilessupercombineeffects is invalid size");

		struct s_i343projectilessupercombinedefinition
		{
			s_anytag_struct_definition anytag;
			// custom default_effects
			s_i343projectilessupercombineeffects default_super_combine_effects;
			// custom value
			// custom biped_effects
			s_i343projectilessupercombineeffects biped_super_combine_effects;
			// custom value
			// custom vehicle_effects
			s_i343projectilessupercombineeffects vehicle_super_combine_effects;
			// custom value
			c_typed_tag_reference<EFFECT_TAG> super_detonation;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> super_detonation_damage;
			s_tag_reference super_detonation_sound;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> super_attached_detonation_damage;
			c_flags<e_scenarioobjecttypeflag, short, k_scenarioobjecttypeflag_count> super_detonation_object_types;
			char generated_padc196[2]; // padding
			long default_super_combine_amount;
			long biped_super_combine_amount;
			long vehicle_super_combine_amount;
			real super_det_time;
			char generated_pad0e4b[4]; // padding
		};
		static_assert(sizeof(s_i343projectilessupercombinedefinition) == 296, "struct s_i343projectilessupercombinedefinition is invalid size");

		struct s_scenery_definition
		{
			s_objectdefinition object;

			/* Pathfinding */

			c_enum<e_objectpathfindingpolicy, short> pathfinding_policy;
			c_flags<e_sceneryflags, short, k_sceneryflags_count> flags;
			char generated_padf66f[4]; // padding
		};
		static_assert(sizeof(s_scenery_definition) == 1228, "struct s_scenery_definition is invalid size");

		struct s_i343physicscollisionmaterialoverride
		{
			string_id name;
		};
		static_assert(sizeof(s_i343physicscollisionmaterialoverride) == 4, "struct s_i343physicscollisionmaterialoverride is invalid size");

		struct s_serializedhavokgeometry
		{
			long long field_pointer_skip;
			dword collision_type;
			dword number_of_shapes;
			c_enum<e_whodoesreload, char> who_will_reload_the_shape_the_parent_tag_or_this_struct;
			char generated_padb5d1[3]; // padding
			s_tag_data havok_data;
			char generated_pad9bf0[4]; // padding
		};
		static_assert(sizeof(s_serializedhavokgeometry) == 44, "struct s_serializedhavokgeometry is invalid size");

		struct s_staticcollisiongeotag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343physicscollisionmaterialoverride> collision_material_overrides_block;
			short numcollisionmaterials;
			c_flags<e_i343physicsinstancedphysicsflags, char, k_i343physicsinstancedphysicsflags_count> flags;
			char generated_pad05b3[1]; // padding
			c_typed_tag_block<s_serializedhavokgeometry> havok_collision_geometry_types_block;
			real_point3d shape_bounds_min;
			real_point3d shape_bounds_max;
			char generated_padb8fe[4]; // padding
		};
		static_assert(sizeof(s_staticcollisiongeotag) == 72, "struct s_staticcollisiongeotag is invalid size");

		struct s_s_structure_soft_ceiling_triangle
		{
			real_plane3d plane;
			real_point3d bounding_sphere_center;
			real bounding_sphere_radius;
			real_point3d vertex0;
			real_point3d vertex1;
			real_point3d vertex2;
		};
		static_assert(sizeof(s_s_structure_soft_ceiling_triangle) == 68, "struct s_s_structure_soft_ceiling_triangle is invalid size");

		struct s_s_structure_soft_ceiling
		{
			string_id name;
			c_enum<e_e_soft_ceiling_type, short> type;
			char generated_paddd86[2]; // padding
			c_typed_tag_block<s_s_structure_soft_ceiling_triangle> soft_ceiling_triangles_block;
		};
		static_assert(sizeof(s_s_structure_soft_ceiling) == 20, "struct s_s_structure_soft_ceiling is invalid size");

		struct s_s_structure_physics_water_group
		{
			string_id name;
		};
		static_assert(sizeof(s_s_structure_physics_water_group) == 4, "struct s_s_structure_physics_water_group is invalid size");

		struct s_s_structure_physics_water_instance_plane
		{
			real_plane3d plane;
		};
		static_assert(sizeof(s_s_structure_physics_water_instance_plane) == 16, "struct s_s_structure_physics_water_instance_plane is invalid size");

		struct s_s_structure_physics_water_instance_debug_triangle
		{
			real_point3d point0;
			real_point3d point1;
			real_point3d point2;
		};
		static_assert(sizeof(s_s_structure_physics_water_instance_debug_triangle) == 36, "struct s_s_structure_physics_water_instance_debug_triangle is invalid size");

		struct s_s_structure_physics_water_instance
		{
			short group;
			char generated_pad726d[2]; // padding
			real_vector3d flow_velocity;
			argb_color fog_color;
			real fog_murkiness;
			c_typed_tag_block<s_s_structure_physics_water_instance_plane> water_planes_block;
			c_typed_tag_block<s_s_structure_physics_water_instance_debug_triangle> water_debug_triangles_block;
			real_bounds bounds_x;
			real_bounds bounds_y;
			real_bounds bounds_z;
		};
		static_assert(sizeof(s_s_structure_physics_water_instance) == 84, "struct s_s_structure_physics_water_instance is invalid size");

		struct s_s_structure_design_physics
		{
			long importer_version;
			c_typed_tag_block<s_s_havok_mopp_code_definition> soft_ceiling_mopp_code_block;
			c_typed_tag_block<s_s_structure_soft_ceiling> soft_ceilings_block;
			c_typed_tag_block<s_s_havok_mopp_code_definition> water_mopp_code_block;
			c_typed_tag_block<s_s_structure_physics_water_group> water_groups_block;
			c_typed_tag_block<s_s_structure_physics_water_instance> water_instances_block;
		};
		static_assert(sizeof(s_s_structure_design_physics) == 64, "struct s_s_structure_design_physics is invalid size");

		struct s_s_planar_fog_vertex
		{
			real_point3d position;
		};
		static_assert(sizeof(s_s_planar_fog_vertex) == 12, "struct s_s_planar_fog_vertex is invalid size");

		struct s_s_planar_fog_triangle_plane
		{
			real_plane3d plane;
		};
		static_assert(sizeof(s_s_planar_fog_triangle_plane) == 16, "struct s_s_planar_fog_triangle_plane is invalid size");

		struct s_s_planar_fog_triangle
		{
			c_typed_tag_block<s_s_planar_fog_triangle_plane> planes_block;
		};
		static_assert(sizeof(s_s_planar_fog_triangle) == 12, "struct s_s_planar_fog_triangle is invalid size");

		struct s_s_planar_fog_definition
		{
			string_id name;
			c_typed_tag_block<s_s_planar_fog_vertex> vertices_block;
			c_typed_tag_block<s_s_planar_fog_triangle> triangles_block;
			real depth;
			real_vector3d normal;
		};
		static_assert(sizeof(s_s_planar_fog_definition) == 44, "struct s_s_planar_fog_definition is invalid size");

		struct s_s_planer_fog_set_definition
		{
			c_typed_tag_block<s_s_planar_fog_definition> planar_fogs_block;
		};
		static_assert(sizeof(s_s_planer_fog_set_definition) == 12, "struct s_s_planer_fog_set_definition is invalid size");

		struct s_s_structure_design
		{
			s_anytag_struct_definition anytag;
			s_s_structure_manifest_build_identifier_definition build_identifier;
			s_s_structure_manifest_build_identifier_definition parent_build_identifier;
			s_s_structure_design_physics physics;
			s_s_planer_fog_set_definition planar_fog_set;
			char generated_pad560c[4]; // padding
			// custom rain
			s_s_render_geometry render_geometry;
			c_typed_tag_block<s_structure_instanced_geometry_instance_with_name> instanced_geometry_instances_block;
			c_typed_tag_block<s_geometry_material> materials_block;
			// custom value
		};
		static_assert(sizeof(s_s_structure_design) == 360, "struct s_s_structure_design is invalid size");

		struct s_s_scenario_budget_reference
		{
			s_tag_reference reference;
		};
		static_assert(sizeof(s_s_scenario_budget_reference) == 16, "struct s_s_scenario_budget_reference is invalid size");

		struct s_s_scenario_required_resources
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_s_scenario_budget_reference> resources_block;
			char generated_padb232[4]; // padding
		};
		static_assert(sizeof(s_s_scenario_required_resources) == 32, "struct s_s_scenario_required_resources is invalid size");

		struct s_areascreeneffectscalarfunction
		{
			// custom mapping
			s_functiondefinition mapping;
		};
		static_assert(sizeof(s_areascreeneffectscalarfunction) == 20, "struct s_areascreeneffectscalarfunction is invalid size");

		struct s_screeneffectfunctiondefinitionwithinputs
		{
			string_id input_variable;
			string_id range_variable;
			// custom mapping
			s_functiondefinition mapping;
		};
		static_assert(sizeof(s_screeneffectfunctiondefinitionwithinputs) == 28, "struct s_screeneffectfunctiondefinitionwithinputs is invalid size");

		struct s_s_single_screen_effect_definition
		{
			string_id name;
			c_flags<e_s_single_screen_effect_definitionc_single_screen_effect_flags, short, k_s_single_screen_effect_definitionc_single_screen_effect_flags_count> flags;
			c_flags<e_s_single_screen_effect_definitionc_single_screen_effect_hidden_flags, short, k_s_single_screen_effect_definitionc_single_screen_effect_hidden_flags_count> hidden_flags;

			/* DISTANCE FALLOFF */

			real maximum_distance;
			s_areascreeneffectscalarfunction distance_falloff$2;

			/* TIME EVOLUTION */

			real delay;
			real lifetime;
			s_areascreeneffectscalarfunction time_falloff;

			/* ANGLE FALLOFF */

			s_areascreeneffectscalarfunction angle_falloff$2;

			/* OBJECT FALLOFF */

			s_screeneffectfunctiondefinitionwithinputs object_falloff$2;

			/* EFFECTS */

			c_typed_tag_reference<BITMAP_TAG> color_grading_look_up_texture;
			real runtime_color_grading_strength;
			c_typed_tag_reference<BITMAP_TAG> hdr_color_grading_look_up_texture;
			real runtime_hdr_color_grading_strength;
			real exposure_boost;
			real exposure_deboost;
			real hue_left;
			real hue_right;
			real saturation;
			real desaturation;
			real contrast_enhance;
			real gamma_enhance;
			real gamma_reduce;
			c_enum<e_i343effectscoloroverridemode, char> filter_color_override_mode;
			char generated_pad1d18[3]; // padding
			rgb_color color_filter;
			c_enum<e_i343effectscoloroverridemode, char> floor_color_override_mode;
			char generated_pad36f9[3]; // padding
			rgb_color color_floor;
			real_fraction color_replace_strength;
			c_enum<e_i343effectscoloroverridemode, char> replace_color_override_mode;
			char generated_pad83ae[3]; // padding
			rgb_color color_replace;
			real tron;
			real radial_blur;
			real_vector3d radial_blur_direction;
			real vision_mode;
			real hud_fade;
			real fov_in;
			real fov_out;
			real screen_shake;
			char generated_padb9c9[4]; // padding
			c_typed_tag_reference<MATERIAL_TAG> shader_effect;
			char generated_pad6f0e[4]; // padding
			long long m_pipelinestate;
		};
		static_assert(sizeof(s_s_single_screen_effect_definition) == 308, "struct s_s_single_screen_effect_definition is invalid size");

		struct s_s_area_screen_effect_definition
		{
			s_anytag_struct_definition anytag;
			c_flags<e_s_area_screen_effect_definitionflags, short, k_s_area_screen_effect_definitionflags_count> global_flags;
			c_flags<e_s_area_screen_effect_definitionc_area_screen_effect_hidden_flags, short, k_s_area_screen_effect_definitionc_area_screen_effect_hidden_flags_count> global_hidden_flags;
			c_typed_tag_block<s_s_single_screen_effect_definition> screen_effects_block;
		};
		static_assert(sizeof(s_s_area_screen_effect_definition) == 32, "struct s_s_area_screen_effect_definition is invalid size");

		struct s_nodegraphcontentsurfacinggraphcontenttag
		{
			s_nodegraphcontentnodegraphcontenttag nodegraph;
		};
		static_assert(sizeof(s_nodegraphcontentsurfacinggraphcontenttag) == 68, "struct s_nodegraphcontentsurfacinggraphcontenttag is invalid size");

		struct s_spottedobjectblock
		{
			c_typed_tag_reference<OBJECT_TAG> spotted_object;
		};
		static_assert(sizeof(s_spottedobjectblock) == 16, "struct s_spottedobjectblock is invalid size");

		struct s_speechscript
		{
			long script_name;
			c_static_string<256> script_source;
		};
		static_assert(sizeof(s_speechscript) == 260, "struct s_speechscript is invalid size");

		struct s_speechgrammarblock
		{
			c_typed_tag_reference<SPEECHGRAMMARGROUP_TAG> speech_grammar;
		};
		static_assert(sizeof(s_speechgrammarblock) == 16, "struct s_speechgrammarblock is invalid size");

		struct s_speechgrammarphraseblock
		{
			string_id vui_id;

			/* Script Action */

			s_speechscript script_action$2;

			/* Script Condition */

			s_speechscript script_condition$2;
			s_tag_data command;
			real weight;
			c_flags<e_speechgrammarphraseflags, char, k_speechgrammarphraseflags_count> flags;
			char generated_padd093[1]; // padding
			short user_level;
		};
		static_assert(sizeof(s_speechgrammarphraseblock) == 552, "struct s_speechgrammarphraseblock is invalid size");

		struct s_speechgrammarnodeblock
		{
			s_tag_data command;

			/* Script Condition */

			s_speechscript script_condition$2;
		};
		static_assert(sizeof(s_speechgrammarnodeblock) == 280, "struct s_speechgrammarnodeblock is invalid size");

		struct s_speechgrammargroup
		{
			s_anytag_struct_definition anytag;
			string_id name;
			c_flags<e_speechgrammarflags, char, k_speechgrammarflags_count> flags;
			char generated_padba5c[3]; // padding
			c_typed_tag_block<s_spottedobjectblock> spotted_objects_load_block;

			/* load grammar condition */

			s_speechscript script_condition;
			c_flags<e_speechgrammarruntimeflags, char, k_speechgrammarruntimeflags_count> run_time_flags;
			char generated_padd43d[1]; // padding
			short absolute_dynamic_grammar_index;
			c_typed_tag_block<s_speechgrammarblock> lynced_grammars_block;
			c_typed_tag_block<s_speechgrammarphraseblock> speech_phrases_block;
			c_typed_tag_block<s_speechgrammarnodeblock> speech_nodes_block;
		};
		static_assert(sizeof(s_speechgrammargroup) == 336, "struct s_speechgrammargroup is invalid size");

		struct s_speechgrammarglobals
		{
			s_anytag_struct_definition anytag;
			real vui_timeout_in_seconds;
			real vui_leafnode_timeout_in_seconds;
			real_fraction default_confidence;
			c_flags<e_speechgrammarglobalsflags, char, k_speechgrammarglobalsflags_count> flags;
			char generated_pad3939[3]; // padding
			c_typed_tag_block<s_speechgrammarblock> speech_grammars_block;
			c_typed_tag_reference<MULTILINGUAL_UNICODE_STRING_LIST_TAG> localized_errors;
			c_typed_tag_reference<MULTILINGUAL_UNICODE_STRING_LIST_TAG> localized_phrases;
			c_typed_tag_reference<MULTILINGUAL_UNICODE_STRING_LIST_TAG> localized_display_text;
			c_typed_tag_reference<MULTILINGUAL_UNICODE_STRING_LIST_TAG> localized_needs_text;
			c_typed_tag_reference<MULTILINGUAL_UNICODE_STRING_LIST_TAG> localized_locate_text;
			c_typed_tag_reference<MULTILINGUAL_UNICODE_STRING_LIST_TAG> localized_orders_text;
			c_typed_tag_reference<EFFECT_TAG> default_spotted_effect;
			real default_shimmer_effect_delay;
			char generated_pad1f58[4]; // padding
		};
		static_assert(sizeof(s_speechgrammarglobals) == 164, "struct s_speechgrammarglobals is invalid size");

		struct s_soundresponsepermutationdefinition
		{
			c_typed_tag_reference<SOUND_TAG> sound;
			c_typed_tag_reference<MUSIC_CONTROL_TAG> music;
		};
		static_assert(sizeof(s_soundresponsepermutationdefinition) == 32, "struct s_soundresponsepermutationdefinition is invalid size");

		struct s_soundcombineresponsedefinition
		{
			string_id name;
			c_flags<e_c_sound_combine_response_flags, char, k_c_sound_combine_response_flags_count> response_behavior;
			char generated_pad9b20[3]; // padding
			c_typed_tag_reference<SOUND_RESPONSE_TAG> response;
		};
		static_assert(sizeof(s_soundcombineresponsedefinition) == 24, "struct s_soundcombineresponsedefinition is invalid size");

		struct s_soundresponsedefinition
		{
			string_id name;
			string_id channel;
			string_id category;
			long category_priority;
			real queue_timeout;
			real consideration_time;
			real gap_after_sound;
			c_flags<e_c_sound_response_queue_flags, char, k_c_sound_response_queue_flags_count> queue_behavior;
			char generated_padb18f[3]; // padding
			c_typed_tag_block<s_soundresponsepermutationdefinition> potential_responses_block;
			c_typed_tag_block<s_soundcombineresponsedefinition> combiners_block;
		};
		static_assert(sizeof(s_soundresponsedefinition) == 56, "struct s_soundresponsedefinition is invalid size");

		struct s_soundresponsegroupdefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_soundresponsedefinition> responses_block;
			char generated_pad2940[4]; // padding
		};
		static_assert(sizeof(s_soundresponsegroupdefinition) == 32, "struct s_soundresponsegroupdefinition is invalid size");

		struct s_shaderinputassemblyparameter
		{
			c_static_string<32> semantic_name;
			word semantic_index;
		};
		static_assert(sizeof(s_shaderinputassemblyparameter) == 34, "struct s_shaderinputassemblyparameter is invalid size");

		struct s_shaderbytecode
		{
			s_anytag_struct_definition anytag;
			s_tag_data shaderbytecodedata;
			c_typed_tag_block<s_shaderinputassemblyparameter> ia_parameters_block;
			long platform_marker;
			word instruction_count;
			word texture_reads;
			char generated_padbcac[4]; // padding
		};
		static_assert(sizeof(s_shaderbytecode) == 60, "struct s_shaderbytecode is invalid size");

		struct s_shaderversion
		{
			s_anytag_struct_definition anytag;
		};
		static_assert(sizeof(s_shaderversion) == 16, "struct s_shaderversion is invalid size");

		struct s_shadergpupropertyname
		{
			string_id name;
		};
		static_assert(sizeof(s_shadergpupropertyname) == 4, "struct s_shadergpupropertyname is invalid size");

		struct s_baseshader
		{
			s_anytag_struct_definition anytag;
			long shader_compiler_version;
			c_flags<e_shaderflags, long, k_shaderflags_count> flags;
			c_flags<e_shadercompileflags, long, k_shadercompileflags_count> compile_flags;
			c_typed_tag_block<s_shadergpupropertyname> emitter_property_names_block;
			c_typed_tag_block<s_shadergpupropertyname> simulator_property_names_block;
			c_typed_tag_block<s_shadergpupropertyname> renderer_property_names_block;
			s_tag_data shader_source_data;
		};
		static_assert(sizeof(s_baseshader) == 84, "struct s_baseshader is invalid size");

		struct s_shaderoptions
		{
			s_anytag_struct_definition anytag;
			c_flags<e_shadercompileflags, long, k_shadercompileflags_count> compile_flags;
			char generated_padec67[4]; // padding
		};
		static_assert(sizeof(s_shaderoptions) == 24, "struct s_shaderoptions is invalid size");

		struct s_shaderdatapathparam
		{
			c_static_string<256> path;
		};
		static_assert(sizeof(s_shaderdatapathparam) == 256, "struct s_shaderdatapathparam is invalid size");

		struct s_shadertag
		{
			s_anytag_struct_definition anytag;
			c_flags<e_shaderflags, long, k_shaderflags_count> flags;
			s_shaderdatapathparam maya_shader;
			char generated_pad09c1[4]; // padding
		};
		static_assert(sizeof(s_shadertag) == 280, "struct s_shadertag is invalid size");

		struct s_shadergroup
		{
			c_typed_tag_block<s_shaderreference> shaders_block;
			c_typed_tag_reference<SHADER_ROOT_SIGNATURE_TAG> root_signature;
			byte entrypoint_index;
			byte vertex_type;
			byte platform_marker;
			char generated_pad3c24[1]; // padding
			dword shader_reference_type_offsets;
			string_id entrypoint_name;
			char generated_pad5605[4]; // padding
			long long m_shaderpipeline;
		};
		static_assert(sizeof(s_shadergroup) == 52, "struct s_shadergroup is invalid size");

		struct s_shadervariant
		{
			s_anytag_struct_definition anytag;
			c_flags<e_shaderflags, long, k_shaderflags_count> flags;
			c_flags<e_shadercompileflags, long, k_shadercompileflags_count> compiler_flags;
			c_typed_tag_block<s_shadergroup> shader_groups_block;
			c_typed_tag_block<s_shaderparameter> material_parameters_block;
			s_tag_data parameter_binding_data;
			c_typed_tag_block<s_shadergpupropertyname> emitter_property_names_block;
			c_typed_tag_block<s_shadergpupropertyname> renderer_property_names_block;
			c_typed_tag_block<s_shadergpupropertyname> simulator_property_names_block;
			char generated_pad13ee[4]; // padding
			long long runtime_pointer;
			char pad[4]; // padding
			char generated_pad60a3[4]; // padding
		};
		static_assert(sizeof(s_shadervariant) == 124, "struct s_shadervariant is invalid size");

		struct s_shaderrootsignature
		{
			s_anytag_struct_definition anytag;
			s_tag_data rootsignaturedata;
			long long m_runtimepointer;
		};
		static_assert(sizeof(s_shaderrootsignature) == 44, "struct s_shaderrootsignature is invalid size");

		struct s_nodegraphcontentshadersubgraphcontenttag
		{
			s_nodegraphcontentnodegraphcontenttag nodegraph;
		};
		static_assert(sizeof(s_nodegraphcontentshadersubgraphcontenttag) == 68, "struct s_nodegraphcontentshadersubgraphcontenttag is invalid size");

		struct s_selfilluminationstate
		{

			/* Self-Illumination State */

			string_id name;
			c_flags<e_selfilluminationstatestateflag, long, k_selfilluminationstatestateflag_count> flags;
			real length_;
			string_id next_state_;
			s_scalarfunctionname intensity_;
			s_scalarfunctionname color_;
			s_scalarfunctionname activation_;
		};
		static_assert(sizeof(s_selfilluminationstate) == 76, "struct s_selfilluminationstate is invalid size");

		struct s_selfilluminationdefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_selfilluminationstate> states_block;
			char generated_pad01b6[4]; // padding
		};
		static_assert(sizeof(s_selfilluminationdefinition) == 32, "struct s_selfilluminationdefinition is invalid size");

		struct s_s_simulated_input_stick_definition
		{
			c_flags<e_s_simulated_input_stick_definitionstickflags, long, k_s_simulated_input_stick_definitionstickflags_count> flags;
			c_enum<e_e_simulated_input_direction, short> response_type;
			c_enum<e_e_simulated_input_mapping_type, short> mapping_type;
			real_bounds _angle;
			// custom mapping
			s_functiondefinition mapping;
			real duration;
			real inverse_duration;
			real inverse_random_length;
			real_bounds inverse_random_angle;
			real linear_zoom_penalty;
			real square_root_zoom_penalty;
		};
		static_assert(sizeof(s_s_simulated_input_stick_definition) == 64, "struct s_s_simulated_input_stick_definition is invalid size");

		struct s_s_simulated_input_definition
		{
			s_anytag_struct_definition anytag;

			/* Simulated Input (SI) */


			/* Impulse */


			/* Scalers */


			/* Screen Space angles */


			/* Move */

			s_s_simulated_input_stick_definition move$2;

			/* Look */

			s_s_simulated_input_stick_definition look$2;
		};
		static_assert(sizeof(s_s_simulated_input_definition) == 144, "struct s_s_simulated_input_definition is invalid size");

		struct s_s_suppressed_incident_definition
		{
			string_id incident_name;
			c_flags<e_c_suppressed_incident_flags, char, k_c_suppressed_incident_flags_count> suppression_type;
			char generated_padf3b1[3]; // padding
		};
		static_assert(sizeof(s_s_suppressed_incident_definition) == 8, "struct s_s_suppressed_incident_definition is invalid size");

		struct s_suppressedincidentgroupdefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_s_suppressed_incident_definition> suppressed_incidents_block;
			char generated_padadce[4]; // padding
		};
		static_assert(sizeof(s_suppressedincidentgroupdefinition) == 32, "struct s_suppressedincidentgroupdefinition is invalid size");

		struct s_s_simulation_single_domain_velocity_bumps_configuration
		{

			/* SINGLE DOMAIN VELOCITY BUMPS */

			c_flags<e_i343simulationmotioncorrectionvelocitybumpflags, char, k_i343simulationmotioncorrectionvelocitybumpflags_count> flags;
			char generated_padedec[3]; // padding
			real velocity_scale;
			real velocity_min;
			real velocity_max;

			/* Velocity Bump Suppression */

			real velocity_difference_ignore_threshold;
			real velocity_difference_absolute_ignore_threshold;
		};
		static_assert(sizeof(s_s_simulation_single_domain_velocity_bumps_configuration) == 24, "struct s_s_simulation_single_domain_velocity_bumps_configuration is invalid size");

		struct s_s_simulation_single_domain_blending_configuration
		{

			/* SINGLE DOMAIN BLENDING CONFIGURATION */

			real min_object_speed;
			real max_object_speed;
			real fraction_at_min_object_speed;
			real fraction_at_max_object_speed;
			real min_speed_at_min_object_speed;
			real min_speed_at_max_object_speed;
		};
		static_assert(sizeof(s_s_simulation_single_domain_blending_configuration) == 24, "struct s_s_simulation_single_domain_blending_configuration is invalid size");

		struct s_s_simulation_single_domain_interpolation_configuration
		{

			/* SINGLE DOMAIN INTERPOLATION */

			real discrepancy_threshold_above_which_we_use_blending;
			real coming_to_rest_speed;
			real coming_to_rest_maximum_ignorable_error;
			// custom velocity_bumps
			s_s_simulation_single_domain_velocity_bumps_configuration velocity_bumps;
			// custom value
			// custom blending
			s_s_simulation_single_domain_blending_configuration blending;
			// custom value
		};
		static_assert(sizeof(s_s_simulation_single_domain_interpolation_configuration) == 60, "struct s_s_simulation_single_domain_interpolation_configuration is invalid size");

		struct s_s_simulation_interpolation_definition
		{
			s_anytag_struct_definition anytag;

			/* SIMULATION INTERPOLATION */

			// custom high_level_settings
			real position_client_ignore_tolerance;
			real angular_speed_threshold_for_temporarily_ignoring_rotation_updates;
			// custom warp_thresholds

			/* WARP THRESHOLDS */

			real position_warp_threshold;
			real position_warp_threshold_xy;
			real rotation_warp_threshold;
			// custom value
			// custom value
			// custom position_while_controlled
			s_s_simulation_single_domain_interpolation_configuration position_while_controlled;
			// custom value
			// custom rotation_while_controlled
			s_s_simulation_single_domain_interpolation_configuration rotation_while_controlled;
			// custom value
			// custom position_while_not_controlled
			s_s_simulation_single_domain_interpolation_configuration position_while_uncontrolled;
			// custom value
			// custom rotation_while_not_controlled
			s_s_simulation_single_domain_interpolation_configuration rotation_while_uncontrolled;
			// custom value
			// custom ucn
			c_typed_tag_reference<UCN_AUTHORITY_TRUST_SETTINGS_TAG> authority_trust_settings;
			// custom value
		};
		static_assert(sizeof(s_s_simulation_interpolation_definition) == 292, "struct s_s_simulation_interpolation_definition is invalid size");

		struct s_lodlevelsettings
		{
			c_enum<e_simplygonsettingsenum, long> cascade_geometry;
			real override_triangle_reduction_ratio;
			real override_and_use_maxdeviation;
			c_enum<e_simplygonsettingsenum, long> allow_degenerate_texture_coordinates;
			c_enum<e_simplygondatacreationpreferenceenum, long> allow_simplygon_to_create_optimized_vertex_data;
			real outward_move_tolerance;
			real inward_move_tolerance;
			c_enum<e_simplygonsettingsenum, long> use_vertex_weighting;
			// custom reduction_importance

			/* Reduction importance weights */

			c_enum<e_simplygonimportanceenum, long> geometry_importance;
			c_enum<e_simplygonimportanceenum, long> texture_importance;
			c_enum<e_simplygonimportanceenum, long> material_importance;
			c_enum<e_simplygonimportanceenum, long> normal_importance;
			c_enum<e_simplygonimportanceenum, long> vertex_color_importance;
			c_enum<e_simplygonimportanceenum, long> curvature_importance;
			c_enum<e_simplygonimportanceenum, long> group_importance;
			c_enum<e_simplygonimportanceenum, long> edge_set_importance;
			c_enum<e_simplygonimportanceenum, long> skinning_importance;
			// custom value
			// custom symmetry_settings

			/* Symmetry settings */

			c_enum<e_simplygonsettingsenum, long> keep_symmetrical;
			c_enum<e_simplygonsettingsenum, long> automatic_axis_of_symmetry_detection;
			real symmetry_detection_tolerance;
			c_enum<e_simplygonsymmetryaxisenum, long> manual_symmetry_axis;
			real manual_symmetry_offset;
			c_enum<e_simplygonsettingsenum, long> use_symmetry_quad_re_triangulator;
			// custom value
			// custom normal_calculation
			c_enum<e_simplygonsettingsenum, long> replace_normals;
			c_enum<e_simplygonsettingsenum, long> replace_tangents;
			real hard_edge_angle;
			c_enum<e_simplygonsettingsenum, long> repair_invalid_normals;
			c_enum<e_simplygonsettingsenum, long> detect_primitive_normals;
			c_enum<e_simplygonsettingsenum, long> scale_by_area;
			c_enum<e_simplygonsettingsenum, long> scale_by_angle;
			// custom value
			long weld_and_t_junction_fixup_passes;
			// custom weld_settings
			c_enum<e_simplygonsettingsenum, long> weld_vertices;
			real weld_distance;
			c_enum<e_simplygonsettingsenum, long> weld_only_border_verts;
			c_enum<e_simplygonsettingsenum, long> weld_only_on_object_boundary;
			// custom value
			// custom t_junction_settings
			c_enum<e_simplygonsettingsenum, long> remove_t_junctions;
			real t_junction_removal_distance;
			// custom value
		};
		static_assert(sizeof(s_lodlevelsettings) == 148, "struct s_lodlevelsettings is invalid size");

		struct s_simplygonsettingstag
		{
			s_anytag_struct_definition anytag;
			c_enum<e_simplygonallowdirectxenum, long> allow_directx;
			c_typed_tag_block<s_lodlevelsettings> per_lod_settings_block;
		};
		static_assert(sizeof(s_simplygonsettingstag) == 32, "struct s_simplygonsettingstag is invalid size");

		struct s_soundincidentresponsedefinition
		{
			c_flags<e_c_sound_audience_flags, char, k_c_sound_audience_flags_count> audience;
			c_flags<e_c_sound_audience_flags, char, k_c_sound_audience_flags_count> excluded_audience;
			c_flags<e_c_sound_splitscreen_flags, char, k_c_sound_splitscreen_flags_count> split_screen_flags;
			char generated_padc0d1[1]; // padding
			c_typed_tag_reference<SOUND_RESPONSE_TAG> response;
		};
		static_assert(sizeof(s_soundincidentresponsedefinition) == 20, "struct s_soundincidentresponsedefinition is invalid size");

		struct s_soundincidentresponsegroupdefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_soundincidentresponsedefinition> responses_block;
			char generated_padb4ca[4]; // padding
		};
		static_assert(sizeof(s_soundincidentresponsegroupdefinition) == 32, "struct s_soundincidentresponsegroupdefinition is invalid size");

		struct s_s_scenario_interpolator_entry_definition
		{
			c_flags<e_interpolatorflags, long, k_interpolatorflags_count> flags;
			string_id name;
			s_scalarfunctionname function;
			real duration;
			c_enum<e_scenariointerpolatorresetvalueenum, long> map_reset_type;
			real custom_map_reset_value;
			c_enum<e_scenariointerpolatorstartvaluetypeenum, long> start_type;
			c_enum<e_scenariointerpolatorstopvaluetypeenum, long> stop_type;
			real custom_stop_value;
		};
		static_assert(sizeof(s_s_scenario_interpolator_entry_definition) == 52, "struct s_s_scenario_interpolator_entry_definition is invalid size");

		struct s_s_scenario_interpolator_tag_definition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_s_scenario_interpolator_entry_definition> interpolators_block;
			char generated_pad61c1[4]; // padding
		};
		static_assert(sizeof(s_s_scenario_interpolator_tag_definition) == 32, "struct s_s_scenario_interpolator_tag_definition is invalid size");

		struct s_skeletonuserparameter
		{
			string_id name;
			real initial_value;
		};
		static_assert(sizeof(s_skeletonuserparameter) == 8, "struct s_skeletonuserparameter is invalid size");

		struct s_skeletontagimporteddata
		{
			c_typed_tag_block<s_skeletonjoint> joints_block;
			c_typed_tag_block<s_skeletonuserparameter> user_parameters_block;
			long joint_checksum;
		};
		static_assert(sizeof(s_skeletontagimporteddata) == 28, "struct s_skeletontagimporteddata is invalid size");

		struct s_jointusage
		{
			string_id joint_name;
			c_enum<e_c_animation_node_usage, short> joint_usage_type;
			char generated_pade9c7[2]; // padding
		};
		static_assert(sizeof(s_jointusage) == 8, "struct s_jointusage is invalid size");

		struct s_jointnavmark
		{
			string_id joint_name;
		};
		static_assert(sizeof(s_jointnavmark) == 4, "struct s_jointnavmark is invalid size");

		struct s_detailjoint
		{
			string_id joint_name;
		};
		static_assert(sizeof(s_detailjoint) == 4, "struct s_detailjoint is invalid size");

		struct s_proceduraljoint
		{
			string_id joint_name;
			c_enum<e_proceduraljointprocedure, char> procedure;
			c_enum<e_proceduraljointprocedureaxis, char> procedure_axis;
			char generated_pad9cf3[2]; // padding
			string_id procedure_node_a;
			string_id procedure_node_b;
			real procedure_var_1;
			real procedure_var_2;
			real_euler_angles3d procedure_neutral_offset;
		};
		static_assert(sizeof(s_proceduraljoint) == 36, "struct s_proceduraljoint is invalid size");

		struct s_jointmaskname
		{
			string_id joint_name;
		};
		static_assert(sizeof(s_jointmaskname) == 4, "struct s_jointmaskname is invalid size");

		struct s_jointmask
		{
			string_id name;
			c_enum<e_jointmaskenum, char> mask_selection_behavior;
			char generated_padf204[3]; // padding
			string_id joint_selection_chain_start;
			c_typed_tag_block<s_jointmaskname> joint_selection_chain_ends_block;
			c_typed_tag_block<s_jointmaskname> explicit_joint_selections_block;
			short add_joints_from_other_mask;
			short remove_joints_from_other_mask;
		};
		static_assert(sizeof(s_jointmask) == 40, "struct s_jointmask is invalid size");

		struct s_filteredjoint
		{
			string_id joint_name;
		};
		static_assert(sizeof(s_filteredjoint) == 4, "struct s_filteredjoint is invalid size");

		struct s_skeletonikjunction
		{
			string_id name;
			string_id pivot_joint;
			real pull_passthrough;
		};
		static_assert(sizeof(s_skeletonikjunction) == 12, "struct s_skeletonikjunction is invalid size");

		struct s_skeletonikjoint
		{
			string_id joint;
			c_flags<e_animationikjointflags, short, k_animationikjointflags_count> flags;
			char generated_pada927[2]; // padding
		};
		static_assert(sizeof(s_skeletonikjoint) == 8, "struct s_skeletonikjoint is invalid size");

		struct s_skeletonikchain
		{
			string_id name;
			c_enum<e_c_animation_ik_chain_type, short> type;
			char generated_pad7620[2]; // padding
			string_id start_joint;
			string_id effector_joint;
			c_typed_tag_block<s_skeletonikjoint> special_joints_block;

			/* Pull settings */

			real pull_strength;
			real push_strength;
			real over_extent_pull_strength;
			real under_extent_push_strength;

			/* Effector Cone Limits */

			real effector_cone_limit_power;
			angle_bounds pitch_bounds;
			angle_bounds yaw_bounds;
			real_bounds offset_bounds;

			/* Spline settings */

			real spline_reversal_strength;
		};
		static_assert(sizeof(s_skeletonikchain) == 76, "struct s_skeletonikchain is invalid size");

		struct s_skeletoniklegdefinition
		{
			long ik_chain;
			real standing_compression_limit;
			real crouching_compression_limit;
			real_bounds foot_pitch_limits;
			real_bounds foot_yaw_limits;
		};
		static_assert(sizeof(s_skeletoniklegdefinition) == 28, "struct s_skeletoniklegdefinition is invalid size");

		struct s_skeletonikarmdefinition
		{
			long ik_chain;
			real wrist_break_threshold;
			string_id fixup_axis_marker;

			/* Advanced */

			real wrist_break_acceptable_min_angle;
		};
		static_assert(sizeof(s_skeletonikarmdefinition) == 16, "struct s_skeletonikarmdefinition is invalid size");

		struct s_skeletonikpoint
		{
			string_id name;
			string_id source_marker;
			c_enum<e_ikattachmenttargettype, long> attach_to;
			string_id destination_marker;
			real_vector3d pole_marker;
			long ik_chain_to_use;
			string_id weight_source_object_function;
			string_id priority_source_object_function;
		};
		static_assert(sizeof(s_skeletonikpoint) == 40, "struct s_skeletonikpoint is invalid size");

		struct s_skeletoniksetitem
		{
			short ik_point;
			c_enum<e_skeletoniksetitemenabledenum, char> point_usage_toggle;
			char generated_pad4862[1]; // padding
		};
		static_assert(sizeof(s_skeletoniksetitem) == 4, "struct s_skeletoniksetitem is invalid size");

		struct s_skeletonikset
		{
			string_id name;
			c_flags<e_iksetflags, long, k_iksetflags_count> flags;
			c_typed_tag_block<s_skeletoniksetitem> ik_points_block;
		};
		static_assert(sizeof(s_skeletonikset) == 20, "struct s_skeletonikset is invalid size");

		struct s_aclshellradiusoverridejoint
		{
			string_id name;
			real shell_radius;
		};
		static_assert(sizeof(s_aclshellradiusoverridejoint) == 8, "struct s_aclshellradiusoverridejoint is invalid size");

		struct s_skeletontag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_skeletontagimporteddata> imported_data_block;
			c_typed_tag_block<s_jointusage> joint_usage_block;
			c_typed_tag_block<s_jointnavmark> nav_joint_block;
			c_typed_tag_block<s_detailjoint> detail_joints_block;
			c_typed_tag_block<s_proceduraljoint> procedural_joints_block;
			c_typed_tag_block<s_jointmask> joint_masks_block;
			c_typed_tag_block<s_filteredjoint> joint_animation_filtering_block;
			// custom ik_settings

			/* IK Junctions */

			c_typed_tag_block<s_skeletonikjunction> ik_junctions_block;

			/* IK Chains */

			c_typed_tag_block<s_skeletonikchain> ik_chains_block;

			/* IK Leg Definitions */

			c_typed_tag_block<s_skeletoniklegdefinition> ik_leg_definitions_block;
			c_typed_tag_block<s_skeletonikarmdefinition> ik_arm_definitions_block;

			/* Points and Sets */

			c_typed_tag_block<s_skeletonikpoint> ik_point_block;
			c_typed_tag_block<s_skeletonikset> ik_sets_block;
			// custom value
			// custom acl_settings
			real error_threshold;
			real default_shell_radius;
			c_typed_tag_block<s_aclshellradiusoverridejoint> shell_radius_overrides_block;
			// custom value
		};
		static_assert(sizeof(s_skeletontag) == 192, "struct s_skeletontag is invalid size");

		struct s_skylighting
		{
			s_anytag_struct_definition anytag;
			// custom sky_lighting
			rgb_color sky_color;
			real sky_color_intensity;
			rgb_color ground_color;
			real ground_color_intensity;
			real horizon_angle;
			real horizon_width;
			real direction_1;
			real front_back_1;
			rgb_color color_1;
			real intensity_1;
			real width_1;
			real direction_2;
			real front_back_2;
			rgb_color color_2;
			real intensity_2;
			real width_2;
			real direction_3;
			real front_back_3;
			rgb_color color_3;
			real intensity_3;
			real width_3;
			char generated_pad0693[4]; // padding
		};
		static_assert(sizeof(s_skylighting) == 144, "struct s_skylighting is invalid size");

		struct s_i343supplylinesmarinesquaddefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_interfaceuiiteminfo> ui_display_info_block;
			c_typed_tag_reference<SQUADSPECIFICATIONTAG_TAG> squad_specification;
		};
		static_assert(sizeof(s_i343supplylinesmarinesquaddefinition) == 44, "struct s_i343supplylinesmarinesquaddefinition is invalid size");

		struct s_scenariolightingvolumes
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_visualenvvolume> visual_environment_volumes_block;
			char generated_pad02e3[4]; // padding
		};
		static_assert(sizeof(s_scenariolightingvolumes) == 32, "struct s_scenariolightingvolumes is invalid size");

		struct s_i343effectssoundmaterialeffectsblock
		{
			c_typed_tag_block<s_s_material_effect_material> sounds_block;
		};
		static_assert(sizeof(s_i343effectssoundmaterialeffectsblock) == 12, "struct s_i343effectssoundmaterialeffectsblock is invalid size");

		struct s_i343effectssoundmaterialeffectsdefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343effectssoundmaterialeffectsblock> effects_block;
			char generated_pad3224[4]; // padding
		};
		static_assert(sizeof(s_i343effectssoundmaterialeffectsdefinition) == 32, "struct s_i343effectssoundmaterialeffectsdefinition is invalid size");

		struct s_structurefxplacementmarker
		{
			c_static_string<32> marker_name;
			real_quaternion rotation;
			real_point3d position;
			s_tag_reference optional_attached_effect;
		};
		static_assert(sizeof(s_structurefxplacementmarker) == 76, "struct s_structurefxplacementmarker is invalid size");

		struct s_structuremetadatalightconemarker
		{
			c_static_string<32> marker_name;
			real_quaternion rotation;
			real_point3d position;
			real length;
			real width;
			real intensity;
			argb_color light_color;
			c_typed_tag_reference<LIGHT_CONE_TAG> light_cone_tag;
		};
		static_assert(sizeof(s_structuremetadatalightconemarker) == 104, "struct s_structuremetadatalightconemarker is invalid size");

		struct s_structure_environment_object_palette_entry
		{
			c_typed_tag_reference<OBJECT_TAG> definition;
			c_typed_tag_reference<RENDER_MODEL_TAG> model;
			long gveyn;
		};
		static_assert(sizeof(s_structure_environment_object_palette_entry) == 36, "struct s_structure_environment_object_palette_entry is invalid size");

		struct s_structure_environment_object
		{
			c_static_string<32> name;
			real_quaternion rotation;
			real_point3d translation;
			real scale;
			short palette_index;
			c_flags<e_structure_environment_objectenvironmentobjectscriptflags, char, k_structure_environment_objectenvironmentobjectscriptflags_count> flags;
			char generated_pad238b[1]; // padding
			long unique_id;
			tag exported_object_type;
			string_id scenario_object_name;
			string_id variant_name;
		};
		static_assert(sizeof(s_structure_environment_object) == 84, "struct s_structure_environment_object is invalid size");

		struct s_structuremetadata
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_structurefxplacementmarker> effects_markers_block;
			c_typed_tag_block<s_structuremetadatalightconemarker> light_cones_block;
			c_typed_tag_block<s_structure_environment_object_palette_entry> object_palette_block;
			c_typed_tag_block<s_structure_environment_object> objects_block;
		};
		static_assert(sizeof(s_structuremetadata) == 64, "struct s_structuremetadata is invalid size");

		struct s_acousticstagzonevoxeldatalod
		{
			qword x_dimension;
			qword y_dimension;
			qword z_dimension;
			qword bsp_start_offset_x;
			qword bsp_start_offset_y;
			qword bsp_start_offset_z;
			qword bsp_size_x;
			qword bsp_size_y;
			qword bsp_size_z;
			s_tag_data voxel_data;
		};
		static_assert(sizeof(s_acousticstagzonevoxeldatalod) == 92, "struct s_acousticstagzonevoxeldatalod is invalid size");

		struct s_acousticstagzonedata
		{
			long guid;
			c_typed_tag_block<s_acousticstagzonevoxeldatalod> lods_block;
		};
		static_assert(sizeof(s_acousticstagzonedata) == 16, "struct s_acousticstagzonedata is invalid size");

		struct s_acousticstagportaldata
		{
			long guid;
			long generated_front_zone;
			long generated_back_zone;
			s_tag_data shape_data;
		};
		static_assert(sizeof(s_acousticstagportaldata) == 32, "struct s_acousticstagportaldata is invalid size");

		struct s_acousticstagdata
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_acousticstagzonedata> voxel_data_block;
			c_typed_tag_block<s_acousticstagportaldata> shape_data_block;
		};
		static_assert(sizeof(s_acousticstagdata) == 40, "struct s_acousticstagdata is invalid size");

		struct s_narrativereferenceinfo
		{
			c_static_string<32> character_name;
			c_static_string<256> dialogue;
			c_static_string<32> wwise_effect;
			c_static_string<32> narrative_wwise_effect_recommendation;
			c_enum<e_sounddimensions, long> wwise_2d_3d;
			c_enum<e_sounddimensions, long> narrative_2d_3d_recommendation;
			real wwise_attenuation;
		};
		static_assert(sizeof(s_narrativereferenceinfo) == 364, "struct s_narrativereferenceinfo is invalid size");

		struct s_aidialogueeventinfo
		{
			c_flags<e_speecheventinfoflag, long, k_speecheventinfoflag_count> flags;
			real skip_fraction;
			c_static_string<256> dialogue_state_table_skip_rule;
			c_typed_tag_block<s_dialoguestatetableexpressiontoken> dst_expression_tokens_block;
		};
		static_assert(sizeof(s_aidialogueeventinfo) == 276, "struct s_aidialogueeventinfo is invalid size");

		struct s_s_facial_animation_language
		{
			s_tag_resource facial_animation_resource;
			s_tag_resource model_animation_resource;
			c_enum<e_e_language, long> language;
		};
		static_assert(sizeof(s_s_facial_animation_language) == 20, "struct s_s_facial_animation_language is invalid size");

		struct s_soundvoeventinfo
		{
			string_id event_name;
			string_id subtitle_name;
			string_id subtitle_character_id;
			real event_duration;
			c_typed_tag_block<s_narrativereferenceinfo> narrative_reference_block;
			c_typed_tag_block<s_aidialogueeventinfo> ai_dialogue_info_block;
			c_typed_tag_block<s_s_facial_animation_language> facial_animation_resource_languages_block;
		};
		static_assert(sizeof(s_soundvoeventinfo) == 52, "struct s_soundvoeventinfo is invalid size");

		struct s_oneshotsoundtag
		{
			s_anytag_struct_definition anytag;
			c_flags<e_oneshotsoundtagflag, long, k_oneshotsoundtagflag_count> flags;
			string_id sfx_event_name;
			string_id sfx_player_event_name;
			real max_radius;
			real max_duration;
			c_typed_tag_reference<SOUNDBANK_TAG> sound_bank;
			c_typed_tag_reference<SOUNDBANK_TAG> player_sound_bank;
			c_typed_tag_reference<SOUND_CATEGORY_TAG> category;
			c_typed_tag_reference<SOUND_CATEGORY_TAG> player_category;
			c_typed_tag_reference<SOUND_TAIL_TAG> sound_tails;
			string_id external_source;
			c_typed_tag_block<s_soundvoeventinfo> vo_event_info_block;
			c_enum<e_i343playeraiportglowcolor, char> ai_port_glow_color;
			char generated_padf447[3]; // padding
			c_typed_tag_reference<STRINGLIST_TAG> unicode_subtitles_tag;
		};
		static_assert(sizeof(s_oneshotsoundtag) == 152, "struct s_oneshotsoundtag is invalid size");

		struct s_impulsetimerparams
		{
			c_flags<e_impulsetimerparamflags, char, k_impulsetimerparamflags_count> impulse_timer_flags;
			char generated_pad854c[3]; // padding
			real hold;
			real decay;
			real minthreshold;
			real distthreshold;
		};
		static_assert(sizeof(s_impulsetimerparams) == 20, "struct s_impulsetimerparams is invalid size");

		struct s_focustagstruct
		{
			real focus_inner_radius;
			real focus_outer_radius;
			real focus_inner_cone_angle;
			real focus_outer_cone_angle;
			real focus_elevation_scale;
		};
		static_assert(sizeof(s_focustagstruct) == 20, "struct s_focustagstruct is invalid size");

		struct s_clustersettings
		{
			real cluster_distance;
			real cluster_smoothing_speed;
			real cluster_timeout;
		};
		static_assert(sizeof(s_clustersettings) == 12, "struct s_clustersettings is invalid size");

		struct s_soundcategorytag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<SOUND_CATEGORY_TAG> parent;
			c_flags<e_soundcategorytagflags, long, k_soundcategorytagflags_count> flags;
			real dont_play_time_seconds;
			s_impulsetimerparams audio_impulse_timer_settings;
			real sound_transmissivity;
			real obstructionocclusionbias;
			real obstructionocclusionscaling;
			s_focustagstruct focus_settings;
			s_clustersettings cluster_settings;
			real sphere_radius;
			real sphere_stretch_value;
			long max_placement_looping_sounds;
		};
		static_assert(sizeof(s_soundcategorytag) == 116, "struct s_soundcategorytag is invalid size");

		struct s_s_sound_reverb_settings
		{

			/* WWise Environment */

			string_id environment_name;
			c_enum<e_esoundclassacoustictypeenum, long> weapon_environment;
		};
		static_assert(sizeof(s_s_sound_reverb_settings) == 8, "struct s_s_sound_reverb_settings is invalid size");

		struct s_sound_environment
		{
			s_anytag_struct_definition anytag;
			c_enum<e_sound_environmentenvironmenttypesenum, char> type;
			char generated_pad0fb7[3]; // padding

			/* Reverb Settings */

			s_s_sound_reverb_settings reverb_settings$2;
			c_typed_tag_reference<SOUNDBANK_TAG> sound_bank;
		};
		static_assert(sizeof(s_sound_environment) == 44, "struct s_sound_environment is invalid size");

		struct s_soundbankrefblockdefinition
		{
			c_typed_tag_reference<SOUNDBANK_TAG> sound_bank;
		};
		static_assert(sizeof(s_soundbankrefblockdefinition) == 16, "struct s_soundbankrefblockdefinition is invalid size");

		struct s_streampackblockdefinition
		{
			c_flags<e_streampackblockdefinitionstreampackblockflags, long, k_streampackblockdefinitionstreampackblockflags_count> flags;
			c_static_string<32> streaming_pck_file;
		};
		static_assert(sizeof(s_streampackblockdefinition) == 36, "struct s_streampackblockdefinition is invalid size");

		struct s_i343soundvehiclesurfacesounddata
		{
			string_id rtpc_name;
			real sweetener_threshold;
		};
		static_assert(sizeof(s_i343soundvehiclesurfacesounddata) == 8, "struct s_i343soundvehiclesurfacesounddata is invalid size");

		struct s_audiogameacousticsqualitypresettagstruct
		{
			c_flags<e_audiogameacousticsqualitypresettagstructflag, char, k_audiogameacousticsqualitypresettagstructflag_count> audio_flags;
			char generated_pad5f57[3]; // padding
			long acoustics_flood_fill_num_string_pull_iterations;
			real acoustics_flood_fill_num_string_pull_iteration_scale;
			long acoustics_num_parallel_source_updates;
			real acoustics_lod_distance_multiplier;
			long max_listener_count_to_enable_voxel_obstruction;
			long number_of_serial_acoustic_propagation_jobs;
		};
		static_assert(sizeof(s_audiogameacousticsqualitypresettagstruct) == 28, "struct s_audiogameacousticsqualitypresettagstruct is invalid size");

		struct s_audioqualitypresettagstruct
		{
			// custom acoustics
			s_audiogameacousticsqualitypresettagstruct acoustics;
			// custom value
		};
		static_assert(sizeof(s_audioqualitypresettagstruct) == 28, "struct s_audioqualitypresettagstruct is invalid size");

		struct s_audioqualitypresetstagstruct
		{
			// custom xboxone
			s_audioqualitypresettagstruct xboxone;
			// custom value
			// custom scarlett
			s_audioqualitypresettagstruct scarlett;
			// custom value
			// custom pc
			s_audioqualitypresettagstruct pc;
			// custom value
		};
		static_assert(sizeof(s_audioqualitypresetstagstruct) == 84, "struct s_audioqualitypresetstagstruct is invalid size");

		struct s_audiogameglobalsettingstag
		{
			s_anytag_struct_definition anytag;
			string_id initial_zone_set_preload_event_name;
			string_id level_unloaded_event_name;
			string_id game_preload_event_name;
			c_typed_tag_reference<SOUNDBANK_TAG> init_sound_bank;
			c_typed_tag_block<s_soundbankrefblockdefinition> global_sound_banks_block;
			c_typed_tag_block<s_soundbankrefblockdefinition> extra_sound_banks_block;
			c_typed_tag_block<s_soundbankrefblockdefinition> campaign_sound_banks_block;
			c_typed_tag_block<s_soundbankrefblockdefinition> multiplayer_sound_banks_block;
			c_typed_tag_block<s_streampackblockdefinition> streaming_pack_files_block;
			c_typed_tag_block<s_streampackblockdefinition> excluded_streaming_pack_files_block;
			real radio_for_voice_radius;
			c_typed_tag_block<s_i343soundvehiclesurfacesounddata> vehicle_surface_sound_info_block;
			c_typed_tag_reference<FORGESOUNDLISTDEFINITION_TAG> forge_sound_events;
			real acoustic_zone_transition_speed;
			c_typed_tag_reference<SOUND_CATEGORY_TAG> root_sound_category_reference;
			real camera_to_biped_listener_position_blend;
			real camera_to_biped_listener_orientation_blend;
			real listener_to_locked_z_axis_orientation_blend;
			real milliseconds_between_focus_rtpc_update;
			// custom quality_presets
			s_audioqualitypresetstagstruct quality_presets;
			// custom value
		};
		static_assert(sizeof(s_audiogameglobalsettingstag) == 268, "struct s_audiogameglobalsettingstag is invalid size");

		struct s_i343objectsregionpermutationdefinition
		{
			string_id region_name;
			string_id permutation_name;
		};
		static_assert(sizeof(s_i343objectsregionpermutationdefinition) == 8, "struct s_i343objectsregionpermutationdefinition is invalid size");

		struct s_i343objectsattachedobjectdefinition
		{
			c_typed_tag_reference<OBJECT_TAG> object;
			c_typed_tag_reference<RENDER_MODEL_TAG> first_person_render_model;
			c_typed_tag_reference<MODEL_ANIMATION_GRAPH_TAG> first_person_model_animation_graph;

			/* FIRST PERSON ASSETS */

			s_tag_reference first_person_asset;
			s_tag_reference first_person_animation_asset;
			string_id variant_name;
			long parent_override;
			string_id default_parent_marker;
			string_id default_attachment_marker;
			string_id secondary_parent_marker;
			string_id secondary_attachment_marker;
			string_id parent_damage_transfer_section;
			c_flags<e_i343objectsattachedobjectflags, char, k_i343objectsattachedobjectflags_count> flags;
			c_enum<e_i343objectsattachedobjectvisibilitybehavior, char> visibility_behavior;
			c_enum<e_i343objectsattachedobjectfirstpersonvisibilitybehavior, char> first_person_visibility_behavior;
			char generated_padf323[1]; // padding
		};
		static_assert(sizeof(s_i343objectsattachedobjectdefinition) == 112, "struct s_i343objectsattachedobjectdefinition is invalid size");

		struct s_i343objectsframeattachmentdefinition
		{
			s_anytag_struct_definition anytag;
			string_id name;
			string_id type;

			/* NOTE */

			string_id malleable_property_id;
			c_typed_tag_block<s_i343objectsregionpermutationdefinition> region_permutations_block;
			c_typed_tag_block<s_object_attachment_definition> attachments_block;
			c_typed_tag_block<s_i343objectsattachedobjectdefinition> attached_objects_block;

			/* NOTE */

			c_typed_tag_reference<GENERICMODIFIERDEFINITIONTAG_TAG> modifiers;
			c_typed_tag_reference<SOUND_TAG> input_slot_change_sound;
			s_tag_reference implementation;
			c_typed_tag_reference<ANYTAG_TAG> metadata_tag;
			c_typed_tag_block<s_interfaceuiiteminfo> ui_display_info_block;
			string_id swapper_menu_activation_stringid_override;
			c_flags<e_i343objectsframeattachmentflags, char, k_i343objectsframeattachmentflags_count> flags;
			char generated_pad3276[3]; // padding
			// custom object_dropping
			c_typed_tag_reference<OBJECT_TAG> object_to_spawn_when_removed;
			real energy_per_spawned_object;
			// custom value
			char generated_pad7f2b[4]; // padding
		};
		static_assert(sizeof(s_i343objectsframeattachmentdefinition) == 172, "struct s_i343objectsframeattachmentdefinition is invalid size");

		struct s_i343objectsframelimitentry
		{
			string_id type;
			byte max;
			c_flags<e_i343objectsframelimitentryflags, char, k_i343objectsframelimitentryflags_count> flags;
			char generated_pad2c79[2]; // padding
		};
		static_assert(sizeof(s_i343objectsframelimitentry) == 8, "struct s_i343objectsframelimitentry is invalid size");

		struct s_i343objectsframeattachmententry
		{
			c_typed_tag_reference<FRAMEATTACHMENTDEFINITION_TAG> frame_attachment;
			c_enum<e_i343objectsframeattachmentset, char> set;
			c_enum<e_i343objectsframeattachmentinitialinputslot, char> initial_input_slot;
			char generated_pad5209[2]; // padding
		};
		static_assert(sizeof(s_i343objectsframeattachmententry) == 20, "struct s_i343objectsframeattachmententry is invalid size");

		struct s_i343objectsframedefinition
		{
			s_anytag_struct_definition anytag;
			string_id name;
			c_typed_tag_block<s_i343objectsframelimitentry> limits_block;
			c_typed_tag_block<s_i343objectsframeattachmententry> frame_attachments_block;
			c_typed_tag_block<s_interfaceuiiteminfo> ui_display_info_block;
			c_enum<e_interfacenavpointespritesequence, long> nav_point_sequence_index;
			char generated_pad0c49[4]; // padding
		};
		static_assert(sizeof(s_i343objectsframedefinition) == 64, "struct s_i343objectsframedefinition is invalid size");

		struct s_i343spartanabilitiesspartanabilitycomponentdefinition
		{
			s_anytag_struct_definition anytag;
			// custom activation_energy_cost_scalar
			s_i343malleablepropertybasefloatstructdefinition activation_energy_cost_scalar;
			c_typed_tag_reference<EFFECT_TAG> ability_activation_failure_effect;
			c_typed_tag_reference<EFFECT_TAG> overheat_effect;
			c_typed_tag_reference<EFFECT_TAG> cooldown_effect;
			real energy_bar_row;
			real energy_bar_column;
			real_fraction energy_bar_warning_pct;
			c_typed_tag_reference<EVADEDEFINITIONTAG_TAG> evade_ref;
			c_typed_tag_reference<GRAPPLEHOOKDEFINITIONTAG_TAG> grapple_hook_ref;
			c_typed_tag_reference<SPRINTDEFINITIONTAG_TAG> sprint_ref;
		};
		static_assert(sizeof(s_i343spartanabilitiesspartanabilitycomponentdefinition) == 136, "struct s_i343spartanabilitiesspartanabilitycomponentdefinition is invalid size");

		struct s_i343supplylinessupplylinessystemglobalsdefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<VEHICLE_TAG> drop_ship;
			string_id drop_ship_nav_marker_type;
			string_id drop_ship_nav_marker_sub_type;
			argb_color drop_ship_nav_marker_color;
			c_typed_tag_reference<CHARACTER_TAG> pilot;
			real vehicle_drop_height;
			char generated_pad479b[4]; // padding
		};
		static_assert(sizeof(s_i343supplylinessupplylinessystemglobalsdefinition) == 80, "struct s_i343supplylinessupplylinessystemglobalsdefinition is invalid size");

		struct s_i343spartantrackingglobals
		{
			s_anytag_struct_definition anytag;
			// custom sorting

			/* value */

			real distance_weight;
			real blended_weight;
			real fov_weight;
			// custom value
			c_typed_tag_reference<SPARTANTRACKINGPINGDEFINITION_TAG> active_ping;
			c_typed_tag_reference<SPARTANTRACKINGPINGDEFINITION_TAG> passive_ping;
			c_typed_tag_reference<SPARTANTRACKINGPINGDEFINITION_TAG> custom_ping;
		};
		static_assert(sizeof(s_i343spartantrackingglobals) == 76, "struct s_i343spartantrackingglobals is invalid size");

		struct s_i343spartantrackingdefaultrangeparam
		{
			real default_range;
		};
		static_assert(sizeof(s_i343spartantrackingdefaultrangeparam) == 4, "struct s_i343spartantrackingdefaultrangeparam is invalid size");

		struct s_i343spartantrackingdisplaymaximumsparam
		{
			byte maximum_number_of_tracked_objects_displayed;
		};
		static_assert(sizeof(s_i343spartantrackingdisplaymaximumsparam) == 1, "struct s_i343spartantrackingdisplaymaximumsparam is invalid size");

		struct s_i343spartantrackingpingdefinition
		{
			s_anytag_struct_definition anytag;
			string_id ping_group;
			real ping_display_time;

			/* Per Priority Default Ranges */

			c_typed_tag_block<s_i343spartantrackingdefaultrangeparam> default_range_per_priority_block;

			/* Per Priority Tracking Limits */

			c_typed_tag_block<s_i343spartantrackingdisplaymaximumsparam> max_tracked_per_priority_block;
			// custom active_ping_properties

			/* The following fields only apply to active tracking. */

			c_typed_tag_reference<EFFECT_TAG> ping_effect;
			real ping_travel_rate;
			// custom value
			// custom outline_properties
			c_typed_tag_reference<OUTLINETYPEDEFINITION_TAG> outline_type;
			c_enum<e_i343outlineservicesystemid, char> outline_system_id;
			char generated_pada560[3]; // padding
			// custom value
			// custom target_marking
			angle _angle;
			real distancefactor;
			real anglefactor;
			// custom value
			char generated_padbf41[4]; // padding
		};
		static_assert(sizeof(s_i343spartantrackingpingdefinition) == 104, "struct s_i343spartantrackingpingdefinition is invalid size");

		struct s_i343aisquadconstructionvehiclecellentry
		{
			c_typed_tag_reference<VEHICLE_TAG> vehicle_definition;
			c_typed_tag_reference<VEHICLECONFIGURATION_TAG> vehicle_configuration;
			c_typed_tag_block<s_i343aisquadconstructionpassengercellentry> passenger_list_block;
			c_flags<e_i343vehicleencountervehicleflags, char, k_i343vehicleencountervehicleflags_count> encounter_vehicle_flags;
			char generated_pad35c6[3]; // padding
		};
		static_assert(sizeof(s_i343aisquadconstructionvehiclecellentry) == 48, "struct s_i343aisquadconstructionvehiclecellentry is invalid size");

		struct s_i343aisquadconstructionsquadintensityentry
		{
			string_id name;
			c_typed_tag_block<s_i343aisquadconstructionactorcellentry> actor_list_block;
			c_typed_tag_block<s_i343aisquadconstructionvehiclecellentry> vehicle_list_block;
		};
		static_assert(sizeof(s_i343aisquadconstructionsquadintensityentry) == 28, "struct s_i343aisquadconstructionsquadintensityentry is invalid size");

		struct s_i343aisquadconstructionsquadspecification
		{
			s_anytag_struct_definition anytag;
			string_id name;
			c_typed_tag_block<s_i343aisquadconstructionactorcellentry> actor_list_block;
			c_typed_tag_block<s_i343aisquadconstructionvehiclecellentry> vehicle_list_block;
			c_typed_tag_block<s_i343aisquadconstructionsquadintensityentry> squad_intensity_list_block;
		};
		static_assert(sizeof(s_i343aisquadconstructionsquadspecification) == 56, "struct s_i343aisquadconstructionsquadspecification is invalid size");

		struct s_aicharacterchoiceweakref
		{
			s_s_ai_spawn_conditions place_on;
			c_typed_tag_reference<CHARACTER_TAG> character_type;
			short chance;
			char generated_padf39f[2]; // padding
		};
		static_assert(sizeof(s_aicharacterchoiceweakref) == 24, "struct s_aicharacterchoiceweakref is invalid size");

		struct s_aiweaponchoiceweakref
		{
			s_s_ai_spawn_conditions place_on;
			c_typed_tag_reference<WEAPON_TAG> weapon_type;
			short chance;
			char generated_pad39d2[2]; // padding
		};
		static_assert(sizeof(s_aiweaponchoiceweakref) == 24, "struct s_aiweaponchoiceweakref is invalid size");

		struct s_aiequipmentchoiceweakref
		{
			s_s_ai_spawn_conditions place_on;
			c_typed_tag_reference<EQUIPMENT_TAG> equipment_type;
			short chance;
			char generated_pad84ac[2]; // padding
		};
		static_assert(sizeof(s_aiequipmentchoiceweakref) == 24, "struct s_aiequipmentchoiceweakref is invalid size");

		struct s_s_cell_template_definition
		{
			string_id name;
			s_s_ai_spawn_conditions place_on;
			short normal_diff_count;
			c_enum<e_squadmajorupgradetype, short> major_upgrade;

			/* Character Build */

			c_typed_tag_block<s_aicharacterchoiceweakref> character_type_block;
			c_typed_tag_block<s_aiweaponchoiceweakref> initial_weapon_block;
			c_typed_tag_block<s_aiweaponchoiceweakref> initial_secondary_weapon_block;
			c_typed_tag_block<s_aiequipmentchoiceweakref> initial_equipment_block;
			c_enum<e_unitgrenadetype, char> grenade_type;
			char generated_padf847[3]; // padding
			c_typed_tag_reference<VEHICLE_TAG> vehicle_type;
			string_id vehicle_variant;
			string_id activity_name;
		};
		static_assert(sizeof(s_s_cell_template_definition) == 88, "struct s_s_cell_template_definition is invalid size");

		struct s_s_squad_template_definition
		{
			s_anytag_struct_definition anytag;
			string_id name;
			c_typed_tag_block<s_s_cell_template_definition> cell_templates_block;
		};
		static_assert(sizeof(s_s_squad_template_definition) == 32, "struct s_s_squad_template_definition is invalid size");

		struct s_scenariorenderdata
		{
			s_anytag_struct_definition anytag;
			short dynamic_analytic_gobo_texture_slots;
			c_flags<e_scenariorenderdataflags, short, k_scenariorenderdataflags_count> flags;
			short volumetric_clouds_dws_sun_index;
			short atmospheric_scattering_dws_sun_index;
			short dws_sun_lens_flare_index;
			short max_gobo_resolution;
			c_enum<e_gobobitdepth, char> gobo_bit_depth;
			c_enum<e_singlepasslightingmode, char> single_pass_lighting_mode;
			c_enum<e_shadowrenderingmode, char> shadow_rendering_mode;
			c_flags<e_enablenoncachedshadowsflag, char, k_enablenoncachedshadowsflag_count> enable_shadows_for_uncached_lights;
		};
		static_assert(sizeof(s_scenariorenderdata) == 32, "struct s_scenariorenderdata is invalid size");

		struct s_spawningweightfunctionparam
		{
			s_scalarfunctionname function;
		};
		static_assert(sizeof(s_spawningweightfunctionparam) == 20, "struct s_spawningweightfunctionparam is invalid size");

		struct s_spawningsphereinfluencerregion
		{
			c_flags<e_spawninginfluencerregionbehaviorflags, long, k_spawninginfluencerregionbehaviorflags_count> flags;
			real radius;
			real weight;
			c_typed_tag_block<s_spawningweightfunctionparam> weight_function_block;
		};
		static_assert(sizeof(s_spawningsphereinfluencerregion) == 24, "struct s_spawningsphereinfluencerregion is invalid size");

		struct s_spawningboxinfluencerregion
		{
			c_flags<e_spawninginfluencerregionbehaviorflags, long, k_spawninginfluencerregionbehaviorflags_count> flags;
			real width;
			real length;
			real height;
			real weight;
		};
		static_assert(sizeof(s_spawningboxinfluencerregion) == 20, "struct s_spawningboxinfluencerregion is invalid size");

		struct s_spawningcylinderinfluencerregion
		{
			c_flags<e_spawninginfluencerregionbehaviorflags, long, k_spawninginfluencerregionbehaviorflags_count> flags;
			real radius;
			real height;
			real weight;
			c_typed_tag_block<s_spawningweightfunctionparam> weight_function_block;
		};
		static_assert(sizeof(s_spawningcylinderinfluencerregion) == 28, "struct s_spawningcylinderinfluencerregion is invalid size");

		struct s_spawningconeinfluencerregion
		{
			c_flags<e_spawninginfluencerregionbehaviorflags, long, k_spawninginfluencerregionbehaviorflags_count> flags;
			real length;
			real base_radius;
			real weight;
			c_typed_tag_block<s_spawningweightfunctionparam> weight_function_block;
		};
		static_assert(sizeof(s_spawningconeinfluencerregion) == 28, "struct s_spawningconeinfluencerregion is invalid size");

		struct s_spawninginfluencerregion
		{
			c_typed_tag_block<s_spawningsphereinfluencerregion> sphere_block;
			c_typed_tag_block<s_spawningboxinfluencerregion> box_block;
			c_typed_tag_block<s_spawningcylinderinfluencerregion> cylinder_block;
			c_typed_tag_block<s_spawningconeinfluencerregion> cone_block;
		};
		static_assert(sizeof(s_spawninginfluencerregion) == 48, "struct s_spawninginfluencerregion is invalid size");

		struct s_spawningpillinfluencerregion
		{
			c_flags<e_spawninginfluencerregionbehaviorflags, long, k_spawninginfluencerregionbehaviorflags_count> flags;
			real length;
			real radius;
			real weight;
			c_typed_tag_block<s_spawningweightfunctionparam> weight_function_block;
		};
		static_assert(sizeof(s_spawningpillinfluencerregion) == 28, "struct s_spawningpillinfluencerregion is invalid size");

		struct s_spawningmovinginfluencerregion
		{
			real lead_time;
			c_typed_tag_block<s_spawningconeinfluencerregion> cone_block;
			c_typed_tag_block<s_spawningpillinfluencerregion> pill_block;
		};
		static_assert(sizeof(s_spawningmovinginfluencerregion) == 28, "struct s_spawningmovinginfluencerregion is invalid size");

		struct s_spawningunitinfluencerdefinition
		{
			c_flags<e_spawningunitinfluencerfilterflags, long, k_spawningunitinfluencerfilterflags_count> filter_flags;
			c_flags<e_spawninginfluencerdispositionflags, long, k_spawninginfluencerdispositionflags_count> allowed_dispositions;
			c_typed_tag_block<s_spawninginfluencerregion> influencer_block;
			c_typed_tag_block<s_spawningmovinginfluencerregion> movement_influencer_block;
		};
		static_assert(sizeof(s_spawningunitinfluencerdefinition) == 32, "struct s_spawningunitinfluencerdefinition is invalid size");

		struct s_spawningunitonlyinfluencerdefinition
		{
			c_flags<e_spawningunitonlyinfluencerflags, long, k_spawningunitonlyinfluencerflags_count> flags;
			s_spawningunitinfluencerdefinition unit_influencer;
		};
		static_assert(sizeof(s_spawningunitonlyinfluencerdefinition) == 36, "struct s_spawningunitonlyinfluencerdefinition is invalid size");

		struct s_spawningunitinfluencerparam
		{
			s_spawningunitinfluencerdefinition unit_influencer;
		};
		static_assert(sizeof(s_spawningunitinfluencerparam) == 32, "struct s_spawningunitinfluencerparam is invalid size");

		struct s_spawningweaponinfluencerdefinition
		{
			c_typed_tag_reference<WEAPON_TAG> weapon;
			c_typed_tag_block<s_spawningunitinfluencerparam> unit_influencer_block;
			real location_unseen_multiplier;
		};
		static_assert(sizeof(s_spawningweaponinfluencerdefinition) == 32, "struct s_spawningweaponinfluencerdefinition is invalid size");

		struct s_spawningvehicleinfluencerdefinition
		{
			c_typed_tag_reference<VEHICLE_TAG> vehicle;
			c_typed_tag_block<s_spawningunitinfluencerparam> unit_influencer_block;
		};
		static_assert(sizeof(s_spawningvehicleinfluencerdefinition) == 28, "struct s_spawningvehicleinfluencerdefinition is invalid size");

		struct s_spawningprojectileinfluencerdefinition
		{
			c_typed_tag_reference<PROJECTILE_TAG> projectile;
			c_typed_tag_block<s_spawninginfluencerregion> influencer_block;
			c_typed_tag_block<s_spawningmovinginfluencerregion> movement_influencer_block;
		};
		static_assert(sizeof(s_spawningprojectileinfluencerdefinition) == 40, "struct s_spawningprojectileinfluencerdefinition is invalid size");

		struct s_spawningequipmentinfluencerdefinition
		{
			c_typed_tag_reference<EQUIPMENT_TAG> equipment;
			c_typed_tag_block<s_spawninginfluencerregion> influencer_block;
		};
		static_assert(sizeof(s_spawningequipmentinfluencerdefinition) == 28, "struct s_spawningequipmentinfluencerdefinition is invalid size");

		struct s_spawningobjectdispenserinfluencerdefinition
		{
			c_flags<e_i343objectdispenserobjectdispenserinfluencerfilterflags, char, k_i343objectdispenserobjectdispenserinfluencerfilterflags_count> filter_flags;
			char generated_pad3f4d[3]; // padding
			c_typed_tag_block<s_spawninginfluencerregion> influencer_block;
		};
		static_assert(sizeof(s_spawningobjectdispenserinfluencerdefinition) == 16, "struct s_spawningobjectdispenserinfluencerdefinition is invalid size");

		struct s_spawningspawnsettingstaggroup
		{
			s_anytag_struct_definition anytag;
			real minimum_spawn_time;

			/* Unseen spawning settings */

			real hostile_visibility_cone_length;
			real friendly_visibility_cone_length;
			real visibility_cone_angle;
			real spawn_point_can_see_hostile_cone_length;
			real spawn_point_can_see_friendly_cone_length;

			/* Spawn weight settings */

			real quantization_step;

			/* Unit Influencers */

			c_typed_tag_block<s_spawningunitonlyinfluencerdefinition> unit_influencers_block;

			/* Dead Unit Influencers */

			real active_duration;
			c_typed_tag_block<s_spawningunitinfluencerparam> dead_unit_influencers_block;

			/* Spawning Unit Influencers */

			c_typed_tag_block<s_spawningunitinfluencerparam> spawning_unit_influencers_block;

			/* Weapon Influencers */

			c_typed_tag_block<s_spawningweaponinfluencerdefinition> weapon_influencers_block;

			/* Vehicle Influencers */

			c_typed_tag_block<s_spawningvehicleinfluencerdefinition> vehicle_influencers_block;

			/* Projectile Influencers */

			c_typed_tag_block<s_spawningprojectileinfluencerdefinition> projectile_influencers_block;

			/* Equipment Influencers */

			c_typed_tag_block<s_spawningequipmentinfluencerdefinition> equipment_influencers_block;

			/* Object Dispenser Influencers */

			c_typed_tag_block<s_spawningobjectdispenserinfluencerdefinition> object_dispenser_influencers_block;
		};
		static_assert(sizeof(s_spawningspawnsettingstaggroup) == 144, "struct s_spawningspawnsettingstaggroup is invalid size");

		struct s_i343spottingglobalsdefinition
		{
			s_anytag_struct_definition anytag;
			long traces_per_update;
			real trace_subdivision_length;
			real max_distance;
			angle fov;
		};
		static_assert(sizeof(s_i343spottingglobalsdefinition) == 32, "struct s_i343spottingglobalsdefinition is invalid size");

		struct s_i343graphicssssprofile
		{
			string_id name;

			/* Subsurface Layer */

			rgb_color subsurface_layer_weight;
			real subsurface_layer_scale;

			/* Shallow Layer */

			rgb_color shallow_layer_weight;
			real shallow_layer_scale;

			/* Middle Layer */

			rgb_color middle_layer_weight;
			real middle_layer_scale;

			/* Deep Layer */

			rgb_color deep_layer_weight;
			real deep_layer_scale;
			real post_scatter_amount;
			rgb_color ao_color;
			real ao_color_amount;
			real ao_specular_power;
			real glancing_roughness;
			real specular_intensity;

			/* Scale Modifiers */

			real scale_modifier_subsurface_and_shallow_layers;
			real scale_modifier_middle_and_deep_layers;
		};
		static_assert(sizeof(s_i343graphicssssprofile) == 108, "struct s_i343graphicssssprofile is invalid size");

		struct s_i343graphicssssprofileglobals
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343graphicssssprofile> scattering_profiles_block;
			char generated_pad7610[4]; // padding
		};
		static_assert(sizeof(s_i343graphicssssprofileglobals) == 32, "struct s_i343graphicssssprofileglobals is invalid size");

		struct s_soundscenarioconstantstagsoundbankloadinfoblock
		{
			c_typed_tag_reference<SOUNDBANK_TAG> sound_bank;
		};
		static_assert(sizeof(s_soundscenarioconstantstagsoundbankloadinfoblock) == 16, "struct s_soundscenarioconstantstagsoundbankloadinfoblock is invalid size");

		struct s_soundscenarioconstantstag
		{
			s_anytag_struct_definition anytag;
			c_flags<e_soundscenarioconstantstagflags, long, k_soundscenarioconstantstagflags_count> flags;
			c_typed_tag_block<s_soundscenarioconstantstagsoundbankloadinfoblock> scenario_sound_bank_list_block;
			long sound_permutation_mission_id;
			char generated_pad89d2[4]; // padding
		};
		static_assert(sizeof(s_soundscenarioconstantstag) == 40, "struct s_soundscenarioconstantstag is invalid size");

		struct s_i343aisquadconstructionsquadspecificationreference
		{
			c_typed_tag_reference<SQUADSPECIFICATIONTAG_TAG> squad_specification;
		};
		static_assert(sizeof(s_i343aisquadconstructionsquadspecificationreference) == 16, "struct s_i343aisquadconstructionsquadspecificationreference is invalid size");

		struct s_i343aisquadconstructionsquadspecificationtree
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343aisquadconstructionsquadspecificationreference> squad_specification_list_block;
			char generated_padddc7[4]; // padding
		};
		static_assert(sizeof(s_i343aisquadconstructionsquadspecificationtree) == 32, "struct s_i343aisquadconstructionsquadspecificationtree is invalid size");

		struct s_soundtailperroom
		{
			s_tag_reference tail_sound;
		};
		static_assert(sizeof(s_soundtailperroom) == 16, "struct s_soundtailperroom is invalid size");

		struct s_soundtailtag
		{
			s_anytag_struct_definition anytag;
			s_soundtailperroom tail[10];
		};
		static_assert(sizeof(s_soundtailtag) == 176, "struct s_soundtailtag is invalid size");

		struct s_indirectlightproberegion
		{
			string_id name;
			real_point3d position_bounds_0;
			real_point3d position_bounds_1;
			long probe_count_x;
			long probe_count_y;
			long probe_count_z;
			long priority;
			real blend_radius_xy;
			real blend_radius_z;
			long irradiance_bitmap_start_index;
			long vsm_bitmap_index;
			long z_offset_bitmap_index;
			real z_spacing_for_z_offsets;
			s_tag_data z_offset_cpu_data;
		};
		static_assert(sizeof(s_indirectlightproberegion) == 88, "struct s_indirectlightproberegion is invalid size");

		struct s_structurelightmap
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_indirectlightproberegion> probe_regions_block;
			c_typed_tag_reference<BITMAP_TAG> probe_bitmaps;
			long number_of_baked_tod_states;
			c_typed_tag_block<s_structurelightdefinition> runtime_lights_block;
			short floating_sun_index;
			char generated_pad9145[2]; // padding
			s_tag_resource baked_dws_irradiance_data;
			char generated_pad7764[4]; // padding
		};
		static_assert(sizeof(s_structurelightmap) == 76, "struct s_structurelightmap is invalid size");

		struct s_structurelights
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_structurelightdefinition> generic_light_definitions_block;
			long lastlightid;
		};
		static_assert(sizeof(s_structurelights) == 32, "struct s_structurelights is invalid size");

		struct s_s_structure_manifest_bsp_definition
		{
			s_s_structure_manifest_build_identifier_definition build_identifer;
			s_s_structure_manifest_build_identifier_definition parent_build_identifer;
			c_static_string<256> bsp_name;
		};
		static_assert(sizeof(s_s_structure_manifest_bsp_definition) == 304, "struct s_s_structure_manifest_bsp_definition is invalid size");

		struct s_s_structure_manifest_definition
		{

			/* build identifer */

			s_s_structure_manifest_build_identifier_definition build_identifer$2;

			/* parent build identifier */

			s_s_structure_manifest_build_identifier_definition parent_build_identifer;
			c_typed_tag_block<s_s_structure_manifest_bsp_definition> bsp_manifest_block;
		};
		static_assert(sizeof(s_s_structure_manifest_definition) == 60, "struct s_s_structure_manifest_definition is invalid size");

		struct s_structureseamoriginalvertexplanenormals
		{
			real_vector3d triangle_normal;
		};
		static_assert(sizeof(s_structureseamoriginalvertexplanenormals) == 12, "struct s_structureseamoriginalvertexplanenormals is invalid size");

		struct s_s_structure_seam_original_vertex
		{
			real_point3d original_vertex;
			long final_point_index;
			c_typed_tag_block<s_structureseamoriginalvertexplanenormals> plane_normals_block;
		};
		static_assert(sizeof(s_s_structure_seam_original_vertex) == 28, "struct s_s_structure_seam_original_vertex is invalid size");

		struct s_s_structure_seam_original_geometry
		{
			c_typed_tag_block<s_s_structure_seam_original_vertex> original_vertices_block;
		};
		static_assert(sizeof(s_s_structure_seam_original_geometry) == 12, "struct s_s_structure_seam_original_geometry is invalid size");

		struct s_structureseamfinalplanesparam
		{
			real_plane3d plane;
		};
		static_assert(sizeof(s_structureseamfinalplanesparam) == 16, "struct s_structureseamfinalplanesparam is invalid size");

		struct s_structureseamfinalpointsparam
		{
			real_point3d final_point;
		};
		static_assert(sizeof(s_structureseamfinalpointsparam) == 12, "struct s_structureseamfinalpointsparam is invalid size");

		struct s_s_structure_seam_final_triangle
		{
			long final_plane;
			short final_point0;
			short final_point1;
			short final_point2;
			char generated_pad4b3a[2]; // padding
		};
		static_assert(sizeof(s_s_structure_seam_final_triangle) == 12, "struct s_s_structure_seam_final_triangle is invalid size");

		struct s_s_structure_seam_final_edge
		{
			short final_point0;
			short final_point1;
		};
		static_assert(sizeof(s_s_structure_seam_final_edge) == 4, "struct s_s_structure_seam_final_edge is invalid size");

		struct s_s_structure_seam_final_geometry
		{
			c_typed_tag_block<s_structureseamfinalplanesparam> planes_block;
			c_typed_tag_block<s_structureseamfinalpointsparam> points_block;
			c_typed_tag_block<s_s_structure_seam_final_triangle> triangles_block;
			c_typed_tag_block<s_s_structure_seam_final_edge> edges_block;
		};
		static_assert(sizeof(s_s_structure_seam_final_geometry) == 48, "struct s_s_structure_seam_final_geometry is invalid size");

		struct s_s_structure_seam
		{
			s_s_structure_seam_identifier identifier;
			s_s_structure_seam_original_geometry original;
			s_s_structure_seam_final_geometry _final;
		};
		static_assert(sizeof(s_s_structure_seam) == 76, "struct s_s_structure_seam is invalid size");

		struct s_s_structure_seams
		{
			s_anytag_struct_definition anytag;
			s_s_structure_manifest_definition structure_manifest;

			/* This tag defines the geometry between seam connected structures bsp. */

			long version;
			c_typed_tag_block<s_error_report_category> errors_block;
			c_typed_tag_block<s_s_structure_seam> seams_block;
			c_typed_tag_block<s_s_havok_mopp_code_definition> seam_triangle_mopp_code_block;
			char generated_padf765[4]; // padding
		};
		static_assert(sizeof(s_s_structure_seams) == 120, "struct s_s_structure_seams is invalid size");

		struct s_special_movement_definition
		{
			c_flags<e_specialmovementflags, long, k_specialmovementflags_count> special_movement_1;
		};
		static_assert(sizeof(s_special_movement_definition) == 4, "struct s_special_movement_definition is invalid size");

		struct s_style_behavior_name
		{
			c_static_string<32> behavior_name;
		};
		static_assert(sizeof(s_style_behavior_name) == 32, "struct s_style_behavior_name is invalid size");

		struct s_style_definition
		{
			s_anytag_struct_definition anytag;
			c_static_string<32> name;

			/* Combat status decay options */

			c_enum<e_stylecombatstatusdecay, short> combat_status_decay_options$2;
			char generated_padeb23[2]; // padding

			/* Style Behavior Control */

			c_flags<e_stylecontrolflags, long, k_stylecontrolflags_count> style_control;
			c_flags<e_behaviorflagsset1, long, k_behaviorflagsset1_count> behaviors1;
			c_flags<e_behaviorflagsset2, long, k_behaviorflagsset2_count> behaviors2;
			c_flags<e_behaviorflagsset3, long, k_behaviorflagsset3_count> behaviors3;
			c_flags<e_behaviorflagsset4, long, k_behaviorflagsset4_count> behaviors4;
			c_flags<e_behaviorflagsset5, long, k_behaviorflagsset5_count> behaviors5;
			c_flags<e_behaviorflagsset6, long, k_behaviorflagsset6_count> behaviors6;
			c_flags<e_behaviorflagsset7, long, k_behaviorflagsset7_count> behaviors7;
			c_flags<e_behaviorflagsset8, long, k_behaviorflagsset8_count> behaviors8;
			c_flags<e_behaviorflagsset9, long, k_behaviorflagsset9_count> behaviors9;
			c_flags<e_behaviorflagsset10, long, k_behaviorflagsset10_count> behaviors10;
			c_flags<e_behaviorflagsset11, long, k_behaviorflagsset11_count> behaviors11;
			c_flags<e_behaviorflagsset12, long, k_behaviorflagsset12_count> behaviors12;
			c_flags<e_behaviorflagsset13, long, k_behaviorflagsset13_count> behaviors13;
			c_flags<e_behaviorflagsset14, long, k_behaviorflagsset14_count> behaviors14;
			c_flags<e_behaviorflagsset15, long, k_behaviorflagsset15_count> behaviors15;
			c_flags<e_behaviorflagsset16, long, k_behaviorflagsset16_count> behaviors16;
			c_typed_tag_block<s_special_movement_definition> special_movement_block;
			c_typed_tag_block<s_style_behavior_name> behavior_list_block;
		};
		static_assert(sizeof(s_style_definition) == 144, "struct s_style_definition is invalid size");

		struct s_subtracksdefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_composersubtrack> subtracks_block;
			char generated_pad99a5[4]; // padding
		};
		static_assert(sizeof(s_subtracksdefinition) == 32, "struct s_subtracksdefinition is invalid size");

		struct s_i343objectsshieldupgrademetadata
		{
			s_anytag_struct_definition anytag;

			/* SHIELD UPGRADE METADATA */

			long upgrade_level;
			char generated_paddc67[4]; // padding
		};
		static_assert(sizeof(s_i343objectsshieldupgrademetadata) == 24, "struct s_i343objectsshieldupgrademetadata is invalid size");

		struct s_interfaceslamsurientrydefinition
		{
			string_id uri;
			s_tag_reference screen_reference;
		};
		static_assert(sizeof(s_interfaceslamsurientrydefinition) == 20, "struct s_interfaceslamsurientrydefinition is invalid size");

		struct s_interfaceslamsurilookuptabledefinition
		{
			s_anytag_struct_definition anytag;
			s_tag_reference root_screen_reference;
			c_typed_tag_block<s_interfaceslamsurientrydefinition> uri_entries_block;
		};
		static_assert(sizeof(s_interfaceslamsurilookuptabledefinition) == 44, "struct s_interfaceslamsurilookuptabledefinition is invalid size");

		struct s_svgreaderpointer
		{
			long long svg_source_bytes_pointer;
			qword svg_source_bytes_length;
			c_static_string<256> filename;
		};
		static_assert(sizeof(s_svgreaderpointer) == 272, "struct s_svgreaderpointer is invalid size");

		struct s_svgsourcefiletag
		{
			s_anytag_struct_definition anytag;
			s_svgreaderpointer reader;
			c_typed_tag_reference<VECTORART_TAG> generatedvectorarttag;
			char generated_padbd9b[4]; // padding
		};
		static_assert(sizeof(s_svgsourcefiletag) == 308, "struct s_svgsourcefiletag is invalid size");

		struct s_switchableasset
		{
			s_tag_reference reference;
		};
		static_assert(sizeof(s_switchableasset) == 16, "struct s_switchableasset is invalid size");

		struct s_switchableassetset
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_switchableasset> asset_references_block;
			char generated_pad2d9e[4]; // padding
		};
		static_assert(sizeof(s_switchableassetset) == 32, "struct s_switchableassetset is invalid size");

		struct s_taggraphtag
		{
			s_nodegraphcontentnodegraphcontenttag nodegraph;
		};
		static_assert(sizeof(s_taggraphtag) == 68, "struct s_taggraphtag is invalid size");

		struct s_i343physicsterraincollisioncellgeotag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_serializedhavokgeometry> serialized_havok_geometry_block;
			char generated_paddcaa[4]; // padding
		};
		static_assert(sizeof(s_i343physicsterraincollisioncellgeotag) == 32, "struct s_i343physicsterraincollisioncellgeotag is invalid size");

		struct s_i343physicsterraincollisiongeoparams
		{
			s_anytag_struct_definition anytag;
			c_flags<e_i343physicscollisiongeometryoptimizerflags, char, k_i343physicscollisiongeometryoptimizerflags_count> flags;
			char generated_pad7b4e[3]; // padding
			real max_distance;
			real max_shrink;
			char generated_padc803[4]; // padding
		};
		static_assert(sizeof(s_i343physicsterraincollisiongeoparams) == 32, "struct s_i343physicsterraincollisiongeoparams is invalid size");

		struct s_i343physicsterraincollisiongeocellinputs
		{
			real_vector3d size;
			s_tag_data pixels;
			s_tag_data materials;
		};
		static_assert(sizeof(s_i343physicsterraincollisiongeocellinputs) == 52, "struct s_i343physicsterraincollisiongeocellinputs is invalid size");

		struct s_i343physicsterraincollisiongeocellinputstag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343physicsterraincollisiongeocellinputs> cell_inputs_block;
			char generated_pade11b[4]; // padding
		};
		static_assert(sizeof(s_i343physicsterraincollisiongeocellinputstag) == 32, "struct s_i343physicsterraincollisiongeocellinputstag is invalid size");

		struct s_i343physicsterraincollisiongeoinputsentry
		{
			c_typed_tag_reference<TERRAIN_GEO_INPUTS_TAG> cell_input;
		};
		static_assert(sizeof(s_i343physicsterraincollisiongeoinputsentry) == 16, "struct s_i343physicsterraincollisiongeoinputsentry is invalid size");

		struct s_i343physicsterraincollisiongeoinputssettag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<BITMAP_TAG> bitmap;
			c_typed_tag_reference<RUNTIME_TERRAIN_TAG> terrainruntime;
			c_typed_tag_reference<TERRAIN_COLLISION_CGO_PARAMS_TAG> optimizationparams;
			c_typed_tag_block<s_i343physicsterraincollisiongeoentry> cell_outputs_block;
			c_typed_tag_block<s_i343physicsterraincollisiongeocellinputs> input_cache_block;
			c_typed_tag_block<s_i343physicsterraincollisiongeoinputsentry> cell_inputs_block;
		};
		static_assert(sizeof(s_i343physicsterraincollisiongeoinputssettag) == 100, "struct s_i343physicsterraincollisiongeoinputssettag is invalid size");

		struct s_i343graphicstexturegroupsettings
		{
			string_id name;
			string_id editor_group;

			/* Mips to Drop */

			s_s_basic_spec_control_setting_int mip_settings;

			/* Required Resolution */

			s_s_basic_spec_control_setting_int required_resolution_settings;
		};
		static_assert(sizeof(s_i343graphicstexturegroupsettings) == 72, "struct s_i343graphicstexturegroupsettings is invalid size");

		struct s_i343graphicstexturegrouptable
		{
			s_anytag_struct_definition anytag;
			c_flags<e_i343graphicstexturegroupflags, short, k_i343graphicstexturegroupflags_count> options;
			char generated_pada88a[2]; // padding

			/* TEXTURE GROUPS */

			c_typed_tag_block<s_i343graphicstexturegroupsettings> settings_block;
		};
		static_assert(sizeof(s_i343graphicstexturegrouptable) == 32, "struct s_i343graphicstexturegrouptable is invalid size");

		struct s_nodegraphcontentstaterulesgraphcontenttag
		{
			s_nodegraphcontentnodegraphcontenttag nodegraph;
		};
		static_assert(sizeof(s_nodegraphcontentstaterulesgraphcontenttag) == 68, "struct s_nodegraphcontentstaterulesgraphcontenttag is invalid size");

		struct s_tifsourcefiletag
		{
			s_anytag_struct_definition anytag;
			long long width;
			long long height;
			long format;
			char generated_pad09ba[4]; // padding
			long long rowpitch;
			long long slicepitch;
			long long pixels;
			s_tag_data pixel_data;
		};
		static_assert(sizeof(s_tifsourcefiletag) == 84, "struct s_tifsourcefiletag is invalid size");

		struct s_nodegraphcontenttransitionlogicgraphcontenttag
		{
			s_nodegraphcontentnodegraphcontenttag nodegraph;
		};
		static_assert(sizeof(s_nodegraphcontenttransitionlogicgraphcontenttag) == 68, "struct s_nodegraphcontenttransitionlogicgraphcontenttag is invalid size");

		struct s_transitionlogicgraphtag
		{
			s_exportedanimnodegraph xanimnodegraph;
		};
		static_assert(sizeof(s_transitionlogicgraphtag) == 732, "struct s_transitionlogicgraphtag is invalid size");

		struct s_i343aitokensystemthreattokencharacterlimit
		{
			c_enum<e_actortype, short> character_type;
			short max_character_instances;
		};
		static_assert(sizeof(s_i343aitokensystemthreattokencharacterlimit) == 4, "struct s_i343aitokensystemthreattokencharacterlimit is invalid size");

		struct s_i343aitokensystemthreattokendefinition
		{

			/* Threat Token Tuning Globals */

			angle aiming_angle;

			/* Threat Score Modifiers */

			short aiming_score_modifier;
			short recently_damaged_score_modifier;
			real recently_damaged_duration;
			short has_clear_los_score_modifier;
			short player_close_to_enemy_score_modifier;
			short close_player_distance;
			short player_within_combat_range_of_enemy_score_modifier;
			short hasnt_acquired_token_in_a_while_score_modifier;
			short hasnt_acquired_token_in_a_while_time;
			short recently_acquired_token_score_modifier;
			short recently_acquired_token_time;
			short fully_effective_score_modifier;
			short character_type_limit_modifier;

			/* Threat Token Character Limits */

			c_typed_tag_block<s_i343aitokensystemthreattokencharacterlimit> character_limits_block;
		};
		static_assert(sizeof(s_i343aitokensystemthreattokendefinition) == 44, "struct s_i343aitokensystemthreattokendefinition is invalid size");

		struct s_i343aitokensystemgrenadetokendefinition
		{
			c_flags<e_i343aitokensystemgrenadetokenflags, char, k_i343aitokensystemgrenadetokenflags_count> flags;
			char generated_pad7795[1]; // padding
			short hasnt_thrown_a_grenade_recently_score_modifier;
			real hasnt_thrown_a_grenade_recently_time;
			short has_no_ranged_weapon_score_modifier;
			short recently_damaged_score_modifier;
			real recently_damaged_duration;
			short high_priority_behavior_score_modifier;
			char generated_pad5db4[2]; // padding
		};
		static_assert(sizeof(s_i343aitokensystemgrenadetokendefinition) == 20, "struct s_i343aitokensystemgrenadetokendefinition is invalid size");

		struct s_i343aitokensystemtokensystemglobalsdefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343aitokensystemthreattokendefinition> threat_token_globals_block;
			c_typed_tag_block<s_i343aitokensystemgrenadetokendefinition> grenade_token_globals_block;
			// custom effectiveness_token_globals
			// custom scoring_criteria

			/* value */

			real recently_damaged_duration;
			angle player_aiming_angle;
			real close_player_distance;
			real recently_acquired_duration;
			real aimed_at_transition_time;
			// custom value
			// custom score_modifiers

			/* value */

			short recently_damaged_score_modifier;
			short player_aiming_at_score_modifier;
			short close_player_score_modifier;
			short in_combat_range_score_modifier;
			short recently_acquired_score_modifier;
			short player_within_ez_score_modifier;
			short first_character_type_score_modifier;
			short has_clear_los_score_modifier;
			// custom value
			// custom override_parameters

			/* value */

			real recently_acquired_override_time;
			short score_override_threshold;
			short holding_score_override_threshold;
			real proximity_override_distance;
			// custom value
			// custom effectivity_modifiers

			/* value */

			real damage_modifier;
			real burst_error_modifier;
			real burst_error_bonus;
			real burst_duration_modifier;
			real burst_radius_modifier;
			real grenade_miss_distance;
			real accuracy_time_modifier;
			// custom value
			// custom value
			char generated_pada628[4]; // padding
		};
		static_assert(sizeof(s_i343aitokensystemtokensystemglobalsdefinition) == 120, "struct s_i343aitokensystemtokensystemglobalsdefinition is invalid size");

		struct s_tracerpropertyscalar
		{
			c_enum<e_tracerstatesinputenum, char> input_variable;
			c_enum<e_tracerstatesinputenum, char> range_variable;
			c_enum<e_editablepropertybaseoutputmodifier, char> output_modifier;
			c_enum<e_tracerstatesinputenum, char> output_modifier_input;
			// custom mapping
			s_functiondefinition mapping;
			real runtime_m_constant_value;
			word runtime_m_flags;
			char pad[2]; // padding
		};
		static_assert(sizeof(s_tracerpropertyscalar) == 32, "struct s_tracerpropertyscalar is invalid size");

		struct s_tracerpropertyrealvector3d
		{
			c_enum<e_tracerstatesinputenum, char> input_variable;
			c_enum<e_tracerstatesinputenum, char> range_variable;
			c_enum<e_editablepropertybaseoutputmodifier, char> output_modifier;
			c_enum<e_tracerstatesinputenum, char> output_modifier_input;
			// custom mapping
			s_functiondefinition mapping;
			real runtime_m_constant_value;
			word runtime_m_flags;
			char pad[2]; // padding
			real_vector3d starting_interpolant;
			real_vector3d ending_interpolant;
		};
		static_assert(sizeof(s_tracerpropertyrealvector3d) == 56, "struct s_tracerpropertyrealvector3d is invalid size");

		struct s_tracerpropertyrealpoint2d
		{
			c_enum<e_tracerstatesinputenum, char> input_variable;
			c_enum<e_tracerstatesinputenum, char> range_variable;
			c_enum<e_editablepropertybaseoutputmodifier, char> output_modifier;
			c_enum<e_tracerstatesinputenum, char> output_modifier_input;
			// custom mapping
			s_functiondefinition mapping;
			real runtime_m_constant_value;
			word runtime_m_flags;
			char pad[2]; // padding
			real_vector2d starting_interpolant;
			real_vector2d ending_interpolant;
		};
		static_assert(sizeof(s_tracerpropertyrealpoint2d) == 48, "struct s_tracerpropertyrealpoint2d is invalid size");

		struct s_tracerpropertycolor
		{
			c_enum<e_tracerstatesinputenum, char> input_variable;
			c_enum<e_tracerstatesinputenum, char> range_variable;
			c_enum<e_editablepropertybaseoutputmodifier, char> output_modifier;
			c_enum<e_tracerstatesinputenum, char> output_modifier_input;
			// custom mapping
			s_functiondefinition mapping;
			real runtime_m_constant_value;
			word runtime_m_flags;
			char pad[2]; // padding
		};
		static_assert(sizeof(s_tracerpropertycolor) == 32, "struct s_tracerpropertycolor is invalid size");

		struct s_tracerdefinition
		{
			// custom value
			string_id tracer_name;
			c_flags<e_tracerdefinitiontracerflags, char, k_tracerdefinitiontracerflags_count> flags;
			// custom tracer_shape
			c_enum<e_tracerdefinitionprofileshape, char> profile_shape;
			byte number_of_n_gon_sides;
			char generated_pad54fe[1]; // padding
			real origin_fade_range;
			real origin_fade_cutoff;
			real edge_fade_range;
			real edge_fade_cutoff;
			s_tracerpropertyscalar profile_lifespan;
			s_tracerpropertyrealvector3d profile_self_acceleration;
			s_tracerpropertyscalar length;
			s_tracerpropertyscalar offset;
			s_tracerpropertyscalar profile_size;
			s_tracerpropertyscalar profile_density;
			s_tracerpropertyrealpoint2d profile_offset;
			s_tracerpropertyscalar profile_rotation;
			// custom value
			// custom tracer_appearance
			c_flags<e_tracerdefinitionappearanceflags, short, k_tracerdefinitionappearanceflags_count> appearance_flags;
			short sort_bias;
			// custom material
			// custom value
			s_material actual_material;
			// custom value
			real_vector2d uv_tiling;
			real_vector2d uv_scrolling;
			c_enum<e_i343effectscoloroverridemode, char> profile_color_override_mode;
			char generated_pada1b3[3]; // padding
			s_tracerpropertycolor profile_color;
			s_tracerpropertyscalar profile_alpha;
			s_tracerpropertyscalar profile_alpha2;
			s_tracerpropertyscalar profile_black_point;
			s_tracerpropertyscalar profile_palette;
			s_tracerpropertyscalar profile_intensity;
			// custom value
			// custom value
			dword runtime_m_constantperprofileproperties;
			dword runtime_m_usedstates;
			dword runtime_m_maxprofilecount;
			s_gpupropertyfunctioncolor runtime_m_gpudata;
			char generated_padee68[4]; // padding
			long long m_pipelinestate;
		};
		static_assert(sizeof(s_tracerdefinition) == 668, "struct s_tracerdefinition is invalid size");

		struct s_tracersystemdefinition
		{
			s_anytag_struct_definition anytag;
			c_flags<e_tracersystemdefinitiontracersystemflags, long, k_tracersystemdefinitiontracersystemflags_count> tracer_system_flags;
			real_bounds camera_distance_range_override;
			c_typed_tag_block<s_tracerdefinition> tracers_block;
		};
		static_assert(sizeof(s_tracersystemdefinition) == 40, "struct s_tracersystemdefinition is invalid size");

		struct s_cameratrackdefinition
		{
			s_anytag_struct_definition anytag;
			s_cameratrack track;
			char generated_pad56d9[4]; // padding
		};
		static_assert(sizeof(s_cameratrackdefinition) == 48, "struct s_cameratrackdefinition is invalid size");

		struct s_i343physicsterraincollisiongeoresource
		{
			s_tag_resource terraincollisiongeodata_resource;
		};
		static_assert(sizeof(s_i343physicsterraincollisiongeoresource) == 8, "struct s_i343physicsterraincollisiongeoresource is invalid size");

		struct s_i343physicsterraincollisiongeotag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343physicsterraincollisiongeoresource> terrain_collision_geometry_block;
			char generated_pad85ae[4]; // padding
		};
		static_assert(sizeof(s_i343physicsterraincollisiongeotag) == 32, "struct s_i343physicsterraincollisiongeotag is invalid size");

		struct s_i343effectstrackdecalsystemdefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<DECAL_SYSTEM_TAG> decal_system;
			// custom distance_between_vertices
			real min_distance;
			real max_distance;
			real distance_velocity_scale;
			// custom value
			// custom velocity_based_offset
			real max_offset;
			real offset_velocity_scale;
			// custom value
			// custom contact_patch
			real contact_patch_width;
			real contact_patch_length;
			// custom value
			real texture_u_repeat_length;
			char generated_padfea3[4]; // padding
		};
		static_assert(sizeof(s_i343effectstrackdecalsystemdefinition) == 68, "struct s_i343effectstrackdecalsystemdefinition is invalid size");

		struct s_i343terraininputstag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343terrainplacement> placement_block;
			c_typed_tag_block<s_i343curvesplineplacement> splines_block;
			c_typed_tag_block<s_i343terrainvolume> terrain_volumes_block;
			char generated_pad0b59[4]; // padding
		};
		static_assert(sizeof(s_i343terraininputstag) == 56, "struct s_i343terraininputstag is invalid size");

		struct s_i343terraintilereference
		{
			c_typed_tag_reference<TERRAIN_TILE_TAG> tile;
		};
		static_assert(sizeof(s_i343terraintilereference) == 16, "struct s_i343terraintilereference is invalid size");

		struct s_i343terraintexturesettings
		{
			string_id surface_id;
			dword texel_density;
			c_flags<e_i343terraintexturesettingsflags, long, k_i343terraintexturesettingsflags_count> flags;
		};
		static_assert(sizeof(s_i343terraintexturesettings) == 12, "struct s_i343terraintexturesettings is invalid size");

		struct s_i343terrainsystemtag
		{
			s_anytag_struct_definition anytag;
			c_static_string<256> name;
			real_vector3d position;
			real_vector2d terrain_size;
			real terrain_height;
			dword tile_x_count;
			dword tile_y_count;
			c_typed_tag_block<s_i343terraintilereference> tiles_block;
			c_typed_tag_block<s_i343graphicsrendergraphparameterdefinitionb> shared_parameters_block;
			c_typed_tag_block<s_i343terraintexturesettings> source_texture_settings_block;
			c_typed_tag_block<s_i343terraintexturesettings> intermediate_texture_settings_block;
			c_typed_tag_reference<RENDERGRAPH_TAG> sculpt_graph;
			c_typed_tag_reference<SURFACINGGRAPH_TAG> gpu_surfacing_graph;
			c_typed_tag_reference<MATERIAL_TAG> render_material;
			c_typed_tag_reference<MATERIAL_TAG> masks_composite_material;
			real macro_color_near_distance;
			real macro_color_far_distance;
			real macro_color_near_opacity;
			real macro_color_far_opacity;
			s_s_basic_spec_control_setting_float micro_height_vertex_density;
			s_s_basic_spec_control_setting_float micro_height_radius;
			s_s_basic_spec_control_setting_int micro_height_mip_level;
			real micro_height_scale;
			c_flags<e_i343terrainflags, long, k_i343terrainflags_count> flags;
		};
		static_assert(sizeof(s_i343terrainsystemtag) == 536, "struct s_i343terrainsystemtag is invalid size");

		struct s_interfacecustomizationuitransitionsound
		{
			string_id display_name;
			c_typed_tag_reference<SOUND_TAG> sound;
			real transition_sound_time;
		};
		static_assert(sizeof(s_interfacecustomizationuitransitionsound) == 24, "struct s_interfacecustomizationuitransitionsound is invalid size");

		struct s_interfacecustomizationuitransitionsoundstag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_interfacecustomizationuitransitionsound> transition_sounds_block;
			char generated_pade975[4]; // padding
		};
		static_assert(sizeof(s_interfacecustomizationuitransitionsoundstag) == 32, "struct s_interfacecustomizationuitransitionsoundstag is invalid size");

		struct s_i343terraintiletag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<TERRAIN_SYSTEM_TAG> terrain_system;
			dword tile_x_index;
			dword tile_y_index;
			c_typed_tag_block<s_i343graphicsrendergraphparameterdefinitionb> parameters_block;
		};
		static_assert(sizeof(s_i343terraintiletag) == 52, "struct s_i343terraintiletag is invalid size");

		struct s_i343terrainseedruntime
		{
			c_typed_tag_reference<RUNTIME_TERRAIN_TAG> runtime_terrain;
		};
		static_assert(sizeof(s_i343terrainseedruntime) == 16, "struct s_i343terrainseedruntime is invalid size");

		struct s_i343terrainseedformoduletag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<LEVEL_TAG> source_level;
			c_typed_tag_block<s_i343terrainseedruntime> runtime_terrain_seeds_block;
		};
		static_assert(sizeof(s_i343terrainseedformoduletag) == 44, "struct s_i343terrainseedformoduletag is invalid size");

		struct s_basicblockuseonce
		{
			c_static_string<256> name;
		};
		static_assert(sizeof(s_basicblockuseonce) == 256, "struct s_basicblockuseonce is invalid size");

		struct s_s_basic_struct
		{
			long long_in_struct;
		};
		static_assert(sizeof(s_s_basic_struct) == 4, "struct s_s_basic_struct is invalid size");

		struct s_basicarray
		{
			long long_in_array;
		};
		static_assert(sizeof(s_basicarray) == 4, "struct s_basicarray is invalid size");

		struct s_s_block_with_struct
		{
			s_s_basic_struct struct_in_block;
		};
		static_assert(sizeof(s_s_block_with_struct) == 4, "struct s_s_block_with_struct is invalid size");

		struct s_s_basic_block
		{
			c_static_string<256> name;
		};
		static_assert(sizeof(s_s_basic_block) == 256, "struct s_s_basic_block is invalid size");

		struct s_s_complex_sub_block
		{
			c_typed_tag_reference<TEST_TAG_TAG> reference;
			c_typed_tag_block<s_s_basic_block> raz_block;
		};
		static_assert(sizeof(s_s_complex_sub_block) == 28, "struct s_s_complex_sub_block is invalid size");

		struct s_s_complex_block
		{
			c_typed_tag_block<s_s_basic_block> foo_block;
			c_typed_tag_block<s_s_complex_sub_block> bar_block;
		};
		static_assert(sizeof(s_s_complex_block) == 24, "struct s_s_complex_block is invalid size");

		struct s_s_complex_struct
		{
			c_typed_tag_block<s_s_basic_block> basic_block;
			argb_color color;
			c_typed_tag_block<s_s_complex_block> complex_block;
		};
		static_assert(sizeof(s_s_complex_struct) == 40, "struct s_s_complex_struct is invalid size");

		struct s_s_complex_array_element
		{
			c_static_string<32> string_in_array;
			c_typed_tag_block<s_s_basic_block> basic_block_in_array_block;
			s_point2d point_2d_in_array;
			s_s_complex_struct complex_struct_in_array;
		};
		static_assert(sizeof(s_s_complex_array_element) == 88, "struct s_s_complex_array_element is invalid size");

		struct s_s_motherload_struct
		{
			s_s_complex_struct _struct;
			s_s_complex_array_element array[8];
			c_typed_tag_block<s_s_complex_block> block_block;
		};
		static_assert(sizeof(s_s_motherload_struct) == 756, "struct s_s_motherload_struct is invalid size");

		struct s_test_tag_definition
		{
			s_anytag_struct_definition anytag;
			c_static_string<32> _string;
			c_static_string<256> long_string;
			string_id hashstring_global_namespace;
			string_id hashstring_test_namespace;
			string_id hashstring_multi_namespace;
			char _char;
			char generated_pad5a87[1]; // padding
			short _short;
			long long int64;
			long _long;
			byte _byte;
			char generated_pad0dd2[1]; // padding
			word _word;
			dword _dword;
			char generated_padc11d[4]; // padding
			qword _qword;
			angle _angle;
			tag _tag;
			c_enum<e_c_char_enum, char> char_enum;
			char generated_padda10[1]; // padding
			c_enum<e_c_short_enum, short> short_enum;
			c_enum<e_c_long_enum, long> long_enum;
			c_flags<e_c_byte_flags, char, k_c_byte_flags_count> byte_flags;
			char generated_pad8d5b[1]; // padding
			c_flags<e_c_word_flags, short, k_c_word_flags_count> word_flags;
			c_flags<e_c_long_flags, long, k_c_long_flags_count> long_flags;
			s_point2d short_point_2d;
			s_rectangle2d short_rectangle_2d;
			pixel32 rgb_pixel_32;
			pixel32 argb_pixel_32;
			real _real;
			real_fraction fraction;
			real_point2d real_point_2d;
			real_point3d real_point_3d;
			real_vector2d real_vector_2d;
			real_vector3d real_vector_3d;
			real_quaternion _real_quaternion;
			real_euler_angles2d real_euler_angles_2d;
			real_euler_angles3d real_euler_angles_3d;
			real_plane2d plane_2d;
			real_plane3d plane_3d;
			rgb_color real_rgb_color;
			argb_color real_argb_color;
			real_hsv_color _real_hsv_color;
			real_ahsv_color _real_ahsv_color;
			short_bounds _short_bounds;
			angle_bounds _angle_bounds;
			real_bounds _real_bounds;
			real_bounds fraction_bounds;
			c_typed_tag_reference<TEST_TAG_TAG> tag_reference;
			c_typed_tag_block<s_basicblockuseonce> basic_block;
			byte byte_block_flags;
			char generated_pad40a6[1]; // padding
			word word_block_flags;
			long dword_block_flags;
			char char_block_index;
			char generated_padf3f1[1]; // padding
			short short_block_index;
			long long_block_index;
			char char_block_index_custom;
			char generated_pad4194[1]; // padding
			short short_block_index_custom;
			long long_block_index_custom;
			s_tag_data data;

			/* explanation */

			s_s_basic_struct basic_struct;
			s_basicarray basic_array[8];
			s_tag_resource basic_resource;
			c_typed_tag_block<s_s_block_with_struct> block_with_struct_block;
			c_typed_tag_block<s_s_complex_block> complex_block;
			s_s_complex_struct complex_struct;
			s_s_complex_array_element complex_array[8];
			s_s_motherload_struct motherload_struct;
		};
		static_assert(sizeof(s_test_tag_definition) == 2232, "struct s_test_tag_definition is invalid size");

		struct s_triggervolumecomponentdefinition
		{
			s_anytag_struct_definition anytag;
			c_flags<e_i343objectstriggervolumeflags, long, k_i343objectstriggervolumeflags_count> flags;
			c_typed_tag_reference<PHYSICS_PHANTOM_SOUNDS_TAG> phantom_physics_sounds;
		};
		static_assert(sizeof(s_triggervolumecomponentdefinition) == 36, "struct s_triggervolumecomponentdefinition is invalid size");

		struct s_i343simulationucnauthoritytrustinterpolatedsettings
		{
			real position_delta_max;
			angle rotation_delta_max;
			real linear_velocity_delta_max;
			angle angular_velocity_delta_max;
		};
		static_assert(sizeof(s_i343simulationucnauthoritytrustinterpolatedsettings) == 16, "struct s_i343simulationucnauthoritytrustinterpolatedsettings is invalid size");

		struct s_i343simulationucnauthoritytrustsettings
		{
			s_anytag_struct_definition anytag;

			/* UCN AUTHORITY TRUST SETTINGS */

			real_bounds velocity_interpolation_range;

			/* Lowest velocity values */

			s_i343simulationucnauthoritytrustinterpolatedsettings interpolation_min_values;

			/* Highest velocity values */

			s_i343simulationucnauthoritytrustinterpolatedsettings interpolation_max_values;
			real_fraction cumulative_limit_fraction;
			char generated_pad799c[4]; // padding
		};
		static_assert(sizeof(s_i343simulationucnauthoritytrustsettings) == 64, "struct s_i343simulationucnauthoritytrustsettings is invalid size");

		struct s_s_vocalization_stimulus
		{
			c_flags<e_c_dialog_definition_stimulus_flags, short, k_c_dialog_definition_stimulus_flags_count> flags;
			char generated_pad22a6[2]; // padding
			string_id stimulus;
			c_typed_tag_reference<SOUND_TAG> sound;
		};
		static_assert(sizeof(s_s_vocalization_stimulus) == 24, "struct s_s_vocalization_stimulus is invalid size");

		struct s_s_vocalization_sound
		{
			string_id vocalization;
			c_flags<e_vocalizationsoundflagsobject, short, k_vocalizationsoundflagsobject_count> flags;
			char generated_pad3ad5[2]; // padding
			c_typed_tag_block<s_s_vocalization_stimulus> stimuli_block;
		};
		static_assert(sizeof(s_s_vocalization_sound) == 20, "struct s_s_vocalization_sound is invalid size");

		struct s_s_dialogue_definition
		{
			s_anytag_struct_definition anytag;
			c_flags<e_dialogueflags, long, k_dialogueflags_count> flags;
			c_typed_tag_block<s_s_vocalization_sound> vocalizations_block;
			string_id mission_dialogue_designator;
			char generated_pada3f0[4]; // padding
			long long vocalizationlookup;
		};
		static_assert(sizeof(s_s_dialogue_definition) == 48, "struct s_s_dialogue_definition is invalid size");

		struct s_nodegraphcontentunittestgraphcontenttag
		{
			s_nodegraphcontentnodegraphcontenttag nodegraph;
		};
		static_assert(sizeof(s_nodegraphcontentunittestgraphcontenttag) == 68, "struct s_nodegraphcontentunittestgraphcontenttag is invalid size");

		struct s_i343gameplaymenuhighvaluetargetuiinfo
		{
			long target_number;
			long targetspriteindex;
			string_id mission_id;
			c_enum<e_i343gameplaymenufaction, char> faction;
			char generated_pad6a84[3]; // padding
			string_id unlock_weapon_name;
			string_id unlock_weapon_description;
			long unlock_weapon_sprite_index;
		};
		static_assert(sizeof(s_i343gameplaymenuhighvaluetargetuiinfo) == 28, "struct s_i343gameplaymenuhighvaluetargetuiinfo is invalid size");

		struct s_i343gameplaymenuhighvaluetargetdeeplinkinfo
		{
			real zoomlevel;
			real duration;
		};
		static_assert(sizeof(s_i343gameplaymenuhighvaluetargetdeeplinkinfo) == 8, "struct s_i343gameplaymenuhighvaluetargetdeeplinkinfo is invalid size");

		struct s_i343gameplaymenugameplaymenuuiinfo
		{
			s_anytag_struct_definition anytag;
			// custom hvt
			c_typed_tag_block<s_i343gameplaymenuhighvaluetargetuiinfo> high_value_target_ui_info_block;
			s_i343gameplaymenuhighvaluetargetdeeplinkinfo deeplink_info;
			// custom value
			char generated_padcad7[4]; // padding
		};
		static_assert(sizeof(s_i343gameplaymenugameplaymenuuiinfo) == 40, "struct s_i343gameplaymenugameplaymenuuiinfo is invalid size");

		struct s_navpointpresentationtagblock
		{
			string_id name;
			c_typed_tag_reference<NAVPOINTPRESENTATION_TAG> navpoint_tag;
		};
		static_assert(sizeof(s_navpointpresentationtagblock) == 20, "struct s_navpointpresentationtagblock is invalid size");

		struct s_interfacefasthudgamertagdisplayoverrides
		{
			real visibility_distance;
			c_flags<e_interfacenavpointdrawwhenflags, long, k_interfacenavpointdrawwhenflags_count> draw_flags;
		};
		static_assert(sizeof(s_interfacefasthudgamertagdisplayoverrides) == 8, "struct s_interfacefasthudgamertagdisplayoverrides is invalid size");

		struct s_s_player_training_entry_data
		{
			string_id display_string;
			word max_display_time;
			word display_count;
			word dissapear_delay;
			word redisplay_delay;
			real display_delay_s;
			c_flags<e_playertrainingflags, short, k_playertrainingflags_count> flags;
			char generated_pad0814[2]; // padding
		};
		static_assert(sizeof(s_s_player_training_entry_data) == 20, "struct s_s_player_training_entry_data is invalid size");

		struct s_hudparallaxparamsblock
		{
			string_id name;
			real parallax_falloff_time;
			real parallax_camera_velocity_factor;
			real_point3d parallax_movement_multiplier;
			real_point3d parallax_clamp_min;
			real_point3d parallax_clamp_max;
			real_euler_angles3d parallax_angular_multiplier;
			real_euler_angles3d parallax_angle_clamp_min;
			real_euler_angles3d parallax_angle_clamp_max;
			c_enum<e_cameratype, char> camera_type;
			char generated_pade2be[3]; // padding
		};
		static_assert(sizeof(s_hudparallaxparamsblock) == 88, "struct s_hudparallaxparamsblock is invalid size");

		struct s_hudwarpparamsblock
		{
			string_id name;
			real_point3d ellipsoid_scale;
			real_point3d ellipsoid_center;
			real_point3d output_offset;
			long tessellation_x;
			long tessellation_y;
			c_flags<e_interfacefasthudenablewarpflags, char, k_interfacefasthudenablewarpflags_count> flags;
			char generated_pad390e[3]; // padding
		};
		static_assert(sizeof(s_hudwarpparamsblock) == 52, "struct s_hudwarpparamsblock is invalid size");

		struct s_hudchromaticaberrationparamsblock
		{
			string_id name;
			real base_mix;
			real_point2d red_aberration_scale;
			real_point2d green_aberration_scale;
			real_point2d blue_aberration_scale;
			c_flags<e_interfacefasthudenablechromaticaberrationflags, char, k_interfacefasthudenablechromaticaberrationflags_count> flags;
			char generated_pad4665[3]; // padding
		};
		static_assert(sizeof(s_hudchromaticaberrationparamsblock) == 36, "struct s_hudchromaticaberrationparamsblock is invalid size");

		struct s_hudhighcontrastparamsblock
		{
			string_id name;
			real dynamic_threshold_min;
			real dynamic_threshold_max;
			real dynamic_threshold_clamp;
			c_flags<e_interfacefasthudenablehighcontrastflags, char, k_interfacefasthudenablehighcontrastflags_count> flags;
			char generated_pad0542[3]; // padding
		};
		static_assert(sizeof(s_hudhighcontrastparamsblock) == 20, "struct s_hudhighcontrastparamsblock is invalid size");

		struct s_userinterfacehudglobalsdefinitions
		{
			s_anytag_struct_definition anytag;

			/* Motion sensor globals */

			c_flags<e_hudmotionsensorglobalshudmotionsensorglobalsflags, char, k_hudmotionsensorglobalshudmotionsensorglobalsflags_count> flags;
			char generated_pad0c0f[3]; // padding
			real active_camo_appears_as_enemy_when_lower_than;
			real height_classified_as_above;
			real height_classified_as_below;
			real upwards_movement_scaling;
			real downwards_movement_scaling;
			real crouching_movement_scaling;
			real edge_indicator_position_scale;
			real vehicle_navigation_marker_range_detection;
			real vehicle_contested_flash_time;
			real activecamo_xray_animation_cooldown_;
			real dead_people_visible_time;
			long motion_tracker_fade_frames;
			long armor_mod_display_counter;
			real broadsword_parallax_velocity_override;
			real pelican_parallax_velocity_override;

			/* Fanfare and Messaging globals */

			real fanfare_display_time_;
			real fanfare_speed_up_display_time_;
			real medal_score_message_lifetime_;
			real medal_score_message_restart_time_;
			real event_feed_life_time_cui;

			/* Remote motion sensor globals */

			real remote_sensor_range;
			real remote_sensor_weak_distance;
			real remote_sensor_failure_distance;

			/* Navpoints globals */

			real near_player_distance_metres;
			real_point2d defaultnavpointposition2d_pixels;
			real defaultnavpoint2ddelaytime_seconds;
			real defaultnavpointspacing2d_pixels;
			real defaultdockingmovefraction;
			real numeric_timer_expiry_threshold_seconds;
			real normalized_timer_expiry_threshold;
			real camouflage_maximum_visible_intensity;
			real damage_state_reset_time_milliseconds;
			real firing_state_reset_time_milliseconds;
			c_typed_tag_block<s_navpointpresentationtagblock> navpoint_presentations_block;
			// custom gamertag_visibility

			/* value */

			c_typed_tag_block<s_interfacefasthudgamertagdisplayoverrides> friendly_block;
			c_typed_tag_block<s_interfacefasthudgamertagdisplayoverrides> fireteam_block;
			c_typed_tag_block<s_interfacefasthudgamertagdisplayoverrides> enemy_block;
			// custom value

			/* Damage globals */

			real shield_bar_recent_damage_duration;
			real damage_indicator_response_duration;
			real damage_flash_response_duration;
			c_typed_tag_reference<BITMAP_TAG> tiled_mesh_seen_when_hit_in_1st_person;
			real number_of_tiles_across_the_screen;
			real microtexture_warp_x;
			real microtexture_warp_y;
			real intensity_scalar;
			real taa_mask_strength;
			real alpha_multiplier;
			real total_intensity_cap_01;

			/* Screen blob globals */

			c_flags<e_hudscreenblobglobalshudscreenblobglobalsflags, char, k_hudscreenblobglobalshudscreenblobglobalsflags_count> screen_blob_flags;
			char generated_pade5d8[3]; // padding
			rgb_color color_of_effect_while_shielded;
			rgb_color color_of_effect_with_no_shield;
			real shield_pattern_scale_x;
			real shield_pattern_scale_y;
			real effect_overall_intensity;
			real effect_lifetime_in_seconds;
			real effect_width_on_first_frame_0_1;
			real effect_width_on_last_frame_0_1;
			s_scalarfunctionname opacity_time_function;
			s_scalarfunctionname size_time_function;
			s_scalarfunctionname size_damage_function;
			c_typed_tag_reference<BITMAP_TAG> pattern_shield_texture;
			c_typed_tag_reference<BITMAP_TAG> mask_0_texture;
			c_typed_tag_reference<BITMAP_TAG> mask_1_texture;
			c_typed_tag_reference<BITMAP_TAG> mask_2_texture;
			c_typed_tag_reference<BITMAP_TAG> mask_3_texture;

			/* Reticule globals */

			real reticule_maximum_spread_angle;

			/* Sounds */

			s_tag_reference banned_vehicle_entrance_sound;

			/* High Contrast globals */

			c_flags<e_highcontrastflags, char, k_highcontrastflags_count> high_contrast_flags;
			char generated_pad9952[3]; // padding

			/* Dynamic Contrast Settings */

			real minimum_threshold;
			real maximum_threshold;
			real clamp_threshold;

			/* Double Draw Settings */

			real darken_factor;
			real brighten_factor;

			/* Text */

			c_typed_tag_block<s_stringfilereferences> string_references_block;
			c_typed_tag_reference<SOUND_TAG> interact_message_appear_sound;
			c_typed_tag_reference<SOUND_TAG> interact_message_disappear_sound_;
			real medal_fanfare_animation_lifetime_;
			real medal_fanfare_animation_in_lifetime_;
			real medal_fanfare_animation_out_begin_time_;
			short max_medals_on_screen;
			char generated_pad7a08[2]; // padding
			real event_fanfare_animation_lifetime_;
			real event_fanfare_animation_in_lifetime_;
			real event_fanfare_animation_out_begin_time_;
			real personal_score_animation_lifetime_;
			real personal_score_animation_in_lifetime_;
			real personal_score_animation_out_begin_time_;
			argb_color heroic_killfeed_color;
			argb_color legendary_killfeed_color;
			argb_color mythic_killfeed_color_;

			/* Player Training */

			c_typed_tag_block<s_s_player_training_entry_data> player_training_data_block;

			/* Grenade Indicator Globals */

			real grenade_indicator_danger_radius_;
			real grenade_indicator_lifetime_dampener_;

			/* Parallax globals */

			real vehicle_transition_time_seconds;
			c_typed_tag_block<s_hudparallaxparamsblock> parallax_params_block;

			/* Warp params */

			c_typed_tag_block<s_hudwarpparamsblock> warp_params_block;

			/* Chromatic aberration params */

			c_typed_tag_block<s_hudchromaticaberrationparamsblock> chromatic_aberration_params_block;

			/* High contrast globals */

			c_typed_tag_block<s_hudhighcontrastparamsblock> high_contrast_params_block;

			/* Threat tracker globals */

			real threat_tracker_range;
		};
		static_assert(sizeof(s_userinterfacehudglobalsdefinitions) == 704, "struct s_userinterfacehudglobalsdefinitions is invalid size");

		struct s_interfacecustomizationuiiteminspectsettings
		{
			long fodeout_end_time;
			string_id default_composer_scene_name;
		};
		static_assert(sizeof(s_interfacecustomizationuiiteminspectsettings) == 8, "struct s_interfacecustomizationuiiteminspectsettings is invalid size");

		struct s_interfacecustomizationuiiteminspecttag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_interfacecustomizationuiiteminspectsettings> customization_inspect_settings_block;
			char generated_pad03f1[4]; // padding
		};
		static_assert(sizeof(s_interfacecustomizationuiiteminspecttag) == 32, "struct s_interfacecustomizationuiiteminspecttag is invalid size");

		struct s_s_user_interface_sounds
		{
			s_anytag_struct_definition anytag;
			// custom controller_input_events
			c_typed_tag_reference<SOUND_TAG> tab_up;
			c_typed_tag_reference<SOUND_TAG> tab_left;
			c_typed_tag_reference<SOUND_TAG> tab_right;
			c_typed_tag_reference<SOUND_TAG> tab_down;
			c_typed_tag_reference<SOUND_TAG> alt_stick_up;
			c_typed_tag_reference<SOUND_TAG> alt_stick_left;
			c_typed_tag_reference<SOUND_TAG> alt_stick_right;
			c_typed_tag_reference<SOUND_TAG> alt_stick_down;
			c_typed_tag_reference<SOUND_TAG> alt_tab_up;
			c_typed_tag_reference<SOUND_TAG> alt_tab_left;
			c_typed_tag_reference<SOUND_TAG> alt_tab_right;
			c_typed_tag_reference<SOUND_TAG> alt_tab_down;
			c_typed_tag_reference<SOUND_TAG> a_button_pressed;
			c_typed_tag_reference<SOUND_TAG> b_button_pressed;
			c_typed_tag_reference<SOUND_TAG> x_button_pressed;
			c_typed_tag_reference<SOUND_TAG> y_button_pressed;
			c_typed_tag_reference<SOUND_TAG> left_trigger_pressed;
			c_typed_tag_reference<SOUND_TAG> right_trigger_pressed;
			c_typed_tag_reference<SOUND_TAG> d_pad_up_pressed;
			c_typed_tag_reference<SOUND_TAG> d_pad_left_pressed;
			c_typed_tag_reference<SOUND_TAG> d_pad_right_pressed;
			c_typed_tag_reference<SOUND_TAG> d_pad_down_pressed;
			c_typed_tag_reference<SOUND_TAG> start_button_pressed;
			c_typed_tag_reference<SOUND_TAG> back_button_pressed;
			c_typed_tag_reference<SOUND_TAG> left_stick_pressed;
			c_typed_tag_reference<SOUND_TAG> right_stick_pressed;
			c_typed_tag_reference<SOUND_TAG> left_bumper_pressed;
			c_typed_tag_reference<SOUND_TAG> right_bumper_pressed;
			c_typed_tag_reference<SOUND_TAG> left_thumbstick_pressed;
			c_typed_tag_reference<SOUND_TAG> right_thumbstick_pressed;
			c_typed_tag_reference<SOUND_TAG> left_stick_pressed_left;
			c_typed_tag_reference<SOUND_TAG> left_stick_pressed_right;
			c_typed_tag_reference<SOUND_TAG> left_stick_pressed_up;
			c_typed_tag_reference<SOUND_TAG> left_stick_pressed_down;
			c_typed_tag_reference<SOUND_TAG> right_stick_pressed_left;
			c_typed_tag_reference<SOUND_TAG> right_stick_pressed_right;
			c_typed_tag_reference<SOUND_TAG> right_stick_pressed_up;
			c_typed_tag_reference<SOUND_TAG> right_stick_pressed_down;
			c_typed_tag_reference<SOUND_TAG> a_button_released;
			c_typed_tag_reference<SOUND_TAG> b_button_released;
			c_typed_tag_reference<SOUND_TAG> x_button_released;
			c_typed_tag_reference<SOUND_TAG> y_button_released;
			c_typed_tag_reference<SOUND_TAG> left_trigger_released;
			c_typed_tag_reference<SOUND_TAG> right_trigger_released;
			c_typed_tag_reference<SOUND_TAG> d_pad_up_released;
			c_typed_tag_reference<SOUND_TAG> d_pad_left_released;
			c_typed_tag_reference<SOUND_TAG> d_pad_right_released;
			c_typed_tag_reference<SOUND_TAG> d_pad_down_released;
			c_typed_tag_reference<SOUND_TAG> start_button_released;
			c_typed_tag_reference<SOUND_TAG> back_button_released;
			c_typed_tag_reference<SOUND_TAG> left_stick_released;
			c_typed_tag_reference<SOUND_TAG> right_stick_released;
			c_typed_tag_reference<SOUND_TAG> left_bumper_released;
			c_typed_tag_reference<SOUND_TAG> right_bumper_released;
			c_typed_tag_reference<SOUND_TAG> left_thumbstick_released;
			c_typed_tag_reference<SOUND_TAG> right_thumbstick_released;
			c_typed_tag_reference<SOUND_TAG> left_stick_released_left;
			c_typed_tag_reference<SOUND_TAG> left_stick_released_right;
			c_typed_tag_reference<SOUND_TAG> left_stick_released_up;
			c_typed_tag_reference<SOUND_TAG> left_stick_released_down;
			c_typed_tag_reference<SOUND_TAG> right_stick_released_left;
			c_typed_tag_reference<SOUND_TAG> right_stick_released_right;
			c_typed_tag_reference<SOUND_TAG> right_stick_released_up;
			c_typed_tag_reference<SOUND_TAG> right_stick_released_down;
			// custom value
			// custom general
			c_typed_tag_reference<SOUND_TAG> error;
			// custom value
			// custom screen
			c_typed_tag_reference<SOUND_TAG> screen_transition_in;
			c_typed_tag_reference<SOUND_TAG> screen_transition_out;
			// custom value
			// custom timers
			c_typed_tag_reference<SOUND_TAG> game_start_countdown_timer_first_tick;
			c_typed_tag_reference<SOUND_TAG> game_start_countdown_timer_tick;
			c_typed_tag_reference<SOUND_TAG> game_start_countdown_timer_final_tick;
			c_typed_tag_reference<SOUND_TAG> alternate_countdown_timer_first_tick;
			c_typed_tag_reference<SOUND_TAG> alternate_countdown_timer_tick;
			c_typed_tag_reference<SOUND_TAG> alternate_countdown_timer_final_tick;
			// custom value
			// custom misc
			s_tag_reference matchmaking_started;
			s_tag_reference matchmaking_stopped;
			s_tag_reference custom_game_started;
			s_tag_reference custom_game_stopped;
			s_tag_reference campaign_started;
			s_tag_reference campaign_stopped;
			// custom value
			// custom exit_experience
			c_typed_tag_reference<SOUND_TAG> game_completion;
			c_typed_tag_reference<SOUND_TAG> winning_bonus;
			c_typed_tag_reference<SOUND_TAG> hopper_bonus;
			c_typed_tag_reference<SOUND_TAG> boost_bonus;
			c_typed_tag_reference<SOUND_TAG> fasttrack_bonus;
			c_typed_tag_reference<SOUND_TAG> totals;
			c_typed_tag_reference<SOUND_TAG> subrank_up;
			c_typed_tag_reference<SOUND_TAG> rank_up;
			c_typed_tag_reference<SOUND_TAG> completed;
			c_typed_tag_reference<SOUND_LOOPING_TAG> counter_loop;
			c_typed_tag_reference<SOUND_TAG> score_bonus;
			c_typed_tag_reference<SOUND_TAG> rewards;
			// custom value
			char generated_paddd62[4]; // padding
		};
		static_assert(sizeof(s_s_user_interface_sounds) == 1476, "struct s_s_user_interface_sounds is invalid size");

		struct s_interfaceuivehicleseattagblock
		{
			string_id label;
			string_id boarding_grenade_string;
			string_id boarding_melee_string;
			string_id in_seat_string;
			string_id enter_seat_string;
		};
		static_assert(sizeof(s_interfaceuivehicleseattagblock) == 20, "struct s_interfaceuivehicleseattagblock is invalid size");

		struct s_interfaceuivehicledisplayinfo
		{
			s_anytag_struct_definition anytag;
			string_id name;
			string_id vehicle_flip_string;
			string_id tint_color;
			c_typed_tag_block<s_interfaceuiiteminfo> ui_info_block;
			c_typed_tag_block<s_interfaceuivehicleseattagblock> seats_block;
			char generated_pad1d69[4]; // padding
		};
		static_assert(sizeof(s_interfaceuivehicledisplayinfo) == 56, "struct s_interfaceuivehicledisplayinfo is invalid size");

		struct s_interfacenodegraphuivehiclenodedefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<CUI_SCREEN_TAG> vehicle_default_screen_reference;
			real scale;
		};
		static_assert(sizeof(s_interfacenodegraphuivehiclenodedefinition) == 36, "struct s_interfacenodegraphuivehiclenodedefinition is invalid size");

		struct s_interfaceuiweapondisplayinfo
		{
			s_anytag_struct_definition anytag;
			string_id primary_pickup_message;
			string_id sub_pickup_message;
			string_id secondary_pickup_message;
			string_id primary_swap_message;
			string_id sub_swap_message;
			string_id secondary_swap_message;
			string_id picked_up_message;
			string_id switch_to_message;
			string_id switch_to_from_ai_message;
			string_id low_ammo_message;
			string_id notify_empty_message;
			string_id notify_overheat_message;
			string_id heat_warning_message;
			string_id tint_color;
			c_typed_tag_block<s_interfaceuiiteminfo> ui_item_info_block;
			char generated_pada0bd[4]; // padding
		};
		static_assert(sizeof(s_interfaceuiweapondisplayinfo) == 88, "struct s_interfaceuiweapondisplayinfo is invalid size");

		struct s_interfacenodegraphuiadsweaponnodedefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<CUI_SCREEN_TAG> hip_fire_reticle_default_screen_reference;
			c_typed_tag_reference<CUI_SCREEN_TAG> reticle_default_screen_reference;
			c_typed_tag_reference<CUI_SCREEN_TAG> sight_front_default_screen_reference;
			c_typed_tag_reference<CUI_SCREEN_TAG> sight_back_default_screen_reference;
			real scale;
			char generated_padbede[4]; // padding
		};
		static_assert(sizeof(s_interfacenodegraphuiadsweaponnodedefinition) == 88, "struct s_interfacenodegraphuiadsweaponnodedefinition is invalid size");

		struct s_s_multilingual_unicode_string_reference
		{
			string_id string_id;
			long english_offset;
			long japanese_offset;
			long german_offset;
			long french_offset;
			long spanish_offset;
			long mexican_spanish_offset;
			long italian_offset;
			long korean_offset;
			long traditional_chinese_offset;
			long simplified_chinese_offset;
			long portuguese_offset;
			long polish_offset;
			long russian_offset;
			long danish_offset;
			long finnish_offset;
			long dutch_offset;
			long norwegian_offset;
			long brazilian_portuguese_offset;
		};
		static_assert(sizeof(s_s_multilingual_unicode_string_reference) == 76, "struct s_s_multilingual_unicode_string_reference is invalid size");

		struct s_s_string_substitution_pair
		{
			string_id first_string_id;
			string_id second_string_id;
			long associated_value;
		};
		static_assert(sizeof(s_s_string_substitution_pair) == 12, "struct s_s_string_substitution_pair is invalid size");

		struct s_s_multilingual_unicode_string_list_group_header
		{
			s_anytag_struct_definition anytag;
			// custom import___directory
			// custom import___single_file
			c_typed_tag_block<s_s_multilingual_unicode_string_reference> string_references_block;
			c_typed_tag_block<s_s_string_substitution_pair> substitution_pairs_block;
			s_tag_data string_data_utf8;
		};
		static_assert(sizeof(s_s_multilingual_unicode_string_list_group_header) == 60, "struct s_s_multilingual_unicode_string_list_group_header is invalid size");

		struct s_s_unit_screen_effect_definition
		{
			c_typed_tag_reference<AREA_SCREEN_EFFECT_TAG> screen_effect;
		};
		static_assert(sizeof(s_s_unit_screen_effect_definition) == 16, "struct s_s_unit_screen_effect_definition is invalid size");

		struct s_s_unit_camera_track
		{
			c_typed_tag_reference<CAMERA_TRACK_TAG> track;
			c_typed_tag_reference<AREA_SCREEN_EFFECT_TAG> screen_effect;
			real transition_time_in;
			real transition_time_out;
		};
		static_assert(sizeof(s_s_unit_camera_track) == 40, "struct s_s_unit_camera_track is invalid size");

		struct s_s_unit_camera_acceleration_displacement_function
		{
			c_enum<e_e_unit_camera_acceleration_displacement_input, char> input_variable;
			char generated_padd066[3]; // padding
			// custom mapping
			s_functiondefinition mapping;
			real maximum_value;
			real camera_scale_axial;
			real camera_scale_perpendicular;
		};
		static_assert(sizeof(s_s_unit_camera_acceleration_displacement_function) == 36, "struct s_s_unit_camera_acceleration_displacement_function is invalid size");

		struct s_s_unit_camera_acceleration
		{
			real maximum_camera_velocity;

			/* value */

			s_s_unit_camera_acceleration_displacement_function forward_back;
			s_s_unit_camera_acceleration_displacement_function left_right;
			s_s_unit_camera_acceleration_displacement_function up_down;
		};
		static_assert(sizeof(s_s_unit_camera_acceleration) == 112, "struct s_s_unit_camera_acceleration is invalid size");

		struct s_s_unit_camera
		{
			// custom unit_camera
			c_flags<e_unitcameraflags, short, k_unitcameraflags_count> flags;
			char generated_padc79e[2]; // padding
			// custom value
			string_id camera_marker_name;
			angle pitch_auto_level;
			angle_bounds pitch_range;
			c_typed_tag_block<s_s_unit_camera_track> camera_tracks_block;
			angle pitch_minimum_spring;
			angle pitch_mmaximum_spring;
			angle spring_velocity;
			angle look_acceleration;
			angle look_deceleration;
			real_fraction look_acc_smoothing_fraction;
			angle field_of_view_bias;
			s_s_camera_obstruction_parameters camera_obstruction;
			c_typed_tag_block<s_s_unit_camera_acceleration> camera_acceleration_block;
			// custom value
		};
		static_assert(sizeof(s_s_unit_camera) == 96, "struct s_s_unit_camera is invalid size");

		struct s_weaponspecificmarkers
		{
			string_id complete_weapon_name;
			string_id weapon_class;
			string_id weapon_name;
			// custom value
			string_id right_hand_marker;
			// custom value
			string_id left_hand_marker;
		};
		static_assert(sizeof(s_weaponspecificmarkers) == 20, "struct s_weaponspecificmarkers is invalid size");

		struct s_s_unit_additional_node_names
		{
			string_id preferred_gun_node;
			// custom value
			string_id preferred_grenade_marker;

			/* Weapon Specific Markers */

			c_typed_tag_block<s_weaponspecificmarkers> weapon_specific_markers_block;
		};
		static_assert(sizeof(s_s_unit_additional_node_names) == 20, "struct s_s_unit_additional_node_names is invalid size");

		struct s_unitboardingmeleedefinition
		{
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> boarding_melee_damage;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> boarding_melee_response;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> eviction_melee_damage;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> eviction_melee_response;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> landing_melee_damage;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> flurry_melee_damage;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> obstacle_smash_damage;
		};
		static_assert(sizeof(s_unitboardingmeleedefinition) == 112, "struct s_unitboardingmeleedefinition is invalid size");

		struct s_hudunitsoundcuedefinition
		{
			s_tag_reference sound;
			c_flags<e_hudunitsoundcueflags, long, k_hudunitsoundcueflags_count> latched_to;
			real scale;
		};
		static_assert(sizeof(s_hudunitsoundcuedefinition) == 24, "struct s_hudunitsoundcuedefinition is invalid size");

		struct s_hudunitsounddefinitions
		{
			c_typed_tag_block<s_hudunitsoundcuedefinition> hud_audio_cues_block;
			// custom health_thresholds
			real health_minor;
			real health_major;
			real health_critical;
			// custom value
			// custom shield_thresholds
			real shield_minor;
			real shield_major;
			real shield_critical;
			// custom value
		};
		static_assert(sizeof(s_hudunitsounddefinitions) == 36, "struct s_hudunitsounddefinitions is invalid size");

		struct s_dialogue_variant_definition
		{
			short variant_number;
			char generated_padef78[2]; // padding
			c_typed_tag_reference<DIALOGUE_TAG> dialogue;
		};
		static_assert(sizeof(s_dialogue_variant_definition) == 20, "struct s_dialogue_variant_definition is invalid size");

		struct s_powered_seat_definition
		{
			real driver_powerup_time;
			real driver_powerdown_time;
		};
		static_assert(sizeof(s_powered_seat_definition) == 8, "struct s_powered_seat_definition is invalid size");

		struct s_sentryturretstatetransitionevent
		{
			c_enum<e_rawsentryturretstate, long> from_state;
			c_enum<e_rawsentryturretstate, long> to_state;
			string_id event;
		};
		static_assert(sizeof(s_sentryturretstatetransitionevent) == 12, "struct s_sentryturretstatetransitionevent is invalid size");

		struct s_sentryproperties
		{
			c_flags<e_sentryturretbehaviorflags, char, k_sentryturretbehaviorflags_count> behavior;
			char generated_pad4624[3]; // padding
			angle sight_cone_angle;
			real sight_cone_cosine;
			real alert_range;
			real attack_range;
			real attack_range_score_multiplier;
			real light_vehicle_range_scale;
			real heavy_vehicle_range_scale;
			real flying_vehicle_range_scale;
			real light_vehicle_score_bonus;
			real heavy_vehicle_score_bonus;
			real flying_vehicle_score_bonus;
			real current_target_score_bonus;
			real startup_time;
			real primary_fire_time;
			real secondary_fire_time;
			c_typed_tag_reference<SOUND_TAG> player_entered_alert_range_sound;
			c_typed_tag_reference<SOUND_TAG> player_exited_alert_range_sound;
			// custom node_graph_events

			/* Events to fire on state transitions */

			c_typed_tag_block<s_sentryturretstatetransitionevent> transition_events_block;
			// custom value
		};
		static_assert(sizeof(s_sentryproperties) == 108, "struct s_sentryproperties is invalid size");

		struct s_unit_initial_weapon
		{
			c_typed_tag_reference<WEAPON_TAG> weapon;
			string_id weapon_name;
			string_id variant_name;
			c_enum<e_e_initial_weapon_position, long> position;
			c_flags<e_unitweaponflags, char, k_unitweaponflags_count> weapon_flags;
			char generated_paddad2[3]; // padding
			angle maximum_firing_cone_angle;
			real max_firing_cone_angle_cosine;
			real minimum_retarget_time;
			real blind_fire_time;
			real lead_fraction;
			real_bounds engagement_range;
			real proximity_score_multiplier;
			real direction_score_multiplier;
			real attacker_score_multiplier;
			real targeting_weight_hologram;
			real targeting_weight_auto_turret;
			real primary_fire_delay_from_idle;
			real secondary_fire_delay_from_idle;
			real caution_duration;
			real alert_angular_speed_max;
			real idle_angular_speed_max;
			angle targeting_yaw_min;
			angle targeting_yaw_max;
			angle targeting_pitch_min;
			angle targeting_pitch_max;
			angle idle_scanning_yaw_min;
			angle idle_scanning_yaw_max;
			angle idle_scanning_pitch_min;
			angle idle_scanning_pitch_max;
			real idle_scanning_min_interest_distance;
			c_typed_tag_reference<EFFECT_TAG> alert_mode_effect;
			// custom value
			string_id alert_mode_effect_marker;
			string_id alert_mode_effect_primary_scale;
			string_id alert_mode_effect_secondary_scale;
			c_typed_tag_block<s_sentryproperties> sentry_properties_block;
			real target_camouflage_threshold;
		};
		static_assert(sizeof(s_unit_initial_weapon) == 180, "struct s_unit_initial_weapon is invalid size");

		struct s_trackingtypeblock
		{
			string_id tracking_type;
		};
		static_assert(sizeof(s_trackingtypeblock) == 4, "struct s_trackingtypeblock is invalid size");

		struct s_s_target_tracking_parameters
		{
			c_flags<e_targettrackingparameterflags, char, k_targettrackingparameterflags_count> target_tracking_flags;
			char generated_pada390[3]; // padding
			c_typed_tag_block<s_trackingtypeblock> tracking_types_block;
			real acquire_time;
			real grace_time;
			real decay_time;
			byte max_target_locks;
			char generated_padbd71[3]; // padding
			s_tag_reference tracking_sound;
			s_tag_reference locked_sound;
		};
		static_assert(sizeof(s_s_target_tracking_parameters) == 64, "struct s_s_target_tracking_parameters is invalid size");

		struct s_seatmodeltarget
		{
			string_id model_target_name;
		};
		static_assert(sizeof(s_seatmodeltarget) == 4, "struct s_seatmodeltarget is invalid size");

		struct s_s_boarding_seat
		{
			short seat;
		};
		static_assert(sizeof(s_s_boarding_seat) == 2, "struct s_s_boarding_seat is invalid size");

		struct s_seatswitchingentrydefinition
		{
			string_id destinationseat;
			string_id animation;
			real seat_switch_cooldown_time;
		};
		static_assert(sizeof(s_seatswitchingentrydefinition) == 12, "struct s_seatswitchingentrydefinition is invalid size");

		struct s_seatswitchingdefinition
		{
			// custom up
			s_seatswitchingentrydefinition up;
			// custom value
			// custom down
			s_seatswitchingentrydefinition down;
			// custom value
			// custom left
			s_seatswitchingentrydefinition left;
			// custom value
			// custom right
			s_seatswitchingentrydefinition right;
			// custom value
		};
		static_assert(sizeof(s_seatswitchingdefinition) == 48, "struct s_seatswitchingdefinition is invalid size");

		struct s_seatbuttoncallout
		{
			string_id text;
		};
		static_assert(sizeof(s_seatbuttoncallout) == 4, "struct s_seatbuttoncallout is invalid size");

		struct s_unit_seat
		{
			c_flags<e_c_unit_seat_flags, long, k_c_unit_seat_flags_count> flags;
			c_flags<e_c_unit_seat_secondary_flags, long, k_c_unit_seat_secondary_flags_count> secondary_flags;
			c_enum<e_passengerseatdesignator, long> passenger_seat_designator;
			c_enum<e_unitgrenadetype, char> seat_has_infinite_grenades_of_type;
			c_enum<e_i343unitsseatselectionpriority, char> seat_selection_priority;
			char generated_pad811e[2]; // padding
			string_id label_text;
			c_static_string<32> label;
			// custom value
			string_id marker_name;
			// custom value
			string_id entry_markers_name;
			// custom value
			string_id exit_marker_name;
			// custom value
			string_id ui_marker_name;
			string_id ui_navpoint_name;
			// custom value
			string_id boarding_grenade_marker;
			string_id boarding_grenade_string;
			string_id boarding_melee_string;
			string_id in_seat_string;
			c_typed_tag_block<s_seatmodeltarget> ai_model_targets_block;
			real_fraction ping_scale;
			real turnover_time;

			/* seat acceleration spring */

			c_typed_tag_reference<SPRING_ACCELERATION_TAG> seat_acceleration;
			real ai_scariness;
			c_enum<e_aiseattype, short> ai_seat_type;
			short boarding_seat;
			c_typed_tag_block<s_s_boarding_seat> additional_boarding_seats_block;
			// custom seat_switching

			/* explanation */

			s_seatswitchingdefinition seat_switching;
			// custom value
			real_fraction listener_interpolation_factor;
			real_fraction listener_orientation_interpolation;
			real_fraction listener_blend_towards_locked_axis;

			/* speed dependent turn rates */

			real_bounds yaw_rate_bounds;
			real_bounds pitch_rate_bounds;
			real pitch_interpolation_time;
			real min_speed_reference;
			real max_speed_reference;
			real speed_exponent;

			/* camera fields */

			s_s_unit_camera unit_camera;
			c_typed_tag_reference<CUI_SCREEN_TAG> hud_screen_reference;
			c_typed_tag_reference<CUI_SCREEN_TAG> alt_hud_screen_reference;
			string_id enter_seat_string;
			c_typed_tag_block<s_seatbuttoncallout> button_callouts_block;
			angle pitch_minimum;
			angle pitch_maximum;
			angle pitch_minimum_for_ai_operator;
			angle pitch_maximum_for_ai_operator;
			angle yaw_minimum;
			angle yaw_maximum;
			angle yaw_minimum_for_ai_operator;
			angle yaw_maximum_for_ai_operator;
			c_typed_tag_reference<CHARACTER_TAG> built_in_gunner;

			/* entry fields */

			real entry_radius;
			angle entry_marker_cone_angle;
			angle entry_marker_facing_angle;
			real maximum_relative_velocity;
			c_typed_tag_reference<EQUIPMENT_TAG> equipment;
			real open_time;
			real close_time;
			string_id open_function_name;
			string_id opening_function_name;
			string_id closing_function_name;
			string_id invisible_seat_region;
			long runtime_invisible_seat_region_index;

			/* seat death grab crate */

			c_typed_tag_reference<CRATE_TAG> seat_death_grab_crate$2;
			string_id seat_selection_string;
			real bailout_velocity;

			/* Seat Ejection Fields */

			real maximum_acceleration;
			real maximum_centrifugal_force;
		};
		static_assert(sizeof(s_unit_seat) == 520, "struct s_unit_seat is invalid size");

		struct s_s_unit_lipsync_scales
		{
			real_fraction attack_weight;
			real_fraction decay_weight;
		};
		static_assert(sizeof(s_s_unit_lipsync_scales) == 8, "struct s_s_unit_lipsync_scales is invalid size");

		struct s_exitanddetachvariant
		{
			string_id variant_name;
			c_typed_tag_reference<WEAPON_TAG> exit_and_detach_weapon;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> exit_and_detach_damage;
		};
		static_assert(sizeof(s_exitanddetachvariant) == 36, "struct s_exitanddetachvariant is invalid size");

		struct s_unitbirthingproperties
		{
			short seat;
			char generated_pada2d2[2]; // padding
			string_id birthing_region;
		};
		static_assert(sizeof(s_unitbirthingproperties) == 8, "struct s_unitbirthingproperties is invalid size");

		struct s_i343activecamouflagemalleablepropertiesdefinition
		{
			c_enum<e_i343activecamouflageeffectiveness, char> camo_level;
			char generated_pad06e4[3]; // padding
			// custom grenade_throw_penalty
			s_i343malleablepropertybasefloatstructdefinition grenade_throw_penalty;
			// custom interpolation_time
			s_i343malleablepropertybasefloatstructdefinition interpolation_time;
			// custom melee_penalty
			s_i343malleablepropertybasefloatstructdefinition melee_penalty;
			// custom minimum_dinged_amount
			s_i343malleablepropertybasefloatstructdefinition minimum_dinged_amount;
			// custom maximum_duration
			s_i343malleablepropertybasefloatstructdefinition maximum_duration;
		};
		static_assert(sizeof(s_i343activecamouflagemalleablepropertiesdefinition) == 64, "struct s_i343activecamouflagemalleablepropertiesdefinition is invalid size");

		struct s_i343damagedamagemalleablepropertiesdefinition
		{

			/* Damage scaling malleable properties */

			// custom weapon_damage_scalar
			s_i343malleablepropertybasefloatstructdefinition weapon_damage_scalar;
			// custom melee_damage_scalar
			s_i343malleablepropertybasefloatstructdefinition melee_damage_scalar;
			// custom melee_knockback_scalar
			s_i343malleablepropertybasefloatstructdefinition melee_knockback_scalar;
			// custom melee_recovery_speed_scalar
			s_i343malleablepropertybasefloatstructdefinition melee_recovery_speed_scalar;
			// custom grenade_damage_scalar
			s_i343malleablepropertybasefloatstructdefinition grenade_damage_scalar;
			// custom grenade_knockback_scalar
			s_i343malleablepropertybasefloatstructdefinition grenade_knockback_scalar;
			// custom body_vampirism_scalar
			s_i343malleablepropertybasefloatstructdefinition body_vampirism_scalar;
			// custom shield_vampirism_scalar
			s_i343malleablepropertybasefloatstructdefinition shield_vampirism_scalar;
			// custom area_of_effect_radius_scalar
			s_i343malleablepropertybasefloatstructdefinition area_of_effect_radius_scalar;
		};
		static_assert(sizeof(s_i343damagedamagemalleablepropertiesdefinition) == 108, "struct s_i343damagedamagemalleablepropertiesdefinition is invalid size");

		struct s_i343unitsunitweaponpropertiesdefinition
		{

			/* Weapon trait malleable properties */

			// custom weapon_switch_speed_scalar
			s_i343malleablepropertybasefloatstructdefinition weapon_switch_speed_scalar;
			// custom weapon_empty_reload_speed_scalar
			s_i343malleablepropertybasefloatstructdefinition weapon_empty_reload_speed_scalar;
			// custom weapon_tactical_reload_speed_scalar
			s_i343malleablepropertybasefloatstructdefinition weapon_tactical_reload_speed_scalar;
			// custom movement_speed_with_turret_scalar
			s_i343malleablepropertybasefloatstructdefinition movement_speed_with_turret_scalar;
		};
		static_assert(sizeof(s_i343unitsunitweaponpropertiesdefinition) == 48, "struct s_i343unitsunitweaponpropertiesdefinition is invalid size");

		struct s_i343unitsemppropertiesdefinition
		{

			/* EMP malleable properties */

			// custom emp_disable_duration_scalar_
			s_i343malleablepropertybasefloatstructdefinition emp_disable_duration_scalar_;
			// custom emp_disable_duration_mp_scalar_
			s_i343malleablepropertybasefloatstructdefinition emp_disable_duration_mp_scalar_;
			c_typed_tag_reference<GENERICMODIFIERDEFINITIONTAG_TAG> emp_unit_modifiers;
		};
		static_assert(sizeof(s_i343unitsemppropertiesdefinition) == 40, "struct s_i343unitsemppropertiesdefinition is invalid size");

		struct s_unitdefinition
		{
			s_objectdefinition object;
			// custom $$$_unit_$$$
			c_flags<e_c_unit_definition_flags_schema_part1, long, k_c_unit_definition_flags_schema_part1_count> unit_flags;
			c_flags<e_c_unit_definition_flags_schema_part2, long, k_c_unit_definition_flags_schema_part2_count> flags2;
			c_enum<e_e_campaign_team, short> default_team;
			c_enum<e_i343aisoundvolume, short> constant_sound_volume;
			c_typed_tag_reference<UNIT_TAG> hologram_unit_reference;
			c_typed_tag_block<s_s_campaign_metagame_bucket> campaign_metagame_bucket_block;
			c_typed_tag_block<s_s_unit_screen_effect_definition> screen_effects_block;
			real camera_stiffness;
			s_s_unit_camera unit_camera;

			/* sync action camera fields */

			s_s_unit_camera sync_action_camera;
			string_id unit_markup_name_for_weapon_class_override;
			c_typed_tag_reference<SPRING_ACCELERATION_TAG> seat_acceleration;
			real pain_major_total_damage_threshold;
			// custom pings
			real soft_ping_threshold;
			real soft_ping_interrupt_time;
			real hard_ping_threshold;
			real hard_ping_interrupt_time;
			real soft_death_direction_speed_threshold;
			real hard_death_threshold;
			real feign_death_threshold;
			real feign_death_time;
			real pain_screen_duration;
			real pain_screen_region_fade_out_duration;
			real_fraction pain_screen_region_fade_out_weight_threshold;
			angle pain_screen_angle_tolerance;
			angle pain_screen_angle_randomness;
			real defensive_screen_duration;
			real_fraction defensive_screen_scrub_fallback_fraction;
			// custom value
			real distance_of_dive_anim;
			real_fraction terminal_velocity_fall_ratio;
			// custom stun
			real_fraction stun_movement_penalty;
			real_fraction stun_turning_penalty;
			real_fraction stun_jumping_penalty;
			real minimum_stun_time;
			real maximum_stun_time;
			// custom value
			real feign_death_chance;
			real feign_repeat_chance;
			c_typed_tag_reference<CHARACTER_TAG> spawned_turret_character;
			// custom aiming_looking
			string_id target_aiming_pivot_marker_name;
			angle aiming_velocity_maximum;
			angle aiming_acceleration_maximum;
			real_fraction casual_aiming_modifier;
			angle looking_velocity_maximum;
			angle looking_acceleration_maximum;
			real dropped_ability_object_velocity;
			// custom value
			real object_velocity_maximum;
			string_id right_hand_node;
			string_id left_hand_node;
			s_s_unit_additional_node_names more_damn_nodes;
			// custom melee_damage
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> melee_damage;
			c_typed_tag_reference<WEAPON_TAG> native_melee_override;
			s_unitboardingmeleedefinition your_momma;
			// custom value
			c_enum<e_interfacemotiontrackerstyleenum, short> motion_sensor_blip_style_enemy;
			c_enum<e_interfacemotiontrackerstyleenum, short> motion_sensor_blip_style_friendly;
			c_enum<e_itemownersize, short> item_owner_size;
			char generated_pad9055[2]; // padding
			real motion_tracker_range_modifier;
			string_id equipment_variant_name;
			string_id grounded_equipment_variant_name;
			c_typed_tag_block<s_hudunitsounddefinitions> hud_audio_cues_block;
			c_typed_tag_block<s_dialogue_variant_definition> dialogue_variants_block;
			// custom standard_grenade_throw
			real grenade_angle;
			real grenade_angle_max_elevation;
			real grenade_angle_min_elevation;
			real grenade_velocity;
			real_euler_angles3d grenade_rotational_velocity_min;
			real_euler_angles3d greande_rotational_velocity_max;
			// custom grenade_throw_speed_scalar
			s_i343malleablepropertybasefloatstructdefinition grenade_throw_speed_scalar;
			// custom value
			// custom primary_weapon_toss
			real weapon_angle;
			real weapon_angle_max_elevation;
			real weapon_angle_min_elevation;
			real weapon_velocity;
			real_euler_angles3d weapon_rotational_velocity_min;
			real_euler_angles3d weapon_rotational_velocity_max;
			// custom value
			c_typed_tag_block<s_powered_seat_definition> powered_seats_block;
			c_typed_tag_block<s_unit_initial_weapon> weapons_block;
			c_typed_tag_block<s_s_target_tracking_parameters> target_tracking_block;
			c_typed_tag_block<s_unit_seat> seats_block;
			real maximum_seat_switch_linear_velocity;
			angle maximum_seat_switch_angular_velocity;
			c_enum<e_empymountbehavior, short> empty_mount_behavior;
			char generated_pad7674[2]; // padding
			// custom open_close
			real opening_time;
			real closing_time;
			// custom value
			c_typed_tag_reference<DOCKINGSITEDEFINITION_TAG> docking_site;

			/* Deprecated Unit Power Component settings.  Please use the new settings in the OBJECT section above. */

			c_typed_tag_block<s_i343objectspowercomponentdefinition> power_component_block;
			// custom boost
			c_typed_tag_reference<UNITBOOSTDEFINITION_TAG> boost_definition;

			/* Deprecated Boost Fields.  Please use the Boost Definition field above. */

			s_boost boost;
			// custom value
			c_enum<e_i343collectibletutorial, long> tutorial_weapon_swap_id;

			/* Lipsync */

			s_s_unit_lipsync_scales lipsync$2;

			/* Exit and Detach */

			c_typed_tag_reference<DAMAGE_EFFECT_TAG> exit_and_detach_damage;
			c_typed_tag_reference<WEAPON_TAG> exit_and_detach_weapon;
			c_typed_tag_block<s_exitanddetachvariant> exit_and_detach_variants_block;

			/* Vehicle Death Telemetry Rule */

			c_enum<e_evehicledeathtelemetryrule, char> death_telemetry_rule;
			char generated_pad29bf[1]; // padding

			/* Experience */

			short experience_for_kill;
			short experience_for_assist;
			char generated_pad0fde[2]; // padding
			real bailout_threshold;
			real_fraction iron_sight_weapon_dampening;
			// custom birthing
			s_unitbirthingproperties birth;
			// custom value
			real_fraction procedural_recoil_scaler;
			c_typed_tag_reference<FLINCH_SYSTEM_TAG> flinch_system;

			/* Active Camouflage Malleable Properties */

			s_i343activecamouflagemalleablepropertiesdefinition active_camouflage_properties;
			c_typed_tag_reference<EFFECT_TAG> active_camouflage_energy_gain_effect;
			s_i343damagedamagemalleablepropertiesdefinition damage_properties;
			s_i343unitsunitweaponpropertiesdefinition weapon_properties;
			s_i343unitsemppropertiesdefinition emp_properties;
			c_typed_tag_reference<EFFECT_TAG> emp_disabled_effect;
			string_id recording_unit_type;
			// custom value
			c_typed_tag_reference<COLLISION_DAMAGE_TAG> knockback_collision_damage_override;
		};
		static_assert(sizeof(s_unitdefinition) == 2544, "struct s_unitdefinition is invalid size");

		struct s_i343unitrecorderrecording
		{
			string_id type;
			string_id name;
			real time_per_sample;
			long num_samples;
			long unit_recording_version;
			s_tag_data recording_data;
			c_enum<e_i343netprotocolgameoptionsmultiplayerteamdesignatorenum, char> team;
			c_flags<e_unitrecorderflags, char, k_unitrecorderflags_count> flags;
			char generated_pade268[2]; // padding
			c_typed_tag_reference<VEHICLE_TAG> vehicle_definition;
			real_vector3d finalangularvelocity;
			real_vector3d finallinearvelocity;
		};
		static_assert(sizeof(s_i343unitrecorderrecording) == 84, "struct s_i343unitrecorderrecording is invalid size");

		struct s_i343unitrecorderunitrecordingdefinition
		{
			s_anytag_struct_definition anytag;
			s_i343unitrecorderrecording recording;
			char generated_padacb9[4]; // padding
		};
		static_assert(sizeof(s_i343unitrecorderunitrecordingdefinition) == 104, "struct s_i343unitrecorderunitrecordingdefinition is invalid size");

		struct s_languagereference
		{
			c_enum<e_e_language, long> language;
			s_tag_resource string_list_resource;
		};
		static_assert(sizeof(s_languagereference) == 12, "struct s_languagereference is invalid size");

		struct s_unicodestringlistgroup
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_languagereference> language_references_block;
			char generated_pad95a9[4]; // padding
		};
		static_assert(sizeof(s_unicodestringlistgroup) == 32, "struct s_unicodestringlistgroup is invalid size");

		struct s_i343unitsweaponframeattachmentdefinition
		{
			s_anytag_struct_definition anytag;
			c_enum<e_i343unitsweaponslot, char> slot;
			char generated_pad89c5[3]; // padding
			c_typed_tag_reference<WEAPON_TAG> weapon;
			c_typed_tag_reference<WEAPON_CONFIGURATION_TAG> configuration;
			char generated_pad6fe4[4]; // padding
		};
		static_assert(sizeof(s_i343unitsweaponframeattachmentdefinition) == 56, "struct s_i343unitsweaponframeattachmentdefinition is invalid size");

		struct s_i343valorrewardsreward
		{
			string_id reward_name;
			string_id is_read_key;
			short icon;
			short background;
			long sprite_index;
			c_typed_tag_reference<BITMAP_TAG> vehicle_sprite;
			c_typed_tag_reference<BITMAP_TAG> weapon_sprite;
			c_typed_tag_reference<BITMAP_TAG> marine_sprite;
		};
		static_assert(sizeof(s_i343valorrewardsreward) == 64, "struct s_i343valorrewardsreward is invalid size");

		struct s_i343valorrewardspoints
		{
			string_id persistence_key;
		};
		static_assert(sizeof(s_i343valorrewardspoints) == 4, "struct s_i343valorrewardspoints is invalid size");

		struct s_i343valorrewardsiconbitmap
		{
			string_id name;
			c_typed_tag_reference<BITMAP_TAG> sprite;
		};
		static_assert(sizeof(s_i343valorrewardsiconbitmap) == 20, "struct s_i343valorrewardsiconbitmap is invalid size");

		struct s_i343valorrewardsbackgroundbitmap
		{
			string_id name;
			c_typed_tag_reference<BITMAP_TAG> sprite;
		};
		static_assert(sizeof(s_i343valorrewardsbackgroundbitmap) == 20, "struct s_i343valorrewardsbackgroundbitmap is invalid size");

		struct s_i343valorrewardsvalorunlocks
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343valorrewardsreward> valor_rewards_block;
			c_typed_tag_block<s_i343valorrewardspoints> valor_points_block;
			c_typed_tag_block<s_i343valorrewardsiconbitmap> icons_block;
			c_typed_tag_block<s_i343valorrewardsbackgroundbitmap> backgrounds_block;
		};
		static_assert(sizeof(s_i343valorrewardsvalorunlocks) == 64, "struct s_i343valorrewardsvalorunlocks is invalid size");

		struct s_i343graphicsvectorvertex
		{
			real_point2d position;
			long region_index;
			real_point3d texcoord;
			long render_type;
		};
		static_assert(sizeof(s_i343graphicsvectorvertex) == 28, "struct s_i343graphicsvectorvertex is invalid size");

		struct s_i343graphicsvectorindex
		{
			word index;
		};
		static_assert(sizeof(s_i343graphicsvectorindex) == 2, "struct s_i343graphicsvectorindex is invalid size");

		struct s_i343graphicsvectordrawinformation
		{
			word entry_point;
			word vertex_start;
			word index_start;
			word index_count;
		};
		static_assert(sizeof(s_i343graphicsvectordrawinformation) == 8, "struct s_i343graphicsvectordrawinformation is invalid size");

		struct s_i343graphicsvectorarttag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343graphicsvectorvertex> m_vectorvertices_block;
			c_typed_tag_block<s_i343graphicsvectorindex> m_vectorindices_block;
			c_typed_tag_block<s_i343graphicsvectordrawinformation> m_drawinformation_block;
			char generated_padc0a6[4]; // padding
			long long vertexbuffer;
			long long indexbuffer;
			real aspectratio;
			char generated_pad0d5b[4]; // padding
		};
		static_assert(sizeof(s_i343graphicsvectorarttag) == 80, "struct s_i343graphicsvectorarttag is invalid size");

		struct s_i343vehiclevehiclevitalitypropertymodifiersdefinition
		{
			real health_scalar;
		};
		static_assert(sizeof(s_i343vehiclevehiclevitalitypropertymodifiersdefinition) == 4, "struct s_i343vehiclevehiclevitalitypropertymodifiersdefinition is invalid size");

		struct s_i343vehiclevehiclemodifiers
		{
			// custom vehicle_attachment
			c_typed_tag_block<s_i343vehiclevehiclevitalitypropertymodifiersdefinition> maximum_vitality_block;
			// custom value
		};
		static_assert(sizeof(s_i343vehiclevehiclemodifiers) == 12, "struct s_i343vehiclevehiclemodifiers is invalid size");

		struct s_i343damageattachmentnamedefinition
		{
			string_id attachment_name;
		};
		static_assert(sizeof(s_i343damageattachmentnamedefinition) == 4, "struct s_i343damageattachmentnamedefinition is invalid size");

		struct s_i343vehiclevehicleattachment
		{
			s_anytag_struct_definition anytag;
			s_i343vehiclevehiclemodifiers properties;

			/* Attachment Name */

			s_i343damageattachmentnamedefinition attachmentname;
		};
		static_assert(sizeof(s_i343vehiclevehicleattachment) == 32, "struct s_i343vehiclevehicleattachment is invalid size");

		struct s_i343vehiclevehicleattachmentreference
		{
			c_typed_tag_reference<VEHICLEATTACHMENT_TAG> attachment;
		};
		static_assert(sizeof(s_i343vehiclevehicleattachmentreference) == 16, "struct s_i343vehiclevehicleattachmentreference is invalid size");

		struct s_i343vehicleweaponconfigurationgroup
		{
			c_typed_tag_reference<WEAPON_CONFIGURATION_TAG> weapon_configuration;
			string_id weapon_name;
		};
		static_assert(sizeof(s_i343vehicleweaponconfigurationgroup) == 20, "struct s_i343vehicleweaponconfigurationgroup is invalid size");

		struct s_i343vehiclevehicleconfigurationdefinitioninternal
		{
			string_id variant_name;
			c_typed_tag_block<s_i343vehiclevehicleattachmentreference> generic_attachments_block;
			c_typed_tag_block<s_i343vehicleweaponconfigurationgroup> weapon_configurations_block;
			c_typed_tag_reference<UIVEHICLEDISPLAYINFODEFINITION_TAG> ui_display_info;
		};
		static_assert(sizeof(s_i343vehiclevehicleconfigurationdefinitioninternal) == 44, "struct s_i343vehiclevehicleconfigurationdefinitioninternal is invalid size");

		struct s_i343vehiclevehicleconfigurationdefinition
		{
			s_i343objectsobjectconfigurationdefinition object_configuration;
			// custom vehicle
			s_i343vehiclevehicleconfigurationdefinitioninternal vehicle;
			// custom value
		};
		static_assert(sizeof(s_i343vehiclevehicleconfigurationdefinition) == 108, "struct s_i343vehiclevehicleconfigurationdefinition is invalid size");

		struct s_s_toruqe_curve_definition
		{
			s_scalarfunctionname function;
		};
		static_assert(sizeof(s_s_toruqe_curve_definition) == 20, "struct s_s_toruqe_curve_definition is invalid size");

		struct s_s_vehicle_gear_definition
		{

			/* loaded torque */

			s_s_toruqe_curve_definition loaded_torque_curve;

			/* cruising torque */

			s_s_toruqe_curve_definition cruising_torque_curve;

			/* gearing */

			real min_time_to_upshift;
			real engine_up_shift_scale;
			real gear_ratio;
			real min_time_to_downshift;
			real engine_down_shift_scale;
			real audio_engine_uprev_rate;
			real audio_engine_shift_up_rpm_value;
			real audio_engine_downrev_rate;
			real audio_engine_shift_down_rpm_value;
			c_typed_tag_reference<SOUND_TAG> gear_shift_sound___shifting_up;
			c_typed_tag_reference<SOUND_TAG> gear_shift_sound___shifting_down;
		};
		static_assert(sizeof(s_s_vehicle_gear_definition) == 108, "struct s_s_vehicle_gear_definition is invalid size");

		struct s_s_vehicle_load_and_cruise_definition
		{
			string_id load_cruise_function;
			long attachment_index;
		};
		static_assert(sizeof(s_s_vehicle_load_and_cruise_definition) == 8, "struct s_s_vehicle_load_and_cruise_definition is invalid size");

		struct s_s_vehicle_engine_definition
		{

			/* engine */

			real engine_moment;
			real engine_min_angular_velocity;
			real engine_max_angular_velocity;
			c_typed_tag_block<s_s_vehicle_gear_definition> gears_block;
			c_typed_tag_reference<SOUND_TAG> gear_shift_sound;
			c_typed_tag_block<s_s_vehicle_load_and_cruise_definition> load_and_cruise_sound_block;
		};
		static_assert(sizeof(s_s_vehicle_engine_definition) == 52, "struct s_s_vehicle_engine_definition is invalid size");

		struct s_s_vehicle_human_tank_definition
		{
			angle forward_arc;
			angle perpendicular_forward_arc;
			real flip_window;
			real pegged_fraction;
			real forward_turn_scale;
			real reverse_turn_scale;

			/* forward differential */

			real maximum_left_differential;
			real maximum_right_differential;
			real differential_acceleration;
			real differential_deceleration;

			/* reverse differential */

			real maximum_left_reverse_differential;
			real maximum_right_reverse_differential;
			real differential_reverse_acceleration;
			real differential_reverse_deceleration;
			s_s_vehicle_engine_definition engine;

			/* wheel circumferance */

			real wheel_circumferance$2;
			real gravity_adjust;

			/* New Tank Controls */

			c_flags<e_c_use_new_control_flag, char, k_c_use_new_control_flag_count> control_flags;
			char generated_pad4b05[3]; // padding
			real at_rest_forward_anglepurple;
			real at_rest_reverse_angleviolet;
			real at_rest_side_on_reverse_angle_closest_to_frontgreen;
			real at_rest_side_on_reverse_angle_furthest_from_frontblue;
			real at_rest_facing_forward_reverse_angleyellow;
			real at_rest_facing_backward_reverse_anglepink;
			real in_motion_opposing_direction_angle;
			real in_motion_speed;
		};
		static_assert(sizeof(s_s_vehicle_human_tank_definition) == 152, "struct s_s_vehicle_human_tank_definition is invalid size");

		struct s_s_vehicle_steering_control_definition
		{

			/* steering overdampening */

			angle overdampen_cusp_angle;
			real overdampen_exponent;
			angle ebrake_overdampen_cusp_angle;
			real ebrake_overdampen_exponent;
			// custom throttle_steering
			angle throttle_steering_angle;
			real throttle_steering_interpolation_rate;
			// custom value
		};
		static_assert(sizeof(s_s_vehicle_steering_control_definition) == 24, "struct s_s_vehicle_steering_control_definition is invalid size");

		struct s_s_vehicle_turning_control_definition
		{

			/* turning */

			real maximum_left_turn;
			real maximum_right_turn_negative;
			real turn_rate;
		};
		static_assert(sizeof(s_s_vehicle_turning_control_definition) == 12, "struct s_s_vehicle_turning_control_definition is invalid size");

		struct s_s_vehicle_human_jeep_definition
		{
			s_s_vehicle_steering_control_definition steering_control;
			s_s_vehicle_turning_control_definition turning_control;
			s_s_vehicle_engine_definition engine;

			/* wheel circumferance */

			real wheel_circumferance$2;
			real gravity_adjust;
			real antiroll_torque_factor;
			s_scalarfunctionname air_control_torque_function;
			real air_control_torque_max;
			// custom wheel_identification
			short front_left_wheel;
			short front_right_wheel;
			short back_left_wheel;
			short back_right_wheel;
			// custom value
		};
		static_assert(sizeof(s_s_vehicle_human_jeep_definition) == 132, "struct s_s_vehicle_human_jeep_definition is invalid size");

		struct s_s_vehicle_steering_animation_definition
		{

			/* steering animation and interpolation
 */

			real interpolation_scale;
			angle max_angle;
		};
		static_assert(sizeof(s_s_vehicle_steering_animation_definition) == 8, "struct s_s_vehicle_steering_animation_definition is invalid size");

		struct s_s_vehicle_human_plane_definition
		{

			/* velocity control variables */

			real maximum_forward_speed;
			real maximum_reverse_speed;
			real speed_acceleration;
			real speed_deceleration;
			real speed_accel_against_direction;
			real maximum_forward_speed_during_boost;
			real maximum_left_slide;
			real maximum_right_slide;
			real slide_acceleration;
			real slide_deceleration;
			real slide_accel_against_direction;
			real maximum_slide_speed_during_boost;
			real maximum_up_rise;
			real maximum_down_rise;
			real rise_acceleration;
			real rise_deceleration;
			real rise_accel_against_direction;
			real maximum_rise_speed_during_boost;

			/* human plane tuning variables */

			real flying_torque_scale;
			real air_friction_deceleration;
			real thrust_scale;
			real turn_rate_scale_when_boosting;
			real maximum_roll;
			s_s_vehicle_steering_animation_definition steering_animation;
		};
		static_assert(sizeof(s_s_vehicle_human_plane_definition) == 100, "struct s_s_vehicle_human_plane_definition is invalid size");

		struct s_s_engine_function_definition
		{
			string_id object_function_damage_region;
			real min_anti_gravity_engine_speed;
			real max_anti_gravity_engine_speed;
			real engine_speed_acceleration;
			real maximum_vehicle_speed;
		};
		static_assert(sizeof(s_s_engine_function_definition) == 20, "struct s_s_engine_function_definition is invalid size");

		struct s_scoutphysicsdefinition
		{
			c_flags<e_scoutphysicsdefinitionscoutflags, char, k_scoutphysicsdefinitionscoutflags_count> flags;
			char generated_padddec[3]; // padding

			/* Air control */

			real air_control_angular_velocity_factor;
			real air_control_throttle_acceleration;
			real air_control_throttle_bonus_clamp_min;
			real air_control_throttle_bonus_clamp_max;
			real air_control_angular_acceleration;
			real_fraction air_control_auto_level_strength;

			/* Brake control */

			real brake_lift_angular_acceleration;
			real brake_lift_acceleration_up;
			real brake_airborne_lift_acceleration_forward;
			real brake_airborne_lift_acceleration_up;
		};
		static_assert(sizeof(s_scoutphysicsdefinition) == 44, "struct s_scoutphysicsdefinition is invalid size");

		struct s_s_vehicle_alien_scout_definition
		{
			s_s_vehicle_steering_control_definition steering_control;

			/* velocity control variables */

			real maximum_forward_speed;
			real maximum_reverse_speed;
			real speed_acceleration;
			real speed_deceleration;
			real maximum_left_slide;
			real maximum_right_slide;
			real slide_acceleration;
			real slide_deceleration;
			real ai_deceleration_multiplier;
			real slide_accel_against_direction;
			real slide_speed_at_top_speed;
			c_flags<e_s_vehicle_alien_scout_definitionc_flags, char, k_s_vehicle_alien_scout_definitionc_flags_count> flags;
			char generated_pad1c8d[3]; // padding
			real drag_coeficient;
			real constant_deceleration;
			real torque_scale;

			/* engine object function */

			s_s_engine_function_definition engine_gravity_function;

			/* contrail object function */

			s_s_engine_function_definition contrail_gravity_function;

			/* engine rotation function */

			real_bounds gear_rotation_speed;
			s_s_vehicle_steering_animation_definition steering_animation;
			s_scoutphysicsdefinition scout_physics;
		};
		static_assert(sizeof(s_s_vehicle_alien_scout_definition) == 184, "struct s_s_vehicle_alien_scout_definition is invalid size");

		struct s_s_vehicle_alien_fighter_definition
		{
			s_s_vehicle_steering_control_definition steering_control;
			s_s_vehicle_turning_control_definition turning_control;

			/* velocity control variables */

			real maximum_forward_speed;
			real maximum_reverse_speed;
			real speed_acceleration;
			real speed_deceleration;
			real boost_maximum_forward_speed;
			real boost_maximum_reverse_speed;
			real boost_speed_acceleration;
			real boost_speed_deceleration;
			real maximum_left_slide;
			real maximum_right_slide;
			real slide_acceleration;
			real slide_deceleration;
			real slide_accel_against_direction;

			/* torque scale */

			real flying_torque_scale;
			real flying_torque_cap_cusp;
			real flying_torque_cap_exponent;

			/* fixed gun offset */

			angle fixed_gun_yaw;
			angle fixed_gun_pitch;

			/* alien fighter trick variables */

			real maximum_trick_frequency;
			real loop_trick_duration;
			real roll_trick_duration;

			/* alien fighter fake flight control */

			real zero_gravity_speed;
			real full_gravity_speed;
			real strafe_boost_scale;
			real off_stick_deceleration_scale;
			real cruising_throttle;
			real dive_speed_scale;
		};
		static_assert(sizeof(s_s_vehicle_alien_fighter_definition) == 144, "struct s_s_vehicle_alien_fighter_definition is invalid size");

		struct s_s_vehicle_turret_definition
		{
			c_flags<e_s_vehicle_turret_definitionc_flags, short, k_s_vehicle_turret_definitionc_flags_count> flags;
			char generated_pad4605[2]; // padding
			string_id physical_yaw_node;
			string_id physical_pitch_node;
			string_id physical_elevate_node;
			angle operating_elevation_angle;
		};
		static_assert(sizeof(s_s_vehicle_turret_definition) == 20, "struct s_s_vehicle_turret_definition is invalid size");

		struct s_s_vtol_descent_function
		{
			s_scalarfunctionname descent_to_boost;
			real max_downward_speed;
		};
		static_assert(sizeof(s_s_vtol_descent_function) == 24, "struct s_s_vtol_descent_function is invalid size");

		struct s_s_vehicle_vtol_interpolated_parameters
		{
			real rotor_damping;
			real maximum_left_acceleration;
			real maximum_forward_acceleration;
			real drag_coeficient;
			real constant_deceleration;
			real magic_angular_acc_exp;
			real magic_angular_acc_scale;
			real magic_angular_acc_k;
		};
		static_assert(sizeof(s_s_vehicle_vtol_interpolated_parameters) == 32, "struct s_s_vehicle_vtol_interpolated_parameters is invalid size");

		struct s_s_vehicle_vtol_definition
		{
			s_s_vehicle_turning_control_definition turning_control;
			// custom value
			string_id left_lift_marker;
			// custom value
			string_id right_lift_marker;
			// custom value
			string_id thrust_marker;
			s_scalarfunctionname trigger_to_throttle;
			s_s_vtol_descent_function descent_to_boost;

			/* minimum and maximum up acceleration */

			real maximum_up_acceleration;
			real maximum_down_acceleration;
			real vertical_deceleration_time;

			/* lift arm pivot */

			real lift_arm_pivot_length;
			real lift_arm_pivot_length_negative_z;

			/* turn, left and forward accelerations */

			real maximum_turn_acceleration;
			real turn_acceleration_gain;

			/* interpolation parameters */

			real interpolation_speed_domain;

			/* function explanation */

			s_scalarfunctionname speed_trottle_ceiling;
			s_scalarfunctionname interpolation_acc;
			s_scalarfunctionname a_b_interpolation_interpolation_mapping;
			c_typed_tag_block<s_s_vehicle_vtol_interpolated_parameters> speed_interpolated_parameters_block;
			angle lift_angles_acc;
			real alt_lock_offset_coefficient;
			real alt_lock_velocity_coefficient;

			/* prop rotation */

			real_bounds prop_rotation_speed;

			/* landing */

			real landing_time;
			real takeoff_time;
			real landing_linear_velocity;
			real landing_angular_velocity;
			real auto_take_off_height_offset;
			c_flags<e_vehiclevtoldefinitionflags, short, k_vehiclevtoldefinitionflags_count> flags;
			char generated_padac32[2]; // padding

			/* dodge boost */

			s_scalarfunctionnamedefaultone dodge_boost_force_application;
			s_scalarfunctionnamedefaultone dodge_boost_velocity;
			real dodge_boost_trigger_time;
			real dodge_boost_duration;
			real dodge_boost_recharge_duration;
			c_typed_tag_reference<DAMAGE_RESPONSE_DEFINITION_TAG> dodge_boost_damage_response;

			/* steering overdampening */

			s_s_vehicle_steering_control_definition steering_control;
		};
		static_assert(sizeof(s_s_vehicle_vtol_definition) == 308, "struct s_s_vehicle_vtol_definition is invalid size");

		struct s_s_vehicle_chopper_definition
		{
			s_s_vehicle_steering_control_definition steering_control;
			s_s_vehicle_turning_control_definition turning_control;
			s_s_vehicle_engine_definition engine;
			real wheel_circumferance;
			real_vector3d pivot_offset;

			/* Yaw Correction */

			real yaw_correction_coefficient_2;
			real yaw_correction_coefficient_1;
			real yaw_correction_coefficient_0;
			real bank_to_slide_ratio;
			real bank_slide_exponent;
			real bank_to_turn_ratio;
			real bank_turn_exponent;
			real bank_fraction;
			real bank_rate;
			real wheel_accel;
			real gyroscopic_damping;
		};
		static_assert(sizeof(s_s_vehicle_chopper_definition) == 148, "struct s_s_vehicle_chopper_definition is invalid size");

		struct s_s_vehicle_guardian_definition
		{
			s_s_vehicle_steering_control_definition steering_control;
			real maximum_forward_speed;
			real maximum_reverse_speed;
			real speed_acceleration;
			real speed_deceleration;
			real maximum_left_slide;
			real maximum_right_slide;
			real slide_acceleration;
			real slide_deceleration;
			real torque_scale;
			real anti_gravity_force_z_offset;
		};
		static_assert(sizeof(s_s_vehicle_guardian_definition) == 64, "struct s_s_vehicle_guardian_definition is invalid size");

		struct s_s_flight_surface_definition
		{
			c_enum<e_dimensions3d, char> offset_axis;
			c_enum<e_dimensions3d, char> pivot_axis;
			c_enum<e_dimensions3d, char> rotation_axis;
			c_enum<e_dimensions3d, char> normal_axis;
			real offset_distance;
			real pivot_distance;

			/* normal force */

			real q;
			real k;
			real function_ceiling;
			angle maximum_angle;
			real render_debug_radius;
		};
		static_assert(sizeof(s_s_flight_surface_definition) == 32, "struct s_s_flight_surface_definition is invalid size");

		struct s_s_vehicle_jackal_glider_drag_definition
		{

			/* drag */

			real q;
			real k;
			real constant_deceleration;
		};
		static_assert(sizeof(s_s_vehicle_jackal_glider_drag_definition) == 12, "struct s_s_vehicle_jackal_glider_drag_definition is invalid size");

		struct s_s_vehicle_jackal_glider_definition
		{
			s_s_vehicle_steering_control_definition steering_control;

			/* velocity control variables */

			real maximum_forward_speed;
			real maximum_reverse_speed;
			real speed_acceleration;
			real speed_deceleration;
			real maximum_left_slide;
			real maximum_right_slide;
			real slide_acceleration;
			real slide_deceleration;
			real torque_scale;

			/* engine object function */

			s_s_engine_function_definition engine_object_function$2;

			/* contrail object function */

			s_s_engine_function_definition contrail_object_function$2;
			s_s_vehicle_steering_animation_definition steering_animation;
			real flying_velocity_threshold;
			angle flying_look_threshold;
			real flying_hover_threshold;
			real grounded_hover_threshold;
			real landing_grounded_time;
			angle ground_turn_radius;
			real ground_acceleration;

			/* wing lift */

			real wing_lift_q;
			real wing_lift_k;
			real wing_lift_function_ceiling;
			real aileron_to_angular_acceleartion_scale;
			angle aileron_yaw_tilt_angle;

			/* wing */

			s_s_flight_surface_definition wing_surface;

			/* ailerons */

			s_s_flight_surface_definition aileron_surface;

			/* elevator */

			s_s_flight_surface_definition elevator_surface;

			/* tail */

			s_s_flight_surface_definition tail_surface;

			/* rudder */

			s_s_flight_surface_definition rudder_surface;

			/* taxi */

			s_s_flight_surface_definition taxi_surface;

			/* ground drag */

			s_s_vehicle_jackal_glider_drag_definition ground_drag_struct;

			/* air drag */

			s_s_vehicle_jackal_glider_drag_definition air_drag_struct;

			/* takeoff drag */

			s_s_vehicle_jackal_glider_drag_definition takeoff_drag_struct;
		};
		static_assert(sizeof(s_s_vehicle_jackal_glider_definition) == 384, "struct s_s_vehicle_jackal_glider_definition is invalid size");

		struct s_s_vehicle_space_fighter_definition
		{
			s_s_vehicle_steering_control_definition steering_control;
			s_s_vehicle_turning_control_definition turning_control;

			/* velocity control variables */

			real full_throttle_speed;
			real neutral_throttle_speed;
			real reverse_throttle_speed;
			real speed_acceleration;
			real speed_deceleration;
			real maximum_left_slide;
			real maximum_right_slide;
			real slide_acceleration;
			real slide_deceleration;
			real slide_accel_against_direction;

			/* torque scale */

			real flying_torque_scale;

			/* fixed gun offset */

			angle fixed_gun_yaw;
			angle fixed_gun_pitch;

			/* alien fighter trick variables */

			real maximum_trick_frequency;
			real loop_trick_duration;
			real roll_trick_duration;

			/* alien fighter fake flight control */

			real strafe_boost_scale;
			real off_stick_deceleration_scale;
			real dive_speed_scale;
			angle roll_max_velocity;
			angle roll_acceleration;
			angle roll_deceleration;
			real_fraction roll_smoothing_fraction;

			/* autolevel */

			real autolevel_time;
			angle autolevel_pitch_cutoff;
			angle autolevel_max_velocity;
			angle autolevel_max_acceleration;
			angle autolevel_max_user_ang_vel;
			real autolevel_spring_k;
			real autolevel_spring_c;

			/* cosmetic roll */

			real cosmetic_roll_scale;
			angle cosmetic_roll_max_bank;
			angle cosmetic_roll_max_velocity;
			angle cosmetic_roll_acceleration;
			real cosmetic_roll_spring_k;
			real cosmetic_roll_spring_c;

			/* new roll */

			c_flags<e_s_vehicle_space_fighter_definitionc_roll_flags, long, k_s_vehicle_space_fighter_definitionc_roll_flags_count> roll_flags;
			angle maximum_left_stick_roll_angle;
			real left_stick_rate_smoothing;
			real left_stick_trend_smoothing;
			angle maximum_right_stick_roll_angle;
			real right_stick_rate_smoothing;
			real right_stick_trend_smoothing;

			/* turn deceleration */

			angle turn_deceleration_threshold;
			real_fraction turn_deceleration_fraction;

			/* soft ceiling turn back */

			c_flags<e_s_vehicle_space_fighter_definitionc_turn_back_flags, long, k_s_vehicle_space_fighter_definitionc_turn_back_flags_count> turn_back_flags;
			real turn_back_latched_period;
			s_scalarfunctionname turn_back_distance_to_turn_rate;

			/* thrust params */

			real ideal_thrust_decay;
			real ideal_thrust_increase;
			real minimum_thrust_decay;
			real minimum_thrust_increase;
			real maximum_thrust_increase;

			/* dive params */

			real minimum_dive_angle;
			real maximum_dive_angle;

			/* strafe params */

			real strafe_boost_power;

			/* wingtip params */

			real wingtip_contrail_turn;
			real wingtip_min_turn;

			/* Safety */

			real dangerous_trajectory_prediction_time;
		};
		static_assert(sizeof(s_s_vehicle_space_fighter_definition) == 288, "struct s_s_vehicle_space_fighter_definition is invalid size");

		struct s_s_vehicle_revenant_definition
		{
			s_s_vehicle_human_tank_definition tank_block;

			/* velocity control variables */

			real maximum_forward_speed;
			real maximum_reverse_speed;
			real speed_acceleration;
			real speed_deceleration;
			real maximum_left_slide;
			real maximum_right_slide;
			real slide_acceleration;
			real slide_deceleration;
			s_scoutphysicsdefinition scout_physics;
			real drag_coeficient;
			real constant_deceleration;
			real torque_scale;
		};
		static_assert(sizeof(s_s_vehicle_revenant_definition) == 240, "struct s_s_vehicle_revenant_definition is invalid size");

		struct s_s_vehicle_physics_types
		{
			// custom value
			c_typed_tag_block<s_s_vehicle_human_tank_definition> type_human_tank_block;
			c_typed_tag_block<s_s_vehicle_human_jeep_definition> type_human_jeep_block;
			c_typed_tag_block<s_s_vehicle_human_plane_definition> type_human_plane_block;
			c_typed_tag_block<s_s_vehicle_alien_scout_definition> type_alien_scout_block;
			c_typed_tag_block<s_s_vehicle_alien_fighter_definition> type_alien_fighter_block;
			c_typed_tag_block<s_s_vehicle_turret_definition> type_turret_block;
			c_typed_tag_block<s_s_vehicle_vtol_definition> type_vtol_block;
			c_typed_tag_block<s_s_vehicle_chopper_definition> type_chopper_block;
			c_typed_tag_block<s_s_vehicle_guardian_definition> type_guardian_block;
			c_typed_tag_block<s_s_vehicle_jackal_glider_definition> type_jackal_glider_block;
			c_typed_tag_block<s_s_vehicle_space_fighter_definition> type_space_fighter_block;
			c_typed_tag_block<s_s_vehicle_revenant_definition> type_revenant_block;
			// custom value
		};
		static_assert(sizeof(s_s_vehicle_physics_types) == 144, "struct s_s_vehicle_physics_types is invalid size");

		struct s_i343vehiclesantigravitypointconfiguration
		{
			string_id name;

			/* Operational Range- Height */

			real inner_distance;
			real outer_distance;

			/* Banking */

			real banking_lift;
			real steering_banking_factor;

			/* Maximum Lifting Force */

			real strength;

			/* Error */

			real_fraction error$2;

			/* Operational Range- Orientation */

			angle inner_rotational_limit;
			angle outer_rotational_limit;

			/* Damping */

			real compression_damping;
			real extension_damping;
			// custom ground_impact_effects
			c_typed_tag_reference<MATERIAL_EFFECTS_TAG> combined_material_effects;
			c_typed_tag_reference<VISUALMATERIALEFFECTSDEFINITION_TAG> visual_material_effects;
			c_typed_tag_reference<SOUNDMATERIALEFFECTSDEFINITION_TAG> sound_material_effects;
			// custom value
		};
		static_assert(sizeof(s_i343vehiclesantigravitypointconfiguration) == 92, "struct s_i343vehiclesantigravitypointconfiguration is invalid size");

		struct s_i343vehiclesantigravitypointstateconfiguration
		{
			c_enum<e_modelstates, short> region_state;
			short configuration;
		};
		static_assert(sizeof(s_i343vehiclesantigravitypointstateconfiguration) == 4, "struct s_i343vehiclesantigravitypointstateconfiguration is invalid size");

		struct s_i343vehiclesantigravitypointdefinition
		{
			// custom value
			string_id marker_name;
			string_id region_name;
			long runtime_region_index;
			// custom value
			string_id looping_sound_marker;
			c_typed_tag_block<s_i343vehiclesantigravitypointstateconfiguration> state_configurations_block;
		};
		static_assert(sizeof(s_i343vehiclesantigravitypointdefinition) == 28, "struct s_i343vehiclesantigravitypointdefinition is invalid size");

		struct s_i343vehiclesfrictionpointconfiguration
		{
			string_id name;
			real radius;

			/* Normal Force Simulation */

			real ground_depth;
			real ground_damp_factor;

			/* Physics Simulation Noise Reduction */

			real_fraction ground_normal_blend_rate;
			real max_normal_force_contribution_to_friction;

			/* Traction */

			real static_friction;
			real kinetic_friction;
			real slide_speed_difference;
			real e_brake_static_friction;
			real e_brake_kinetic_friction;
			real e_brake_slide_speed_difference;
			real ai_static_friction_override;
			real ai_kinetic_friction_override;
			angle world_space_slope_to_stop_all_traction;
			angle local_space_slope_to_start_traction_loss;
			angle local_space_slope_to_stop_all_traction;
			angle local_space_slope_to_stop_hit_checks;

			/* Grounded Vehicle Stabilizing Torque */

			s_scalarfunctionname grounded_speed_to_down_torque_function;
			s_scalarfunctionname nearly_grounded_speed_to_down_torque_function;
			// custom ground_impact_effects
			c_typed_tag_reference<MATERIAL_EFFECTS_TAG> combined_material_effects;
			c_typed_tag_reference<VISUALMATERIALEFFECTSDEFINITION_TAG> visual_material_effects;
			c_typed_tag_reference<SOUNDMATERIALEFFECTSDEFINITION_TAG> sound_material_effects;
			// custom value
			c_flags<e_i343vehiclesfrictionpointconfigurationflags, long, k_i343vehiclesfrictionpointconfigurationflags_count> flags;
		};
		static_assert(sizeof(s_i343vehiclesfrictionpointconfiguration) == 164, "struct s_i343vehiclesfrictionpointconfiguration is invalid size");

		struct s_i343vehiclesfrictionpointstateconfiguration
		{
			c_enum<e_modelstates, short> region_state;
			short configuration;
		};
		static_assert(sizeof(s_i343vehiclesfrictionpointstateconfiguration) == 4, "struct s_i343vehiclesfrictionpointstateconfiguration is invalid size");

		struct s_i343vehiclesfrictionpointdefinition
		{
			// custom value
			string_id marker_name;
			string_id region_name;
			long runtime_region_index;
			real_fraction load_fraction;
			real turn_ratio;
			c_flags<e_i343vehiclesfrictionpointdefinitionflags, long, k_i343vehiclesfrictionpointdefinitionflags_count> flags;
			// custom value
			string_id looping_sound_marker;
			string_id grinding_object_function;
			string_id rolling_object_function;
			c_typed_tag_block<s_i343vehiclesfrictionpointstateconfiguration> state_configurations_block;
		};
		static_assert(sizeof(s_i343vehiclesfrictionpointdefinition) == 48, "struct s_i343vehiclesfrictionpointdefinition is invalid size");

		struct s_i343vehiclesvehiclephysicsdefinition
		{
			real gravity_scale;
			long iteration_count;
			c_typed_tag_block<s_i343vehiclesantigravitypointconfiguration> anti_gravity_point_configurations_block;
			c_typed_tag_block<s_i343vehiclesantigravitypointdefinition> anti_gravity_points_block;
			c_typed_tag_block<s_i343vehiclesfrictionpointconfiguration> friction_point_configurations_block;
			c_typed_tag_block<s_i343vehiclesfrictionpointdefinition> friction_points_block;

			/* Grounded Vehicle Stabilizing Downforce */

			real maximum_speed_for_downforce;
			angle angle_to_exclude_downforce;
			s_scalarfunctionname grounded_speed_to_com_downforce_function;
			s_scalarfunctionname nearly_grounded_speed_to_com_downforce_function;

			/* Airborne Vehicle Rotational Stabilization */

			real_vector3d airborne_angular_stabilization_coefficients;
		};
		static_assert(sizeof(s_i343vehiclesvehiclephysicsdefinition) == 116, "struct s_i343vehiclesvehiclephysicsdefinition is invalid size");

		struct s_s_unit_trick_definition
		{
			string_id animation_name;
			c_enum<e_c_unit_trick_activation_type, char> activation_type;
			c_enum<e_c_unit_trick_velocity_preservation_mode, char> velocity_preservation;
			c_flags<e_c_unit_trick_flags, char, k_c_unit_trick_flags_count> flags;
			char generated_pad983c[1]; // padding
			real camera_interpolation_time;
			real trick_exit_time;
			real_bounds trick_exit_camera_interpolation_time;
			real trick_exit_displacement_reference;
			real cooldown_time;
			c_enum<e_i343collectibletutorial, long> tutorial_id;
		};
		static_assert(sizeof(s_s_unit_trick_definition) == 36, "struct s_s_unit_trick_definition is invalid size");

		struct s_s_vehicleaicruisecontrol
		{

			/* ai speed control */

			real proportional;
			real integral;
			real derivative;
			real slow_down_rate;
		};
		static_assert(sizeof(s_s_vehicleaicruisecontrol) == 16, "struct s_s_vehicleaicruisecontrol is invalid size");

		struct s_vehicledefinition
		{
			s_unitdefinition unit;
			// custom $$$_vehicle_$$$
			c_flags<e_c_vehicle_definition_flags, long, k_c_vehicle_definition_flags_count> flags;

			/* physics type */

			s_s_vehicle_physics_types physics_types;

			/* General Vehicle Physics */

			s_i343vehiclesvehiclephysicsdefinition havok_vehicle_physics;
			c_typed_tag_block<s_s_unit_trick_definition> tricks_block;
			c_enum<e_player_training_vehicle_type, char> player_training_vehicle_type;
			c_enum<e_vehiclesize, char> vehicle_size;
			char complex_suspension_sample_count;
			char generated_pad9b33[1]; // padding
			angle complex_suspension_distribution_angle;
			real complex_suspension_wheel_diameter;
			real complex_suspension_wheel_width;
			real minimum_flipping_angular_velocity;
			real maximum_flipping_angular_velocity;
			angle upside_down_angle;
			real crouch_transition_time;
			real hoojytsu;
			real seat_enterance_acceleration_scale;
			real seat_exit_accelersation_scale;
			string_id blur_function_name;
			real blur_speed;
			string_id flip_message;

			/* sounds and effects */

			c_typed_tag_reference<SOUNDBANK_TAG> player_vehicle_sound_bank;
			c_typed_tag_reference<MATERIAL_EFFECTS_TAG> surface_sound_material_effects;
			c_typed_tag_reference<SOUND_TAG> light_suspension_sound;
			real light_suspension_sound_displacement_threshold;
			c_typed_tag_reference<SOUND_TAG> medium_suspension_sound;
			real medium_suspension_sound_displacement_threshold;
			c_typed_tag_reference<SOUND_TAG> hard_suspension_sound;
			real hard_suspension_sound_displacement_threshold;
			real fake_audio_speed___speed_increase_amount;
			real fake_audio_speed___boost_speed_increase_amount;
			real fake_audio_speed___speed_decrease_amount;
			real fake_audio_speed___non_boost_limit;
			real fake_audio_speed___max_speed_scale;
			c_typed_tag_block<s_soundrtpcblockdefinition> sound_rtpcs_block;
			c_typed_tag_block<s_soundsweetenerblockdefinition> sound_sweeteners_block;
			c_typed_tag_reference<EFFECT_TAG> special_effect;
			s_tag_reference driver_boost_damage_effect_or_response;
			s_tag_reference rider_boost_damage_effect_or_response;
			string_id vehicle_name;
			c_typed_tag_block<s_s_vehicleaicruisecontrol> ai_cruise_control_block;
			c_typed_tag_block<s_interfaceuiiteminfo> ui_display_info_block;
			c_typed_tag_reference<UIVEHICLEDISPLAYINFODEFINITION_TAG> ui_vehicle_display_info;
			c_enum<e_interfacenavpointespritesequence, long> vehicle_nav_point_sequence_index;
			// custom value
		};
		static_assert(sizeof(s_vehicledefinition) == 3108, "struct s_vehicledefinition is invalid size");

		struct s_i343effectsvisualmaterialeffectsblock
		{
			c_typed_tag_block<s_s_material_effect_material> effects_block;
		};
		static_assert(sizeof(s_i343effectsvisualmaterialeffectsblock) == 12, "struct s_i343effectsvisualmaterialeffectsblock is invalid size");

		struct s_i343effectsvisualmaterialeffectsdefinition
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_block<s_i343effectsvisualmaterialeffectsblock> effects_block;
			char generated_pad4a67[4]; // padding
		};
		static_assert(sizeof(s_i343effectsvisualmaterialeffectsdefinition) == 32, "struct s_i343effectsvisualmaterialeffectsdefinition is invalid size");

		struct s_i343weaponrecoilviewkickpropertymodifiersdefinition
		{
			real view_kick_deceleration_modifier;
			real view_kick_return_to_center_modifier;
		};
		static_assert(sizeof(s_i343weaponrecoilviewkickpropertymodifiersdefinition) == 8, "struct s_i343weaponrecoilviewkickpropertymodifiersdefinition is invalid size");

		struct s_i343weaponrecoilgunkickpropertymodifiersdefinition
		{
			real gunkick_spring_constant_modifier;
		};
		static_assert(sizeof(s_i343weaponrecoilgunkickpropertymodifiersdefinition) == 4, "struct s_i343weaponrecoilgunkickpropertymodifiersdefinition is invalid size");

		struct s_i343weaponheatpropertymodifiersdefinition
		{
			real heat_loss_per_second_modifier;
			real overheated_heat_loss_per_second_modifier;
			real heat_generated_per_round_modifier;
		};
		static_assert(sizeof(s_i343weaponheatpropertymodifiersdefinition) == 12, "struct s_i343weaponheatpropertymodifiersdefinition is invalid size");

		struct s_i343weaponaimassistpropertymodifiersdefinition
		{
			real autoaim_angle;
			real prioritization_angle;
			real autoaim_range;
			real autoaim_falloff_range;
			real autoaim_near_falloff_range;
			real magnetism_angle;
			real magnetism_range;
			real magnetism_falloff_range;
			real magnetism_near_falloff_range;
			real deviation_angle;
		};
		static_assert(sizeof(s_i343weaponaimassistpropertymodifiersdefinition) == 40, "struct s_i343weaponaimassistpropertymodifiersdefinition is invalid size");

		struct s_i343weaponaccuracypropertymodifiersdefinition
		{
			real accuracy_spread;
		};
		static_assert(sizeof(s_i343weaponaccuracypropertymodifiersdefinition) == 4, "struct s_i343weaponaccuracypropertymodifiersdefinition is invalid size");

		struct s_i343weaponunitpropertymodifiersdefinition
		{
			real move_speed_scale_modifier;
			real turn_rate_scale_modifier;
			real simulated_input_scale_modifier;
		};
		static_assert(sizeof(s_i343weaponunitpropertymodifiersdefinition) == 12, "struct s_i343weaponunitpropertymodifiersdefinition is invalid size");

		struct s_i343weaponaltfirecomponentdefinition
		{
			s_anytag_struct_definition anytag;
			c_flags<e_i343weaponaltfireflags, char, k_i343weaponaltfireflags_count> alt_fire_flags;
			char generated_pada038[3]; // padding
			c_typed_tag_reference<OUTLINETYPEDEFINITION_TAG> target_tracking_outline;
			real alt_fire_animation_transition_in_time;
			real alt_fire_animation_transition_out_time;
			real weapon_fov_scale;
			real_point3d alt_fire_translation_offset;

			/* alt-fire percent to offset percent */

			s_scalarfunctionname alt_fire_percent_to_offset_percent$2;
			string_id alt_fire_animation_mode;
			c_typed_tag_block<s_i343weaponrecoilviewkickpropertymodifiersdefinition> recoil_view_kick_modifiers_block;
			c_typed_tag_block<s_i343weaponrecoilgunkickpropertymodifiersdefinition> recoil_gunkick_modifiers_block;
			c_typed_tag_block<s_i343weaponheatpropertymodifiersdefinition> heat_modifiers_block;
			c_typed_tag_block<s_i343weaponaimassistpropertymodifiersdefinition> aim_assist_modifiers_block;
			c_typed_tag_block<s_i343weaponaccuracypropertymodifiersdefinition> accuracy_modifiers_block;
			c_typed_tag_block<s_i343weaponunitpropertymodifiersdefinition> unit_modifiers_block;
			c_typed_tag_reference<SOUND_TAG> activate_sound;
			c_typed_tag_reference<SOUND_TAG> deactivate_sound;
			char generated_padba19[4]; // padding
		};
		static_assert(sizeof(s_i343weaponaltfirecomponentdefinition) == 192, "struct s_i343weaponaltfirecomponentdefinition is invalid size");

		struct s_i343weapongenericattachmentdefinition
		{
			c_typed_tag_reference<WEAPON_ATTACHMENT_TAG> attachment;
		};
		static_assert(sizeof(s_i343weapongenericattachmentdefinition) == 16, "struct s_i343weapongenericattachmentdefinition is invalid size");

		struct s_i343weaponweaponconfigurationdefinitioninternal
		{
			string_id variant_name;
			c_typed_tag_block<s_i343weapongenericattachmentdefinition> generic_attachments_block;
			c_typed_tag_reference<WEAPON_ATTACHMENT_BARREL_TAG> barrel_attachment;
			c_typed_tag_reference<WEAPON_ATTACHMENT_HEAT_TAG> heat_attachment;
			c_typed_tag_reference<WEAPON_ATTACHMENT_MAGAZINE_TAG> magazine_attachment;
			c_typed_tag_reference<WEAPON_ATTACHMENT_MELEE_TAG> melee_attachment;
			c_typed_tag_reference<WEAPON_ATTACHMENT_SIGHT_TAG> sight_attachment;
			c_typed_tag_reference<WEAPON_ATTACHMENT_TARGET_TRACKING_TAG> target_tracking_attachment;
			c_typed_tag_reference<WEAPON_ATTACHMENT_TRIGGER_TAG> trigger_attachment;

			/* WARNING */

			c_typed_tag_reference<GENERICMODIFIERDEFINITIONTAG_TAG> unit_modifier_set;
			c_typed_tag_reference<UIWEAPONDISPLAYINFODEFINITION_TAG> ui_display_info;
		};
		static_assert(sizeof(s_i343weaponweaponconfigurationdefinitioninternal) == 160, "struct s_i343weaponweaponconfigurationdefinitioninternal is invalid size");

		struct s_i343weaponweaponconfigurationdefinition
		{
			s_i343objectsobjectconfigurationdefinition object_configuration;
			// custom weapon
			s_i343weaponweaponconfigurationdefinitioninternal weapon;
			// custom value
			char generated_padb818[4]; // padding
		};
		static_assert(sizeof(s_i343weaponweaponconfigurationdefinition) == 228, "struct s_i343weaponweaponconfigurationdefinition is invalid size");

		struct s_i343weapondepthoffieldinternaldefinition
		{

			/* depth of field */

			real world_blur_aperture;
			real world_blur_focus_max_distance;
			real_fraction world_blur_focus_smoothing_value;
			real_fraction world_blur_trend_smoothing_value;
			real_fraction world_blur_half_width_ratio;
			real weapon_blur_aperture;
			real weapon_blur_focus_distance;
			real weapon_blur_half_width;

			/* vignette */

			real_bounds vignette_radius_bounds;
			real_fraction vignette_intensity;
		};
		static_assert(sizeof(s_i343weapondepthoffieldinternaldefinition) == 44, "struct s_i343weapondepthoffieldinternaldefinition is invalid size");

		struct s_i343weapondepthoffielddefinition
		{
			s_anytag_struct_definition anytag;
			s_i343weapondepthoffieldinternaldefinition dof;
			char generated_paddff6[4]; // padding
		};
		static_assert(sizeof(s_i343weapondepthoffielddefinition) == 64, "struct s_i343weapondepthoffielddefinition is invalid size");

		struct s_i343weaponaimassistmodifierdefinition
		{
			s_anytag_struct_definition anytag;
			// custom weapon_aim_assist

			/* Aim Assist Override */

			c_typed_tag_block<s_i343weaponaimassistpropertymodifiersdefinition> aim_assist_modifiers_block;
			// custom value
			char generated_pad6673[4]; // padding
		};
		static_assert(sizeof(s_i343weaponaimassistmodifierdefinition) == 32, "struct s_i343weaponaimassistmodifierdefinition is invalid size");

		struct s_i343weaponattachmentregionpermutationdefinition
		{
			string_id region_name;
			string_id permutation_name;
		};
		static_assert(sizeof(s_i343weaponattachmentregionpermutationdefinition) == 8, "struct s_i343weaponattachmentregionpermutationdefinition is invalid size");

		struct s_i343weaponattachmentobjectcomponentdefinition
		{
			c_typed_tag_reference<OBJECT_TAG> object;
			string_id weapon_marker;
			string_id attachment_marker;
		};
		static_assert(sizeof(s_i343weaponattachmentobjectcomponentdefinition) == 24, "struct s_i343weaponattachmentobjectcomponentdefinition is invalid size");

		struct s_i343weaponprecisionaimpropertymodifiersdefinition
		{
			real precision_transition_in_time_modifier;
			real precision_transition_out_time_modifier;
		};
		static_assert(sizeof(s_i343weaponprecisionaimpropertymodifiersdefinition) == 8, "struct s_i343weaponprecisionaimpropertymodifiersdefinition is invalid size");

		struct s_i343weaponanimationpropertymodifiersdefinition
		{
			real ready_playback_speed_modifier;
			real ready_initial_playback_modifier;
			real put_away_playback_speed_modifier;
			real reload_playback_speed_modifier;
			real reload_while_empty_playback_speed_modifier;
		};
		static_assert(sizeof(s_i343weaponanimationpropertymodifiersdefinition) == 20, "struct s_i343weaponanimationpropertymodifiersdefinition is invalid size");

		struct s_i343weaponattachmentcomponentdefinition
		{
			// custom weapon_attachment
			string_id variant_region_name;
			string_id variant_permutation_name;
			c_typed_tag_block<s_i343weaponattachmentregionpermutationdefinition> region_permutations_block;
			c_typed_tag_block<s_object_attachment_definition> attachments_block;

			/* Attachment Name */

			s_i343damageattachmentnamedefinition attachmentname;
			c_typed_tag_block<s_i343weaponattachmentobjectcomponentdefinition> attachment_object_block;
			c_typed_tag_block<s_i343weaponaccuracypropertymodifiersdefinition> accuracy_modifiers_block;
			c_typed_tag_block<s_i343weaponprecisionaimpropertymodifiersdefinition> precision_aim_modifiers_block;
			c_typed_tag_block<s_i343weaponunitpropertymodifiersdefinition> unit_modifiers_block;
			c_typed_tag_block<s_i343weaponaimassistpropertymodifiersdefinition> aim_assist_modifiers_block;
			c_typed_tag_reference<WEAPON_AIM_ASSIST_MODIFIERS_TAG> aim_assist_reference;
			c_typed_tag_block<s_i343weaponrecoilviewkickpropertymodifiersdefinition> recoil_view_kick_modifiers_block;
			c_typed_tag_block<s_i343weaponrecoilgunkickpropertymodifiersdefinition> recoil_gunkick_modifiers_block;
			c_typed_tag_block<s_i343weaponanimationpropertymodifiersdefinition> animation_modifiers_block;
			c_typed_tag_block<s_i343weaponheatpropertymodifiersdefinition> heat_modifiers_block;
			c_typed_tag_block<s_interfaceuiiteminfo> ui_display_info_block;
			// custom value
		};
		static_assert(sizeof(s_i343weaponattachmentcomponentdefinition) == 172, "struct s_i343weaponattachmentcomponentdefinition is invalid size");

		struct s_i343weaponbarrelspinningdefinition
		{
			// custom barrel_spinning
			real idle_spin_speed;
			real ready_spin_speed;
			real firing_rate_scalar;
			real spin_up_time;
			real spin_down_time;
			// custom value
		};
		static_assert(sizeof(s_i343weaponbarrelspinningdefinition) == 20, "struct s_i343weaponbarrelspinningdefinition is invalid size");

		struct s_i343weaponbarrelfiringdefinition
		{
			real_bounds rounds_per_second;
			string_id rate_of_fire_acceleration;
			real acceleration_time;
			string_id rate_of_fire_deceleration;
			real deceleration_time;
			real barrel_spin_scale;
			s_i343weaponbarrelspinningdefinition barrel_spin_scalars;
			real_fraction blurred_rate_of_fire;
			short_bounds shots_per_fire;
			real fire_recovery_time;
			real_fraction soft_recovery_fraction;
			real melee__fire_recovery_time;
			real_fraction melee_soft_recovery_fraction;
			real runtime_rate_of_fire_acceleration_rate;
			real runtime_rate_of_fire_deceleration_rate;
		};
		static_assert(sizeof(s_i343weaponbarrelfiringdefinition) == 80, "struct s_i343weaponbarrelfiringdefinition is invalid size");

		struct s_i343weaponbarrelfiringparam
		{
			s_i343weaponbarrelfiringdefinition firing_params;
		};
		static_assert(sizeof(s_i343weaponbarrelfiringparam) == 80, "struct s_i343weaponbarrelfiringparam is invalid size");

		struct s_i343weaponeffectreferenceblockdefinition
		{
			s_tag_reference effect;
		};
		static_assert(sizeof(s_i343weaponeffectreferenceblockdefinition) == 16, "struct s_i343weaponeffectreferenceblockdefinition is invalid size");

		struct s_i343effectsmarkeroverrideblock
		{

			/* Marker overrides */

			// custom value
			string_id marker;
			// custom value
			string_id markeroverride;
		};
		static_assert(sizeof(s_i343effectsmarkeroverrideblock) == 8, "struct s_i343effectsmarkeroverrideblock is invalid size");

		struct s_i343weaponbarrelfiringeffect
		{
			s_tag_reference effect;
			c_flags<e_i343weaponbarrelfiringeffectflags, long, k_i343weaponbarrelfiringeffectflags_count> flags;
			c_typed_tag_block<s_i343weaponeffectreferenceblockdefinition> override_effects_block;
			c_typed_tag_block<s_i343effectsmarkeroverrideblock> marker_overrides_block;
		};
		static_assert(sizeof(s_i343weaponbarrelfiringeffect) == 44, "struct s_i343weaponbarrelfiringeffect is invalid size");

		struct s_i343weaponbarrelfiringeffectdefinition
		{
			short shot_count_lower_bound;
			short shot_count_upper_bound;

			/* firing effect */

			s_i343weaponbarrelfiringeffect firing_effect_overrides;

			/* critical effect */

			s_i343weaponbarrelfiringeffect critical_effect_overrides;

			/* misfire effect */

			s_i343weaponbarrelfiringeffect misfire_effect_overrides;

			/* empty effect */

			s_i343weaponbarrelfiringeffect empty_effect_overrides;

			/* optional secondary firing effect */

			s_i343weaponbarrelfiringeffect optional_secondary_firing_effect_overrides;
			s_tag_reference firing_effect$2;
			s_tag_reference critical_effect$2;
			s_tag_reference misfire_effect$2;
			s_tag_reference empty_effect$2;
			s_tag_reference optional_secondary_firing_effect$2;
			s_tag_reference firing_damage;
			s_tag_reference critical_damage;
			s_tag_reference misfire_damage;
			s_tag_reference empty_damage;
			s_tag_reference optional_secondary_firing_damage;
			s_tag_reference firing_rider_damage;
			s_tag_reference critical_rider_damage;
			s_tag_reference misfire_rider_damage;
			s_tag_reference empty_rider_damage;
			s_tag_reference optional_secondary_firing_rider_damage;
		};
		static_assert(sizeof(s_i343weaponbarrelfiringeffectdefinition) == 464, "struct s_i343weaponbarrelfiringeffectdefinition is invalid size");

		struct s_i343weaponprojectiledistributioncustomangleoffset
		{
			real_euler_angles2d angle_offset;
		};
		static_assert(sizeof(s_i343weaponprojectiledistributioncustomangleoffset) == 8, "struct s_i343weaponprojectiledistributioncustomangleoffset is invalid size");

		struct s_i343weaponprojectiledistributioncustomvector
		{
			real_point2d point_offset;
		};
		static_assert(sizeof(s_i343weaponprojectiledistributioncustomvector) == 8, "struct s_i343weaponprojectiledistributioncustomvector is invalid size");

		struct s_i343weaponbarreldistrubutiondefinition
		{
			c_enum<e_i343weaponbarreldistributionfunction, short> distribution_function;
			short projectiles_per_shot;
			c_typed_tag_block<s_i343weaponprojectiledistributioncustomangleoffset> direction_offset_block;
			c_typed_tag_block<s_i343weaponprojectiledistributioncustomvector> position_offsets_block;
			real distribution_angle;
		};
		static_assert(sizeof(s_i343weaponbarreldistrubutiondefinition) == 32, "struct s_i343weaponbarreldistrubutiondefinition is invalid size");

		struct s_i343weaponbarreldistrubutionparam
		{
			s_i343weaponbarreldistrubutiondefinition projectile_distribution;
		};
		static_assert(sizeof(s_i343weaponbarreldistrubutionparam) == 32, "struct s_i343weaponbarreldistrubutionparam is invalid size");

		struct s_i343weaponbarrelerrordefinition
		{
			real lower_bound_deceleration_time;
			real deceleration_time;
			real runtime_error_min_deceleration_rate;
			real runtime_error_deceleration_rate;
			angle minimum_error;
			angle_bounds minimum_error_angle;
			angle_bounds error_angle;
			real_bounds damage_error;
		};
		static_assert(sizeof(s_i343weaponbarrelerrordefinition) == 44, "struct s_i343weaponbarrelerrordefinition is invalid size");

		struct s_i343weaponbarrelerrorparam
		{
			s_i343weaponbarrelerrordefinition projectile_error;
		};
		static_assert(sizeof(s_i343weaponbarrelerrorparam) == 44, "struct s_i343weaponbarrelerrorparam is invalid size");

		struct s_i343weaponbarrelnoisedefinition
		{
			c_enum<e_i343aisoundvolume, short> ai_noise;
			c_enum<e_i343weaponmotiontrackernoiselevel, short> motion_tracker_noise;
		};
		static_assert(sizeof(s_i343weaponbarrelnoisedefinition) == 4, "struct s_i343weaponbarrelnoisedefinition is invalid size");

		struct s_i343weaponbarrelnoiseparam
		{
			s_i343weaponbarrelnoisedefinition barrel_noise;
		};
		static_assert(sizeof(s_i343weaponbarrelnoiseparam) == 4, "struct s_i343weaponbarrelnoiseparam is invalid size");

		struct s_i343weaponweaponattachmentheatgeneratedperroundparam
		{
			real_fraction heat_generated_per_round;
		};
		static_assert(sizeof(s_i343weaponweaponattachmentheatgeneratedperroundparam) == 4, "struct s_i343weaponweaponattachmentheatgeneratedperroundparam is invalid size");

		struct s_i343weaponbarrelagegenerateddefinition
		{
			real_fraction age_generated_per_round;
			real_fraction campaign_age_generated_per_round;
		};
		static_assert(sizeof(s_i343weaponbarrelagegenerateddefinition) == 8, "struct s_i343weaponbarrelagegenerateddefinition is invalid size");

		struct s_i343weaponbarrelagegeneratedparam
		{
			s_i343weaponbarrelagegenerateddefinition age_generation;
		};
		static_assert(sizeof(s_i343weaponbarrelagegeneratedparam) == 8, "struct s_i343weaponbarrelagegeneratedparam is invalid size");

		struct s_i343weaponbarrelsweetheatdefinition
		{
			// custom heat_sweet_spot
			real_fraction sweet_spot_start_heat_level;
			real_fraction sweet_spot_end_heat_level;
			c_typed_tag_reference<PROJECTILE_TAG> sweet_heat_projectile;
			// custom value
		};
		static_assert(sizeof(s_i343weaponbarrelsweetheatdefinition) == 24, "struct s_i343weaponbarrelsweetheatdefinition is invalid size");

		struct s_i343weaponbarrelsweetheatparam
		{
			s_i343weaponbarrelsweetheatdefinition sweet_heat;
		};
		static_assert(sizeof(s_i343weaponbarrelsweetheatparam) == 24, "struct s_i343weaponbarrelsweetheatparam is invalid size");

		struct s_i343weaponfiresoundvariationdefinition
		{
			s_tag_reference weapon_fire_sound;
		};
		static_assert(sizeof(s_i343weaponfiresoundvariationdefinition) == 16, "struct s_i343weaponfiresoundvariationdefinition is invalid size");

		struct s_i343weaponfiresounddefinition
		{
			c_enum<e_i343weaponsoundfiringtype, short> firing_type;
			short barrel_attachment_index;
			real fire_start_delay;
			c_typed_tag_block<s_i343weaponfiresoundvariationdefinition> weapon_fire_sound_variations_block;
		};
		static_assert(sizeof(s_i343weaponfiresounddefinition) == 20, "struct s_i343weaponfiresounddefinition is invalid size");

		struct s_i343weaponfiresoundparam
		{
			s_i343weaponfiresounddefinition weapon_fire_sound;
		};
		static_assert(sizeof(s_i343weaponfiresoundparam) == 20, "struct s_i343weaponfiresoundparam is invalid size");

		struct s_i343weaponfiresoundtailsdefinition
		{
			string_id weapon_switch_group;
			string_id weapon_switch_value;
		};
		static_assert(sizeof(s_i343weaponfiresoundtailsdefinition) == 8, "struct s_i343weaponfiresoundtailsdefinition is invalid size");

		struct s_i343weaponfiresoundtailsparam
		{
			s_i343weaponfiresoundtailsdefinition weapon_fire_tail;
		};
		static_assert(sizeof(s_i343weaponfiresoundtailsparam) == 8, "struct s_i343weaponfiresoundtailsparam is invalid size");

		struct s_i343weaponbarreloverridedefinition
		{
			c_typed_tag_reference<PROJECTILE_TAG> projectile;
			c_typed_tag_block<s_i343weaponbarrelfiringparam> firing_params_block;
			c_typed_tag_block<s_i343weaponbarrelfiringeffectdefinition> firing_effects_block;
			c_typed_tag_block<s_i343weaponbarreldistrubutionparam> projectile_distribution_block;
			c_typed_tag_block<s_i343weaponbarrelerrorparam> projectile_error_block;
			c_typed_tag_block<s_i343weaponbarrelnoiseparam> noise_block;
			c_typed_tag_block<s_i343weaponweaponattachmentheatgeneratedperroundparam> heat_generated_per_round_block;
			c_typed_tag_block<s_i343weaponbarrelagegeneratedparam> age_generation_block;
			c_typed_tag_block<s_i343weaponbarrelsweetheatparam> sweet_heat_block;
			// custom $$$_new_sound_$$$
			c_typed_tag_block<s_i343weaponfiresoundparam> weapon_fire_sound_block;
			c_typed_tag_block<s_i343weaponfiresoundtailsparam> weapon_fire_tail_sound_block;
			// custom value
		};
		static_assert(sizeof(s_i343weaponbarreloverridedefinition) == 136, "struct s_i343weaponbarreloverridedefinition is invalid size");

		struct s_i343weaponattachmentbarrelcomponentdefinition
		{
			// custom weapon_barrel
			c_typed_tag_block<s_i343weaponbarreloverridedefinition> primary_barrel_override_block;
			c_typed_tag_block<s_i343weaponbarreloverridedefinition> secondary_barrel_override_block;
			// custom value
		};
		static_assert(sizeof(s_i343weaponattachmentbarrelcomponentdefinition) == 24, "struct s_i343weaponattachmentbarrelcomponentdefinition is invalid size");

		struct s_i343weaponattachmentbarreldefinition
		{
			s_anytag_struct_definition anytag;
			s_i343weaponattachmentcomponentdefinition weapon_attachment_component;
			s_i343weaponattachmentbarrelcomponentdefinition weapon_attachment_barrel_component;
		};
		static_assert(sizeof(s_i343weaponattachmentbarreldefinition) == 212, "struct s_i343weaponattachmentbarreldefinition is invalid size");

		struct s_i343weaponattachmentheatcomponentdefinition
		{
			// custom weapon_heat
			c_typed_tag_reference<EFFECT_TAG> overheated;
			// custom value
		};
		static_assert(sizeof(s_i343weaponattachmentheatcomponentdefinition) == 16, "struct s_i343weaponattachmentheatcomponentdefinition is invalid size");

		struct s_i343weaponattachmentheatdefinition
		{
			s_anytag_struct_definition anytag;
			s_i343weaponattachmentcomponentdefinition weapon_attachment_component;
			s_i343weaponattachmentheatcomponentdefinition weapon_attachment_heat_component;
			char generated_padaac3[4]; // padding
		};
		static_assert(sizeof(s_i343weaponattachmentheatdefinition) == 208, "struct s_i343weaponattachmentheatdefinition is invalid size");

		struct s_i343weaponmagazineoverridedefinition
		{
			short rounds_total_initial;
			short rounds_total_maximum;
			short rounds_loaded_maximum;
			short rounds_inventory_maximum;
			short rounds_reloaded;
			c_enum<e_i343munitionseammorefilltype, short> ammo_refill_type;
		};
		static_assert(sizeof(s_i343weaponmagazineoverridedefinition) == 12, "struct s_i343weaponmagazineoverridedefinition is invalid size");

		struct s_i343weaponattachmentmagazinecomponentdefinition
		{
			// custom weapon_magazine
			c_typed_tag_block<s_i343weaponmagazineoverridedefinition> primary_magazine_override_block;
			c_typed_tag_block<s_i343weaponmagazineoverridedefinition> secondary_magazine_override_block;
			// custom value
		};
		static_assert(sizeof(s_i343weaponattachmentmagazinecomponentdefinition) == 24, "struct s_i343weaponattachmentmagazinecomponentdefinition is invalid size");

		struct s_i343weaponattachmentmagazinedefinition
		{
			s_anytag_struct_definition anytag;
			s_i343weaponattachmentcomponentdefinition weapon_attachment_component;
			s_i343weaponattachmentmagazinecomponentdefinition weapon_attachment_magazine_component;
		};
		static_assert(sizeof(s_i343weaponattachmentmagazinedefinition) == 212, "struct s_i343weaponattachmentmagazinedefinition is invalid size");

		struct s_i343weaponattachmentdefinition
		{
			s_anytag_struct_definition anytag;
			s_i343weaponattachmentcomponentdefinition weapon_attachment_component;
		};
		static_assert(sizeof(s_i343weaponattachmentdefinition) == 188, "struct s_i343weaponattachmentdefinition is invalid size");

		struct s_i343weaponmeleecomponentdefinition
		{
			// custom weapon_melee
			c_typed_tag_block<s_s_melee_damage_parameters> melee_damage_parameters_block;
			string_id melee_animation_set;
			// custom value
		};
		static_assert(sizeof(s_i343weaponmeleecomponentdefinition) == 16, "struct s_i343weaponmeleecomponentdefinition is invalid size");

		struct s_i343weaponattachmentmeleedefinition
		{
			s_anytag_struct_definition anytag;
			s_i343weaponattachmentcomponentdefinition weapon_attachment_component;
			s_i343weaponmeleecomponentdefinition weapon_melee_component;
		};
		static_assert(sizeof(s_i343weaponattachmentmeleedefinition) == 204, "struct s_i343weaponattachmentmeleedefinition is invalid size");

		struct s_i343weaponsightcomponentdefinition
		{
			// custom weapon_sight
			c_flags<e_i343weaponsightcomponentdefinitionflags, long, k_i343weaponsightcomponentdefinitionflags_count> sight_flags;
			c_typed_tag_reference<OUTLINETYPEDEFINITION_TAG> target_tracking_outline;
			// custom ads_transition_in_time
			s_i343malleablepropertybasefloatstructdefinition ads_transition_in_time;
			// custom ads_transition_out_time
			s_i343malleablepropertybasefloatstructdefinition ads_transition_out_time;
			real weapon_fov_scale;
			real_point3d ads_translation_offset;

			/* ads percent to offset percent */

			s_scalarfunctionname ads_percent_to_offset_percent$2;
			real_fraction ads_state_enabled_fraction;

			/* ads enabled to complete */

			s_scalarfunctionname ads_enabled_to_complete$2;
			real_bounds tc_transition_in_fraction;
			real_fraction transparency_transition_start_ads_fraction;
			real_fraction transparency_transition_finish_ads_fraction;
			real range_finder_max_range;
			// custom ui
			c_typed_tag_reference<CUI_SCREEN_TAG> sight_2d_screen_reference;
			c_typed_tag_reference<CUI_SCREEN_TAG> sight_front_screen_reference;
			c_typed_tag_reference<CUI_SCREEN_TAG> sight_back_screen_reference;
			// custom value
			c_typed_tag_reference<WEAPON_DEPTH_OF_FIELD_TAG> depth_of_field;
			// custom penalized_descope

			/* penalized descope */

			c_typed_tag_reference<SOUND_TAG> penalized_descope_sound;
			real penalized_descope_transition_out_modifier;
			real penalized_descope_ads_hold_disable_time;
			// custom value
			string_id ads_anim_mode;
			real_fraction ads_camo_removal_scale;
			c_typed_tag_block<s_i343weaponattachmentregionpermutationdefinition> ads_scope_swap_block;
			real_fraction ads_scope_swap_transition_fraction;
			// custom value
		};
		static_assert(sizeof(s_i343weaponsightcomponentdefinition) == 236, "struct s_i343weaponsightcomponentdefinition is invalid size");

		struct s_i343weaponzoomleveldefinition
		{
			real magnification;
			c_enum<e_i343weaponzoommagnificationprofilesetting, char> magnification_profile_setting;
			char generated_padcc8f[3]; // padding
			real zoom_transition_time;
			real effect_rate;
			c_typed_tag_reference<SOUND_TAG> zoom_in_sound;
			c_typed_tag_reference<SOUND_TAG> zoom_out_sound;
			c_flags<e_i343weaponzoomleveldefinitionscreeneffectflags, char, k_i343weaponzoomleveldefinitionscreeneffectflags_count> zoom_effect_flags;
			char generated_pad7fda[3]; // padding
			c_typed_tag_reference<EFFECT_TAG> zoom_effect;
			c_typed_tag_reference<AREA_SCREEN_EFFECT_TAG> screen_effect;
			c_typed_tag_block<s_i343weaponaccuracypropertymodifiersdefinition> accuracy_modifiers_block;
			c_typed_tag_block<s_i343weaponunitpropertymodifiersdefinition> unit_modifiers_block;
			c_typed_tag_block<s_i343weaponaimassistpropertymodifiersdefinition> aim_assist_modifiers_block;
			c_typed_tag_reference<WEAPON_AIM_ASSIST_MODIFIERS_TAG> aim_assist_reference;
			c_typed_tag_block<s_i343weaponrecoilviewkickpropertymodifiersdefinition> recoil_view_kick_modifiers_block;
			c_typed_tag_block<s_i343weaponrecoilgunkickpropertymodifiersdefinition> recoil_gunkick_modifiers_block;
		};
		static_assert(sizeof(s_i343weaponzoomleveldefinition) == 160, "struct s_i343weaponzoomleveldefinition is invalid size");

		struct s_i343weaponzoomcomponentdefinition
		{
			// custom weapon_zoom
			c_typed_tag_block<s_i343weaponzoomleveldefinition> zoom_block;
			// custom value
		};
		static_assert(sizeof(s_i343weaponzoomcomponentdefinition) == 12, "struct s_i343weaponzoomcomponentdefinition is invalid size");

		struct s_i343weaponattachmentsightdefinition
		{
			s_anytag_struct_definition anytag;
			s_i343weaponattachmentcomponentdefinition weapon_attachment_component;
			s_i343weaponsightcomponentdefinition weapon_sight_component;
			s_i343weaponzoomcomponentdefinition weapon_zoom;
		};
		static_assert(sizeof(s_i343weaponattachmentsightdefinition) == 436, "struct s_i343weaponattachmentsightdefinition is invalid size");

		struct s_i343weapontiggerchargingfirefractions
		{
			real_fraction charge_fraction;
		};
		static_assert(sizeof(s_i343weapontiggerchargingfirefractions) == 4, "struct s_i343weapontiggerchargingfirefractions is invalid size");

		struct s_i343weapontriggerchargingdefinition
		{

			/* CHARGING */

			c_flags<e_i343weaponchargingdefinitionflags, short, k_i343weaponchargingdefinitionflags_count> flags;
			c_enum<e_i343weapontriggerchargeinitiationmechanism, char> charging_initiation_mechanism;
			c_enum<e_i343weapontriggeroverchargedaction, char> overcharged_action;
			real charging_time;
			real charged_time;
			word cancelled_trigger_throw;
			char generated_padfd33[2]; // padding
			real charged_illumination;
			s_tag_reference charging_effect;
			s_tag_reference charging_damage_effect;
			c_typed_tag_reference<DAMAGE_RESPONSE_DEFINITION_TAG> charging_continuous_damage_response;
			real charged_drain_rate;
			s_tag_reference discharge_effect;
			s_tag_reference discharge_damage_effect;
			c_typed_tag_block<s_i343weapontiggerchargingfirefractions> fire_fractions_block;
		};
		static_assert(sizeof(s_i343weapontriggerchargingdefinition) == 116, "struct s_i343weapontriggerchargingdefinition is invalid size");

		struct s_i343weaponweapontriggerchargingoverride
		{
			s_i343weapontriggerchargingdefinition charging;
		};
		static_assert(sizeof(s_i343weaponweapontriggerchargingoverride) == 116, "struct s_i343weaponweapontriggerchargingoverride is invalid size");

		struct s_i343weapontriggeroverridedefinition
		{
			c_typed_tag_block<s_i343weaponweapontriggerchargingoverride> trigger_override_block;
		};
		static_assert(sizeof(s_i343weapontriggeroverridedefinition) == 12, "struct s_i343weapontriggeroverridedefinition is invalid size");

		struct s_i343weaponattachmenttriggercomponentdefinition
		{
			// custom weapon_trigger
			c_typed_tag_block<s_i343weapontriggeroverridedefinition> primary_trigger_override_block;
			c_typed_tag_block<s_i343weapontriggeroverridedefinition> secondary_trigger_override_block;
			// custom value
		};
		static_assert(sizeof(s_i343weaponattachmenttriggercomponentdefinition) == 24, "struct s_i343weaponattachmenttriggercomponentdefinition is invalid size");

		struct s_i343weaponattachmenttriggerdefinition
		{
			s_anytag_struct_definition anytag;
			s_i343weaponattachmentcomponentdefinition weapon_attachment_component;
			s_i343weaponattachmenttriggercomponentdefinition weapon_attachment_trigger_component;
		};
		static_assert(sizeof(s_i343weaponattachmenttriggerdefinition) == 212, "struct s_i343weaponattachmenttriggerdefinition is invalid size");

		struct s_i343weaponlaserguidancedefinition
		{
			c_enum<e_i343weaponlaserguidanceactivationmode, char> laser_guidance_activation;
		};
		static_assert(sizeof(s_i343weaponlaserguidancedefinition) == 1, "struct s_i343weaponlaserguidancedefinition is invalid size");

		struct s_i343weapontargettrackingcomponentdefinition
		{
			// custom target_tracking
			c_typed_tag_block<s_s_target_tracking_parameters> target_tracking_block;
			// custom value
			// custom laser_guidance
			c_typed_tag_block<s_i343weaponlaserguidancedefinition> laser_guidance_block;
			// custom value
			string_id locking_reticle_screen_name;
			string_id locked_on_reticle_screen_name;
		};
		static_assert(sizeof(s_i343weapontargettrackingcomponentdefinition) == 32, "struct s_i343weapontargettrackingcomponentdefinition is invalid size");

		struct s_i343weaponattachmenttargettrackingdefinition
		{
			s_anytag_struct_definition anytag;
			s_i343weaponattachmentcomponentdefinition weapon_attachment_component;
			s_i343weapontargettrackingcomponentdefinition weapon_target_tracking_component;
		};
		static_assert(sizeof(s_i343weaponattachmenttargettrackingdefinition) == 220, "struct s_i343weaponattachmenttargettrackingdefinition is invalid size");

		struct s_i343weapondebugadsreticlemovmementthreshold
		{
			c_static_string<32> ads_reticle_movement_threshold_name;
			angle ads_reticle_movement_threshold_angle;
			rgb_color ads_reticle_movement_threshold_color;
		};
		static_assert(sizeof(s_i343weapondebugadsreticlemovmementthreshold) == 48, "struct s_i343weapondebugadsreticlemovmementthreshold is invalid size");

		struct s_i343weaponfirstpersonweaponoffsetcontrol
		{
			c_enum<e_i343weaponfirstpersonweapongroup, short> first_person_weapon_group;
			char generated_padfc06[2]; // padding
			string_id weapon_group_header_string;
			real_bounds depth_offset_bounds;
			real_bounds horizontal_offset_bounds;
			real_bounds vertical_offset_bounds;
			real_vector3d maximum_computed_offset_extents;
			c_flags<e_i343weaponweaponoffsetaxiscontrolflag, char, k_i343weaponweaponoffsetaxiscontrolflag_count> depth_axis_flags;
			c_flags<e_i343weaponweaponoffsetaxiscontrolflag, char, k_i343weaponweaponoffsetaxiscontrolflag_count> horizontal_axis_flags;
			c_flags<e_i343weaponweaponoffsetaxiscontrolflag, char, k_i343weaponweaponoffsetaxiscontrolflag_count> vertical_axis_flags;
			char generated_pad48bb[1]; // padding
		};
		static_assert(sizeof(s_i343weaponfirstpersonweaponoffsetcontrol) == 48, "struct s_i343weaponfirstpersonweaponoffsetcontrol is invalid size");

		struct s_i343weaponfirstpersonweaponoffsetcontrolindex
		{
			long index;
		};
		static_assert(sizeof(s_i343weaponfirstpersonweaponoffsetcontrolindex) == 4, "struct s_i343weaponfirstpersonweaponoffsetcontrolindex is invalid size");

		struct s_i343weaponweaponglobalsdefinition
		{
			s_anytag_struct_definition anytag;
			angle_bounds gunkick_yaw_mapping_bounds;
			s_scalarfunctionname gunkick_yaw_to_roll;
			angle_bounds viewkick_yaw_mapping_bounds;
			s_scalarfunctionname viewkick_yaw_to_roll;
			real max_player_additive_velocity_for_flag_throw;
			real descope_magnetism_transition_time;
			s_scalarfunctionname descope_magnetism_transition;
			s_scalarfunctionname flag_throw_forward_additive_velocity_;
			s_scalarfunctionname flag_throw_backward_additive_velocity_;
			s_scalarfunctionname flag_throw_pitch;
			c_typed_tag_block<s_i343weapondebugadsreticlemovmementthreshold> ads_reticle_movement_thresholds_block;
			c_flags<e_i343weaponzoomsuppressionflags, char, k_i343weaponzoomsuppressionflags_count> suppression_flags;
			char generated_pad7ec6[3]; // padding
			c_typed_tag_block<s_i343weaponfirstpersonweaponoffsetcontrol> first_person_weapon_offset_controls_block;
			s_i343weaponfirstpersonweaponoffsetcontrolindex first_person_weapon_offset_controls_index_cache[5];
			real game_options___weapon_offset_scaling_factor;
			char generated_padcb7b[4]; // padding
		};
		static_assert(sizeof(s_i343weaponweaponglobalsdefinition) == 216, "struct s_i343weaponweaponglobalsdefinition is invalid size");

		struct s_nodegraphreferenceblockdefinition
		{
			c_typed_tag_reference<NODE_GRAPH_STACK_TAG> node_graph_tag;
		};
		static_assert(sizeof(s_nodegraphreferenceblockdefinition) == 16, "struct s_nodegraphreferenceblockdefinition is invalid size");

		struct s_bitmapdictionaryreferenceblockdefinition
		{
			c_typed_tag_reference<BITMAP_DICTIONARY_TAG> bitmap_dictionary;
		};
		static_assert(sizeof(s_bitmapdictionaryreferenceblockdefinition) == 16, "struct s_bitmapdictionaryreferenceblockdefinition is invalid size");

		struct s_s_luauserlibrary
		{
			c_typed_tag_reference<LUA_SCRIPT_TAG> lua_library;
		};
		static_assert(sizeof(s_s_luauserlibrary) == 16, "struct s_s_luauserlibrary is invalid size");

		struct s_s_cui_component_screen_reference
		{
			string_id name;
			c_typed_tag_reference<CUI_SCREEN_TAG> cui_screen_tag;
		};
		static_assert(sizeof(s_s_cui_component_screen_reference) == 20, "struct s_s_cui_component_screen_reference is invalid size");

		struct s_s_cui_overlay_camera_definition
		{
			string_id resolution_name;
			c_enum<e_e_cui_camera_pivot_corner, char> pivot_corner;
			char generated_pad630c[3]; // padding
			real z_near;
			real z_far;
			real x_angle_degrees;
			real y_angle_degrees;
		};
		static_assert(sizeof(s_s_cui_overlay_camera_definition) == 24, "struct s_s_cui_overlay_camera_definition is invalid size");

		struct s_userinterfacegamescreensequencestep
		{
			c_flags<e_i343netprotocolset_i343netprotocolgameoptionsscreensequencestepflags_, char, k_i343netprotocolset_i343netprotocolgameoptionsscreensequencestepflags__count> flags;
			char generated_pad4325[3]; // padding
			c_enum<e_i343netprotocolgameoptionsescreensequenceallowedvariants, long> allowedvariants;
			string_id start_hui_event;
			string_id end_hui_event;
			c_static_string<32> mp_game_event;
			c_static_string<32> server_lua_function;
			c_static_string<32> client_lua_function;
			real starttime;
			real endtime;
		};
		static_assert(sizeof(s_userinterfacegamescreensequencestep) == 120, "struct s_userinterfacegamescreensequencestep is invalid size");

		struct s_s_user_interface_tag_globals
		{
			s_anytag_struct_definition anytag;

			/* Screen Widgets */

			c_typed_tag_block<s_nodegraphreferenceblockdefinition> node_graphs_block;
			c_typed_tag_block<s_bitmapdictionaryreferenceblockdefinition> bitmap_dictionaries_block;

			/* Lua User Libraries */

			c_typed_tag_block<s_s_luauserlibrary> lua_user_libraries_block;
			c_typed_tag_block<s_s_cui_component_screen_reference> cui_screen_widgets_block;
			c_typed_tag_block<s_s_cui_overlay_camera_definition> cui_overlay_cameras_block;
			real spawn_timer_countdown_rate;
			c_typed_tag_block<s_userinterfacegamescreensequencestep> game_intro_sequence_block;
			c_typed_tag_block<s_userinterfacegamescreensequencestep> game_round_end_sequence_block;
			c_typed_tag_block<s_userinterfacegamescreensequencestep> game_round_end_with_killcam_sequence_block;
			c_typed_tag_block<s_userinterfacegamescreensequencestep> game_next_round_sequence_block;
			c_typed_tag_block<s_userinterfacegamescreensequencestep> game_end_sequence_block;
			c_typed_tag_block<s_userinterfacegamescreensequencestep> game_end_with_killcam_sequence_block;
			c_typed_tag_block<s_userinterfacegamescreensequencestep> in_game_sequence_block;
			c_typed_tag_block<s_userinterfacegamescreensequencestep> halftime_sequence_block;
			c_typed_tag_block<s_userinterfacegamescreensequencestep> overtime_sequence_block;
			c_typed_tag_block<s_userinterfacegamescreensequencestep> map_intro_sequence_block;
			c_typed_tag_block<s_userinterfacegamescreensequencestep> player_intro_sequence_block;
			c_typed_tag_block<s_userinterfacegamescreensequencestep> team_intro_sequence_block;
			c_typed_tag_block<s_userinterfacegamescreensequencestep> team_regroup_sequence_block;
			c_typed_tag_block<s_userinterfacegamescreensequencestep> team_outro_sequence_block;
			c_typed_tag_reference<USER_INTERFACE_HUD_GLOBALS_DEFINITION_TAG> hud_globals;
			long total_object_count_budget;
			c_typed_tag_reference<INGAMEMAPRENDER_TAG> in_game_map_render_tag;
			c_typed_tag_reference<INGAMEMAPSETTINGS_TAG> in_game_map_settings_tag;
		};
		static_assert(sizeof(s_s_user_interface_tag_globals) == 300, "struct s_s_user_interface_tag_globals is invalid size");

		struct s_s_color_preset
		{
			string_id name;
			argb_color color;
		};
		static_assert(sizeof(s_s_color_preset) == 20, "struct s_s_color_preset is invalid size");

		struct s_realargbcolorblock
		{
			argb_color color;
		};
		static_assert(sizeof(s_realargbcolorblock) == 16, "struct s_realargbcolorblock is invalid size");

		struct s_s_tint_colors
		{
			c_typed_tag_block<s_realargbcolorblock> text_team_block;
			c_typed_tag_block<s_realargbcolorblock> bitmap_team_block;
		};
		static_assert(sizeof(s_s_tint_colors) == 24, "struct s_s_tint_colors is invalid size");

		struct s_s_gui_alert_description
		{
			string_id error_name;
			c_flags<e_s_gui_alert_descriptionguialertdescriptionflags, char, k_s_gui_alert_descriptionguialertdescriptionflags_count> flags;
			c_enum<e_e_gui_error_category, char> error_category;
			c_enum<e_e_gui_error_icon, char> error_icon;
			char generated_padd9db[1]; // padding
			string_id title;
			string_id message;
		};
		static_assert(sizeof(s_s_gui_alert_description) == 16, "struct s_s_gui_alert_description is invalid size");

		struct s_s_gui_dialog_description
		{
			string_id dialog_name;
			c_flags<e_c_gui_dialog_description_flags, short, k_c_gui_dialog_description_flags_count> flags;
			char generated_pad869b[2]; // padding
			string_id title;
			string_id message;
			string_id first_item;
			string_id second_item;
			string_id third_item;
			string_id fourth_item;
			string_id button_key;
			c_enum<e_e_gui_dialog_choice, short> default_item;
			c_enum<e_e_gui_dialog_b_button_action, short> b_button_action;
		};
		static_assert(sizeof(s_s_gui_dialog_description) == 40, "struct s_s_gui_dialog_description is invalid size");

		struct s_fontsetreferenceblockdefinition
		{
			c_typed_tag_reference<WPF_FONT_SET_TAG> wpf_font_set_tag;
		};
		static_assert(sizeof(s_fontsetreferenceblockdefinition) == 16, "struct s_fontsetreferenceblockdefinition is invalid size");

		struct s_reticleoverplayerdefinition
		{
			real firsttierangle;
			real firsttierdistance;
			real secondtierangle;
			real secondtierdistance;
			real vehicledistancescalar;
		};
		static_assert(sizeof(s_reticleoverplayerdefinition) == 20, "struct s_reticleoverplayerdefinition is invalid size");

		struct s_fontmappingdefinition
		{
			c_static_string<256> original_name;
			c_static_string<256> remapped_name;
		};
		static_assert(sizeof(s_fontmappingdefinition) == 512, "struct s_fontmappingdefinition is invalid size");

		struct s_localizedfontmappingsetdefinition
		{
			c_enum<e_e_language, long> language;
			c_typed_tag_block<s_fontmappingdefinition> mappings_block;
		};
		static_assert(sizeof(s_localizedfontmappingsetdefinition) == 16, "struct s_localizedfontmappingsetdefinition is invalid size");

		struct s_rebindingslidersettings
		{
			real min_value;
			real max_value;
			real increment_value;
			real scaling_value;
		};
		static_assert(sizeof(s_rebindingslidersettings) == 16, "struct s_rebindingslidersettings is invalid size");

		struct s_rebindingdropdownlist
		{
			string_id label;
		};
		static_assert(sizeof(s_rebindingdropdownlist) == 4, "struct s_rebindingdropdownlist is invalid size");

		struct s_rebindingaxiscategorysettings
		{
			c_static_string<256> axis_name;
			string_id axis_description;
			c_enum<e_rebindingaxiscategorysettingsrebindingsettingcategory, long> display_category;
			c_enum<e_rebindingaxiscategorysettingsrebindinginterfacetype, long> menu_type;
			c_flags<e_rebindingaxiscategorysettingsrebindingflags, char, k_rebindingaxiscategorysettingsrebindingflags_count> flags;
			c_static_string<256> toggle_axis;
			char generated_pade2be[3]; // padding

			/* Slider Settings */

			c_typed_tag_block<s_rebindingslidersettings> slider_settings_block;

			/* Dropdown Settings */

			c_typed_tag_block<s_rebindingdropdownlist> dropdown_list_block;
		};
		static_assert(sizeof(s_rebindingaxiscategorysettings) == 552, "struct s_rebindingaxiscategorysettings is invalid size");

		struct s_axisaltnamepair
		{
			string_id axis_name;
			string_id alt_name;
		};
		static_assert(sizeof(s_axisaltnamepair) == 8, "struct s_axisaltnamepair is invalid size");

		struct s_unbindableinputdeviceelementslist
		{
			c_enum<e_inputdeviceelement, short> unbindable_input;
		};
		static_assert(sizeof(s_unbindableinputdeviceelementslist) == 2, "struct s_unbindableinputdeviceelementslist is invalid size");

		struct s_unbindableaxistoinputdeviceelementslist
		{
			string_id axis_name;
			c_typed_tag_block<s_unbindableinputdeviceelementslist> unbindable_input_list_for_axis_block;
		};
		static_assert(sizeof(s_unbindableaxistoinputdeviceelementslist) == 16, "struct s_unbindableaxistoinputdeviceelementslist is invalid size");

		struct s_swapperinput
		{
			string_id axis;
		};
		static_assert(sizeof(s_swapperinput) == 4, "struct s_swapperinput is invalid size");

		struct s_dropshadowparameters
		{
			string_id name;
			real_point2d offset;
			string_id color;
			long sample_size;
		};
		static_assert(sizeof(s_dropshadowparameters) == 20, "struct s_dropshadowparameters is invalid size");

		struct s_fontsizescalevalues
		{
			long range_min;
			long range_max;
			long large_font_value;
			long extra_large_font_value;
		};
		static_assert(sizeof(s_fontsizescalevalues) == 16, "struct s_fontsizescalevalues is invalid size");

		struct s_settingsmenuslidersettings
		{
			string_id name;
			real min_value;
			real max_value;
			real step_size;
			real scaling_factor;
		};
		static_assert(sizeof(s_settingsmenuslidersettings) == 20, "struct s_settingsmenuslidersettings is invalid size");

		struct s_s_user_interface_shared_globals
		{
			s_anytag_struct_definition anytag;

			/* Global Text Strings */

			c_typed_tag_reference<MULTILINGUAL_UNICODE_STRING_LIST_TAG> unicode_string_list_tag;

			/* Global Text Strings for Language */

			c_typed_tag_reference<STRINGLIST_TAG> string_list_tag;

			/* Global Resources */

			c_typed_tag_block<s_resourcefilereferences> resources_tags_block;

			/* Global Navpoint Resources */

			c_typed_tag_block<s_resourcefilereferences> navpoint_resources_tags_block;

			/* Color presets */

			c_typed_tag_block<s_s_color_preset> color_presets_block;

			/* Disposition Colors */

			c_typed_tag_reference<DISPOSITIONCOLORS_TAG> disposition_colors$2;

			/* Tint colors */

			c_typed_tag_block<s_s_tint_colors> tint_colors_block;

			/* User interface sounds */

			c_typed_tag_reference<USER_INTERFACE_SOUNDS_DEFINITION_TAG> default_sounds;
			c_typed_tag_reference<SOUND_RESPONSE_TAG> weapon_discarded_sound;
			c_typed_tag_reference<SOUND_RESPONSE_TAG> callout_spam_prevention_sound;
			c_typed_tag_reference<SOUND_TAG> grenade_switching_sound;

			/* HaloX Alerts */

			c_typed_tag_block<s_s_gui_alert_description> alert_descriptions_block;

			/* HaloX Dialogs */

			c_typed_tag_block<s_s_gui_dialog_description> dialog_descriptions_block;

			/* Lua User Libraries */

			c_typed_tag_block<s_s_luauserlibrary> lua_user_libraries_block;

			/* Lua User Sample Data Libraries */

			c_typed_tag_block<s_s_luauserlibrary> lua_user_sample_data_libraries_block;

			/* Basic widget tab speed */

			// custom basic_widget_tab_speed_function
			s_functiondefinition basic_widget_tab_speed_function;
			long max_input_time_x_on_the_basic_graph_msec;

			/* Spinner tab speed */

			// custom spinner_tab_speed_function
			s_functiondefinition spinner_tab_speed_function;
			long max_input_time_x_on_the_graph_msec;

			/* Attract Mode Settings */

			long delay;
			c_typed_tag_block<s_fontsetreferenceblockdefinition> wpf_font_sets_block;
			c_typed_tag_reference<TYPEFACE_TAG> typefaces;
			c_typed_tag_block<s_bitmapdictionaryreferenceblockdefinition> bitmap_dictionaries_block;
			c_typed_tag_block<s_bitmapdictionaryreferenceblockdefinition> double_tap_bitmap_dictionaries_block;
			// custom loading_screen
			c_typed_tag_reference<CUI_SCREEN_TAG> loading_screen_tag;
			real fade_from_level_to_loading_screen_seconds;
			real fade_from_level_to_blocking_load_seconds;
			real fade_in_to_loading_screen_seconds;
			real fade_out_from_loading_screen_seconds;
			// custom value

			/* Blur transitions */

			// custom gameplay_overlay_blur_fade_in_function
			s_functiondefinition gameplay_overlay_blur_fade_in_function;
			real gameplay_overlay_blur_fade_in_time_s;
			// custom gameplay_overlay_blur_fade_out_function
			s_functiondefinition gameplay_overlay_blur_fade_out_function;
			real gameplay_overlay_blur_fade_out_time_s;
			// custom watermark_screen
			c_typed_tag_reference<CUI_SCREEN_TAG> watermark_screen_tag;
			// custom value
			// custom reticle_over_player_behavior
			s_reticleoverplayerdefinition reticle_over_player_behavior;
			// custom value

			/* Localized font mappings */

			c_typed_tag_block<s_localizedfontmappingsetdefinition> font_mappings_block;

			/* FastHud Font Fake Bitmap */

			c_typed_tag_reference<BITMAP_TAG> fasthud_font_fake_bitmap$2;
			c_typed_tag_reference<EMBLEM_THEME_GLOBALS_TAG> emblem_themes;
			c_typed_tag_reference<URI_LOOKUP_TABLE_TAG> slams_uri_lookup_table;

			/* Rebinding Params */

			c_typed_tag_block<s_rebindingaxiscategorysettings> keyboard_rebinding_axes_block;
			c_typed_tag_block<s_rebindingaxiscategorysettings> controller_rebinding_options_axes_block;
			c_typed_tag_block<s_rebindingaxiscategorysettings> controller_rebinding_axes_block;
			c_typed_tag_block<s_axisaltnamepair> axis_alt_names_block;
			c_typed_tag_block<s_unbindableinputdeviceelementslist> unbindable_input_list_block;
			c_typed_tag_block<s_unbindableaxistoinputdeviceelementslist> unbindable_input_list_for_ui_special_controls_block;
			c_typed_tag_block<s_swapperinput> equipment_swapper_open_inputs_block;
			c_typed_tag_block<s_swapperinput> grenade_swapper_open_inputs_block;
			c_typed_tag_block<s_swapperinput> equipment_swapper_selection_inputs_block;
			c_typed_tag_block<s_swapperinput> grenade_swapper_selection_inputs_block;
			c_typed_tag_block<s_dropshadowparameters> drop_shadow_parameters_block;
			c_typed_tag_block<s_fontsizescalevalues> font_size_scale_values_block;
			c_typed_tag_block<s_settingsmenuslidersettings> settings_menu_slider_settings_block;
			c_typed_tag_reference<NARRATIONPHONEMES_TAG> narration_phonemes_tag;
			char generated_pad6e00[4]; // padding
		};
		static_assert(sizeof(s_s_user_interface_shared_globals) == 680, "struct s_s_user_interface_shared_globals is invalid size");

		struct s_s_wind_function
		{
			// custom mapping
			s_functiondefinition mapping;
		};
		static_assert(sizeof(s_s_wind_function) == 20, "struct s_s_wind_function is invalid size");

		struct s_s_wind_definition
		{
			s_anytag_struct_definition anytag;

			/* WIND DIRECTION */

			real_vector2d wind_direction_radian;
			s_s_wind_function speed;

			/* DECORATOR WIND MOTION */

			s_s_wind_function bend;
			s_s_wind_function oscillation;
			real gust_size;
			c_typed_tag_reference<BITMAP_TAG> gust_noise_bitmap;
			real cloud_influence;
			real fog_influence;
			real materials_speed_influence;
			s_s_wind_function materials_gust_breakup;
			s_s_wind_function materials_gust_strength;
			s_s_wind_function materials_world_uv_max_x;
			s_s_wind_function materials_world_uv_max_y;
			s_s_wind_function materials_world_uv_max_z;
			char generated_padb4ac[4]; // padding
		};
		static_assert(sizeof(s_s_wind_definition) == 220, "struct s_s_wind_definition is invalid size");

		struct s_waterphysicsdragpropertiestag
		{
			s_anytag_struct_definition anytag;
			s_s_water_physics_drag_properties drag;
		};
		static_assert(sizeof(s_waterphysicsdragpropertiestag) == 72, "struct s_waterphysicsdragpropertiestag is invalid size");

		struct s_blendanimationtokennode
		{
			string_id animation_name;
			c_enum<e_animationmode, long> mode;
			string_id group_name;
			real playback_rate;
			c_flags<e_blendanimtokenflags, short, k_blendanimtokenflags_count> animation_token_flags;
			char generated_pad8928[2]; // padding
			real alpha;
			real beta;
		};
		static_assert(sizeof(s_blendanimationtokennode) == 28, "struct s_blendanimationtokennode is invalid size");

		struct s_blendsubgraphnode
		{
			string_id coordinate_source_token;
			real alpha;
			real beta;
			s_subgraphreferenceexportedanimnodegraph subgraph_reference;
		};
		static_assert(sizeof(s_blendsubgraphnode) == 28, "struct s_blendsubgraphnode is invalid size");

		struct s_exportedblendgraphtag
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<NODEGRAPH_TAG> source_graph;
			c_enum<e_animblendnodetype, long> blend_type;
			c_typed_tag_block<s_blendanimationtokennode> animation_tokens_block;
			c_typed_tag_block<s_blendsubgraphnode> subgraph_nodes_block;
			real alpha_min;
			real alpha_max;
			real beta_min;
			real beta_max;
			long partition_count;
			char generated_pad9fc6[4]; // padding
		};
		static_assert(sizeof(s_exportedblendgraphtag) == 84, "struct s_exportedblendgraphtag is invalid size");

		struct s_xmlfiletag
		{
			s_anytag_struct_definition anytag;
			long long archive_read_pointer;
		};
		static_assert(sizeof(s_xmlfiletag) == 24, "struct s_xmlfiletag is invalid size");

		struct s_objectgraphconnectionendpoint
		{
			c_enum<e_objectgraphnodetype, char> node_type;
			char generated_pad0068[3]; // padding
			long node_index;
			long pin_index;
		};
		static_assert(sizeof(s_objectgraphconnectionendpoint) == 12, "struct s_objectgraphconnectionendpoint is invalid size");

		struct s_objectgraphconnection
		{
			c_typed_tag_block<s_objectgraphconnectionendpoint> source_block;
			c_typed_tag_block<s_objectgraphconnectionendpoint> destination_block;
		};
		static_assert(sizeof(s_objectgraphconnection) == 24, "struct s_objectgraphconnection is invalid size");

		struct s_booltogglenodedata
		{
			c_flags<e_booltogglenodeflags, short, k_booltogglenodeflags_count> flags;
		};
		static_assert(sizeof(s_booltogglenodedata) == 2, "struct s_booltogglenodedata is invalid size");

		struct s_booltoeventnodedata
		{
			char dummy_data;
		};
		static_assert(sizeof(s_booltoeventnodedata) == 1, "struct s_booltoeventnodedata is invalid size");

		struct s_brancheventnodedata
		{
			c_flags<e_brancheventnodeflags, short, k_brancheventnodeflags_count> flags;
		};
		static_assert(sizeof(s_brancheventnodedata) == 2, "struct s_brancheventnodedata is invalid size");

		struct s_checklightingvariantnodedata
		{
			string_id lighting_variant_name_id;
		};
		static_assert(sizeof(s_checklightingvariantnodedata) == 4, "struct s_checklightingvariantnodedata is invalid size");

		struct s_clampnodedata
		{
			real minimum;
			real maximum;
		};
		static_assert(sizeof(s_clampnodedata) == 8, "struct s_clampnodedata is invalid size");

		struct s_comparefloatnodedata
		{
			char dummy_data;
		};
		static_assert(sizeof(s_comparefloatnodedata) == 1, "struct s_comparefloatnodedata is invalid size");

		struct s_constantvector3node
		{
			real_vector3d value;
		};
		static_assert(sizeof(s_constantvector3node) == 12, "struct s_constantvector3node is invalid size");

		struct s_debugprintnodedata
		{
			long message_length;
			c_static_string<256> message;
		};
		static_assert(sizeof(s_debugprintnodedata) == 260, "struct s_debugprintnodedata is invalid size");

		struct s_envelopenodedata
		{
			real attack;
			real hold;
			real release;
		};
		static_assert(sizeof(s_envelopenodedata) == 12, "struct s_envelopenodedata is invalid size");

		struct s_eventrouternodedata
		{
			char dummy_data;
		};
		static_assert(sizeof(s_eventrouternodedata) == 1, "struct s_eventrouternodedata is invalid size");

		struct s_floatsnapshotnodedata
		{
			char dummy_data;
		};
		static_assert(sizeof(s_floatsnapshotnodedata) == 1, "struct s_floatsnapshotnodedata is invalid size");

		struct s_getgamefloatvaluenodedata
		{
			string_id value_name;
		};
		static_assert(sizeof(s_getgamefloatvaluenodedata) == 4, "struct s_getgamefloatvaluenodedata is invalid size");

		struct s_floatswitchnodedata
		{
			char dummy_data;
		};
		static_assert(sizeof(s_floatswitchnodedata) == 1, "struct s_floatswitchnodedata is invalid size");

		struct s_getgameeventnodedata
		{
			long event_name_length;
			c_static_string<256> event_name;
			c_flags<e_getgameeventnodeflags, short, k_getgameeventnodeflags_count> event_flags;
			char generated_pad9308[2]; // padding
		};
		static_assert(sizeof(s_getgameeventnodedata) == 264, "struct s_getgameeventnodedata is invalid size");

		struct s_loopingsoundnodedata
		{
			c_typed_tag_reference<SOUND_LOOPING_TAG> sound_tag;
			string_id marker;
		};
		static_assert(sizeof(s_loopingsoundnodedata) == 20, "struct s_loopingsoundnodedata is invalid size");

		struct s_objectfunctionnodedata
		{
			string_id function_name;
		};
		static_assert(sizeof(s_objectfunctionnodedata) == 4, "struct s_objectfunctionnodedata is invalid size");

		struct s_oneshotsoundnodedata
		{
			c_typed_tag_reference<SOUND_TAG> sound_tag;
			string_id marker;
		};
		static_assert(sizeof(s_oneshotsoundnodedata) == 20, "struct s_oneshotsoundnodedata is invalid size");

		struct s_oneshotsoundreferencenodedata
		{
			c_typed_tag_reference<SOUND_TAG> sound_tag;
		};
		static_assert(sizeof(s_oneshotsoundreferencenodedata) == 16, "struct s_oneshotsoundreferencenodedata is invalid size");

		struct s_persistentrandomfloatnodedata
		{
			char dummy_data;
		};
		static_assert(sizeof(s_persistentrandomfloatnodedata) == 1, "struct s_persistentrandomfloatnodedata is invalid size");

		struct s_probabilityeventnodedata
		{
			char dummy_data;
		};
		static_assert(sizeof(s_probabilityeventnodedata) == 1, "struct s_probabilityeventnodedata is invalid size");

		struct s_piecewisefunctionnodedata
		{
			s_tag_data point_data;
			c_enum<e_piecewisefunctiontype, char> functiontype;
			char generated_pada36a[3]; // padding
		};
		static_assert(sizeof(s_piecewisefunctionnodedata) == 24, "struct s_piecewisefunctionnodedata is invalid size");

		struct s_randomnode
		{
			c_enum<e_randomtype, char> random_type;
		};
		static_assert(sizeof(s_randomnode) == 1, "struct s_randomnode is invalid size");

		struct s_randomplacementcollectionpositionnodedata
		{
			char dummy_data;
		};
		static_assert(sizeof(s_randomplacementcollectionpositionnodedata) == 1, "struct s_randomplacementcollectionpositionnodedata is invalid size");

		struct s_rateofchangenodedata
		{
			real time_span;
		};
		static_assert(sizeof(s_rateofchangenodedata) == 4, "struct s_rateofchangenodedata is invalid size");

		struct s_registereventnodedata
		{
			long event_name_length;
			c_static_string<256> event_name;
		};
		static_assert(sizeof(s_registereventnodedata) == 260, "struct s_registereventnodedata is invalid size");

		struct s_setrtpcnodedata
		{
			string_id rtpc_name;
		};
		static_assert(sizeof(s_setrtpcnodedata) == 4, "struct s_setrtpcnodedata is invalid size");

		struct s_smoothingnodedata
		{
			real window_length;
		};
		static_assert(sizeof(s_smoothingnodedata) == 4, "struct s_smoothingnodedata is invalid size");

		struct s_statebrokerboolnodedata
		{
			string_id state_name;
		};
		static_assert(sizeof(s_statebrokerboolnodedata) == 4, "struct s_statebrokerboolnodedata is invalid size");

		struct s_statebrokerintnodedata
		{
			string_id state_name;
		};
		static_assert(sizeof(s_statebrokerintnodedata) == 4, "struct s_statebrokerintnodedata is invalid size");

		struct s_springnodedata
		{
			real frequency;
			real damping;
		};
		static_assert(sizeof(s_springnodedata) == 8, "struct s_springnodedata is invalid size");

		struct s_thresholdgatenodedata
		{
			real rising_input_threshold;
			real falling_input_threshold;
			c_flags<e_thresholdgatenodeflags, char, k_thresholdgatenodeflags_count> flags;
			char generated_pad9c34[3]; // padding
		};
		static_assert(sizeof(s_thresholdgatenodedata) == 12, "struct s_thresholdgatenodedata is invalid size");

		struct s_timernodedata
		{
			c_flags<e_timernodeflags, short, k_timernodeflags_count> timer_flags;
		};
		static_assert(sizeof(s_timernodedata) == 2, "struct s_timernodedata is invalid size");

		struct s_createeffectnodedata
		{
			c_typed_tag_reference<EFFECT_TAG> effect_tag;
			string_id marker_name;
		};
		static_assert(sizeof(s_createeffectnodedata) == 20, "struct s_createeffectnodedata is invalid size");

		struct s_createbeameffectnodedata
		{
			c_typed_tag_reference<EFFECT_TAG> effect_tag;
			string_id start_marker;
			string_id end_marker;
		};
		static_assert(sizeof(s_createbeameffectnodedata) == 24, "struct s_createbeameffectnodedata is invalid size");

		struct s_stopeffectnodedata
		{
			c_typed_tag_reference<EFFECT_TAG> effect_tag;
			string_id marker_name;
		};
		static_assert(sizeof(s_stopeffectnodedata) == 20, "struct s_stopeffectnodedata is invalid size");

		struct s_setobjectfunctionnodedata
		{
			string_id function_name;
		};
		static_assert(sizeof(s_setobjectfunctionnodedata) == 4, "struct s_setobjectfunctionnodedata is invalid size");

		struct s_objectgraphoutput
		{
			c_enum<e_objectgraphnodetype, char> node_type;
			char generated_padeab4[3]; // padding
			long node_index;
			long pin_index;
		};
		static_assert(sizeof(s_objectgraphoutput) == 12, "struct s_objectgraphoutput is invalid size");

		struct s_dwspopstatenodedata
		{
			c_static_string<256> state_name;
			long state_guid;
			char generated_pad7e46[4]; // padding
		};
		static_assert(sizeof(s_dwspopstatenodedata) == 264, "struct s_dwspopstatenodedata is invalid size");

		struct s_dwspushstatenodedata
		{
			c_static_string<256> state_name;
			long state_guid;
			char generated_padabaf[4]; // padding
		};
		static_assert(sizeof(s_dwspushstatenodedata) == 264, "struct s_dwspushstatenodedata is invalid size");

		struct s_dwsenabletoverridenodedata
		{
			char dummy_data;
		};
		static_assert(sizeof(s_dwsenabletoverridenodedata) == 1, "struct s_dwsenabletoverridenodedata is invalid size");

		struct s_dwssettoverridenodedata
		{
			real t_override;
		};
		static_assert(sizeof(s_dwssettoverridenodedata) == 4, "struct s_dwssettoverridenodedata is invalid size");

		struct s_setlightsourceenergynodedata
		{
			long light_guid;
			long kit_guid;
			real energy;
		};
		static_assert(sizeof(s_setlightsourceenergynodedata) == 12, "struct s_setlightsourceenergynodedata is invalid size");

		struct s_setlightdimmernodedata
		{
			long light_guid;
			long kit_guid;
			real dimmer;
		};
		static_assert(sizeof(s_setlightdimmernodedata) == 12, "struct s_setlightdimmernodedata is invalid size");

		struct s_setgraphupdatemodedata
		{
			c_enum<e_objectgraphupdatemode, char> graph_update_mode;
		};
		static_assert(sizeof(s_setgraphupdatemodedata) == 1, "struct s_setgraphupdatemodedata is invalid size");

		struct s_windspeednodedata
		{
			char dummy_data;
		};
		static_assert(sizeof(s_windspeednodedata) == 1, "struct s_windspeednodedata is invalid size");

		struct s_exportedobjectnodegraph
		{
			s_anytag_struct_definition anytag;
			c_typed_tag_reference<OBJECTNODEGRAPH_TAG> source_graph;
			real max_update_rate;
			real max_update_rate_cull_modifier;
			real min_update_rate;
			c_enum<e_lodmode, char> lod_mode;
			char generated_pade2c0[3]; // padding
			real lod_distance;
			c_enum<e_objectgraphupdatemode, char> update_mode;
			char generated_padfca1[3]; // padding
			real priority_factor;
			c_typed_tag_block<s_objectgraphconnection> connections_block;
			c_typed_tag_block<s_booleanlogicnode> boolean_logic_nodes_block;
			c_typed_tag_block<s_booltogglenodedata> bool_toggle_nodes_block;
			c_typed_tag_block<s_booltoeventnodedata> bool_to_event_nodes_block;
			c_typed_tag_block<s_brancheventnodedata> branch_event_nodes_block;
			c_typed_tag_block<s_checklightingvariantnodedata> check_lighting_variant_nodes_block;
			c_typed_tag_block<s_clampnodedata> clamp_nodes_block;
			c_typed_tag_block<s_comparefloatnodedata> compare_float_nodes_block;
			c_typed_tag_block<s_constantfloatnode> constant_float_nodes_block;
			c_typed_tag_block<s_constantintnode> constant_int_nodes_block;
			c_typed_tag_block<s_constantint64node> constant_int64_nodes_block;
			c_typed_tag_block<s_constantuint64node> constant_uint64_nodes_block;
			c_typed_tag_block<s_constantstringnode> constant_string_nodes_block;
			c_typed_tag_block<s_constantvector3node> constant_vector3_nodes_block;
			c_typed_tag_block<s_constantboolnode> constant_bool_nodes_block;
			c_typed_tag_block<s_debugprintnodedata> debug_print_nodes_block;
			c_typed_tag_block<s_envelopenodedata> envelope_nodes_block;
			c_typed_tag_block<s_eventrouternodedata> event_router_block;
			c_typed_tag_block<s_floatsnapshotnodedata> float_snapshot_nodes_block;
			c_typed_tag_block<s_floatlogicnode> float_logic_nodes_block;
			c_typed_tag_block<s_floatoperatornode> float_operator_nodes_block;
			c_typed_tag_block<s_getgamefloatvaluenodedata> get_game_float_value_nodes_block;
			c_typed_tag_block<s_floatswitchnodedata> float_switch_nodes_block;
			c_typed_tag_block<s_getgameeventnodedata> get_game_event_nodes_block;
			c_typed_tag_block<s_loopingsoundnodedata> looping_sound_nodes_block;
			c_typed_tag_block<s_objectfunctionnodedata> object_function_nodes_block;
			c_typed_tag_block<s_oneshotsoundnodedata> one_shot_sound_nodes_block;
			c_typed_tag_block<s_oneshotsoundreferencenodedata> one_shot_sound_reference_nodes_block;
			c_typed_tag_block<s_persistentrandomfloatnodedata> persistent_random_float_nodes_block;
			c_typed_tag_block<s_probabilityeventnodedata> probability_event_nodes_block;
			c_typed_tag_block<s_piecewisefunctionnodedata> piecewise_function_nodes_block;
			c_typed_tag_block<s_randomnode> random_nodes_block;
			c_typed_tag_block<s_randomplacementcollectionpositionnodedata> random_placement_position_nodes_block;
			c_typed_tag_block<s_rateofchangenodedata> rate_of_change_nodes_block;
			c_typed_tag_block<s_registereventnodedata> registerevent_nodes_block;
			c_typed_tag_block<s_setrtpcnodedata> set_rtpc_nodes_block;
			c_typed_tag_block<s_smoothingnodedata> smoothing_nodes_block;
			c_typed_tag_block<s_statebrokerboolnodedata> state_broker_bool_nodes_block;
			c_typed_tag_block<s_statebrokerintnodedata> state_broker_int_nodes_block;
			c_typed_tag_block<s_springnodedata> spring_nodes_block;
			c_typed_tag_block<s_thresholdgatenodedata> threshold_gate_nodes_block;
			c_typed_tag_block<s_timernodedata> timer_nodes_block;
			c_typed_tag_block<s_createeffectnodedata> create_effect_nodes_block;
			c_typed_tag_block<s_createbeameffectnodedata> create_beam_effect_node_block;
			c_typed_tag_block<s_stopeffectnodedata> stop_effect_nodes_block;
			c_typed_tag_block<s_setobjectfunctionnodedata> set_object_function_nodes_block;
			c_typed_tag_block<s_valueconversionnode> value_conversion_nodes_block;
			c_typed_tag_block<s_objectgraphoutput> object_graph_outputs_block;
			c_typed_tag_block<s_dwspopstatenodedata> dws_pop_state_nodes_block;
			c_typed_tag_block<s_dwspushstatenodedata> dws_push_state_nodes_block;
			c_typed_tag_block<s_dwsenabletoverridenodedata> dws_enable_t_override_nodes_block;
			c_typed_tag_block<s_dwssettoverridenodedata> dws_set_t_override_nodes_block;
			c_typed_tag_block<s_setlightsourceenergynodedata> set_light_source_energy_nodes_block;
			c_typed_tag_block<s_setlightdimmernodedata> set_light_dimmer_nodes_block;
			c_typed_tag_block<s_setgraphupdatemodedata> set_graph_update_mode_nodes_block;
			c_typed_tag_block<s_windspeednodedata> wind_speed_nodes_block;
		};
		static_assert(sizeof(s_exportedobjectnodegraph) == 732, "struct s_exportedobjectnodegraph is invalid size");

		struct s_goboscalarfunction
		{

			/* Gobo Parameters */

			string_id input_variable;
			string_id range_variable;
			c_enum<e_lightoutputmodifier, short> output_modifier;
			char generated_pad6da9[2]; // padding
			string_id output_modifier_input;
			// custom mapping
			s_functiondefinition mapping;
		};
		static_assert(sizeof(s_goboscalarfunction) == 36, "struct s_goboscalarfunction is invalid size");

		struct s_goboanimationparameter
		{
			c_enum<e_goboanimationparametertype, long> type;
			real origin_x;
			real origin_y;
			s_goboscalarfunction function;
		};
		static_assert(sizeof(s_goboanimationparameter) == 48, "struct s_goboanimationparameter is invalid size");

		struct s_gobodefinition
		{
			c_enum<e_esampleraddressmode, char> bitmap_address_mode;
			c_enum<e_esampleraddressmode, char> displacement_bitmap_address_mode;
			char generated_pad1972[2]; // padding
			c_typed_tag_reference<BITMAP_TAG> bitmap;
			c_typed_tag_block<s_goboanimationparameter> animation_parameters_block;
			c_typed_tag_reference<BITMAP_TAG> displacement_bitmap;
			c_typed_tag_block<s_goboanimationparameter> displacement_animation_parameters_block;
		};
		static_assert(sizeof(s_gobodefinition) == 60, "struct s_gobodefinition is invalid size");

		struct s_gobosetting
		{
			s_anytag_struct_definition anytag;

			/* Gobos */

			c_typed_tag_block<s_gobodefinition> gobos_block;
			long resolution;
		};
		static_assert(sizeof(s_gobosetting) == 32, "struct s_gobosetting is invalid size");

		struct s_lightingsettingsglobal
		{
			c_flags<e_c_lightmap_global_flags, long, k_c_lightmap_global_flags_count> global_flags;
			c_enum<e_lightmapmode, long> mode;
			c_enum<e_lightmapquality, short> lightmap_quality;
			c_enum<e_lightmapindirectquality, short> indirect_quality;
		};
		static_assert(sizeof(s_lightingsettingsglobal) == 12, "struct s_lightingsettingsglobal is invalid size");

		struct s_lightingsettingsao
		{
			real radius;
			real falloff_power;
			real multiplier;
		};
		static_assert(sizeof(s_lightingsettingsao) == 12, "struct s_lightingsettingsao is invalid size");

		struct s_lightingsettingslocaloverrides
		{
			long high_quality_average_jitter_samples;
			long per_vertex_supersample_count;
			long indirect_quality_offset;
		};
		static_assert(sizeof(s_lightingsettingslocaloverrides) == 12, "struct s_lightingsettingslocaloverrides is invalid size");

		struct s_adjacentbsplighting
		{
			string_id name;
			string_id lighting_variant_name;
		};
		static_assert(sizeof(s_adjacentbsplighting) == 8, "struct s_adjacentbsplighting is invalid size");

		struct s_lightingsettingslocal
		{
			c_enum<e_lightingsettingssizeclass, long> size_class;
			c_enum<e_lightingsettingssizeclass, long> static_size_class;
			c_enum<e_lightingsettingssupersampleclass, long> supersample_factor_class;
			c_enum<e_lightingsettingsoptixjobsizeclass, long> optix_job_size_class;
			c_enum<e_lightingsettingslodclampclass, long> adjacent_bsp_lod_clamp_level;
			c_enum<e_lightmapcompressionmode, long> lightmap_compression;
			c_flags<e_lightmaplocalflags, long, k_lightmaplocalflags_count> local_flags;
			real skydome_amplification_factor;
			real indirect_amplification_factor;
			// custom ambient_occlusion_settings
			s_lightingsettingsao ao_settings;
			// custom value
			// custom quality_overrides
			s_lightingsettingslocaloverrides local_lightmapper_override_settings;
			// custom value
			c_enum<e_requiredairprobedensity, long> required_aiprobe_density;
			real airprobe_compression_threshold;
			c_typed_tag_reference<SKY_LIGHTING_TAG> sky_lighting;
			c_typed_tag_reference<BITMAP_TAG> sky_lighting_cubemap;
			c_enum<e_lightingsettingssizeclass, long> forge_lightmap_size_class;
			c_typed_tag_block<s_adjacentbsplighting> adjacent_bsps_block;
		};
		static_assert(sizeof(s_lightingsettingslocal) == 116, "struct s_lightingsettingslocal is invalid size");

		struct s_floatingshadowsettings
		{
			s_speccontrolnodebyteexact number_of_cascades;
			s_speccontrolnodeshadowquality quality;
			c_enum<e_firstpersonfloatingshadowmode, char> first_person_floating_shadow_mode;
			char generated_pad30c7[1]; // padding
			real cascade_overlap;
			real min_shadow_caster_pixel_radius;
			real_vector3d rotating_sun_axis;
			// custom pcss_settings
			real pcss_light_size;
			real pcss_minimum_filter_width;
			real pcss_maximum_filter_width;
			// custom value
			string_id rotating_sun_device_machine_driver_name;
			s_floatingshadowcascadesettings dynamic_cascades[6];
			long number_of_parallax_sampling_steps;
			real sun_direction_parallax_sampling_weight;
			real first_person_additional_depth_bias;
		};
		static_assert(sizeof(s_floatingshadowsettings) == 2760, "struct s_floatingshadowsettings is invalid size");

		struct s_lightingsettingsruntime
		{
			s_visualenvironment visual_environment;
			c_typed_tag_reference<CUSTOM_OBJECT_LIGHTING_TAG> custom_fallback_airprobe;
			s_rgblightprobe raw_sh_data[27];
			c_flags<e_customfallbackairprobeflags, long, k_customfallbackairprobeflags_count> custom_fallback_airprobe_flags;
			// custom cubemaps
			c_typed_tag_reference<BITMAP_TAG> cubemap_texture;
			c_flags<e_cubemapflagsclass, long, k_cubemapflagsclass_count> cubemap_flags;
			real_point3d cubemap_sample_position;
			real_point3d cubemap_intensity;
			real self_illum_scale_down;
			// custom value
			real max_shadow_count_scale;
			// custom floating_shadows
			s_floatingshadowsettings floating_shadow_settings;
			// custom value
		};
		static_assert(sizeof(s_lightingsettingsruntime) == 3020, "struct s_lightingsettingsruntime is invalid size");

		struct s_lightingsettingsadditionalbsp
		{
			c_typed_tag_reference<SCENARIO_STRUCTURE_BSP_TAG> bsp_reference;
		};
		static_assert(sizeof(s_lightingsettingsadditionalbsp) == 16, "struct s_lightingsettingsadditionalbsp is invalid size");

		struct s_indirectirradiancetodsettings
		{
			string_id dws_event_list_to_apply_for_baking;
			string_id dws_state_to_apply_for_baking;
			c_enum<e_dynamiclightsinbake, char> lights_on_during_bake;
			c_enum<e_emissivematerialsinbake, char> emissive_material_on_during_bake;
			char generated_pad89a2[2]; // padding
		};
		static_assert(sizeof(s_indirectirradiancetodsettings) == 12, "struct s_indirectirradiancetodsettings is invalid size");

		struct s_indirectirradianceprobesettings
		{
			c_enum<e_autoloadneighboringbspsinbake, char> auto_load_neighboring_bsps;
			char generated_pad8dc5[3]; // padding
			c_typed_tag_block<s_lightingsettingsadditionalbsp> additional_bsps_to_load_for_baking_block;
			c_typed_tag_block<s_indirectirradiancetodsettings> tod_settings_block;
			long number_of_bounces;
			real sky_amplification_factor;
			real bounce_light_amplification_factor;
			real probe_xy_spacing_factor;
			real probe_z_spacing_factor;
			c_enum<e_deferredreflectionsinbake, char> deferred_reflections_during_bake;
			char generated_pad73e4[3]; // padding
			real lod_scale_during_bake;
			long maximum_texture_size_during_bake;
		};
		static_assert(sizeof(s_indirectirradianceprobesettings) == 60, "struct s_indirectirradianceprobesettings is invalid size");

		struct s_lightingsettings
		{
			s_anytag_struct_definition anytag;
			long version;
			// custom global_quality_settings
			s_lightingsettingsglobal global_lightmapper_settings;
			// custom value
			// custom local_settings
			s_lightingsettingslocal local_lightmapper_settings;
			// custom value
			// custom runtime_settings
			s_lightingsettingsruntime runtime_settings;
			// custom value
			s_indirectirradianceprobesettings indirect_irradiance_probe_settings;
			char generated_pad54e9[4]; // padding
		};
		static_assert(sizeof(s_lightingsettings) == 3232, "struct s_lightingsettings is invalid size");

		struct s_runtimeanimentry
		{
			c_typed_tag_reference<MODEL_ANIMATION_GRAPH_TAG> m_generatedmodelanimation;
			long m_animationid;
			real m_weight;
			s_tag_reference m_animsource;
		};
		static_assert(sizeof(s_runtimeanimentry) == 40, "struct s_runtimeanimentry is invalid size");

		struct s_runtimeanimentrylist
		{
			string_id m_token;
			c_typed_tag_block<s_runtimeanimentry> m_animations_block;
			c_flags<e_runtimeanimentrylistflags, char, k_runtimeanimentrylistflags_count> flags;
			char generated_padec23[3]; // padding
		};
		static_assert(sizeof(s_runtimeanimentrylist) == 20, "struct s_runtimeanimentrylist is invalid size");

		struct s_runtimeanimsettag
		{
			s_anytag_struct_definition anytag;
			string_id m_channel;
			c_typed_tag_reference<RUNTIMEANIMSET_TAG> m_parent;
			c_typed_tag_block<s_runtimeanimentrylist> m_animentrylists_block;
			char generated_pad402f[4]; // padding
		};
		static_assert(sizeof(s_runtimeanimsettag) == 52, "struct s_runtimeanimsettag is invalid size");

		struct s_streamingzonesetoboslete
		{
			s_anytag_struct_definition anytag;
		};
		static_assert(sizeof(s_streamingzonesetoboslete) == 16, "struct s_streamingzonesetoboslete is invalid size");

		struct s_nodegraphcontentanimgraphcontenttag
		{
			s_nodegraphcontentnodegraphcontenttag nodegraph;
		};
		static_assert(sizeof(s_nodegraphcontentanimgraphcontenttag) == 68, "struct s_nodegraphcontentanimgraphcontenttag is invalid size");

		struct s_nodegraphcontentanimstatecontenttag
		{
			s_nodegraphcontentnodegraphcontenttag nodegraph;
		};
		static_assert(sizeof(s_nodegraphcontentanimstatecontenttag) == 68, "struct s_nodegraphcontentanimstatecontenttag is invalid size");

		struct s_nodegraphcontentblackboardcontenttag
		{
			s_nodegraphcontentnodegraphcontenttag nodegraph;
		};
		static_assert(sizeof(s_nodegraphcontentblackboardcontenttag) == 68, "struct s_nodegraphcontentblackboardcontenttag is invalid size");

		struct s_s_biped_camera_height
		{
			string_id weapon_class;
			real standing_height;
			real crouching_height;
			real sliding_camera_height_min;
		};
		static_assert(sizeof(s_s_biped_camera_height) == 16, "struct s_s_biped_camera_height is invalid size");

		struct s_s_biped_movement_gate
		{
			real period;
			real z_offset;
			real constant_z_offset;
			real y_offset;
			real speed_threshold;
			// custom default_function
			s_functiondefinition default_function;
		};
		static_assert(sizeof(s_s_biped_movement_gate) == 40, "struct s_s_biped_movement_gate is invalid size");

		struct s_s_character_physics_ground_definition
		{
			c_flags<e_s_character_physics_ground_definitiongroundphysicsflags, long, k_s_character_physics_ground_definitiongroundphysicsflags_count> flags;
			angle maximum_slope_angle;
			angle downhill_falloff_angle;
			angle downhill_cutoff_angle;
			angle uphill_falloff_angle;
			angle uphill_cutoff_angle;
			real_fraction downhill_velocity_scale;
			real_fraction uphill_velocity_scale;
			angle climb_inflection_angle;
			// custom ground_to_airborne_control
			real airborne_reaction_time;
			real airborne_reaction_time_slide;
			real airborne_reaction_time_slide_max_height;
			real airborne_reaction_time_sprint;
			real airborne_reaction_time_evade;
			real scale_airborne_reaction_time;
			real prevent_jump_from_slide_time;
			// custom value
			real scale_ground_adhesion_velocity;
			real gravity_scale;
			real airborne_acceleration_scale;
			real successive_slide_delay;
			real minimum_slide_trigger_sprint_fraction;

			/* Slide distance function */

			// custom slide_distance_function
			s_functiondefinition slide_distance_function$2;
			real forward_speed;
			angle maximum_direction_change_during_slide;
			angle maximum_turn_during_slide;

			/* Slide speed function */

			// custom slide_speed_function
			s_functiondefinition slide_speed_function$2;
			c_typed_tag_reference<LOWCEILINGCONTROLTAG_TAG> low_ceiling_control;
		};
		static_assert(sizeof(s_s_character_physics_ground_definition) == 152, "struct s_s_character_physics_ground_definition is invalid size");

		struct s_s_character_physics_flying_definition
		{
			angle bank_angle;
			real bank_apply_time;
			real bank_decay_time;
			real pitch_ratio;
			real max_velocity;
			real max_sidestep_velocity;
			real acceleration;
			real deceleration;
			angle angular_velocity_maximum;
			angle angular_acceleration_maximum;
			real crouch_velocity_modifier;
			c_flags<e_s_character_physics_flying_definitionflyingphysicsflag, long, k_s_character_physics_flying_definitionflyingphysicsflag_count> flags;
		};
		static_assert(sizeof(s_s_character_physics_flying_definition) == 48, "struct s_s_character_physics_flying_definition is invalid size");

		struct s_s_character_physics_definition
		{
			c_flags<e_s_character_physics_definitionc_flags, long, k_s_character_physics_definitionc_flags_count> flags;
			real height_standing;
			real height_crouching;
			real radius;
			real mass;
			c_enum<e_i343physicsmodelerigidbodysize, char> maximum_rigid_body_size_override;
			char generated_pad024d[3]; // padding
			string_id living_material_name;
			string_id dead_material_name;
			short runtime_global_material_type;
			short runtime_dead_global_material_type;
			c_typed_tag_block<s_i343physicsmodelhavokserializedshape> dead_sphere_shapes_block;
			c_typed_tag_block<s_i343physicsmodelhavokserializedshape> transformed_dead_sphere_shapes_block;
			c_typed_tag_block<s_i343physicsmodelhavokserializedshape> pill_shapes_block;
			c_typed_tag_block<s_i343physicsmodelhavokserializedshape> sphere_shapes_block;
			c_typed_tag_block<s_i343physicsmodelhavokserializedshape> compund_sphere_shapes_block;
			// custom physics___ground
			s_s_character_physics_ground_definition ground_physics;
			// custom value
			// custom physics___flying
			s_s_character_physics_flying_definition flying_physics;
			// custom value
			// custom physics___clambering
			c_typed_tag_reference<CLAMBERINGDEFINITION_TAG> clambering_definition;
			// custom value
		};
		static_assert(sizeof(s_s_character_physics_definition) == 312, "struct s_s_character_physics_definition is invalid size");

		struct s_biped_contact_point
		{
			// custom value
			string_id marker_name;
		};
		static_assert(sizeof(s_biped_contact_point) == 4, "struct s_biped_contact_point is invalid size");

		struct s_s_biped_leaping_data
		{
			// custom wall_leaping

			/* wall-leaping fields */

			c_flags<e_c_biped_leap_flags, long, k_c_biped_leap_flags_count> leap_flags;
			real_fraction dampening_scale;
			real_fraction roll_delay;
			real_fraction cannonball_off_axis_scale;
			real_fraction cannonball_off_track_scale;
			angle_bounds cannonball_roll_bounds;
			real_bounds anticipation_ratio_bounds;
			real_bounds reaction_force_bounds;
			real_fraction lobbing_desire;
			// custom value
		};
		static_assert(sizeof(s_s_biped_leaping_data) == 48, "struct s_s_biped_leaping_data is invalid size");

		struct s_s_biped_vaulting_data
		{
			// custom vaulting

			/* vaulting fields */

			real_bounds vault_height_bounds;
			real vault_max_horizontal_distance;
			real_fraction vault_arc_amount;
			real vault_min_object_size;
			real search_width;
			// custom value
		};
		static_assert(sizeof(s_s_biped_vaulting_data) == 24, "struct s_s_biped_vaulting_data is invalid size");

		struct s_s_biped_ground_fitting_data
		{
			// custom ground_fitting

			/* ground fitting data */

			c_flags<e_c_biped_ground_fitting_flags, long, k_c_biped_ground_fitting_flags_count> ground_fitting_flags;
			real_fraction ground_normal_dampening;
			real root_offset_max_scale_idle;
			real root_offset_max_scale_moving;
			real_fraction root_offset_dampening;
			real_fraction following_cam_scale;
			real_fraction root_leaning_scale;
			real stance_width_scale;
			angle foot_roll_max;
			angle foot_pitch_max;
			real_fraction foot_normal_dampening;
			real foot_fitting_test_distance;
			real_fraction foot_displacement_upward_dampening;
			real_fraction foot_displacement_downward_dampening;
			real foot_pull_threshold_distance_idle;
			real foot_pull_threshold_distance_moving;
			real foot_turn_minimum_radius;
			real foot_turn_maximum_radius;
			real foot_turn_threshold_radius;
			real foot_turn_rate_dampening;
			real foot_turn_weight_dampening;
			real foot_turn_blend_on_time;
			real foot_turn_blend_off_time;
			// custom value
			// custom pivot_on_foot

			/* pivot-on-foot data */

			real_fraction pivot_on_foot_scale;
			real pivot_min_foot_delta;
			real pivot_stride_length_scale;
			real_fraction pivot_throttle_scale;
			real_fraction pivot_offset_dampening;
			real_fraction pivot_force_turn_rate;
			// custom value
			// custom ground_fitting_pelvis_elevation_settings
			real ideal_pelvis_over_high_foot_scale;
			real ideal_pelvis_over_low_foot_scale;
			// custom value
			// custom ledge_push

			/* Pushing over Ledges */

			real push_over_mag;
			real push_back_mag;
			real ledgeiksuccessrange;
			real ledge_warning_time;
			// custom value
			// custom foot_locking
			real footlock_scale;
			real footlock_min_throttle;
			real footlock_max_throttle;
			// custom value
		};
		static_assert(sizeof(s_s_biped_ground_fitting_data) == 152, "struct s_s_biped_ground_fitting_data is invalid size");

		struct s_bipedaimingjointfixup
		{
			string_id rotation_node;
			// custom value
			string_id marker_name;
			angle_bounds yaw_bounds;
			angle_bounds pitch_bounds;
			real max_yaw_velocity;
			real max_pitch_velocity;
		};
		static_assert(sizeof(s_bipedaimingjointfixup) == 32, "struct s_bipedaimingjointfixup is invalid size");

		struct s_bipedpostureadjustmentbounds
		{
			real_bounds x_bounds;
			real_bounds y_bounds;
			real_bounds z_bounds;
		};
		static_assert(sizeof(s_bipedpostureadjustmentbounds) == 24, "struct s_bipedpostureadjustmentbounds is invalid size");

		struct s_bipedfbikposturesettings
		{

			/* spine bounds for random posture variation */

			s_bipedpostureadjustmentbounds spine;

			/* hand bounds for random posture variation */

			s_bipedpostureadjustmentbounds hands;

			/* head bounds for random posture variation */

			s_bipedpostureadjustmentbounds head;
		};
		static_assert(sizeof(s_bipedfbikposturesettings) == 72, "struct s_bipedfbikposturesettings is invalid size");

		struct s_bipedfbikaimsettings
		{

			/* aim refinement settings */

			real aim_fixup_cos;
			real aim_fixup_power;
		};
		static_assert(sizeof(s_bipedfbikaimsettings) == 8, "struct s_bipedfbikaimsettings is invalid size");

		struct s_bipedfbiklooksettings
		{

			/* look refinement settings */

			real look_yaw_scale;
			real look_non_yaw_scale;
			real look_bend_scale;
			real look_spine_scale;
			angle look_cone_angle;
		};
		static_assert(sizeof(s_bipedfbiklooksettings) == 20, "struct s_bipedfbiklooksettings is invalid size");

		struct s_bipedfbikjumpanticsettings
		{
			// custom jump_antic_settings
			c_flags<e_bipedjumpanticflags, long, k_bipedjumpanticflags_count> flags;
			real max_falloff_elevation;

			/* Overlay buildup curve */

			// custom overlay_buildup
			s_functiondefinition overlay_buildup_function;

			/* Overlay falloff curve */

			// custom overlay_falloff
			s_functiondefinition overlay_falloff_function;

			/* Hip IK buildup curve */

			// custom hip_ik_buildup
			s_functiondefinition hip_ik_buildup_function;

			/* Hip IK falloff curve */

			// custom hip_ik_falloff
			s_functiondefinition hip_ik_falloff_function;

			/* Leg IK falloff curve */

			// custom leg_ik_falloff
			s_functiondefinition leg_ik_falloff_function;
			// custom value
		};
		static_assert(sizeof(s_bipedfbikjumpanticsettings) == 108, "struct s_bipedfbikjumpanticsettings is invalid size");

		struct s_bipedfbiksettings
		{
			// custom ik_aim_and_posture_adjustment
			c_flags<e_bipedfbikflags, long, k_bipedfbikflags_count> flags;
			s_bipedfbikposturesettings posture;
			s_bipedfbikaimsettings aim;
			s_bipedfbiklooksettings look;
			s_bipedfbikjumpanticsettings jumpantic;
			// custom value
		};
		static_assert(sizeof(s_bipedfbiksettings) == 212, "struct s_bipedfbiksettings is invalid size");

		struct s_i343bipedpropertiesdefinition
		{
			c_typed_tag_block<s_i343bipedlocomotionpropertiesdefinition> locomotion_properties_block;
			// custom walking_speed
			s_i343malleablepropertybasefloatstructdefinition walking_speed;
			// custom ai_sprinting_speed
			s_i343malleablepropertybasefloatstructdefinition ai_sprinting_speed;
			// custom running_forward_speed
			s_i343malleablepropertybasefloatstructdefinition running_forward_speed;
			// custom running_backward_speed
			s_i343malleablepropertybasefloatstructdefinition running_backward_speed;
			// custom running_sideways_speed
			s_i343malleablepropertybasefloatstructdefinition running_sideways_speed;
			// custom crouching_forward_speed
			s_i343malleablepropertybasefloatstructdefinition crouching_forward_speed;
			// custom crouching_backward_speed
			s_i343malleablepropertybasefloatstructdefinition crouching_backward_speed;
			// custom crouching_sideways_speed
			s_i343malleablepropertybasefloatstructdefinition crouching_sideways_speed;
			// custom maximum_run_acceleration
			s_i343malleablepropertybasefloatstructdefinition maximum_run_acceleration;
			// custom maximum_crouch_acceleration
			s_i343malleablepropertybasefloatstructdefinition maximum_crouch_acceleration;
			// custom maximum_airborne_acceleration
			s_i343malleablepropertybasefloatstructdefinition maximum_airborne_acceleration;
			// custom movement_speed_scalar
			s_i343malleablepropertybasefloatstructdefinition movement_speed_scalar;
			// custom movement_gravity_scalar
			s_i343malleablepropertybasefloatstructdefinition movement_gravity_scalar;
			// custom movement_jump_scalar
			s_i343malleablepropertybasefloatstructdefinition movement_jump_scalar;
			// custom movement_clamber_speed_scalar
			s_i343malleablepropertybasefloatstructdefinition movement_clamber_speed_scalar;
			// custom speed_forward_scalar
			s_i343malleablepropertybasefloatstructdefinition speed_forward_scalar;
			// custom speed_strafe_scalar
			s_i343malleablepropertybasefloatstructdefinition speed_strafe_scalar;
			// custom acceleration_forward_scalar
			s_i343malleablepropertybasefloatstructdefinition acceleration_forward_scalar;
			real acceleration_opposing_forward_scalar;
			// custom acceleration_strafe_scalar
			s_i343malleablepropertybasefloatstructdefinition acceleration_strafe_scalar;
			real acceleration_opposing_strafe_scalar;
			// custom acceleration_airborne_scalar
			s_i343malleablepropertybasefloatstructdefinition acceleration_airborne_scalar;
			// custom slide_max_distance_scalar
			s_i343malleablepropertybasefloatstructdefinition slide_max_distance_scalar;
			// custom slide_speed_scalar
			s_i343malleablepropertybasefloatstructdefinition slide_speed_scalar;
		};
		static_assert(sizeof(s_i343bipedpropertiesdefinition) == 284, "struct s_i343bipedpropertiesdefinition is invalid size");

		struct s_bipedhoverproperties
		{
			// custom hover_properties
			real_bounds resting_hover_height;
			real default_height_tolerance;
			real spring_interpolation_time;
			real_fraction hard_land_start_threshold;
			real_fraction hard_land_settle_down_threshold;
			real hard_land_slow_down_height;
			real hard_land_bottom_height;
			real_fraction soft_land_start_threshold;
			real_fraction soft_land_slow_down_threshold;
			real soft_land_settle_height;
			real soft_land_bottom_height;
			s_scalarfunctionname land_interpolation_function;
			s_scalarfunctionname settle_land_interpolation_function;
			s_scalarfunctionname reset_to_resting_height_interpolation_function;
			// custom value
		};
		static_assert(sizeof(s_bipedhoverproperties) == 108, "struct s_bipedhoverproperties is invalid size");

		struct s_bipeddefinition
		{
			s_unitdefinition unit;
			// custom $$$_biped_$$$
			c_typed_tag_reference<BIPED_TAG> parent;
			angle moving_turning_speed;
			c_flags<e_c_biped_definition_flags, long, k_c_biped_definition_flags_count> flags;
			angle stationary_turning_threshold;
			angle stationary_turn_fixup_speed;
			c_typed_tag_reference<DEATH_PROGRAM_SELECTOR_TAG> death_program_selector;
			string_id ragdoll_region_name;
			string_id assassination_chud_text;

			/* jumping and landing */

			real jump_velocity;
			c_typed_tag_block<s_s_unit_trick_definition> tricks_block;
			real maximum_soft_landing_time;
			real maximum_hard_landing_time;
			real minimum_soft_landing_velocity;
			real minimum_hard_landing_velocity;
			real maximum_hard_landing_velocity;
			real stun_duration;

			/* camera, collision, and autoaim */

			real standing_camera_height;
			real running_camera_height;
			real crouching_camera_height;
			real crouch_walking_camera_height;
			real crouch_transition_time;
			real bunker_forward_offset;
			real bunker_side_offset;
			real slide_camera_height_minimum;

			/* slide camera height function */

			// custom slide_camera_height_function
			s_functiondefinition slide_camera_height_function$2;
			real_fraction slide_rumble_low_frequency;
			real_fraction slide_rumble_high_frequency;
			real_fraction slide_rumble_left_trigger;
			real_fraction slide_rumble_right_trigger;
			real slide_firing_delay;
			// custom camera_height_velocity_function
			s_functiondefinition camera_height_velocity_function;
			c_typed_tag_block<s_s_biped_camera_height> camera_heights_block;
			angle camera_interpolation_start;
			angle camera_interpolation_end;
			real_vector3d camera_offset;
			real root_offset_camera_scale;
			real root_offset_camera_dampening;
			real autoaim_width;
			real runtime_cosine_stationary_turning_threshold;
			real runtime_crouch_transition_velocity;
			real runtime_camera_height_velocity;
			c_typed_tag_reference<EFFECT_TAG> area_damage_effect;
			c_typed_tag_reference<EFFECT_TAG> health_station_recharge_effect;
			c_typed_tag_block<s_s_biped_movement_gate> movement_gates_block;
			c_typed_tag_block<s_s_biped_movement_gate> movement_gates_crouching_block;
			real jump_aim_offset_distance;
			real jump_aim_offset_duration;
			real land_aim_offset_distance;
			real land_aim_offset_duration;
			// custom physics
			s_s_character_physics_definition physics;
			// custom value
			c_typed_tag_block<s_biped_contact_point> contact_points_block;
			c_typed_tag_reference<CHARACTER_TAG> reanimation_character;
			c_typed_tag_reference<CHARACTER_TAG> death_spawn_character;
			short death_spawn_count;
			char generated_pad3e4d[2]; // padding
			s_s_biped_leaping_data leaping_data;
			s_s_biped_vaulting_data vaulting_data;
			s_s_biped_ground_fitting_data ground_fitting_data;
			real movement_speed_scale;
			// custom value
			c_typed_tag_reference<SOUNDBANK_TAG> player_biped_sound_bank;
			c_typed_tag_reference<SOUND_TAG> crouch_down_sound;
			c_typed_tag_reference<SOUND_TAG> crouch_up_sound;
			c_typed_tag_reference<SOUND_TAG> shield_impact_override;
			c_typed_tag_reference<SOUND_TAG> non_shield_impact_override;
			real sound_radius_multiplier;
			c_typed_tag_block<s_soundrtpcblockdefinition> sound_rtpcs_block;
			c_typed_tag_block<s_soundsweetenerblockdefinition> sound_sweeteners_block;
			c_typed_tag_block<s_bipedaimingjointfixup> aiming_fixup_block;
			c_typed_tag_reference<SELF_ILLUMINATION_TAG> self_illumination;
			c_typed_tag_reference<SPARTANABILITYCOMPONENTDEFINITION_TAG> spartan_abilities;
			s_bipedfbiksettings fbik_data;

			/* procedural animation */

			real head_soft_ping_magnitude;
			real chest_soft_ping_magnitude;
			real gut_soft_ping_magnitude;
			real soft_ping_recoil_magnitude;
			real head_soft_ping_primary_response_time;
			real head_soft_ping_secondary_response_time;
			real chest_soft_ping_primary_response_time;
			real chest_soft_ping_secondary_response_time;
			real gut_soft_ping_primary_response_time;
			real gut_soft_ping_secondary_response_time;
			real arms_soft_ping_primary_response_time;
			real arms_soft_ping_secondary_response_time;
			angle head_soft_ping_random_twist_strength;
			angle chest_soft_ping_random_twist_strength;
			angle gut_soft_ping_random_twist_strength;
			real maximum_soft_ping_damage_scalar;
			string_id override_object_function_for_the_sprint_speed_fraction;

			/* properties */

			s_i343bipedpropertiesdefinition properties$2;

			/* Biped modifier */

			c_typed_tag_reference<GENERICMODIFIERDEFINITIONTAG_TAG> biped_modifier_set;
			c_typed_tag_reference<EFFECT_TAG> rez_out_effect;
			real rez_out_effect_buffer;
			c_typed_tag_block<s_bipedhoverproperties> hover_properties_block;
			char generated_padc5c1[4]; // padding
		};
		static_assert(sizeof(s_bipeddefinition) == 4216, "struct s_bipeddefinition is invalid size");

		struct s_crate_definition
		{
			s_objectdefinition object;
			// custom $$$_crate_$$$
			c_flags<e_cratedefinitionflags, long, k_cratedefinitionflags_count> flags;
			c_typed_tag_block<s_s_campaign_metagame_bucket> campaign_metagame_bucket_block;
			long self_destruction_timer;
			c_typed_tag_reference<EFFECT_TAG> projectile_bounce_effect;
			// custom value
		};
		static_assert(sizeof(s_crate_definition) == 1256, "struct s_crate_definition is invalid size");

		struct s_nodegraphcontentblendspace1dcontenttag
		{
			s_nodegraphcontentnodegraphcontenttag nodegraph;
		};
		static_assert(sizeof(s_nodegraphcontentblendspace1dcontenttag) == 68, "struct s_nodegraphcontentblendspace1dcontenttag is invalid size");

		struct s_nodegraphcontentblendspaceradialcontenttag
		{
			s_nodegraphcontentnodegraphcontenttag nodegraph;
		};
		static_assert(sizeof(s_nodegraphcontentblendspaceradialcontenttag) == 68, "struct s_nodegraphcontentblendspaceradialcontenttag is invalid size");

		struct s_nodegraphcontentblendspace2dcontenttag
		{
			s_nodegraphcontentnodegraphcontenttag nodegraph;
		};
		static_assert(sizeof(s_nodegraphcontentblendspace2dcontenttag) == 68, "struct s_nodegraphcontentblendspace2dcontenttag is invalid size");

		struct s_compositexmltag
		{
			s_xmlfiletag xmltag;
		};
		static_assert(sizeof(s_compositexmltag) == 24, "struct s_compositexmltag is invalid size");

		struct s_creature_definition
		{
			s_objectdefinition object;
			// custom $$$_creature_$$$
			c_flags<e_c_creature_definition_flags, long, k_c_creature_definition_flags_count> flags;
			c_enum<e_e_campaign_team, short> default_team;
			char generated_pad86f7[2]; // padding
			angle turning_velocity_maximum_ground_creatures_only;
			angle turning_acceleration_maximum_ground_creatures_only;
			real_fraction casual_turning_modifier_ground_creatures_only;
			real autoaim_width;
			s_s_character_physics_definition physics;
			angle minimal_obstacle_surface_pitch;

			/* New creature flying physics */

			angle yaw_acceleration;
			angle yaw_max_velocity;
			angle pitch_acceleration;
			angle pitch_max_velocity;
			angle roll_acceleration;
			angle roll_max_velocity;
			angle maximum_pitch_angle;
			angle maximum_roll_angle;
			real max_forward_velocity;
			real max_non_directional_vertical_velocity;
			real forward_acceleration;
			real non_directional_vertical_acceleration;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> impact_damage;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> impact_shield_damage;
			c_typed_tag_block<s_s_campaign_metagame_bucket> campaign_metagame_bucket_block;
			c_typed_tag_block<s_soundrtpcblockdefinition> sound_rtpcs_block;

			/* death and destruction */

			real_bounds destroy_after_death_time;
			c_typed_tag_reference<EFFECT_TAG> trail_effect;
			c_typed_tag_reference<EFFECT_TAG> death_effect;
			string_id shooting_effect_marker_name;
			real medium_lod_distance;
			real low_lod_distance;
			// custom value
		};
		static_assert(sizeof(s_creature_definition) == 1716, "struct s_creature_definition is invalid size");

		struct s_i343devicesdevicecomponentlistdefinition
		{
			// custom device_components
			c_typed_tag_reference<OBJECT_DISPENSER_COMPONENT_TAG> object_dispenser_component;
			// custom value
		};
		static_assert(sizeof(s_i343devicesdevicecomponentlistdefinition) == 16, "struct s_i343devicesdevicecomponentlistdefinition is invalid size");

		struct s_device_definition
		{
			s_objectdefinition object;
			// custom $$$_device_$$$
			c_flags<e_devicevariableflag, long, k_devicevariableflag_count> device_flags;
			real power_transition_time;
			real power_acceleration_time;
			real position_transition_time;
			real position_acceleration_time;
			real depowered_position_transition_time;
			real depowered_position_acceleration_time;
			c_flags<e_devicelightmapflag, short, k_devicelightmapflag_count> lightmap_flags;
			char generated_pad86c1[2]; // padding
			s_tag_reference open_up;
			s_tag_reference close_down;
			s_tag_reference opened;
			s_tag_reference closed;
			s_tag_reference depowered;
			s_tag_reference repowered;
			real delay_time;
			s_tag_reference delay_effect;
			real automatic_activation_radius;
			// custom value
			string_id marker_name;
			real marker_radius_min;
			real marker_radius;
			angle marker_cone_angle;
			angle marker_facing_angle;
			real min_targetable_position_threshold;
			real max_targetable_position_threshold;
			real_fraction initial_animation_position;
			s_i343devicesdevicecomponentlistdefinition device_components;
			// custom value
		};
		static_assert(sizeof(s_device_definition) == 1420, "struct s_device_definition is invalid size");

		struct s_nodegraphcontentdecoratorshadergraphcontenttag
		{
			s_nodegraphcontentnodegraphcontenttag nodegraph;
		};
		static_assert(sizeof(s_nodegraphcontentdecoratorshadergraphcontenttag) == 68, "struct s_nodegraphcontentdecoratorshadergraphcontenttag is invalid size");

		struct s_dispenserdefinition
		{
			s_device_definition device;
			// custom dispenser
			c_flags<e_dispenserflags, char, k_dispenserflags_count> flags;
			c_enum<e_dispensertrigger, char> triggers_when;
			byte use_cooldown;
			byte abandonment_time;
			byte max_quota;
			char generated_pade51a[3]; // padding
			real interaction_hold_time;
			string_id interaction_screen;
			s_tag_reference dispensed_object;
			string_id desired_variant_name;
			string_id action_string;
			string_id same_team_denial_string;
			string_id disabled_denial_string;
			string_id use_cooldown_denial_string;
			string_id max_quota_denial_string;
			string_id interaction_in_progress_denial_string;
			// custom value
			string_id spawn_marker_name;
			// custom value
			string_id effect_marker_name;
			c_typed_tag_reference<EFFECT_TAG> dispense_effect;
			string_id dispenser_attach_marker;
			string_id dispensed_object_attach_marker;
			// custom value
			char generated_padc84a[4]; // padding
		};
		static_assert(sizeof(s_dispenserdefinition) == 1516, "struct s_dispenserdefinition is invalid size");

		struct s_nodegraphcontentebtcontenttag
		{
			s_nodegraphcontentnodegraphcontenttag nodegraph;
		};
		static_assert(sizeof(s_nodegraphcontentebtcontenttag) == 68, "struct s_nodegraphcontentebtcontenttag is invalid size");

		struct s_s_effect_scenery_definition
		{
			s_objectdefinition object;
		};
		static_assert(sizeof(s_s_effect_scenery_definition) == 1220, "struct s_s_effect_scenery_definition is invalid size");

		struct s_nodegraphcontentforgemenugraphcontenttag
		{
			s_nodegraphcontentnodegraphcontenttag nodegraph;
		};
		static_assert(sizeof(s_nodegraphcontentforgemenugraphcontenttag) == 68, "struct s_nodegraphcontentforgemenugraphcontenttag is invalid size");

		struct s_nodegraphcontentforgenodegraphcontenttag
		{
			s_nodegraphcontentnodegraphcontenttag nodegraph;
		};
		static_assert(sizeof(s_nodegraphcontentforgenodegraphcontenttag) == 68, "struct s_nodegraphcontentforgenodegraphcontenttag is invalid size");

		struct s_giant_buckle_parameters
		{

			/* timing controls */

			real lower_time;
			c_enum<e_e_slider_movement_pattern, long> lower_curve;
			real raise_time;
			c_enum<e_e_slider_movement_pattern, long> raise_curve;
			real pause_time_easy;
			real pause_time_normal;
			real pause_time_heroic;
			real pause_time_legendary;

			/* optional buckle gravity */

			real buckle_gravity_scale;

			/* buckling search */

			// custom value
			string_id buckling_marker;
			real forward_rear_scan;
			real left_right_scan;
			long forward_rear_steps;
			long left_right_steps;

			/* buckling angle control */

			angle_bounds pitch_bounds;
			angle_bounds roll_bounds;

			/* animations */

			string_id buckle_animation;
			string_id descent_overlay;
			string_id paused_overlay;
			real_fraction descent_overlay_scale;
			real_fraction paused_overlay_scale;
		};
		static_assert(sizeof(s_giant_buckle_parameters) == 92, "struct s_giant_buckle_parameters is invalid size");

		struct s_giant_definition
		{
			s_unitdefinition unit;
			// custom $$$_giant_$$$
			c_flags<e_c_giant_definition_flags, long, k_c_giant_definition_flags_count> flags;

			/* movement */

			real accel_time;
			real decel_time;
			real_fraction minimum_speed_scale;
			real speed_scale;
			real_fraction elevation_change_rate;
			real proxy_body_offset;
			real_fraction proxy_body_deadzone;

			/* foot-placement limit */

			real max_vertical_reach;
			real foot_target_radius;
			c_typed_tag_block<s_giant_buckle_parameters> buckle_settings_block;

			/* ankle ik scale */

			real ankle_ik_scale$2;
			// custom value
		};
		static_assert(sizeof(s_giant_definition) == 2600, "struct s_giant_definition is invalid size");

		struct s_i343itemsvarianthudmessages
		{
			string_id variant_name;

			/* Overrides */

			string_id pickup;
			string_id sub_pickup;
			string_id swap;
			string_id sub_swap;
			string_id pickup_dual;
			string_id swap_dual;
			string_id picked_up;
			string_id switch_to;
			string_id switch_to_from_ai;
			string_id notify_empty;
			string_id low_ammo;
			string_id notify_overheated;
			string_id heat_warning;
		};
		static_assert(sizeof(s_i343itemsvarianthudmessages) == 56, "struct s_i343itemsvarianthudmessages is invalid size");

		struct s_predictedbitmapsblock
		{
			c_typed_tag_reference<BITMAP_TAG> bitmap;
		};
		static_assert(sizeof(s_predictedbitmapsblock) == 16, "struct s_predictedbitmapsblock is invalid size");

		struct s_itemdefinition
		{
			s_objectdefinition object;
			// custom $$$_item_$$$
			c_flags<e_c_item_definition_flags, long, k_c_item_definition_flags_count> item_flags;
			short old_message_index;
			short sort_order;
			real old_multiplayer_on_ground_scale;
			real old_campaign_on_ground_scale;

			/* NEW hud messages */

			string_id pickup;
			string_id sub_pickup;
			string_id swap;
			string_id sub_swap;
			string_id pickup_dual;
			string_id swap_dual;
			string_id picked_up;
			string_id switch_to;
			string_id switch_to_from_ai;
			string_id notify_empty;
			string_id low_ammo;
			string_id notify_overheated;
			string_id heat_warning;
			string_id pickup_message;
			string_id sub_pickup_message;
			string_id swap_message;
			string_id sub_swap_message;
			string_id pickup_message_dual;
			string_id swap_message_dual;
			string_id picked_up_msg;
			string_id switch_to_msg;
			string_id switch_to_from_ai_msg;
			string_id notify_empty_msg;
			string_id low_ammo_msg;
			string_id notify_overheated_message;
			c_typed_tag_block<s_i343itemsvarianthudmessages> variant_hud_message_overrides_block;
			c_typed_tag_block<s_predictedbitmapsblock> predicted_bitmaps_block;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> item_detonation_damage_effect;
			real_bounds detonation_delay;
			c_typed_tag_reference<EFFECT_TAG> detonating_effect;
			c_typed_tag_reference<EFFECT_TAG> detonation_effect;

			/* Item scale settings */

			real ground_scale;
			real small_unit_armed;
			real small_unit_stowed;
			real medium_unit_armed;
			real medium_unit_stowed;
			real large_unit_armed;
			real large_unit_stowed;
			real huge_unit_armed;
			real huge_unit_stowed;
			c_typed_tag_reference<GROUNDED_FRICTION_TAG> grounded_friction_settings;
			c_typed_tag_reference<OBJECT_TAG> tossed_override;
			// custom override_toss_properties
			real toss_angle;
			real toss_angle_max_elevation;
			real toss_angle_min_elevation;
			real toss_velocity;
			real_euler_angles3d toss_rotational_velocity_min;
			real_euler_angles3d toss_rotational_velocity_max;

			/* Item throw settings */

			real_vector3d item_throw_offset;
			real_euler_angles3d item_throw_rotation_offset;
			// custom value
			// custom value
			char generated_pad9d08[4]; // padding
		};
		static_assert(sizeof(s_itemdefinition) == 1552, "struct s_itemdefinition is invalid size");

		struct s_kitplacementlabel
		{
			c_static_string<256> value;
		};
		static_assert(sizeof(s_kitplacementlabel) == 256, "struct s_kitplacementlabel is invalid size");

		struct s_kitplacement
		{
			string_id name;
			long guid;
			real_point3d position;
			real_euler_angles3d orientation;
			real_vector3d scale;
			s_tag_reference kit;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			c_flags<e_kitplacementflags, long, k_kitplacementflags_count> flags;
			c_typed_tag_block<s_kitplacementlabel> string_properties_block;
		};
		static_assert(sizeof(s_kitplacement) == 88, "struct s_kitplacement is invalid size");

		struct s_kitcollectionplacement
		{
			string_id name;
			long guid;
			real_point3d position;
			real_euler_angles3d orientation;
			real_vector3d scale;
			s_tag_reference kit;
			c_typed_tag_block<s_editormetadata> editormetadata_block;
			c_flags<e_kitplacementflags, long, k_kitplacementflags_count> flags;
			c_typed_tag_block<s_kitplacementlabel> string_properties_block;
			c_typed_tag_reference<KITCOLLECTION_TAG> kit_collection;
		};
		static_assert(sizeof(s_kitcollectionplacement) == 104, "struct s_kitcollectionplacement is invalid size");

		struct s_kit
		{
			s_levelobjects levelobjects;
			c_typed_tag_reference<KIT_TAG> parent;
			c_typed_tag_reference<LUA_TAG> script_tag;
			s_s_property_collection scriptable_properties;
			c_typed_tag_block<s_kitplacement> new_kit_placements_block;
			c_typed_tag_block<s_kitcollectionplacement> kit_collection_placements_block;
			long long owner_tag;
			long placement_index;
			byte placement_type;
			byte is_nested;
			char generated_pad3420[2]; // padding
			c_flags<e_kitflags, long, k_kitflags_count> kit_flags;
			char generated_pad4e01[4]; // padding
		};
		static_assert(sizeof(s_kit) == 1224, "struct s_kit is invalid size");

		struct s_layermetadata
		{
			real_point3d geocenter;
		};
		static_assert(sizeof(s_layermetadata) == 12, "struct s_layermetadata is invalid size");

		struct s_layer
		{
			s_levelobjects levelobjects;
			c_typed_tag_block<s_scenario_layer_reference> child_scenarios_block;
			c_typed_tag_reference<SCENARIO_STRUCTURE_BSP_TAG> default_bsp;
			string_id default_lighting_variant;
			c_flags<e_scenarioflags, long, k_scenarioflags_count> flags;
			c_typed_tag_block<s_kitplacement> new_kit_placements_block;
			c_typed_tag_block<s_kitcollectionplacement> kit_collection_placements_block;
			c_typed_tag_block<s_layermetadata> layer_metadata_block;
			c_flags<e_layerflags, long, k_layerflags_count> layer_flags;
		};
		static_assert(sizeof(s_layer) == 1148, "struct s_layer is invalid size");

		struct s_defaultplayerstartindex
		{
			long index;
		};
		static_assert(sizeof(s_defaultplayerstartindex) == 4, "struct s_defaultplayerstartindex is invalid size");

		struct s_multiplayerscenariointrodefinition
		{
			string_id name;
			c_typed_tag_block<s_compositiondefinitionreference> intro_compositions_block;
		};
		static_assert(sizeof(s_multiplayerscenariointrodefinition) == 16, "struct s_multiplayerscenariointrodefinition is invalid size");

		struct s_bsplightingvolumesreference
		{
			c_typed_tag_reference<BSP_LIGHTING_VOLUMES_TAG> bsp_lighting_volumes;
		};
		static_assert(sizeof(s_bsplightingvolumesreference) == 16, "struct s_bsplightingvolumesreference is invalid size");

		struct s_lightingobjectsindex
		{
			short index;
		};
		static_assert(sizeof(s_lightingobjectsindex) == 2, "struct s_lightingobjectsindex is invalid size");

		struct s_lightingvariant
		{
			string_id variant_name;
			c_typed_tag_reference<STRUCTURE_LIGHTS_TAG> structure_lighting_info;
			c_typed_tag_reference<STRUCTURE_LIGHTMAP_TAG> structure_lightmap;
			c_typed_tag_reference<LIGHTING_SETTINGS_TAG> lighting_settings;
			c_typed_tag_block<s_bsplightingvolumesreference> bsp_lighting_volume_references_block;
			c_typed_tag_block<s_lightingobjectsindex> light_indices_block;
			c_typed_tag_block<s_lightingobjectsindex> priority_volume_indices_block;
			c_typed_tag_block<s_lightingobjectsindex> density_volume_indices_block;
			c_typed_tag_block<s_lightingobjectsindex> region_volume_indices_block;
			c_typed_tag_block<s_lightingobjectsindex> cubemap_volume_indices_block;
			c_typed_tag_block<s_lightingobjectsindex> visual_environment_volume_indices_block;
			string_id soundscape_name;
			short sky_reference;
			char generated_pad17c3[2]; // padding
			long forge_lightmap_size;
		};
		static_assert(sizeof(s_lightingvariant) == 148, "struct s_lightingvariant is invalid size");

		struct s_scenario_structure_bsp_reference
		{
			c_typed_tag_reference<SCENARIO_STRUCTURE_BSP_TAG> structure_bsp;
			c_typed_tag_reference<STRUCTURE_META_TAG> structure_metadata;
			string_id load_variant_name;
			c_flags<e_scenariostructurebspreferenceflags, short, k_scenariostructurebspreferenceflags_count> flags;
			char generated_pad5da6[2]; // padding
			real_point3d aabbboundsmin;
			real_point3d aabbboundsmax;
			real custom_gravity_scale;
			c_typed_tag_block<s_lightingvariant> structure_lighting_info_variants_block;
			c_typed_tag_block<s_lightingobjectsindex> bsp_volume_indices_block;
			c_typed_tag_reference<AUTOHLODSETTINGS_TAG> auto_generated_hlods_settings_override;
			c_typed_tag_block<s_scenario_layer_reference> layers_block;
			c_typed_tag_reference<STATIC_COLLISION_TAG> hexgridcollisionref;
			c_typed_tag_reference<RTMP_TAG> hexgridmaterialpaletteref;
		};
		static_assert(sizeof(s_scenario_structure_bsp_reference) == 152, "struct s_scenario_structure_bsp_reference is invalid size");

		struct s_s_scenario_structure_design_reference
		{
			c_typed_tag_reference<STRUCTURE_DESIGN_TAG> structure_design;
		};
		static_assert(sizeof(s_s_scenario_structure_design_reference) == 16, "struct s_s_scenario_structure_design_reference is invalid size");

		struct s_bspflagstoragearray
		{
			dword flag_data;
		};
		static_assert(sizeof(s_bspflagstoragearray) == 4, "struct s_bspflagstoragearray is invalid size");

		struct s_s_scenario_sky_reference
		{
			c_typed_tag_reference<SCENERY_TAG> sky;
			short name;
			char generated_pad4092[2]; // padding
			string_id sky_name;
			s_bspflagstoragearray active_on_bsps[32];
		};
		static_assert(sizeof(s_s_scenario_sky_reference) == 152, "struct s_s_scenario_sky_reference is invalid size");

		struct s_bspclusterreference
		{
			short bsp_index;
			short cluster_index;
		};
		static_assert(sizeof(s_bspclusterreference) == 4, "struct s_bspclusterreference is invalid size");

		struct s_s_scenario_zone_set_cluster_seam_cluster_mappings
		{
			c_typed_tag_block<s_bspclusterreference> root_clusters_block;
			c_typed_tag_block<s_bspclusterreference> attached_clusters_block;
			c_typed_tag_block<s_bspclusterreference> connected_clusters_block;
		};
		static_assert(sizeof(s_s_scenario_zone_set_cluster_seam_cluster_mappings) == 36, "struct s_s_scenario_zone_set_cluster_seam_cluster_mappings is invalid size");

		struct s_s_scenario_zone_set_structure_bsp_pvs
		{
			c_typed_tag_block<s_s_scenario_zone_set_cluster_seam_cluster_mappings> bsp_cluster_mapings_block;
		};
		static_assert(sizeof(s_s_scenario_zone_set_structure_bsp_pvs) == 12, "struct s_s_scenario_zone_set_structure_bsp_pvs is invalid size");

		struct s_s_scenario_zone_set_pvs
		{
			s_bspflagstoragearray structure_bsp_mask[32];
			c_typed_tag_block<s_s_scenario_zone_set_structure_bsp_pvs> structure_bsp_pvs_block;
		};
		static_assert(sizeof(s_s_scenario_zone_set_pvs) == 140, "struct s_s_scenario_zone_set_pvs is invalid size");

		struct s_doorencodedpasblock
		{
			long encoded_data;
		};
		static_assert(sizeof(s_doorencodedpasblock) == 4, "struct s_doorencodedpasblock is invalid size");

		struct s_roomdoorportalencodedpasblock
		{
			long encoded_data;
		};
		static_assert(sizeof(s_roomdoorportalencodedpasblock) == 4, "struct s_roomdoorportalencodedpasblock is invalid size");

		struct s_aideafeningencodedpasblock
		{
			long encoded_data;
		};
		static_assert(sizeof(s_aideafeningencodedpasblock) == 4, "struct s_aideafeningencodedpasblock is invalid size");

		struct s_encodedroomdistancesblock
		{
			char encoded_data;
		};
		static_assert(sizeof(s_encodedroomdistancesblock) == 1, "struct s_encodedroomdistancesblock is invalid size");

		struct s_s_game_audibility_bsp_game_portal_mapping
		{
			long first_door_occluder_index;
			long door_occluder_count;
		};
		static_assert(sizeof(s_s_game_audibility_bsp_game_portal_mapping) == 8, "struct s_s_game_audibility_bsp_game_portal_mapping is invalid size");

		struct s_s_game_audibility_bsp_mapping
		{
			long first_room_index;
			long room_index_count;
		};
		static_assert(sizeof(s_s_game_audibility_bsp_mapping) == 8, "struct s_s_game_audibility_bsp_mapping is invalid size");

		struct s_bspclustertoroomindices
		{
			short room_index;
		};
		static_assert(sizeof(s_bspclustertoroomindices) == 2, "struct s_bspclustertoroomindices is invalid size");

		struct s_s_game_audibility
		{
			long door_portal_count;
			long room_count;
			real_bounds room_distance_bounds;
			c_typed_tag_block<s_doorencodedpasblock> encoded_door_pas_block;
			c_typed_tag_block<s_roomdoorportalencodedpasblock> room_door_portal_encoded_pas_block;
			c_typed_tag_block<s_aideafeningencodedpasblock> ai_deafening_pas_block;
			c_typed_tag_block<s_encodedroomdistancesblock> room_distances_block;
			c_typed_tag_block<s_s_game_audibility_bsp_game_portal_mapping> game_portal_to_door_occluder_mapping_block;
			c_typed_tag_block<s_s_game_audibility_bsp_mapping> bsp_cluster_to_room_bounds_block;
			c_typed_tag_block<s_bspclustertoroomindices> bsp_cluster_to_room_indices_block;
		};
		static_assert(sizeof(s_s_game_audibility) == 100, "struct s_s_game_audibility is invalid size");

		struct s_bspreferenceflags
		{
			// custom bsp_flags
			c_typed_tag_block<s_scenariobspreference> references_block;
			s_bspflagstoragearray flags[32];
		};
		static_assert(sizeof(s_bspreferenceflags) == 140, "struct s_bspreferenceflags is invalid size");

		struct s_structuredesignreference
		{
			c_typed_tag_reference<STRUCTURE_DESIGN_TAG> structure_design;
		};
		static_assert(sizeof(s_structuredesignreference) == 16, "struct s_structuredesignreference is invalid size");

		struct s_structuredesignflagstoragearray
		{
			dword flag_data;
		};
		static_assert(sizeof(s_structuredesignflagstoragearray) == 4, "struct s_structuredesignflagstoragearray is invalid size");

		struct s_structuredesignreferenceflags
		{
			c_typed_tag_block<s_structuredesignreference> references_block;
			s_structuredesignflagstoragearray flags[32];
		};
		static_assert(sizeof(s_structuredesignreferenceflags) == 140, "struct s_structuredesignreferenceflags is invalid size");

		struct s_scenariozonesetbudgetoverride
		{
			long env_bitmap;
			long env_object_bitmap;
			long env_geometry;
			long env_object_geometry;
		};
		static_assert(sizeof(s_scenariozonesetbudgetoverride) == 16, "struct s_scenariozonesetbudgetoverride is invalid size");

		struct s_scenariozonesetlipsyncblock
		{
			c_typed_tag_reference<SOUND_TAG> dummy;
		};
		static_assert(sizeof(s_scenariozonesetlipsyncblock) == 16, "struct s_scenariozonesetlipsyncblock is invalid size");

		struct s_s_scenario_zone_set
		{
			string_id name;
			c_static_string<256> name_string;
			long pvs_index;
			c_flags<e_scenariozonesetbitflag, long, k_scenariozonesetbitflag_count> flags;
			s_bspreferenceflags bsp_zone_flags;
			s_bspreferenceflags streaming_bsp_zone_flags;
			s_structuredesignreferenceflags structure_design_zone_flags;
			s_bspflagstoragearray runtime_bsp_zone_flags[32];
			s_structuredesignflagstoragearray runtime_structure_design_zone_flags[32];
			long parent_zoneset;
			long audibility_index;
			c_typed_tag_block<s_scenariozonesetbudgetoverride> budget_overrides_block;
			c_typed_tag_block<s_scenariozonesetlipsyncblock> lipsync_sounds_block;
			c_typed_tag_reference<SOUNDBANK_TAG> cinematic_soundbank;
			rgb_color sky_clear_color;
			c_typed_tag_reference<ZONESET_BAKED_PVS_TAG> baked_pvs_reference_tag;
			real_point3d aabbboundsmin;
			real_point3d aabbboundsmax;
			string_id load_variant_name;
		};
		static_assert(sizeof(s_s_scenario_zone_set) == 1048, "struct s_s_scenario_zone_set is invalid size");

		struct s_bsplightingorderelement
		{
			short bsp_reference;
		};
		static_assert(sizeof(s_bsplightingorderelement) == 2, "struct s_bsplightingorderelement is invalid size");

		struct s_scenarioclusterpointsblock
		{
			real_point3d centroid;
		};
		static_assert(sizeof(s_scenarioclusterpointsblock) == 12, "struct s_scenarioclusterpointsblock is invalid size");

		struct s_s_scenario_cluster_data
		{
			c_typed_tag_reference<SCENARIO_STRUCTURE_BSP_TAG> bsp;
			long bsp_checksum;
			c_typed_tag_block<s_scenarioclusterpointsblock> cluster_centroids_block;
			s_tag_resource legacy_bsp_kd_tree;
		};
		static_assert(sizeof(s_s_scenario_cluster_data) == 40, "struct s_s_scenario_cluster_data is invalid size");

		struct s_s_scenario_kill_trigger_volume
		{
			short trigger_volume;
			c_flags<e_triggervolumeflags, char, k_triggervolumeflags_count> flags;
			char generated_pad4499[1]; // padding
		};
		static_assert(sizeof(s_s_scenario_kill_trigger_volume) == 4, "struct s_s_scenario_kill_trigger_volume is invalid size");

		struct s_s_scenario_safe_zone_trigger_volume
		{
			short trigger_volume;
			c_flags<e_triggervolumeflags, char, k_triggervolumeflags_count> flags;
			char generated_pad0479[1]; // padding
		};
		static_assert(sizeof(s_s_scenario_safe_zone_trigger_volume) == 4, "struct s_s_scenario_safe_zone_trigger_volume is invalid size");

		struct s_s_scenario_location_name_trigger_volume
		{
			short trigger_volume;
			c_static_string<32> name;
			char generated_padd416[2]; // padding
			string_id name_identifier;
		};
		static_assert(sizeof(s_s_scenario_location_name_trigger_volume) == 40, "struct s_s_scenario_location_name_trigger_volume is invalid size");

		struct s_scenariounsafespawnvolume
		{
			short trigger_volume;
		};
		static_assert(sizeof(s_scenariounsafespawnvolume) == 2, "struct s_scenariounsafespawnvolume is invalid size");

		struct s_s_scenario_zone_set_switch_trigger_volume
		{
			c_flags<e_scenariozonesetswitchtriggervolumeflags, short, k_scenariozonesetswitchtriggervolumeflags_count> flags;
			short begin_zone_set;
			short trigger_volume;
			short commit_zone_set;
		};
		static_assert(sizeof(s_s_scenario_zone_set_switch_trigger_volume) == 8, "struct s_s_scenario_zone_set_switch_trigger_volume is invalid size");

		struct s_scenariosubtitleref
		{
			c_typed_tag_reference<MULTILINGUAL_UNICODE_STRING_LIST_TAG> subtitles;
		};
		static_assert(sizeof(s_scenariosubtitleref) == 16, "struct s_scenariosubtitleref is invalid size");

		struct s_scriptstring
		{
			string_id id;
			c_static_string<256> text;
		};
		static_assert(sizeof(s_scriptstring) == 260, "struct s_scriptstring is invalid size");

		struct s_runtimelayerreference
		{
			c_typed_tag_reference<RUNTIMELAYER_TAG> _tag;
			c_static_string<256> editor_display_name;
		};
		static_assert(sizeof(s_runtimelayerreference) == 272, "struct s_runtimelayerreference is invalid size");

		struct s_blockrange
		{
			dword begin;
			dword end;
		};
		static_assert(sizeof(s_blockrange) == 8, "struct s_blockrange is invalid size");

		struct s_modulecomponentlookupentry
		{
			qword hash;
			word hs_type;
			char generated_paddf9f[2]; // padding
			dword compressed_placement_handle;
			dword block_id;
			char generated_pad92ea[4]; // padding
		};
		static_assert(sizeof(s_modulecomponentlookupentry) == 24, "struct s_modulecomponentlookupentry is invalid size");

		struct s_modulecomponentlookuptable
		{
			c_typed_tag_block<s_modulecomponentlookupentry> component_table_block;
		};
		static_assert(sizeof(s_modulecomponentlookuptable) == 12, "struct s_modulecomponentlookuptable is invalid size");

		struct s_runtimelayerdata
		{
			string_id name;
			string_id layertagname;
			c_flags<e_runtimelayerflags, long, k_runtimelayerflags_count> flags;
			c_typed_tag_block<s_blockrange> blocks_block;
			long parent;
			string_id loadvariant;
			s_bspflagstoragearray bsps[32];
			s_modulecomponentlookuptable module_component_lookup_table;
		};
		static_assert(sizeof(s_runtimelayerdata) == 172, "struct s_runtimelayerdata is invalid size");

		struct s_placementindexdata
		{
			dword compressedhandle;
		};
		static_assert(sizeof(s_placementindexdata) == 4, "struct s_placementindexdata is invalid size");

		struct s_levelobjectsblockoffset
		{
			dword blockbyteoffset;
			c_typed_tag_block<s_placementindexdata> placementindex_block;
		};
		static_assert(sizeof(s_levelobjectsblockoffset) == 16, "struct s_levelobjectsblockoffset is invalid size");

		struct s_levelregiondata
		{
			string_id zonesetname;
			real_point3d regionmin;
			real_point3d regionmax;
			c_typed_tag_block<s_scenario_layer_reference> inherited_region_layers_block;
		};
		static_assert(sizeof(s_levelregiondata) == 40, "struct s_levelregiondata is invalid size");

		struct s_i343decoratorsdecoratorpalettetagreference
		{
			c_typed_tag_reference<DECORATOR_PALETTE_TAG> _tag;
		};
		static_assert(sizeof(s_i343decoratorsdecoratorpalettetagreference) == 16, "struct s_i343decoratorsdecoratorpalettetagreference is invalid size");

		struct s_soundplacementmapentry
		{
			long sound_placement_reference;
		};
		static_assert(sizeof(s_soundplacementmapentry) == 4, "struct s_soundplacementmapentry is invalid size");

		struct s_nodegraphplacementmapentry
		{
			long node_graph_placement_reference;
		};
		static_assert(sizeof(s_nodegraphplacementmapentry) == 4, "struct s_nodegraphplacementmapentry is invalid size");

		struct s_effectplacementmapentry
		{
			long effect_placement_reference;
		};
		static_assert(sizeof(s_effectplacementmapentry) == 4, "struct s_effectplacementmapentry is invalid size");

		struct s_acousticzoneplacementmapentry
		{
			long acoustic_zone_placement_reference;
		};
		static_assert(sizeof(s_acousticzoneplacementmapentry) == 4, "struct s_acousticzoneplacementmapentry is invalid size");

		struct s_acousticportalplacementmapentry
		{
			long acoustic_portal_placement_reference;
		};
		static_assert(sizeof(s_acousticportalplacementmapentry) == 4, "struct s_acousticportalplacementmapentry is invalid size");

		struct s_bspmapentry
		{
			c_typed_tag_block<s_soundplacementmapentry> sound_placements_block;
			c_typed_tag_block<s_nodegraphplacementmapentry> object_node_graph_placements_block;
			c_typed_tag_block<s_effectplacementmapentry> effect_placements_block;
			c_typed_tag_block<s_acousticzoneplacementmapentry> acoustics_zone_placements_block;
			c_typed_tag_block<s_acousticportalplacementmapentry> acoustics_portal_placements_block;
		};
		static_assert(sizeof(s_bspmapentry) == 60, "struct s_bspmapentry is invalid size");

		struct s_preimportedanimnodegraphreference
		{
			c_typed_tag_reference<XANIMNODEGRAPH_TAG> reference;
		};
		static_assert(sizeof(s_preimportedanimnodegraphreference) == 16, "struct s_preimportedanimnodegraphreference is invalid size");

		struct s_modulelookupkey
		{
			qword hash;
			long index;
			char generated_padceef[4]; // padding
		};
		static_assert(sizeof(s_modulelookupkey) == 16, "struct s_modulelookupkey is invalid size");

		struct s_level
		{
			s_levelobjects levelobjects;
			c_typed_tag_block<s_scenario_layer_reference> child_scenarios_block;
			c_enum<e_e_scenario_type, short> type;
			c_enum<e_i343collectiblemission, short> mission;
			c_flags<e_scenarioflags, long, k_scenarioflags_count> flags;
			c_flags<e_scenarioruntimetriggervolumeflags, long, k_scenarioruntimetriggervolumeflags_count> runtime_trigger_volume_flags;
			long campaign_id;
			long map_id;
			string_id map_name;
			c_typed_tag_block<s_defaultplayerstartindex> default_player_start_indices_block;
			c_typed_tag_reference<SCENARIO_SOUND_CONSTANTS_TAG> sound_constants;
			c_typed_tag_reference<MUSKETEER_TOE_DEFINITION_TAG_TAG> musketeer_toe;
			long conversion_version;
			angle local_north;
			real local_sea_level;
			real altitude_cap;
			real_vector2d grid_world_anchor_point;
			short grid_cell_size;
			s_point2d grid_size;
			char generated_pad226a[2]; // padding
			c_typed_tag_block<s_multiplayerscenariointrodefinition> multiplayer_intro_cinematics_block;
			c_typed_tag_reference<COMPOSITION_TAG> multiplayer_outro_cinematic;
			c_typed_tag_reference<COMPOSITION_TAG> multiplayer_outro_cinematic_fallback;
			c_typed_tag_reference<GAME_PERFORMANCE_THROTTLE_TAG> game_performance_throttles;
			c_typed_tag_reference<ASSET_CATEGORY_GLOBALS_TAG> asset_category_globals_override;
			c_typed_tag_block<s_scenario_structure_bsp_reference> structure_bsps_block;
			c_typed_tag_block<s_s_scenario_structure_design_reference> structure_designs_block;
			c_typed_tag_reference<STRUCTURE_SEAMS_TAG> structure_seams;
			c_typed_tag_block<s_s_scenario_sky_reference> skies_block;
			c_typed_tag_block<s_s_scenario_zone_set_pvs> zone_set_pvs_block;
			c_typed_tag_block<s_s_game_audibility> zone_set_audibility_block;
			c_typed_tag_block<s_s_scenario_zone_set> zone_sets_block;
			c_typed_tag_block<s_bsplightingorderelement> bsp_lighting_order_override_block;
			c_typed_tag_block<s_s_scenario_cluster_data> scenario_cluster_data_block;
			c_typed_tag_reference<MULTIPLAYER_OBJECT_TYPE_LIST_TAG> multiplayer_object_types;
			char generated_pad6f1f[4]; // padding
			long long lightconeconstants;

			/* SPAWN INFLUENCE OVERRIDES */

			c_typed_tag_reference<SPAWNSETTINGS_TAG> spawn_settings;
			c_typed_tag_reference<WIND_TAG> wind;
			c_typed_tag_reference<SCENARIO_RENDER_DATA_TAG> scenario_render_data;
			c_typed_tag_reference<PATHFINDING_TAG> ai_pathfinding_data;
			c_typed_tag_block<s_s_scenario_kill_trigger_volume> scenario_kill_triggers_block;
			c_typed_tag_block<s_s_scenario_safe_zone_trigger_volume> scenario_safe_zone_triggers_block;
			c_typed_tag_block<s_s_scenario_location_name_trigger_volume> scenario_location_name_triggers_block;
			c_typed_tag_block<s_scenariounsafespawnvolume> scenario_unsafe_spawn_trigger_volumes_block;
			c_typed_tag_block<s_s_scenario_zone_set_switch_trigger_volume> zone_set_switch_trigger_volumes_block;
			c_typed_tag_block<s_scenariosubtitleref> subtitle_references_block;
			c_typed_tag_reference<SCRIPT_CONTAINER_TAG> level_scripts;
			c_typed_tag_reference<MULTILINGUAL_UNICODE_STRING_LIST_TAG> chapter_title_text;
			c_typed_tag_reference<SCENARIO_INTERPOLATOR_TAG> interpolators;
			c_typed_tag_reference<AREA_SCREEN_EFFECT_TAG> global_screen_effect;
			c_typed_tag_reference<ATMOSPHERE_GLOBALS_TAG> atmosphere_globals;
			c_typed_tag_reference<PERFORMANCE_THROTTLES_TAG> performance_throttles;
			c_typed_tag_reference<LOCATION_NAME_GLOBALS_DEFINITION_TAG> location_name_globals;
			c_typed_tag_reference<CUI_SCREEN_TAG> hud_screen_reference;
			c_typed_tag_reference<SCENARIO_REQUIRED_RESOURCE_TAG> required_resources;

			/* garbage collection */

			s_garbagecollectionglobalvariables garbage_collection$2;
			c_typed_tag_block<s_scriptstring> script_strings_block;
			c_typed_tag_block<s_runtimelayerreference> runtime_layers_block;
			c_typed_tag_block<s_runtimelayerdata> internal_runtime_layers_block;
			c_typed_tag_block<s_levelobjectsblockoffset> block_offsets_block;
			c_typed_tag_reference<LEVEL_TAG> source_level;
			c_typed_tag_block<s_levelregiondata> level_region_data_block;
			c_typed_tag_block<s_i343decoratorsdecoratorpalettetagreference> decorator_palettes_block;
			s_tag_reference dynamic_world_state_globals;
			c_typed_tag_reference<DYNAMICWORLDSTATEGLOBALS_TAG> tag_graph_output;
			string_id output_node_name;
			c_typed_tag_block<s_taggraphtaggraphfloatparam> tag_graph_float_params_block;
			c_flags<e_scenariodynamicworldstateflags, short, k_scenariodynamicworldstateflags_count> dynamic_world_state_flags;
			char generated_padbbd4[2]; // padding
			long dynamic_world_state_lens_flare_guid;
			c_typed_tag_reference<LEVELSTATICGEO_TAG> static_world;
			c_typed_tag_reference<TEXTUREGROUP_TAG> texture_group_table;
			// custom hlods
			c_typed_tag_reference<HLODSYSTEM_TAG> hlods;
			// custom hlods_switch_distance_multipliers
			s_s_basic_spec_control_setting_float hlods_switch_distance_multipliers;
			// custom value
			c_typed_tag_reference<AUTOHLODSETTINGS_TAG> auto_generated_hlods_settings;
			c_typed_tag_reference<ULEVEL_TAG> unprocessed_level;
			// custom value
			c_flags<e_enabledynamicwindflag, char, k_enabledynamicwindflag_count> dynamic_wind;
			c_flags<e_enableinteractionflag, char, k_enableinteractionflag_count> push_bending;
			char generated_pad0889[2]; // padding
			c_typed_tag_block<s_bspmapentry> placement_bsp_map_block;
			string_id audio_level_state_value;
			real_point3d broadphase_extents_override_min;
			real_point3d broadphase_extents_override_max;
			c_typed_tag_block<s_preimportedanimnodegraphreference> preimported_animation_node_graphs_block;
			c_typed_tag_block<s_modulelookupkey> sorted_module_lookup_table_block;
		};
		static_assert(sizeof(s_level) == 2036, "struct s_level is invalid size");

		struct s_nodegraphcontentluagraphcontenttag
		{
			s_nodegraphcontentnodegraphcontenttag nodegraph;
		};
		static_assert(sizeof(s_nodegraphcontentluagraphcontenttag) == 68, "struct s_nodegraphcontentluagraphcontenttag is invalid size");

		struct s_machine_definition
		{
			s_device_definition device;

			/* $$$ MACHINE $$$ */

			c_enum<e_machinetype, short> type;
			c_flags<e_i343machinedefinitionflags, short, k_i343machinedefinitionflags_count> flags;
			real door_open_time;
			real_bounds door_occlusion_bounds;
			c_enum<e_machinecollisionresponses, short> collision_response;
			short elevator_node;
			c_enum<e_objectpathfindingpolicy, short> pathfinding_policy;
			char generated_pad4262[2]; // padding
			string_id shield_name;
			string_id shield_function;
			c_typed_tag_block<s_soundrtpcblockdefinition> sound_rtpcs_block;
			string_id action_denied_string_id;
		};
		static_assert(sizeof(s_machine_definition) == 1468, "struct s_machine_definition is invalid size");

		struct s_nodegraphcontentmaterialshadergraphcontenttag
		{
			s_nodegraphcontentnodegraphcontenttag nodegraph;
		};
		static_assert(sizeof(s_nodegraphcontentmaterialshadergraphcontenttag) == 68, "struct s_nodegraphcontentmaterialshadergraphcontenttag is invalid size");

		struct s_rawgeotag
		{
			s_runtimegeotag runtime_geo;
		};
		static_assert(sizeof(s_rawgeotag) == 248, "struct s_rawgeotag is invalid size");

		struct s_s_terminal_page_definition
		{
			short bitmap_sequence_index;
			short bitmap_sprite_index;
			string_id text;
		};
		static_assert(sizeof(s_s_terminal_page_definition) == 8, "struct s_s_terminal_page_definition is invalid size");

		struct s_terminal_definition
		{
			s_device_definition device;

			/* $$$ TERMINAL $$$ */

			dword bah_bah;
			string_id action_string;
			string_id name;
			c_typed_tag_reference<SOUND_TAG> activation_sound;
			c_typed_tag_reference<BITMAP_TAG> bitmap;
			c_typed_tag_reference<MULTILINGUAL_UNICODE_STRING_LIST_TAG> strings;
			c_typed_tag_block<s_s_terminal_page_definition> pages_block;
			char generated_padfd24[4]; // padding
		};
		static_assert(sizeof(s_terminal_definition) == 1496, "struct s_terminal_definition is invalid size");

		struct s_unprocessedlevel
		{
			s_level level;
		};
		static_assert(sizeof(s_unprocessedlevel) == 2036, "struct s_unprocessedlevel is invalid size");

		struct s_i343weaponheatbasepropertiesdefinition
		{
			// custom heat_loss_per_second_scale
			s_i343malleablepropertybasefloatstructdefinition heat_loss_per_second_scale;
			// custom overheated_heat_loss_per_second_scale
			s_i343malleablepropertybasefloatstructdefinition overheated_heat_loss_per_second_scale;
			// custom heat_generated_per_round_scale
			s_i343malleablepropertybasefloatstructdefinition heat_generated_per_round_scale;
		};
		static_assert(sizeof(s_i343weaponheatbasepropertiesdefinition) == 36, "struct s_i343weaponheatbasepropertiesdefinition is invalid size");

		struct s_aimassistdefinitiondeprecated
		{
			c_flags<e_aimassistdefinitionflags, char, k_aimassistdefinitionflags_count> flags;
			char generated_padf30a[3]; // padding
			angle autoaim_angle;
			real autoaim_range;
			real autoaim_falloff_range;
			real autoaim_near_falloff_range;
			angle magnetism_angle;
			real magnetism_range;
			real magnetism_falloff_range;
			real magnetism_near_falloff_range;
			angle deviation_angle;
		};
		static_assert(sizeof(s_aimassistdefinitiondeprecated) == 40, "struct s_aimassistdefinitiondeprecated is invalid size");

		struct s_i343malleablepropertybaseanglestructdefinition
		{
			angle base_value;
			angle_bounds value_bounds;
		};
		static_assert(sizeof(s_i343malleablepropertybaseanglestructdefinition) == 12, "struct s_i343malleablepropertybaseanglestructdefinition is invalid size");

		struct s_i343weaponaimassistdefinition
		{
			c_flags<e_aimassistdefinitionflags, char, k_aimassistdefinitionflags_count> flags;
			char generated_pad01dc[3]; // padding
			// custom autoaim_angle
			s_i343malleablepropertybaseanglestructdefinition autoaim_angle;
			// custom prioritization_angle
			s_i343malleablepropertybaseanglestructdefinition prioritization_angle;
			// custom autoaim_range
			s_i343malleablepropertybasefloatstructdefinition autoaim_range;
			// custom autoaim_falloff_range
			s_i343malleablepropertybasefloatstructdefinition autoaim_falloff_range;
			// custom autoaim_near_falloff_range
			s_i343malleablepropertybasefloatstructdefinition autoaim_near_falloff_range;
			// custom magnetism_angle
			s_i343malleablepropertybaseanglestructdefinition magnetism_angle;
			// custom magnetism_range
			s_i343malleablepropertybasefloatstructdefinition magnetism_range;
			// custom magnetism_falloff_range
			s_i343malleablepropertybasefloatstructdefinition magnetism_falloff_range;
			// custom magnetism_near_falloff_range
			s_i343malleablepropertybasefloatstructdefinition magnetism_near_falloff_range;
			// custom deviation_angle
			s_i343malleablepropertybaseanglestructdefinition deviation_angle;
		};
		static_assert(sizeof(s_i343weaponaimassistdefinition) == 124, "struct s_i343weaponaimassistdefinition is invalid size");

		struct s_weaponmovementpenalties
		{
			real_fraction forward_movement_penalty;
			real_fraction sideways_movement_penalty;
		};
		static_assert(sizeof(s_weaponmovementpenalties) == 8, "struct s_weaponmovementpenalties is invalid size");

		struct s_weaponclassoverride
		{
			string_id unit_markup_name;
			c_static_string<32> override_weapon_class;
			string_id override_weapon_class_string_id;
		};
		static_assert(sizeof(s_weaponclassoverride) == 40, "struct s_weaponclassoverride is invalid size");

		struct s_i343weaponweaponoffsetrestrictedbounds
		{
			real_bounds depth_offset_restricted_bounds;
			real_bounds horizontal_offset_restricted_bounds;
			real_bounds vertical_offset_restricted_bounds;
			real_vector3d minimum_computed_offset_extents;
			real_vector3d maximum_computed_offset_extents;
		};
		static_assert(sizeof(s_i343weaponweaponoffsetrestrictedbounds) == 48, "struct s_i343weaponweaponoffsetrestrictedbounds is invalid size");

		struct s_weapon_first_person_interface_definition
		{
			string_id name;
			c_typed_tag_reference<RENDER_MODEL_TAG> first_person_model;
			c_typed_tag_reference<MODEL_ANIMATION_GRAPH_TAG> first_person_animations;
			s_tag_reference first_person_asset;
			s_tag_reference first_person_animation_asset;
			real first_person_fov_scale;
		};
		static_assert(sizeof(s_weapon_first_person_interface_definition) == 72, "struct s_weapon_first_person_interface_definition is invalid size");

		struct s_weapon_interface_definition_new
		{

			/* interface */

			c_flags<e_uiweaponflags, char, k_uiweaponflags_count> ui_flags;
			char generated_pad6ebb[3]; // padding
			c_typed_tag_block<s_weapon_first_person_interface_definition> first_person_block;
			// custom ui
			c_typed_tag_reference<CUI_SCREEN_TAG> hip_fire_reticle_screen_reference;
			real_bounds bloom_diameter_in_pixels;
			real_bounds aim_assist_diameter_in_pixels;
			c_typed_tag_reference<CUI_SCREEN_TAG> sight_front_screen_reference;
			c_typed_tag_reference<CUI_SCREEN_TAG> sight_back_screen_reference;
			c_typed_tag_block<s_interfaceuiiteminfo> ui_display_info_block;
			c_typed_tag_reference<BITMAP_TAG> ammo_ticker_bitmap_reference;
			// custom value
		};
		static_assert(sizeof(s_weapon_interface_definition_new) == 108, "struct s_weapon_interface_definition_new is invalid size");

		struct s_weapon_ammunition_object
		{
			short rounds;
			char generated_padaca6[2]; // padding
			c_typed_tag_reference<EQUIPMENT_TAG> equipment;
		};
		static_assert(sizeof(s_weapon_ammunition_object) == 20, "struct s_weapon_ammunition_object is invalid size");

		struct s_weapon_magazine_definition
		{
			c_flags<e_weaponmagazineflags, long, k_weaponmagazineflags_count> flags;
			short rounds_recharged;
			short rounds_total_initial;
			short rounds_total_maximum;
			short rounds_loaded_maximum;
			short runtime_rounds_inventory_maximum;
			c_enum<e_i343munitionseammorefilltype, short> ammo_refill_type;
			real reload_dialogue_time;
			short rounds_reloaded;
			char generated_padccf5[2]; // padding
			real chamber_time;
			s_tag_reference reloading_effect;
			s_tag_reference reloading_damage_effect;
			s_tag_reference chambering_effect;
			s_tag_reference chambering_damage_effect;
			c_typed_tag_block<s_weapon_ammunition_object> magazines_block;
		};
		static_assert(sizeof(s_weapon_magazine_definition) == 104, "struct s_weapon_magazine_definition is invalid size");

		struct s_i343weapontriggerautofiredefinition
		{

			/* AUTOFIRE */

			real autofire_time;
			real autofire_throw;
			c_enum<e_i343weapontriggerautofireaction, short> secondary_action;
			c_enum<e_i343weapontriggerautofireaction, short> primary_action;
		};
		static_assert(sizeof(s_i343weapontriggerautofiredefinition) == 12, "struct s_i343weapontriggerautofiredefinition is invalid size");

		struct s_i343weapontriggerdefinition
		{
			c_flags<e_i343weaponc_weapon_trigger_definition_flags, long, k_i343weaponc_weapon_trigger_definition_flags_count> flags;
			c_enum<e_i343weapontriggerinput, short> input;
			c_enum<e_i343weapontriggerbehavior, short> behavior;
			short primary_barrel;
			short secondary_barrel;
			c_enum<e_i343weapontriggerpredictiontype, short> prediction;

			/* ALT-FIRE */

			c_enum<e_i343weapontriggeraltfirebehavior, char> alt_fire_behavior;
			char generated_pad88ae[1]; // padding
			s_i343weapontriggerautofiredefinition autofire;
			s_i343weapontriggerchargingdefinition charging;
			c_typed_tag_reference<EFFECT_TAG> double_latch_projectile_releasable_effect;
			c_typed_tag_reference<EFFECT_TAG> double_latch_projectile_released_effect;
		};
		static_assert(sizeof(s_i343weapontriggerdefinition) == 176, "struct s_i343weapontriggerdefinition is invalid size");

		struct s_i343weaponbarrelerrorturnrates
		{
			// custom error_turn_rates

			/* error turn rates */

			angle min_error_look_pitch_rate;
			angle full_error_look_pitch_rate;
			real look_pitch_error_power;
			// custom value
		};
		static_assert(sizeof(s_i343weaponbarrelerrorturnrates) == 12, "struct s_i343weaponbarrelerrorturnrates is invalid size");

		struct s_i343weaponbarrelfunctionblock
		{
			s_scalarfunctionname min_error_function;
			s_scalarfunctionname function;
		};
		static_assert(sizeof(s_i343weaponbarrelfunctionblock) == 40, "struct s_i343weaponbarrelfunctionblock is invalid size");

		struct s_i343weaponbarrelaccuracypenaltyfunctions
		{
			c_typed_tag_block<s_i343weaponbarrelfunctionblock> firing_penalty_function_block;
			c_typed_tag_block<s_i343weaponbarrelfunctionblock> firing_crouched_penalty_function_block;
			c_typed_tag_block<s_i343weaponbarrelfunctionblock> moving_penalty_function_block;
			c_typed_tag_block<s_i343weaponbarrelfunctionblock> turning_penalty_function_block;
			real error_angle_max_rotation;
		};
		static_assert(sizeof(s_i343weaponbarrelaccuracypenaltyfunctions) == 52, "struct s_i343weaponbarrelaccuracypenaltyfunctions is invalid size");

		struct s_i343weaponbarrelaccuracypenaltydefinition
		{
			// custom accuracy_penalties
			real reload_penalty_low;
			real reload_penalty;
			real switch_penalty_low;
			real switch_penalty;
			real zoom_penalty_low;
			real zoom_penalty;
			real jump_penalty_low;
			real jump_penalty;

			/* barrel_error penalty functions */

			// custom single_wield_penalties
			s_i343weaponbarrelaccuracypenaltyfunctions single_wield_penalties;
			// custom value
			// custom dual_wield_penalties
			s_i343weaponbarrelaccuracypenaltyfunctions dual_wield_penalties;
			// custom value
			// custom value
		};
		static_assert(sizeof(s_i343weaponbarrelaccuracypenaltydefinition) == 136, "struct s_i343weaponbarrelaccuracypenaltydefinition is invalid size");

		struct s_i343weaponbarrelfirstpersonoffsetblock
		{
			real_point3d first_person_offset;
		};
		static_assert(sizeof(s_i343weaponbarrelfirstpersonoffsetblock) == 12, "struct s_i343weaponbarrelfirstpersonoffsetblock is invalid size");

		struct s_i343weaponbarreldamageeffect
		{
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> damage_effect;
		};
		static_assert(sizeof(s_i343weaponbarreldamageeffect) == 16, "struct s_i343weaponbarreldamageeffect is invalid size");

		struct s_i343weaponrecoilviewkickaccelerationdimension
		{
			angle_bounds view_kick_random_acceleration;
			angle view_kick_min_magnitude;
		};
		static_assert(sizeof(s_i343weaponrecoilviewkickaccelerationdimension) == 12, "struct s_i343weaponrecoilviewkickaccelerationdimension is invalid size");

		struct s_i343weaponrecoilimpulsescalesstruct
		{
			real recoil_impulse_scale_ground_throttle;
			real recoil_impulse_scale_crouched;
			real recoil_impulse_scale_airborne;
		};
		static_assert(sizeof(s_i343weaponrecoilimpulsescalesstruct) == 12, "struct s_i343weaponrecoilimpulsescalesstruct is invalid size");

		struct s_i343weaponrecoilviewkickaccelerationstance
		{
			// custom yaw
			s_i343weaponrecoilviewkickaccelerationdimension view_kick_yaw;
			// custom value
			// custom pitch
			s_i343weaponrecoilviewkickaccelerationdimension view_kick_pitch;
			// custom value
			s_i343weaponrecoilimpulsescalesstruct view_kick_recoil_scales;
		};
		static_assert(sizeof(s_i343weaponrecoilviewkickaccelerationstance) == 36, "struct s_i343weaponrecoilviewkickaccelerationstance is invalid size");

		struct s_i343weaponrecoilviewkickaccelerationstanceblock
		{
			s_i343weaponrecoilviewkickaccelerationstance acceleration_stance;
		};
		static_assert(sizeof(s_i343weaponrecoilviewkickaccelerationstanceblock) == 36, "struct s_i343weaponrecoilviewkickaccelerationstanceblock is invalid size");

		struct s_i343weaponrecoilviewkickacceleration
		{
			// custom view_kick_acceleration

			/* view kick acceleration */

			s_i343weaponrecoilviewkickaccelerationstance acceleration_precision_aim;
			c_typed_tag_block<s_i343weaponrecoilviewkickaccelerationstanceblock> acceleration_hip_block;
			// custom value
		};
		static_assert(sizeof(s_i343weaponrecoilviewkickacceleration) == 48, "struct s_i343weaponrecoilviewkickacceleration is invalid size");

		struct s_i343weaponrecoilgunkickaccelerationstancedefinition
		{
			angle_bounds gunkick_yaw_acceleration;
			angle gunkick_yaw_min_magnitude;
			angle_bounds gunkick_pitch_acceleration;
			angle gunkick_pitch_min_magnitude;
			s_i343weaponrecoilimpulsescalesstruct gunkick_impulse_scales;
		};
		static_assert(sizeof(s_i343weaponrecoilgunkickaccelerationstancedefinition) == 36, "struct s_i343weaponrecoilgunkickaccelerationstancedefinition is invalid size");

		struct s_i343weaponrecoilgunkickaccelerationstancedefinitionblock
		{
			s_i343weaponrecoilgunkickaccelerationstancedefinition gunkick_acceleration_stance;
		};
		static_assert(sizeof(s_i343weaponrecoilgunkickaccelerationstancedefinitionblock) == 36, "struct s_i343weaponrecoilgunkickaccelerationstancedefinitionblock is invalid size");

		struct s_i343weaponrecoilgunkickaccelerationdefinition
		{
			// custom gunkick

			/* Gunkick */

			s_i343weaponrecoilgunkickaccelerationstancedefinition gunkick_ads_settings;
			c_typed_tag_block<s_i343weaponrecoilgunkickaccelerationstancedefinitionblock> gunkick_hip_settings_block;
			// custom value
		};
		static_assert(sizeof(s_i343weaponrecoilgunkickaccelerationdefinition) == 48, "struct s_i343weaponrecoilgunkickaccelerationdefinition is invalid size");

		struct s_i343weaponproceduralanimationfirstpersonfireimpulsedefinition
		{
			real_bounds procedural_animation_fp_fire_kickback_impulse;
		};
		static_assert(sizeof(s_i343weaponproceduralanimationfirstpersonfireimpulsedefinition) == 8, "struct s_i343weaponproceduralanimationfirstpersonfireimpulsedefinition is invalid size");

		struct s_i343weaponproceduralanimationfirstpersonfireimpulseblock
		{
			s_i343weaponproceduralanimationfirstpersonfireimpulsedefinition procedural_animation_fp_fire_kickback_impulse;
		};
		static_assert(sizeof(s_i343weaponproceduralanimationfirstpersonfireimpulseblock) == 8, "struct s_i343weaponproceduralanimationfirstpersonfireimpulseblock is invalid size");

		struct s_i343weaponproceduralanimationfirstpersonfiredefinition
		{
			s_i343weaponproceduralanimationfirstpersonfireimpulsedefinition procedural_animation_fp_fire_kickback_impulse;
			c_typed_tag_block<s_i343weaponproceduralanimationfirstpersonfireimpulseblock> procedural_animation_fp_fire_kickback_impulse_hip_block;
		};
		static_assert(sizeof(s_i343weaponproceduralanimationfirstpersonfiredefinition) == 20, "struct s_i343weaponproceduralanimationfirstpersonfiredefinition is invalid size");

		struct s_i343weaponbarreldefinition
		{
			c_flags<e_i343weaponbarreldefinitionflags, long, k_i343weaponbarreldefinitionflags_count> flags;

			/* firing */

			s_i343weaponbarrelfiringdefinition firing$2;
			short magazine;
			short rounds_per_shot;
			short minimum_rounds_loaded;
			short rounds_per_burst;
			short rounds_between_tracers;
			c_enum<e_i343weaponbarrelautomaticreloadbehavior, char> automatic_reload_behavior;
			char generated_paddab6[1]; // padding
			// custom value
			string_id optional_barrel_marker_name;
			s_i343weaponbarrelnoisedefinition noise;

			/* prediction properties */

			c_enum<e_i343weaponbarrelpredictiontype, short> prediction_type;
			char generated_pad276b[2]; // padding
			real event_synchronized_projectiles_per_second;
			real maximum_barrel_error_for_event_synchronization;
			s_i343weaponbarrelerrorturnrates error_turn_rates;

			/* projectile */

			s_i343weaponbarreldistrubutiondefinition projectile_distribution;
			s_i343weaponbarrelerrordefinition projectile_error;
			s_i343weaponbarrelaccuracypenaltydefinition accuracy_penalties;
			c_typed_tag_block<s_i343weaponbarrelfirstpersonoffsetblock> first_person_offset_block;
			s_tag_reference projectile$2;
			c_typed_tag_reference<PROJECTILE_TAG> tag_graph_output;
			string_id output_node_name;
			c_typed_tag_block<s_taggraphtaggraphfloatparam> float_params_block;
			c_typed_tag_reference<PROJECTILE_TAG> optional_secondary_projectile;
			s_i343weaponbarreldamageeffect eh;
			c_typed_tag_reference<CRATE_TAG> crate_projectile;
			real crate_projectile_speed;

			/* misc */

			real ejection_port_recovery_time;
			real illumination_recovery_time;
			real_fraction heat_generated_per_round;
			string_id heat_generated_per_round_function;
			real_fraction deprecated_age_generated_per_round;
			real_fraction deprecated_campaign_age_generated_per_round;
			s_i343weaponbarrelagegenerateddefinition age_generation;
			s_i343weaponbarrelsweetheatdefinition sweet_heat;
			real overload_time;
			real runtime_illumination_recovery_rate;
			real runtime_ejection_port_recovery_rate;
			c_typed_tag_block<s_i343weaponbarrelfiringeffectdefinition> firing_effects_block;
			// custom recoil
			s_i343weaponrecoilviewkickacceleration recoil_view_kick_acceleration;
			s_i343weaponrecoilgunkickaccelerationdefinition recoil_gun_kick_acceleration;
			// custom value
			s_i343weaponproceduralanimationfirstpersonfiredefinition procedural_animation_fp_fire_impulse;
		};
		static_assert(sizeof(s_i343weaponbarreldefinition) == 648, "struct s_i343weaponbarreldefinition is invalid size");

		struct s_i343weaponanimationbasepropertiesdefinition
		{
			// custom ready_playback_speed_scale
			s_i343malleablepropertybasefloatstructdefinition ready_playback_speed_scale;
			// custom ready_initial_playback_speed_scale
			s_i343malleablepropertybasefloatstructdefinition ready_initial_playback_speed_scale;
			// custom put_away_playback_speed_scale
			s_i343malleablepropertybasefloatstructdefinition put_away_playback_speed_scale;
			// custom reload_playback_speed_scale
			s_i343malleablepropertybasefloatstructdefinition reload_playback_speed_scale;
			// custom reload_while_empty_playback_speed_scale
			s_i343malleablepropertybasefloatstructdefinition reload_while_empty_playback_speed_scale;
		};
		static_assert(sizeof(s_i343weaponanimationbasepropertiesdefinition) == 60, "struct s_i343weaponanimationbasepropertiesdefinition is invalid size");

		struct s_s_weapon_screen_effect_definition
		{
			c_flags<e_c_weapon_screen_effect_flags, char, k_c_weapon_screen_effect_flags_count> flags;
			char generated_pad0661[3]; // padding
			c_typed_tag_reference<AREA_SCREEN_EFFECT_TAG> screen_effect;
		};
		static_assert(sizeof(s_s_weapon_screen_effect_definition) == 20, "struct s_s_weapon_screen_effect_definition is invalid size");

		struct s_i343weaponunitbasepropertiesdefinition
		{
			// custom move_speed_scale
			s_i343malleablepropertybasefloatstructdefinition move_speed_scale;
			// custom turn_rate_scale
			s_i343malleablepropertybasefloatstructdefinition turn_rate_scale;
			// custom simulated_input_scale
			s_i343malleablepropertybasefloatstructdefinition simulated_input_scale;
		};
		static_assert(sizeof(s_i343weaponunitbasepropertiesdefinition) == 36, "struct s_i343weaponunitbasepropertiesdefinition is invalid size");

		struct s_i343weaponrecoilviewkicksettingsdimension
		{
			angle_bounds view_kick_bounds;
		};
		static_assert(sizeof(s_i343weaponrecoilviewkicksettingsdimension) == 8, "struct s_i343weaponrecoilviewkicksettingsdimension is invalid size");

		struct s_i343weaponrecoilviewkicksettingsstance
		{
			angle view_kick_deceleration;
			angle view_kick_return_to_center_acceleration;
		};
		static_assert(sizeof(s_i343weaponrecoilviewkicksettingsstance) == 8, "struct s_i343weaponrecoilviewkicksettingsstance is invalid size");

		struct s_i343weaponrecoilviewkicksettingsstanceblock
		{
			s_i343weaponrecoilviewkicksettingsstance view_kick_settings_stance;
		};
		static_assert(sizeof(s_i343weaponrecoilviewkicksettingsstanceblock) == 8, "struct s_i343weaponrecoilviewkicksettingsstanceblock is invalid size");

		struct s_i343weaponrecoilviewkickdefinition
		{
			// custom view_kick

			/* view kick settings */

			c_enum<e_i343weaponerecoilviewkicksystemtype, char> view_kick_system_type;
			char generated_pad1679[3]; // padding
			// custom yaw
			s_i343weaponrecoilviewkicksettingsdimension view_kick_yaw;
			// custom value
			// custom pitch
			s_i343weaponrecoilviewkicksettingsdimension view_kick_pitch;
			// custom value

			/* settings */

			s_i343weaponrecoilviewkicksettingsstance view_kick_precision_aim;
			c_typed_tag_block<s_i343weaponrecoilviewkicksettingsstanceblock> view_kick_hip_block;
			// custom value
			s_scalarfunctionname view_kick_multiplier_function;
			long view_kick_shots_fired_to_max_out_multipler_function;
			real view_kick_time_to_zero_multipler_function;
		};
		static_assert(sizeof(s_i343weaponrecoilviewkickdefinition) == 68, "struct s_i343weaponrecoilviewkickdefinition is invalid size");

		struct s_i343weaponrecoilviewkickbasepropertiesdefinition
		{
			// custom view_kick_return_deceleration_scale
			s_i343malleablepropertybasefloatstructdefinition view_kick_return_deceleration_scale;
			// custom view_kick_return_return_to_center_scale
			s_i343malleablepropertybasefloatstructdefinition view_kick_return_return_to_center_scale;
		};
		static_assert(sizeof(s_i343weaponrecoilviewkickbasepropertiesdefinition) == 24, "struct s_i343weaponrecoilviewkickbasepropertiesdefinition is invalid size");

		struct s_i343weaponrecoilgunkickstancedefinition
		{
			real gunkick_spring_constant;
			real gunkick_damping_ratio;
		};
		static_assert(sizeof(s_i343weaponrecoilgunkickstancedefinition) == 8, "struct s_i343weaponrecoilgunkickstancedefinition is invalid size");

		struct s_i343weaponrecoilgunkickstanceblock
		{
			s_i343weaponrecoilgunkickstancedefinition gunkick_stance;
		};
		static_assert(sizeof(s_i343weaponrecoilgunkickstanceblock) == 8, "struct s_i343weaponrecoilgunkickstanceblock is invalid size");

		struct s_i343weaponrecoilgunkickdefinition
		{
			// custom gunkick

			/* gunkick */

			s_i343weaponrecoilgunkickstancedefinition gunkick_ads_settings;
			c_typed_tag_block<s_i343weaponrecoilgunkickstanceblock> gunkick_hip_settings_block;
			angle_bounds gunkick_yaw_bounds;
			angle_bounds gunkick_pitch_bounds;
			// custom value
		};
		static_assert(sizeof(s_i343weaponrecoilgunkickdefinition) == 36, "struct s_i343weaponrecoilgunkickdefinition is invalid size");

		struct s_i343weaponrecoilgunkickbasepropertiesdefinition
		{
			// custom gunkick_spring_constant_scale
			s_i343malleablepropertybasefloatstructdefinition gunkick_spring_constant_scale;
		};
		static_assert(sizeof(s_i343weaponrecoilgunkickbasepropertiesdefinition) == 12, "struct s_i343weaponrecoilgunkickbasepropertiesdefinition is invalid size");

		struct s_i343weaponproceduralanimationfirstpersonfirespringdamperdefinition
		{
			real procedural_animation_fp_fire_spring_constant;
			real procedural_animation_fp_fire_damping_ratio;
			real runtime_damping_constant;
		};
		static_assert(sizeof(s_i343weaponproceduralanimationfirstpersonfirespringdamperdefinition) == 12, "struct s_i343weaponproceduralanimationfirstpersonfirespringdamperdefinition is invalid size");

		struct s_i343weaponproceduralanimationfirstpersonfirespringdamperblock
		{
			s_i343weaponproceduralanimationfirstpersonfirespringdamperdefinition procedural_animation_fp_fire_spring;
		};
		static_assert(sizeof(s_i343weaponproceduralanimationfirstpersonfirespringdamperblock) == 12, "struct s_i343weaponproceduralanimationfirstpersonfirespringdamperblock is invalid size");

		struct s_i343weaponproceduralanimationfirstpersondefinition
		{
			// custom procedural_animation_fp
			s_i343weaponproceduralanimationfirstpersonfirespringdamperdefinition procedural_animation_fp_fire_spring;
			c_typed_tag_block<s_i343weaponproceduralanimationfirstpersonfirespringdamperblock> procedural_animation_fp_fire_spring_hip_block;
			// custom value
		};
		static_assert(sizeof(s_i343weaponproceduralanimationfirstpersondefinition) == 24, "struct s_i343weaponproceduralanimationfirstpersondefinition is invalid size");

		struct s_i343proceduralanimationrecoilsettings
		{
			real duration;
			s_scalarfunctionname kickback;
			s_scalarfunctionname pitch;
			s_scalarfunctionname yaw;
			s_scalarfunctionname roll;
			s_scalarfunctionname head;
			s_scalarfunctionname shoulders;
		};
		static_assert(sizeof(s_i343proceduralanimationrecoilsettings) == 124, "struct s_i343proceduralanimationrecoilsettings is invalid size");

		struct s_i343weaponfiresoundsdefinition
		{
			s_i343weaponfiresounddefinition fire_sound;
			s_tag_reference bullet_shell_sound;
			s_i343weaponfiresoundtailsdefinition tail_sounds;
			s_tag_reference dry_fire_sound;
		};
		static_assert(sizeof(s_i343weaponfiresoundsdefinition) == 60, "struct s_i343weaponfiresoundsdefinition is invalid size");

		struct s_i343weaponweaponsounddefinition
		{
			// custom $$$_sound_$$$
			c_flags<e_i343weaponweaponsoundflags, char, k_i343weaponweaponsoundflags_count> weapon_sound_flags;
			char generated_pad94e7[3]; // padding
			c_typed_tag_block<s_i343weaponfiresoundsdefinition> weapon_fire_sounds_block;
			s_tag_reference tracking_sound;
			s_tag_reference locked_sound;
			c_typed_tag_reference<SOUND_TAG> ammo_pickup_sound;
			byte concurrent_impact_sound_limit;
			char generated_pad4832[3]; // padding
			c_typed_tag_block<s_soundrtpcblockdefinition> sound_rtpcs_block;
			c_typed_tag_block<s_soundsweetenerblockdefinition> sound_sweeteners_block;
			// custom value
		};
		static_assert(sizeof(s_i343weaponweaponsounddefinition) == 92, "struct s_i343weaponweaponsounddefinition is invalid size");

		struct s_weapondefinition
		{
			s_itemdefinition item;
			// custom $$$_weapon_$$$

			/* value */

			c_flags<e_c_weapon_definition_flags, long, k_c_weapon_definition_flags_count> flags;
			c_flags<e_c_weapon_definition_secondary_flags, long, k_c_weapon_definition_secondary_flags_count> secondary_flags;
			c_flags<e_weapondefinitionactionsuppressionflags, char, k_weapondefinitionactionsuppressionflags_count> suppression_flags;
			char generated_paddf4e[3]; // padding
			c_flags<e_i343weaponanimationflags, long, k_i343weaponanimationflags_count> animation_flags;
			string_id unused_label;
			real turn_on_time;
			real ready_time;
			s_tag_reference ready_effect;
			s_tag_reference ready_damage_effect;

			/* heat */

			real_fraction heat_recovery_threshold;
			real_fraction overheated_threshold;
			real_fraction heat_detonation_threshold;
			real_fraction heat_detonation_fraction;
			real heat_loss_per_second;
			string_id heat_loss;
			string_id heat_loss_venting;
			real heat_venting_time;
			real_fraction heat_venting_exit_heat;
			real_fraction heat_illumination;
			real_fraction heat_warning_threshold;
			real overheated_heat_loss_per_second;
			string_id overheated_heat_loss;
			real_fraction overheated_instantaneous_age;
			real_fraction overheated_age_per_second;
			s_i343weaponheatbasepropertiesdefinition heat_base_properties;
			s_tag_reference overheated;
			s_tag_reference overheated_damage_effect;
			s_tag_reference detonation;
			s_tag_reference detonation_damage_effect;
			c_typed_tag_block<s_s_melee_damage_parameters> melee_damage_parameters_block;
			s_tag_reference clang_effect;

			/* zoom */

			short magnification_levels;
			char generated_pad2c03[2]; // padding
			real_bounds magnification_range;
			char zoom_effect_ticks;
			char generated_pad78b8[3]; // padding
			s_tag_reference zoom_effect;
			// custom aim_assist_deprecated
			c_typed_tag_block<s_aimassistdefinitiondeprecated> aim_assist_modes_block;
			// custom value
			// custom aim_assist
			s_i343weaponaimassistdefinition aim_assist;
			// custom value
			c_typed_tag_block<s_s_target_tracking_parameters> target_tracking_block;
			c_typed_tag_block<s_i343weaponlaserguidancedefinition> laser_guidance_block;

			/* ballistics */

			real_bounds ballistic_arcing_firing_bounds;
			real_bounds ballistic_arcing_fraction_bounds;

			/* movement */

			c_enum<e_i343weaponmovementpenaltymode, short> movement_penalized;
			char generated_pad5fc5[2]; // padding
			real_fraction forward_movement_penalty;
			real_fraction sideways_movement_penalty;
			// custom movement_penalty_reloading
			s_weaponmovementpenalties movement_penalty___reloading;
			// custom value
			// custom movement_penalty_zoom
			s_weaponmovementpenalties movement_penalty___zoom;
			// custom value
			// custom movement_penalty_other
			s_weaponmovementpenalties movement_penalty___other;
			// custom value

			/* Aiming */

			real maximum_pitch_rate;

			/* AI targeting parameters */

			real ai_scariness;
			real bot_desirability;

			/* miscellaneous */

			real weapon_power_on_time;
			real weapon_power_off_time;
			s_tag_reference weapon_power_on_effect;
			s_tag_reference weapon_power_off_effect;
			real age_heat_recovery_penalty;
			real age_rate_of_fire_penalty;
			real_fraction age_misfire_start;
			real_fraction age_misfire_chance;
			c_enum<e_i343munitionseammorefilltype, short> age_based_ammo_refill_type;
			char generated_padac7a[2]; // padding
			real active_camo_ding;
			real_fraction ai_active_camo_scaling;
			string_id handle_node;

			/* weapon labels */

			c_static_string<32> weapon_class;
			string_id weapon_class_string_id;
			c_typed_tag_block<s_weaponclassoverride> weapon_class_override_block;
			string_id weapon_name;

			/* first person weapon group */

			c_enum<e_i343weaponfirstpersonweapongroup, short> first_person_weapon_group$2;
			char generated_padf92f[2]; // padding
			c_typed_tag_block<s_i343weaponweaponoffsetrestrictedbounds> first_person_weapon_offset_restricted_bounds_block;

			/* more miscellaneous */

			c_enum<e_weapontype, short> weapon_type;
			short low_ammo_threshold;
			s_weapon_interface_definition_new player_interface;
			c_typed_tag_block<s_weapon_magazine_definition> magazines_block;
			c_typed_tag_reference<WEAPONCOMPONENTALTFIRE_TAG> alt_fire;
			c_typed_tag_block<s_i343weapontriggerdefinition> new_triggers_block;
			c_typed_tag_block<s_i343weaponbarreldefinition> barrels_block;
			real runtime_weapon_power_on_velocity;
			real runtime_weapon_power_off_velocity;

			/* first-person movement control */

			real max_movement_acceleration;
			real max_movement_velocity;
			real max_turning_acceleration;
			real max_turning_velocity;
			c_typed_tag_reference<VEHICLE_TAG> deployed_vehicle;
			c_typed_tag_reference<EFFECT_TAG> age_effect;
			c_typed_tag_reference<WEAPON_TAG> aged_weapon;
			c_typed_tag_reference<MATERIAL_EFFECTS_TAG> aged_material_effects;
			real per_kill_or_hit_aging_amount;
			real external_aging_amount;
			real external_heat_amount;
			real_vector3d first_person_weapon_offset;
			real_bounds support_third_person_camera_range;
			real weapon_zoom_time;
			real weapon_ready_for_use_time;
			// custom value
			real deprecated_ready_playback_speed;
			real deprecated_ready_initial_playback_speed;
			real deprecated_put_away_playback_speed;
			real deprecated_reload_playback_speed;
			real deprecated_reload_while_empty_playback_speed;
			// custom value
			s_i343weaponanimationbasepropertiesdefinition animation_base_properties;
			real sprint_exit_disable_weapon_duration;
			real grapple_hook_exit_disable_weapon_duration;
			real tether_transition_to_linked_time;
			real tether_transition_from_linked_time;
			string_id unit_stow_anchor_name;
			c_typed_tag_block<s_s_weapon_screen_effect_definition> screen_effects_block;
			c_typed_tag_reference<SOUNDBANK_TAG> player_sound_bank;
			string_id locking_reticle_screen_name;
			string_id locked_on_reticle_screen_name;
			// custom default_attachments
			c_typed_tag_block<s_i343weapongenericattachmentdefinition> generic_attachments_block;
			c_typed_tag_reference<WEAPON_ATTACHMENT_BARREL_TAG> barrel_attachment;
			c_typed_tag_reference<WEAPON_ATTACHMENT_MAGAZINE_TAG> magazine_attachment;
			c_typed_tag_reference<WEAPON_ATTACHMENT_MELEE_TAG> melee_attachment;
			c_typed_tag_reference<WEAPON_ATTACHMENT_SIGHT_TAG> weapon_sight;
			c_typed_tag_reference<WEAPON_ATTACHMENT_TARGET_TRACKING_TAG> weapon_target_tracking_attachment;
			c_typed_tag_reference<WEAPON_ATTACHMENT_TRIGGER_TAG> weapon_trigger_attachment;
			c_typed_tag_reference<WEAPON_ATTACHMENT_HEAT_TAG> heat_attachment;
			c_typed_tag_reference<UIWEAPONDISPLAYINFODEFINITION_TAG> ui_display_info;
			// custom value
			// custom accuracy_spread_scale
			s_i343malleablepropertybasefloatstructdefinition accuracy_spread_scale;
			s_i343weaponunitbasepropertiesdefinition unit_properties;
			// custom recoil
			s_i343weaponrecoilviewkickdefinition recoil_view_kick;
			s_i343weaponrecoilviewkickbasepropertiesdefinition recoil_view_kick_base_properties;
			s_i343weaponrecoilgunkickdefinition recoil_gun_kick;
			s_i343weaponrecoilgunkickbasepropertiesdefinition recoil_gunkick_base_properties;
			// custom value
			// custom procedural_animation
			s_i343weaponproceduralanimationfirstpersondefinition procedural_animation_fp;
			s_i343proceduralanimationrecoilsettings procedural_recoil_settings;
			// custom value
			// custom weapon_switch_events
			string_id weaponswitcheventnameinbegin;
			string_id weaponswitcheventnameinend;
			string_id weaponswitcheventnameoutbegin;
			string_id weaponswitcheventnameoutend;
			// custom value
			c_typed_tag_reference<WEAPON_TAG> pickup_weapon;
			string_id pickup_weapon_attachment_point;
			string_id pickup_weapon_unit_attachment_point;
			c_enum<e_i343collectibletutorial, long> tutorial_weapon_fire_id;
			c_typed_tag_reference<GENERICMODIFIERDEFINITIONTAG_TAG> equipped_modifiers;
			// custom value
			s_i343weaponweaponsounddefinition sound;
			real ammo_pickup_delay;
		};
		static_assert(sizeof(s_weapondefinition) == 3256, "struct s_weapondefinition is invalid size");

		struct s_control_definition
		{
			s_device_definition device;
			// custom $$$_control_$$$
			c_enum<e_controltypes, short> type;
			c_enum<e_controltriggers, short> triggers_when;
			real call_value;
			string_id action_string;
			string_id secondary_action_string;
			string_id action_denied_string;
			string_id action_denied_secondary_string;
			string_id mp_team_use_denied_string;
			string_id mp_team_use_denied_secondary_string;
			string_id action_and_mp_team_use_denied_string;
			string_id action_and_mp_team_use_denied_secondary_string;
			real interaction_hold_time;
			string_id interaction_screen;
			s_tag_reference hold_start;
			c_typed_tag_reference<SOUND_TAG> action_denied_sound;
			c_enum<e_devicecontrolteamrestriction, short> mp_team_use_restriction;
			char generated_pad88c2[2]; // padding
			s_tag_reference on;
			s_tag_reference off;
			s_tag_reference deny;
			c_static_string<32> script_name;
			c_flags<e_devicecontrolflags, char, k_devicecontrolflags_count> flags;
			char generated_padd577[3]; // padding
			// custom value
			c_typed_tag_block<s_soundrtpcblockdefinition> sound_rtpcs_block;
		};
		static_assert(sizeof(s_control_definition) == 1600, "struct s_control_definition is invalid size");

		struct s_optionalunitcamerablock
		{
			s_s_unit_camera unit_camera;
		};
		static_assert(sizeof(s_optionalunitcamerablock) == 96, "struct s_optionalunitcamerablock is invalid size");

		struct s_equipmentabilitydeactivationoverridesettings
		{
			real cooldown_time;
			real energy_change;
		};
		static_assert(sizeof(s_equipmentabilitydeactivationoverridesettings) == 8, "struct s_equipmentabilitydeactivationoverridesettings is invalid size");

		struct s_controlstateuiinfo
		{
			c_typed_tag_reference<BITMAP_TAG> state_bitmp;
			long state_bitmap_index;
			string_id button_state_string;
		};
		static_assert(sizeof(s_controlstateuiinfo) == 24, "struct s_controlstateuiinfo is invalid size");

		struct s_i343equipmentbasiccontrolstate
		{
			byte control_state_count;
			c_flags<e_i343equipmentcontrolstateflags, char, k_i343equipmentcontrolstateflags_count> control_state_flags;
		};
		static_assert(sizeof(s_i343equipmentbasiccontrolstate) == 2, "struct s_i343equipmentbasiccontrolstate is invalid size");

		struct s_equipmentabilitytypespawner
		{
			real_vector3d spawn_offset;
			real spawn_radius;
			real spawn_velocity_scalar;
			real spawn_z_offset;
			real spawn_area_radius;
			real spawn_velocity;
			real max_range;
			string_id raycast_layer;
			real spawn_collision_radius_offset;
			string_id spawn_marker;
			string_id spawn_marker_on_object;
			c_typed_tag_reference<OBJECT_TAG> spawn_marker_owner_object;
			angle spawn_variance_angle;
			short objects_spawned_per_activation;
			byte max_simultaneous;
			char generated_padbdd2[1]; // padding
			c_enum<e_i343equipmentspawnedobjectsbehaviour, short> spawned_objects_behaviour;
			c_enum<e_i343equipmentspawnobjectsspawntype, short> type;
			s_i343equipmentbasiccontrolstate control_state_support;
			char generated_pad0a87[2]; // padding
			c_flags<e_i343equipmentspawningflags, long, k_i343equipmentspawningflags_count> spawn_flags;
			c_typed_tag_reference<OBJECT_TAG> spawned_object;
			c_typed_tag_reference<EFFECT_TAG> spawned_effect;
		};
		static_assert(sizeof(s_equipmentabilitytypespawner) == 120, "struct s_equipmentabilitytypespawner is invalid size");

		struct s_equipmentabilitytypeproximitymine
		{
			c_typed_tag_reference<EFFECT_TAG> explosion_effect;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> explosion_damage_effect;
			real arm_time;
			real self_destruct_time;
			real trigger_time;
			real trigger_velocity;
		};
		static_assert(sizeof(s_equipmentabilitytypeproximitymine) == 48, "struct s_equipmentabilitytypeproximitymine is invalid size");

		struct s_equipmentabilitytypemotiontrackernoise
		{
			c_flags<e_equipmentabilitytypemotiontrackernoisec_flags, long, k_equipmentabilitytypemotiontrackernoisec_flags_count> flags;
			real arm_time;
			real noise_radius;
			long noise_count;
			real flash_radius;
		};
		static_assert(sizeof(s_equipmentabilitytypemotiontrackernoise) == 20, "struct s_equipmentabilitytypemotiontrackernoise is invalid size");

		struct s_equipmentabilitytypetreeoflife
		{
			c_flags<e_equipmentabilitytypetreeoflifec_flags, long, k_equipmentabilitytypetreeoflifec_flags_count> flags;
			string_id origin_marker;
			real radius;
		};
		static_assert(sizeof(s_equipmentabilitytypetreeoflife) == 12, "struct s_equipmentabilitytypetreeoflife is invalid size");

		struct s_equipmentabilitytyperepulsorfield
		{
			c_flags<e_equipmentabilitytypephysicsfieldbaserepulsorfieldflags, long, k_equipmentabilitytypephysicsfieldbaserepulsorfieldflags_count> flags;
			real radius;
			real power;
		};
		static_assert(sizeof(s_equipmentabilitytyperepulsorfield) == 12, "struct s_equipmentabilitytyperepulsorfield is invalid size");

		struct s_equipmentabilitytypedaddy
		{
			c_typed_tag_reference<OBJECT_TAG> child_object;
			c_flags<e_equipmentabilitytypedaddyflags, short, k_equipmentabilitytypedaddyflags_count> flags;
			char generated_pad8b8c[2]; // padding
			real shield_damage_to_energy_scale;
			real starting_warm_up_object_scale;
			real target_object_scale;
			real_point3d offset_from_parent;
			real vertical_offset_in_world_space;
			real_bounds min_and_max_pitch;
			real visual_activation_time;
			c_typed_tag_reference<EFFECT_TAG> spawn_effect;
			// custom value
			string_id spawn_effect_marker;
			c_typed_tag_reference<EFFECT_TAG> despawn_effect;
			// custom value
			string_id despawn_effect_marker;
			string_id parent_attachment_marker;
			// custom value
			string_id child_attachment_marker;
			string_id deploy_animation;
			string_id stow_animation;
		};
		static_assert(sizeof(s_equipmentabilitytypedaddy) == 116, "struct s_equipmentabilitytypedaddy is invalid size");

		struct s_equipmentabilitytypeammopack
		{
			real energy_change_per_clip_added;
			long extra_fragmentation_grenade;
			long extra_plasma_grenade;
			long extra_lightning_grenade;
			long extra_gravity_grenade;
			long extra_spike_grenade;
			long extra_pulse_grenade;
		};
		static_assert(sizeof(s_equipmentabilitytypeammopack) == 28, "struct s_equipmentabilitytypeammopack is invalid size");

		struct s_equipmentabilitytypehealthpack
		{
			c_flags<e_i343equipmenthealthpackflags, char, k_i343equipmenthealthpackflags_count> flags;
			char generated_padb6f1[3]; // padding
			real_fraction instant_shield_restore_amount;
			real_fraction instant_body_restore_amount;
			s_scalarfunctionname health_given_over_energy_used;
		};
		static_assert(sizeof(s_equipmentabilitytypehealthpack) == 32, "struct s_equipmentabilitytypehealthpack is invalid size");

		struct s_equipmentabilitytypejetpack
		{
			c_flags<e_equipmentabilitytypejetpackflags, char, k_equipmentabilitytypejetpackflags_count> flags;
			char generated_pad3a84[3]; // padding
			s_scalarfunctionname thrust_to_acceleration_function;
			s_scalarfunctionname infinite_energy_thrust_to_acceleration_function;
			real thrust_attack_time;
			real thrust_decay_time;
			real negative_velocity_acceleration_scale;
			real airborne_acceleration_scale;
			real grounded_acceleration_magnitude;
			real landing_anticipation_time;

			/* Zero-G jet pack */

			real camera_vs_move_input_thrust_control;
			real min_speed;
			real max_speed;
			real stick_forward_thrust;
			real stick_strafe_thrust;
			real drag;
			real drag_cutoff_time;
			real acceleration_frame_rate;
		};
		static_assert(sizeof(s_equipmentabilitytypejetpack) == 100, "struct s_equipmentabilitytypejetpack is invalid size");

		struct s_equipmentabilitytypehologram
		{
			real max_destination_range;
			real hologram_duration;
			string_id collision_layer;
			c_typed_tag_reference<EFFECT_TAG> creation_effect;
			c_typed_tag_reference<EFFECT_TAG> destination_effect;
			c_typed_tag_reference<EFFECT_TAG> attached_effect;
			// custom value
			string_id attached_effect_marker;
			string_id attached_effect_primary_scale;
			string_id attached_effect_secondary_scale;
			c_typed_tag_reference<EFFECT_TAG> destruction_effect;
			real shimmer_decrease_rate;
			real shimmer_bullet_ping;
			s_scalarfunctionname shimmer_to_camo_function;
			c_flags<e_equipmentabilitytypehologramflags, char, k_equipmentabilitytypehologramflags_count> flags;
			char generated_padf149[3]; // padding
			real speed_scale;
			// custom aim_settings
			real aim_at_enemy_update_rate;
			real aim_at_enemy_target_range;
			real aim_at_enemy_target_stickiness;
			c_enum<e_equipmentabilitytypehologramhologramaimbehavior, char> aim_behavior_stopped;
			c_enum<e_equipmentabilitytypehologramhologramaimbehavior, char> aim_behavior_moving;
			// custom value
			// custom multi_mimic_settings
			c_flags<e_equipmentabilitytypehologramformationflags, char, k_equipmentabilitytypehologramformationflags_count> formation_flags;
			byte mimic_count;
			real mimic_min_dist;
			real mimic_max_dist;
			real mimic_shuffle_time;
			real mimic_shuffle_variance;
			// custom value
		};
		static_assert(sizeof(s_equipmentabilitytypehologram) == 156, "struct s_equipmentabilitytypehologram is invalid size");

		struct s_equipmentabilitytypespecialweapon
		{
			c_typed_tag_reference<WEAPON_TAG> weapon;
		};
		static_assert(sizeof(s_equipmentabilitytypespecialweapon) == 16, "struct s_equipmentabilitytypespecialweapon is invalid size");

		struct s_equipmentabilitytypespecialmove
		{
			string_id forward;
			string_id left;
			string_id backward;
			string_id right;
			c_enum<e_equipmentabilitytypespecialmovedefaultdirection, char> default_direction;
			char generated_pad5e1c[3]; // padding
			c_typed_tag_reference<EFFECT_TAG> directional_effect;
			real danger_radius;
			real speed_multiplier;
		};
		static_assert(sizeof(s_equipmentabilitytypespecialmove) == 44, "struct s_equipmentabilitytypespecialmove is invalid size");

		struct s_equipmentabilitytypeengineershields
		{
			real radius;
			string_id shield_name;
			c_flags<e_equipmentabilitytypeengineershieldsc_engineer_shields_flags, long, k_equipmentabilitytypeengineershieldsc_engineer_shields_flags_count> flags;
		};
		static_assert(sizeof(s_equipmentabilitytypeengineershields) == 12, "struct s_equipmentabilitytypeengineershields is invalid size");

		struct s_equipmentabilitytypeautoturret
		{
			c_flags<e_equipmentabilitytypeautoturretc_autoturretflags, char, k_equipmentabilitytypeautoturretc_autoturretflags_count> flags;
			s_i343equipmentbasiccontrolstate control_state_support;
			char generated_pad1d63[1]; // padding
			c_typed_tag_reference<OBJECT_TAG> weapon;
			real_point3d orbit_offset_from_player;
			real orbit_range;
			real orbit_rate;
			real maximum_range;
			real max_velocity;
			real max_acceleration;
			real turret_halt_engage_time;
			real turret_idle_equipment_drain_multiplier;
			real turret_inactive_equipment_drain_multiplier;
			real spawn_radius;
			real spawn_in_time;
			real_vector3d spawn_offset_from_player;
			real vertical_bob_height;
			real vertical_bobs_per_second;
			c_typed_tag_reference<EFFECT_TAG> spawn_effect;
			// custom value
			string_id spawn_effect_marker;
			string_id spawn_dissolve_type;
			string_id spawn_dissolve_marker;
			c_typed_tag_reference<EFFECT_TAG> collision_phase_effect;
		};
		static_assert(sizeof(s_equipmentabilitytypeautoturret) == 136, "struct s_equipmentabilitytypeautoturret is invalid size");

		struct s_equipmentabilitytypeshieldprojector
		{
			real lifetime_;
			real recharge_time_;
			real warmup_time_;
			real_fraction max_move_percentage_;
			real offset_amount_;
			real min_projection_distance_;
			real max_projection_distance_;
			real_fraction min_required_energy_level_;
			c_typed_tag_reference<EFFECT_TAG> project_effect_;
			c_typed_tag_reference<EFFECT_TAG> warmup_effect_;
			c_typed_tag_reference<CRATE_TAG> shield_crate_;
		};
		static_assert(sizeof(s_equipmentabilitytypeshieldprojector) == 80, "struct s_equipmentabilitytypeshieldprojector is invalid size");

		struct s_equipmentabilitytypeprojectilecollector
		{
			real_fraction chance_to_collect_;
			real_bounds collect_cooldown_;
			real_bounds attack_delay_;
			real max_collect_range;
			real_bounds orbit_radius;
			real orbit_speed;
			real vertical_offset;
			real strength;
			real attack_speed;
			c_typed_tag_reference<EFFECT_TAG> collect_effect_;
		};
		static_assert(sizeof(s_equipmentabilitytypeprojectilecollector) == 64, "struct s_equipmentabilitytypeprojectilecollector is invalid size");

		struct s_equipmentabilitytypeactiveshield
		{
			c_flags<e_equipmentabilitytypeactiveshieldflags, char, k_equipmentabilitytypeactiveshieldflags_count> flags;
		};
		static_assert(sizeof(s_equipmentabilitytypeactiveshield) == 1, "struct s_equipmentabilitytypeactiveshield is invalid size");

		struct s_equipmentabilitytypefortificationshield
		{
			c_typed_tag_reference<CRATE_TAG> shield_object;
			real object_deploy_scale;
			real autoshutdown_range;
		};
		static_assert(sizeof(s_equipmentabilitytypefortificationshield) == 24, "struct s_equipmentabilitytypefortificationshield is invalid size");

		struct s_equipmentabilitytypegenericpowerup
		{
			c_typed_tag_reference<POWERUPDEFINITION_TAG> generic_powerup;
		};
		static_assert(sizeof(s_equipmentabilitytypegenericpowerup) == 16, "struct s_equipmentabilitytypegenericpowerup is invalid size");

		struct s_equipmentabilitytypemalleableproperties
		{
			c_typed_tag_reference<GENERICMODIFIERDEFINITIONTAG_TAG> modifiers;
		};
		static_assert(sizeof(s_equipmentabilitytypemalleableproperties) == 16, "struct s_equipmentabilitytypemalleableproperties is invalid size");

		struct s_equipmentabilitytypespartancustomtracking
		{
			c_typed_tag_reference<SPARTANTRACKINGPINGDEFINITION_TAG> ping_definition;
			c_typed_tag_reference<SPARTANTRACKINGPINGDEFINITION_TAG> marking_ping_definition;
		};
		static_assert(sizeof(s_equipmentabilitytypespartancustomtracking) == 32, "struct s_equipmentabilitytypespartancustomtracking is invalid size");

		struct s_equipmentabilitytypeteleporter
		{

			/* Teleporter */

			c_flags<e_equipmentabilitytypeteleporterflags, short, k_equipmentabilitytypeteleporterflags_count> flags;
			char generated_padfb70[2]; // padding
			real arming_delay;
			c_typed_tag_reference<EFFECT_TAG> armed_effect;
			string_id teleport_animation;
			string_id teleport_first_person_animation_set;
			real teleport_delay;
			real destination_offset_z;
			c_typed_tag_reference<EFFECT_TAG> source_effect;
			c_typed_tag_reference<EFFECT_TAG> destination_effect;
			real obstruction_self_destruct_duration;
			c_typed_tag_reference<EFFECT_TAG> teleport_failure_effect;
		};
		static_assert(sizeof(s_equipmentabilitytypeteleporter) == 92, "struct s_equipmentabilitytypeteleporter is invalid size");

		struct s_equipmentabilitytypeframeabilityitem
		{

			/* Frame Ability */

			c_typed_tag_reference<FRAMEATTACHMENTDEFINITION_TAG> frame_attachment_to_activate;
			c_flags<e_i343equipmentframeabilityitempickupflags, char, k_i343equipmentframeabilityitempickupflags_count> pickup_flags;
			c_enum<e_i343equipmentduplicateitempickupbehaviour, char> behaviour_when_you_walk_over_an_item_you_already_hold;
			c_enum<e_i343equipmentabilityenergytransferbehavior, char> energy_transfer_behavior;
			char generated_pad7f06[1]; // padding
		};
		static_assert(sizeof(s_equipmentabilitytypeframeabilityitem) == 20, "struct s_equipmentabilitytypeframeabilityitem is invalid size");

		struct s_equipmentabilitytypeequipmentrecharger
		{

			/* equipment recharger */

			long pickup_charges_given;
		};
		static_assert(sizeof(s_equipmentabilitytypeequipmentrecharger) == 4, "struct s_equipmentabilitytypeequipmentrecharger is invalid size");

		struct s_i343equipmentknockbackunittargetmarker
		{

			/* knockback unit target markers */

			string_id marker_name;
		};
		static_assert(sizeof(s_i343equipmentknockbackunittargetmarker) == 4, "struct s_i343equipmentknockbackunittargetmarker is invalid size");

		struct s_equipmentabilitytypeknockback
		{

			/* knockback */

			// custom target_searching
			real search_radius;
			string_id search_origin_marker;
			real_vector3d search_offset;
			angle search_angle;
			// custom value
			// custom target_knockback_data
			// custom object_knockback_maginitude
			// custom mapping_function
			s_functiondefinition target_knockback_impulse_magnitude;
			real target_knockback_impulse_maximum_mass;
			// custom value
			real target_knockback_impulse_magnitude_grounded_bipeds;
			real target_knockback_impulse_magnitude_airborne_bipeds;
			real target_knockback_impulse_magnitude_projectiles;
			c_typed_tag_reference<KNOCKBACKRESPONSEOVERRIDESET_TAG> target_knockback_per_object_overrides;
			string_id target_knockback_origin_marker;
			real target_knockback_target_point_min_range;
			real target_knockback_target_point_max_range;
			angle target_knockback_ground_deflection_offset_angle;
			angle target_knockback_ground_deflection_min_angle;
			angle target_knockback_ground_deflection_max_angle;
			// custom value
			// custom owner_knockback_data
			// custom mapping_function
			s_functiondefinition owner_knockback_impulse_magnitude;
			angle max_pitch_angle;
			angle owner_knockback_vertical_snap_angle;
			// custom value
			real knockback_state_override_time;
			real knockback_vehicle_emp_duration;
			c_typed_tag_reference<DAMAGE_EFFECT_TAG> damage_effect;
			// custom effects
			c_typed_tag_reference<EFFECT_TAG> rocket_jump_effect;
			c_typed_tag_reference<EFFECT_TAG> default_effect;
			c_typed_tag_reference<EFFECT_TAG> vehicle_effect;
			c_typed_tag_reference<EFFECT_TAG> biped_effect;
			c_typed_tag_reference<EFFECT_TAG> projectile_effect;
			// custom value
			string_id biped_head_marker;
			string_id biped_foot_marker;
			c_typed_tag_block<s_i343equipmentknockbackunittargetmarker> line_of_sight_test_unit_markers_block;
		};
		static_assert(sizeof(s_equipmentabilitytypeknockback) == 252, "struct s_equipmentabilitytypeknockback is invalid size");

		struct s_equipmentabilitytypeactivecamo
		{
			real duration;
			c_typed_tag_reference<GENERICMODIFIERDEFINITIONTAG_TAG> modifiers;
		};
		static_assert(sizeof(s_equipmentabilitytypeactivecamo) == 20, "struct s_equipmentabilitytypeactivecamo is invalid size");

		struct s_equipmentability
		{
			c_enum<e_equipmentactivationmode, char> activation_mode;
			char generated_pade86c[3]; // padding
			// custom timers
			real duration;
			real warmup_time;
			real cooldown_time;
			real phantom_volume_activation_time;
			real motion_tracker_ping_duration;
			real super_active_duration;
			// custom value
			// custom energy

			/* Energy */

			real minimum_activation_energy;
			real low_energy_warning_threshold;
			real activation_energy_cost;
			real deactivation_energy_cost;
			real active_energy_rate;
			s_scalarfunctionname movement_speed_to_energy_rate;
			real movement_speed_domain;
			// custom value
			c_typed_tag_block<s_equipmentabilitydeactivationoverridesettings> deactivation_override_settings_block;
			c_flags<e_equipmentabilityflags, long, k_equipmentabilityflags_count> flags;
			c_flags<e_equipmentabilitysecondaryflags, long, k_equipmentabilitysecondaryflags_count> secondary_flags;
			short charges;
			c_flags<e_controlstateuiflags, char, k_controlstateuiflags_count> control_state_ui_flags;
			char generated_pad024d[1]; // padding
			c_typed_tag_block<s_controlstateuiinfo> control_states_ui_info_block;
			char object_noise_adjustment;
			char generated_pad4f02[3]; // padding
			real active_camo_ding;
			// custom type_definitions
			c_typed_tag_block<s_equipmentabilitytypespawner> spawner_block;
			c_typed_tag_block<s_equipmentabilitytypeproximitymine> proximity_mine_block;
			c_typed_tag_block<s_equipmentabilitytypemotiontrackernoise> motion_tracker_noise_block;
			c_typed_tag_block<s_equipmentabilitytypetreeoflife> tree_of_life_block;
			c_typed_tag_block<s_equipmentabilitytyperepulsorfield> repulsor_field_block;
			c_typed_tag_block<s_equipmentabilitytypedaddy> iwhbydaddy_block;
			c_typed_tag_block<s_equipmentabilitytypeammopack> ammo_pack_block;
			c_typed_tag_block<s_equipmentabilitytypehealthpack> health_pack_block;
			c_typed_tag_block<s_equipmentabilitytypejetpack> jet_pack_block;
			c_typed_tag_block<s_equipmentabilitytypehologram> hologram_block;
			c_typed_tag_block<s_equipmentabilitytypespecialweapon> special_weapon_block;
			c_typed_tag_block<s_equipmentabilitytypespecialmove> special_move_block;
			c_typed_tag_block<s_equipmentabilitytypeengineershields> engineer_shields_block;
			c_typed_tag_block<s_equipmentabilitytypeautoturret> auto_turret_block;
			c_typed_tag_block<s_equipmentabilitytypeshieldprojector> shield_projector_block;
			c_typed_tag_block<s_equipmentabilitytypeprojectilecollector> projectile_collector_block;
			c_typed_tag_block<s_equipmentabilitytypeactiveshield> active_shield_block;
			c_typed_tag_block<s_equipmentabilitytypefortificationshield> fortification_shield_block;
			c_typed_tag_block<s_equipmentabilitytypegenericpowerup> generic_powerup_block;
			c_typed_tag_block<s_equipmentabilitytypemalleableproperties> malleable_properties_block;
			c_typed_tag_block<s_equipmentabilitytypespartancustomtracking> custom_spartan_tracking_block;
			c_typed_tag_block<s_equipmentabilitytypeteleporter> teleporter_block;
			c_typed_tag_block<s_equipmentabilitytypeframeabilityitem> frame_ability_block;
			c_typed_tag_block<s_equipmentabilitytypeequipmentrecharger> equipment_recharger_block;
			c_typed_tag_block<s_equipmentabilitytypeknockback> knockback_block;
			c_typed_tag_block<s_equipmentabilitytypeactivecamo> active_camo_block;
			// custom value
			c_typed_tag_reference<SOUND_TAG> activation_while_disabled_by_player_traits_sound;
			c_typed_tag_reference<EFFECT_TAG> activate_effect;
			c_typed_tag_reference<EFFECT_TAG> looping_effect;
			c_typed_tag_reference<EFFECT_TAG> deactivate_effect;
			string_id activation_animation;
			real activation_duration_override;
			string_id active_animation;
			string_id deactivate_animation;
			string_id first_person_activation_animation_set;
			string_id first_person_active_animation_set;
			string_id active_animation_stance;
		};
		static_assert(sizeof(s_equipmentability) == 520, "struct s_equipmentability is invalid size");

		struct s_i343equipmentobjectfunctionremapping
		{

			/* Object Function Remapping Table */

			string_id base_function_name;
			string_id new_function_name;
		};
		static_assert(sizeof(s_i343equipmentobjectfunctionremapping) == 8, "struct s_i343equipmentobjectfunctionremapping is invalid size");

		struct s_equipmentdefinition
		{
			s_itemdefinition item;
			// custom $$$_equipment_$$$
			c_enum<e_i343unitsarmorinput, long> input;
			// custom energy
			real initial_energy;
			real energy_recovery_time;
			real inactive_energy_rate;
			// custom value
			real gravity_scale;
			// custom at_rest_activation
			real velocity_for_rest;
			real time_at_rest;
			real rest_failsafe_time;
			// custom value
			c_flags<e_c_equipment_flags, long, k_c_equipment_flags_count> flags;
			string_id unit_stow_marker_name;
			c_enum<e_e_equipment_pickup_behaviour, char> pickup_behavior;
			char generated_pad180b[3]; // padding
			real pickup_radius;
			// custom ai

			/* AI */

			real danger_radius;
			real min_deployment_distance;
			real awareness_time;
			string_id ai_dialogue_equipment_type;
			c_enum<e_aiequipmenttype, char> ai_equipment_type;
			char generated_padcb56[3]; // padding
			// custom value
			c_typed_tag_block<s_optionalunitcamerablock> override_camera_block;
			c_typed_tag_block<s_equipmentability> abilities_block;
			c_typed_tag_reference<CUI_SCREEN_TAG> hud_screen_reference;
			c_typed_tag_block<s_interfaceuiiteminfo> ui_display_info_block;
			c_typed_tag_reference<SOUND_TAG> pickup_sound;
			c_typed_tag_reference<EFFECT_TAG> energy_charged_effect;
			c_typed_tag_reference<SOUND_TAG> unable_to_activate_sound;
			c_typed_tag_reference<SOUNDBANK_TAG> player_sound_bank;
			c_typed_tag_block<s_soundrtpcblockdefinition> sound_rtpcs_block;
			c_typed_tag_block<s_soundsweetenerblockdefinition> sound_sweeteners_block;
			c_typed_tag_block<s_i343equipmentobjectfunctionremapping> object_functions_exposed_to_unit_block;
			// custom value
		};
		static_assert(sizeof(s_equipmentdefinition) == 1772, "struct s_equipmentdefinition is invalid size");

#pragma pack(pop)

	} // end namespace infinite

} // end namespace blofeld
